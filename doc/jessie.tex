%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                        %
%  The Why platform for program certification                            %
%                                                                        %
%  Copyright (C) 2002-2011                                               %
%                                                                        %
%    Jean-Christophe FILLIATRE, CNRS & Univ. Paris-sud 11                %
%    Claude MARCHE, INRIA & Univ. Paris-sud 11                           %
%    Yannick MOY, Univ. Paris-sud 11                                     %
%    Romain BARDOU, Univ. Paris-sud 11                                   %
%                                                                        %
%  Secondary contributors:                                               %
%                                                                        %
%    Thierry HUBERT, Univ. Paris-sud 11  (former Caduceus front-end)     %
%    Nicolas ROUSSET, Univ. Paris-sud 11 (on Jessie & Krakatoa)          %
%    Ali AYAD, CNRS & CEA Saclay         (floating-point support)        %
%    Sylvie BOLDO, INRIA                 (floating-point support)        %
%    Jean-Francois COUCHOT, INRIA        (sort encodings, hyps pruning)  %
%    Mehdi DOGGUY, Univ. Paris-sud 11    (Why GUI)                       %
%                                                                        %
%  This software is free software; you can redistribute it and/or        %
%  modify it under the terms of the GNU Lesser General Public            %
%  License version 2.1, with the special exception on linking            %
%  described in file LICENSE.                                            %
%                                                                        %
%  This software is distributed in the hope that it will be useful,      %
%  but WITHOUT ANY WARRANTY; without even the implied warranty of        %
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  %
%                                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,twoside,openright]{report}
\usepackage{hevea}

\usepackage[a4paper=true,pdftex,colorlinks=true,urlcolor=blue,pdfstartview=FitH]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{amssymb}
%BEGIN LATEX
\usepackage{graphicx}
\newcommand{\negtenthspace}{\hspace*{-0.1\linewidth}}
%END LATEX
%HEVEA \newcommand{\includegraphics}[2][2]{\imgsrc{#2}}
%HEVEA \newcommand{\negtenthspace}{\relax}

\usepackage{color}
%\usepackage{mathptm}
%\usepackage{xspace}
\usepackage{makeidx}
\makeindex
\input{./version.tex}
\input{./macros.tex}
\definecolor{darkgreen}{rgb}{0, 0.5, 0}

\setlength{\textheight}{240mm}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}

\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}

\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\footrulewidth}{0.4pt}
\addtolength{\headheight}{2pt}
\addtolength{\headwidth}{1cm}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\chead{}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lfoot{\fancyplain{}{C. March\'e, Y. Moy}}
\cfoot{\fancyplain{}{Why platform, Jessie plugin for Frama-C}}
\rfoot{\fancyplain{}{ProVal, \today}}


\begin{document}
\ifhevea%
This document is also available in \ahref{jessie.pdf}{PDF format}.
\else
\sloppy
\hbadness=9999
\fi

\whytitlepage{The Jessie plugin\\~\\ for Deduction Verification in Frama-C}{Tutorial and Reference Manual}{\whyversion}{Claude March\'e, Yannick Moy}

\tableofcontents

\chapter{Introduction}

Jessie is a plugin for the Frama-C environment, aimed at performing
deductive verification of C programs, annotated using the ACSL
language~\cite{baudin09acsl}, using the \Why{}~\cite{why} tool for
generating proof obligations.

This version \whyversion{} of Jessie is compatible with Frama-C version
Nitrogen (and no other).

\section{Important note for version 2.30}

The use of the Why2 VC generator is now obsolete, and it is
recommended to switch to the Why3 system for specification and VC
generation. Why3 must be installed independently of Why2, please see the
instructions given at \url{http://why3.lri.fr}.

The version of Why3 that is compatible with this version \whyversion{} of Jessie
is the version 0.71. Please see \url{http://krakatoa.lri.fr/} for more
details on compatibility between Frama-C, Why2/Jessie and Why3.

In this manual, it is assumed that the Why3 VC generator and IDE is in
use.  The old behavior using the Why2 VC generator and GUI remains
possible, using option \texttt{-jessie-atp=gui}.

\section{Basic Use}

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=0.8\linewidth]{why_frama_c2.mps}
  \end{center}
  \caption{Frama-C, the Why Platform and the new Why3 system}
  \label{fig:platform}
\hrulefill
\end{figure}

The Jessie plug-in allows to perform deductive verification of C
programs inside Frama-C. The C file possibly annotated in ACSL is
first checked for syntax errors by Frama-C core, before it is
translated to various intermediate languages inside the Why Platform
embedded in Frama-C, and finally verification conditions (VCs) are
generated and a prover is called on these, as sketched in
Figure~\ref{fig:platform}.

To prove the VCs generated, one needs to install external provers such
as Alt-Ergo, CVC3 or Z3. Please see at URL
\url{http://krakatoa.lri.fr/} how to get such provers. Once some of
these are installed, you should run the auto-configuration tool by
running command \texttt{why3config --detect} (equivalent to the
former Why 2.xx  command \texttt{why-config})

By default, the Jessie plug-in launches in its GUI mode. To invoke this
mode on a file \verb|ex.c|, just type

\begin{verbatim}
> frama-c -jessie ex.c
\end{verbatim}

A program does not need to be complete to be analyzed with the Jessie
plug-in. As a first example, take program \verb|max|:
\input{texpp/max.cpp} The ACSL annotation expresses the fact function
\verb|max| returns the maximum of its parameters \verb|i| and
\verb|j|. Now, running the Jessie plug-in launches Why3 IDE produces
the output shown on Figure~\ref{fig:max:ide}.

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=\linewidth]{jessie/max_why3ide.png}
  \end{center}
  \caption{Why3 IDE for \texttt{max} function}
  \label{fig:max:ide}
\end{figure}

On this figure, the user selected the row ``WP Jessie program'' and
clicked on the buttons on the left, corresponding to provers Alt-Ergo,
Z3 and CVC3. The two VCs are shown valid, meaning that for this small
function, the code matches its specification.

\section{Safety Checking vs. Functional Verification}

In the simple \verb|max| example, there are two VCs, one for the
``default behavior'' and one for ``Safety'' of function \verb|max|. In
general, each function leads to these VCs:
\begin{itemize}
\item \textit{Safety}: this VC guard against safety violations
  such as null-pointer dereferencing, buffer overflow, integer overflow, etc.
\item \textit{Default behavior}: this VC concern the
  verification of a function's default behavior, which includes
  verification of its postcondition, frame condition, loop invariants
  and intermediate assertions.
\item \textit{User-defined behavior}: these VCs concern the
  verification of a function's user-defined behavior, which includes
  verification of its postcondition, frame condition, loop invariants
  and intermediate assertions for this specific behavior.
\end{itemize}

Here is a more complex variant of function \verb|max| which takes
pointer parameters and returns 0 on success and -1 on failure.

\input{texpp/max_ptr.cpp}

Notice that the annotations refer to the null pointer using ACSL
syntax \verb|\null|. It would be possible to use also the C macro
\texttt{NULL}, but in that case we would have to ask Frama-C
preprocessor phase to process the annotations too, since it does not
by default. This is done by option \verb|-pp-annot| of
Frama-C. However, this alternative is not recommended since it is
depended of the proprecessor in use (see
\url{http://bts.frama-c.com/dokuwiki/doku.php?id=mantis:frama-c:start#faq_tips_and_tricks})

Running the Jessie plug-in in GUI mode results in 4 VCs:
Safety, default behavior, normal behavior `normal` and normal behavior
`zero` for the two user-defined behaviors.

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=\linewidth]{jessie/max_ptr_why3ide.png}
  \end{center}
  \caption{Why3 IDE for \texttt{max\_ptr} function}
  \label{fig:max_ptr:ide}
\end{figure}

% VCs that are proved in one group can be available to prove VCs in other
% groups. No circularity paradox is possible here, since the proof of a
% VC can only rely on other VCs higher in the control-flow graph of the
% function. We made the following choices:

% \begin{itemize}
% \item To prove a VC in \textit{Safety}, one can rely on VCs in
%   \textit{Default behavior}. Typically, one can rely on preconditions
%   or loop invariants to prove safety.
% \item To prove a VC in \textit{Default behavior}, one can rely on VCs
%   in \textit{Safety}. Typically, one can rely on ranges of values
%   implied by safety to prove loop invariants and postconditions.
% \item To prove a VC in a \textit{Normal behavior}, one can rely on VCs
%   in both \textit{Safety} and \textit{Default behavior}.
% \end{itemize}

Next, we detail how to prove each VC.

\chapter{Safety Checking}

A preliminary to the verification of functional properties using the
Jessie plug-in is to verify the safety of functions. Safety has
several components: memory safety, integer safety, termination. Memory
safety deals with validity of memory accesses to allocated
memory. Integer safety deals with absence of integer overflows and
validity of operations on integers, such as the absence of division by
zero. Termination amounts to check whether loops are always
terminating, as well as recursive or mutually recursive functions.

\section{Memory Safety}

Our running example will be the famous \verb|binary_search| function,
which searches for a {\tt long} in an ordered array of {\tt long}s. On
success, it returns the index at which the element appears in the
array. On failure, it returns \verb|-1|.

\input{texpp/binary_search_raw.cpp}

To concentrate first on memory safety only, we declare two pragmas as
above. The first pragma dictates that integers in C programs behave as
infinite-precision mathematical integers, without overflows. The
second pragma instructs the plug-in to ignore termination issues.

Let's call Frama-C with the Jessie plug-in on this program:

\begin{verbatim}
> frama-c -jessie binary-search.c
\end{verbatim}

As seen on Figure~\ref{fig:raw}, we get 3 VCs, an obvious one that
states the divisor \verb|2| is not null, and two more that state the
array access \verb|t[m]| should be within bounds. This is due to the
memory model used, that decomposes any access check into two: one that
states the access is above the minimal bound allowed, and one that
states the access is below the maximal bound allowed.

\begin{figure}[t]
  \begin{center}
  \includegraphics[width=0.8\linewidth]{jessie/binary-search-raw.png}
  \end{center}
  \caption{Memory safety with no annotations}
  \label{fig:raw}
  \hrulefill
\end{figure}

The obvious VC is trivially proved by all provers, while the two VCs
for memory safety cannot be proved. Indeed, it is false that, in any
context, function \verb|binary_search| is memory safe. To ensure
memory safety, \verb|binary_search| must be called in a context 
where \verb|n| is positive and array \verb|t| is valid
between indices \verb|0| and \verb|n-1| included. Since function
\verb|binary_search| accesses array \verb|t| inside a loop, 
providing a precondition is not
enough to make the generated VC provable.
One must also provide a {\em loop invariant}. A loop invariant
is a property that remains true at each iteration of the loop.
It is often necessary for the user to provide these properties
to help Jessie reason about loops. Assuming that the right property
has been provided, Jessie is then left with the easier task of
generating and verifying VCs that ensure that the property indeed
holds at the beginning of each iteration.

In this example, it is necessary to provide an invariant 
that states the guarantees provided on the array 
index, despite its changing value. It
states that the value of index \verb|l| stays within the bounds of the
array \verb|t|.

\input{texpp/binary_search_rawmem.cpp}

Seven VCs are now generated: 2 to guarantee the loop invariant is
initially established (because the conjunction is split), 2 to guarantee
the same loop invariant is preserved throughout the loop, and the 3 VCs
seen previously. Not all generated VCs are proved automatically with
these annotations. Of the 3 VCs seen previously, the maximal bound
check is still not proved. And the preservation of the loop invariant
that deals with an upper bound on \verb|u| is not proved either. It
comes from the non-linear expression assigned to \verb|m|in the loop,
that is difficult to take into account automatically. 

We solve this problem by adding an assertion to help automatic
provers, providing some form of hint in the proof. This can be done by
inserting assertions in the code, or by adding a global\emph{lemma}, that
should be proved using available axioms, and used as an axiom in
proving the VC for safety. This works for our example.

\input{texpp/binary_search_mem.cpp}

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=0.8\linewidth]{jessie/binary-search-mem.png}
  \end{center}
  \caption{Memory safety with precondition and loop invariant}
  \label{fig:mem}
  \hrulefill
\end{figure}

The results are shown on Figure~\ref{fig:mem}, where all VCs, are
proved by some prover. This guarantees the memory safety of function
\verb|binary_search|. The lemma itself is proved by Alt-Ergo, which
has a little knowledge of the division operator. Given the lemma,
other VCs are fully proved by Simplify and Z3, and partly by Yices and
CVC3.

%Notice the assertion adds 2 VC, which totals 9
%VC for function \verb|binary_search|, plus the lemma.
% In the following, we remove the assertion, which is not useful.


\section{Integer Overflow Safety}

Let us now consider machine integers instead of idealized mathematical
integers. This is obtained by removing the pragma
\texttt{JessieIntegerModel}.  Without this pragma, integer types are
now intepreted as bounded machine integers. However, the default is a
\emph{defensive} interpretation, which forbids the arithmetic
operations to overflow.\footnote{In a context where it is intended for
  the operations to overflows, and thus operations are intentionnally
  done modulo, the same pragma should be set to the value
  \texttt{modulo}, see Jessie manual.}

\begin{figure}[t]
  \begin{center}
    \negtenthspace\includegraphics[width=1.2\linewidth]{jessie/binary-search-ovfl.png}
  \end{center}
  \caption{Memory safety + integer overflow safety}
  \label{fig:ovfl}
  \hrulefill
\end{figure}

The result can be seen in Figure~\ref{fig:ovfl}. There are ten more VCs
to check that integer operations return a result within bounds, only one of
which is not proved. With this exception, the results are nearly the same
as with exact integers (proving the lemma takes more time, due
to the additional encoding for bounded integers).

The only unproved VC expresses that \verb|l+u| does not overflow. 
Nothing prevents this from happening with our current
precondition for function \verb|binary_search|~\cite{Tuch_KN_07}. There are two
possibilities here. The easiest is to strengthen the precondition
by requiring that \verb|n| is no more than half the maximal signed
integer \verb|INT_MAX|. The best way is to change the source of
\verb|binary_search| to prevent overflows even in presence of large
integers. It consists in changing the buggy line

\begin{verbatim}
    int m = (l + u) / 2;
\end{verbatim}

into

\begin{verbatim}
    int m = l + (u - l) / 2;
\end{verbatim}

This is our choice here. As shown in Figure~\ref{fig:ovfl-ok}, all VCs
are now proved automatically.

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=\linewidth]{jessie/binary-search-ovfl-ok.png}
  \end{center}
  \caption{Safety for patched program}
  \label{fig:ovfl-ok}
  \hrulefill
\end{figure}

% Another choice is to set the integer mode to modulo, which means
% overflows are allowed, with modulo semantics. To reach that result, we
% call Frama-C with options:

% \begin{verbatim}
% > framac -jessie -jessie-int-model modulo binary-search.c
% \end{verbatim}

% This leads to the same choices as above to guarantee this time that
% the memory access \verb|t[m]| is within bounds. Otherwise, \verb|m|
% might become strictly negative, very likely accessing beyond \verb|t|
% bounds.


\section{Checking Termination}

The last kind of safety property we want is termination. To check it,
we first remove the pragma \texttt{JessieTerminationPolicy}. If we run
the VC generation again, we get an additional VC that requires to prove
the property $0 > 0$. This VC is false, so our first step should be
to help Jessie generate a more provable VC.
The VC $0 > 0$ is generated because we did not provide any
\emph{loop variant} for the \texttt{while} loop. A loop variant is a
quantity which must decrease strictly at each loop iteration, while
provably remaining non-negative for as long as the loop runs. 
In this example, a proper variant is $u-l$. 
So our annotated program now looks as follows:

\input{texpp/binary_search_term.cpp}

The additional VC is now proved.

Termination of recursive functions can be dealt with similarly by
adding a \texttt{decreases} clause to the function's contract. 
It is also possible to prove termination by using variants over 
any datatype $d$ equipped with a well-founded relation. 
See the ACSL documentation for details.


% \section{Combining with Value analysis plug-in}

% TODO

\chapter{Functional Verification}


\section{Behaviors}

\subsection{Simple functional property}

Now that the safety of function \verb|binary_search| has been established, one
can attempt the verification of functional properties, like the
input-output behavior of function \verb|binary_search|. At the
simplest, one can add a postcondition that \verb|binary_search| should
respect upon returning to its caller. Here, we add bounds on the value
returned by \verb|binary_search|. To prove this postcondition,
strengthening the loop invariant is necessary.

\input{texpp/binary_search_post.cpp}

As shown in Figure~\ref{fig:post}, all VCs are proved automatically here.

\begin{figure}[t]
  \begin{center}
    \negtenthspace\includegraphics[width=1.2\linewidth]{jessie/binary-search-post.png}
  \end{center}
  \caption{General postcondition}
  \label{fig:post}
  \hrulefill
\end{figure}

\subsection{More advanced functional properties}

One can be more precise and separate the postcondition according to
different behaviors. The \emph{assumes} clause of a behavior gives
precisely the context in which a behavior applies. Here, we state that
function \verb|binary_search| has two modes: a success mode and a
failure mode. This directly relies on array \verb|t| to be sorted,
thus we add this as a general requirement. The success mode states
that whenever the calling context is such that value \verb|v| is in
the range of \verb|t| searched, then the value returned is a valid
index. The failure mode states that whenever the calling context is
such that value \verb|v| is not in the range of \verb|t| searched,
then function \verb|binary_search| returns \verb|-1|.  Again, it is
necessary to strengthen the loop invariant to prove the VC generated.

\input{texpp/binary_search_behav.cpp}

Figure~\ref{fig:behav} summarizes the results obtained in that case,
for each behavior.

\begin{figure}[t]
  \begin{center}
    \negtenthspace\includegraphics[width=1.2\linewidth]{jessie/binary-search-behav.png}
  \end{center}
  \caption{Postconditions in behaviors}
  \label{fig:behav}
  \hrulefill
\end{figure}

\section{Advanced Algebraic Modeling}

The following example introduces use of algebraic specification. The
goal is the verify a simple sorting algorithm (by extraction of the
minimum).

The first step is to introduce logical predicates to define the
meanings for an array to be sorted in increasing order, to be a
permutation of another. This is done as follows, in a separate file
say \texttt{sorting.h}

\input{texpp/sorting.hpp}

The code is then annotated using these predicates as follows

\input{texpp/minimum_sort.cpp}

Each VC is proved by at least one prover. Figure~\ref{fig:sorting}
displays the results in GWhy, with emphasis on the VC for preservation
of the loop invariant for permutation behavior, the most
difficult one, only proved by Alt-Ergo.

\begin{figure}[t]
  \begin{center}
    \negtenthspace\includegraphics[width=1.2\linewidth]{jessie/sorting.png}
  \end{center}
  \caption{VCs for minimum sort}
  \label{fig:sorting}
  \hrulefill
\end{figure}


% \chapter{Inference of Annotations}

% Inference of annotations is an experimental feature of the Jessie
% plug-in, whose theoretical bases are described
% in~\cite{moy09phd,moy10jsc}.

% \section{Postconditions and Loop Invariants}

% To alleviate the annotation burden, it is possible to ask the Jessie
% plug-in to infer some of them, through a combination of abstract
% interpretation and weakest preconditions. This requires that APRON
% library for abstract interpretation is installed and Frama-C
% configuration recognized it. Then, one can call
% \begin{verbatim}
%  > framac -jessie -jessie-atp=simplify -jessie-infer-annot inv max.c
% \end{verbatim}
% to perform abstract interpretation on program \verb|max.c|, which
% computes necessary loop invariants and postconditions (meaning an
% overapproximation of the real ones).

% \input{texpp/max_ptr_noannot.cpp}

% On our unannotated \verb|max.c| program, this produces postcondition
% \verb|true| for the first return and
% \verb|\valid(r) && \valid(i) && \valid(j)| for the second return.

% Various domains from APRON library are available with option
% \verb|-jessie-abstract-domain|:

% \begin{itemize}
% \item \textit{box} - domain of intervals, where an integer variables
%   is bounded by constants.
% \item \textit{oct} - domain of octagons, where the sum and difference
%   of two integer variables are bounded by constants.
% \item \textit{poly} - domain of polyhedrons, computing linear
%   relations over integer variables.
% \end{itemize}

% \section{Preconditions and Loop Invariants}

% Preconditions can also be computed by calling
% \begin{verbatim}
% > framac -jessie -jessie-atp=simplify -jessie-infer-annot pre max.c
% \end{verbatim}
% which attempts to compute a sufficient precondition to guard against
% safety violations and prove functional properties. In case it computes
% \verb|false| as sufficient precondition, which occurs e.g. each time
% the property is beyond the capabilities of our method, it simply
% ignores it. Still, our method can compute a stronger precondition than
% necessary. E.g., on function \verb|max|, it computes precondition
% \verb|\valid(r) && \valid(i) && \valid(j)|, while a more precise
% precondition would allow \verb|r| to be null. Still, the generated
% precondition is indeed sufficient to prove the safety of function
% \verb|max|:

% \begin{verbatim}
%  Running Simplify on proof obligations
%  (. = valid * = invalid ? = unknown # = timeout ! = failure)
%  simplify/max_why.sx           : ......... (9/0/0/0/0)
% \end{verbatim}

% To improve on the precision of the generated precondition, various
% methods have been implemented:

% \begin{itemize}
% \item \textit{Quantifier elimination} - This method computes an
%   invariant \verb|I| at the program point where check \verb|C| should
%   hold, forms the quantified formula \verb|\forall x,y... ; I ==> C|
%   over local variables \verb|x,y...|, and eliminates quantifiers from
%   this formula, resulting in a sufficient precondition.
%   This is the method called with option \verb|-jessie-infer-annot pre|.
% \item \textit{Weakest preconditions with quantifier elimination} - This
%   method improves on direct quantifier elimination by propagating
%   formula \verb|I ==> C| backward in the control-flow graph of the
%   function before quantifying over local variables and eliminating
%   quantifiers.
%   This is the method called with option \verb|-jessie-infer-annot wpre|.
% \item \textit{Modified weakest preconditions with quantifier
%     elimination} - This method strengthens the formula obtained by
%   weakest preconditions with quantifier elimination, by only
%   considering tests and assignments which deal with variables in the
%   formula being propagated. Thus, it may result in a stronger
%   precondition (i.e. a precondition less precise) but at a smaller
%   computational cost. In particular, it may be applicable to programs
%   where weakest preconditions with quantifier elimination is too costly.
%   This is the method called with option \verb|-jessie-infer-annot spre|.
% \end{itemize}


\chapter{Separation of Memory Regions}

By default, the Jessie plug-in assumes different pointers point into
different memory \textit{regions}.  E.g., the following postcondition
can be proved on function \verb|max|, because parameters \verb|r|,
\verb|i| and \verb|j| are assumed to point into different regions.

\input{texpp/max_ptr_sep.cpp}

To change this default behavior, add the following line at the top of the file:
\begin{verbatim}
# pragma SeparationPolicy(none)
\end{verbatim}

In this setting, the postcondition cannot be proved:

\begin{verbatim}
Running Simplify on proof obligations
(. = valid * = invalid ? = unknown # = timeout ! = failure)
simplify/max_why.sx           : ?..?........ (10/0/2/0/0)
\end{verbatim}

Now, function \verb|max| should only be called in a context where
parameters \verb|r|, \verb|i| and \verb|j| indeed point into
different regions, like the following:

\input{texpp/max_sep_ctxt.cpp}

In this context, all VCs are proved.

In fact, regions that are only read, like the regions pointed to by
\verb|i| and \verb|j|, need not be disjoint. Since nothing is written
in these regions, it is still correct to prove their contract in a
context where they are assumed disjoint, whereas they may not be
disjoint in reality. It is the case in the following context:

\input{texpp/max_sep_ctxt2.cpp}

In this context too, all VCs are proved.

Finally, let's consider the following case of a context in which a
region that is read and a function that is written are not disjoint:

\input{texpp/max_sep_ctxt3.cpp}

The proof that regions are indeed disjoint boils down to proving that
set of pointers \verb|{&a}| and \verb|{&a}| are disjoint (because
function \verb|max| only writes and reads \verb|*r| and \verb|*i|),
which is obviously false.

\begin{center}
  \includegraphics[width=\linewidth]{jessie/max_ptr_ctxt_small.png}
\end{center}

% \chapter{Treatment of Unions and Casts}

% Unions without pointer fields are translated to bitvectors, so
% that access in these unions are translated to low-level
% accesses. Thus, the following code can be analyzed, but we do not yet
% provide a way to prove the resulting assertions, by asserting that any
% subset of bits from the bitvector representation of 0 is 0:

% \input{texpp/union_plain.cpp}

% Unions with pointer fields (either direct fields or sub-fields of
% structure fields) are translated differently, because we treat
% pointers differently than other types, to allow an automatic analysis
% of separation of memory blocks. Thus, we treat unions with pointer
% fields as discriminated unions, so that writing in a field erases all
% information on other fields. This allows to verify the following
% program:

% \input{texpp/union_discr.cpp}

% Finally, casts between pointer types are allowed, with the
% corresponding accesses to memory treated as low-level accesses to some
% bitvector. This allows to verify the safety of the following program:

% \input{texpp/cast_ptr.cpp}

% Notice that unions are allowed in logical annotations, but pointer
% casts aren't yet.

\chapter{Reference Manual}

\section{General usage}
\label{sec:general}

The Jessie plug-in is activated by passing option
\verb|-jessie| to \verb|frama-c|. Running the Jessie plug-in
on a file f.jc produces the following files:

\begin{itemize}
\item f.jessie: sub-directory where every generated files go
\item f.jessie/f.jc: translation of source file into intermediate Jessie language
\item f.jessie/f.cloc: trace file for source locations
\end{itemize}

The plug-in will then automatically call the Jessie tool of the Why
platform to analyze the generated file f.jc above. By default, VCs are
generated using Why3 VC generator and displayed in the Why3IDE
interface. Using \verb|-jessie-atp=gui| option will use the Why2 VC
generator and display in the Why GUI interface, as it was the default
in version 2.29 and before (deprecated).

The \verb|-jessie-atp=<p>| option allows to run VCs in batch, using
the given theorem prover \texttt{<p>}. It uses the Why2 VC
generator only, and is thus deprecated. Running prover in batch mode
after using the Why3 VC generator can be done using Why3 tools
\verb|why3bench| or \verb|why3replayer|, see Why3 manual for details.


\section{Unsupported features}

\subsection{Unsupported C features}

\begin{description}
\item[Arbitrary gotos] ~\\
  only forward gotos, not jumping into nested
  blocks, are allowed. There is no plan to support arbitrary gotos in
  a near future.
\item[Function pointers] ~\\
  There is no plan to support them in a near
  future. In some cases, Frama-C's specialization plug-in can be used to
  remove function pointers.
\item[Arbitrary cast] ~\\
  \begin{itemize}
  \item from integers to pointers, from pointer to integers: no support
  \item between pointers: experimental support, only for casts in code, not logic
  \end{itemize}
  Note: casts between integer types are supported
\item[Union types] ~\\
  experimental support, both in code and annotations
\item[Variadic C functions] ~\\
  unsupported

\item[\texttt{volatile} declaration modifier]~\\
  not supported
\item[\texttt{const} declaration modifier]~\\
  accepted but not taken into account, that is treated as non-const.

\end{description}


\subsection{partially supported ACSL features}

\begin{description}
\item[Inductive predicates] ~\\
  supported, but must follow the positive
  Horn clauses style presented in the ACSL documentation.
\item[Axiomatic declarations] ~\\
  supported (experimental)
\end{description}

\subsection{Unsupported ACSL features}

\begin{description}
\item[Logic language] ~\\
  \begin{itemize}
  \item direct equality on structures is not supported. Equality of
    each field should be used instead (e.g. by introducing an adequate
    predicate). Similarly, direct equality of arrays is not supported,
    and equality of each cells should be used instead.
  \item array and structure field functional modifiers are not supported
  \item higher-order constructs \verb|\lambda|, \verb|\sum|,
    \verb|\prod|, etc. are not supported
  \end{itemize}
\item[Logic specifications] ~\\
  \begin{itemize}
  \item model variables and fields
  \item global invariants and type invariants
  \item \verb|volatile| declarations
  \item \verb|\initialized| and \verb|\specified| predicates
  \end{itemize}
\item[Contract clauses] ~\\
  \begin{itemize}
  \item \texttt{terminates} clause
  \item abrupt termination clauses
  \item general code invariants (only loop invariants are supported)
  \end{itemize}
\item[Ghost code] ~\\
  \begin{itemize}
  \item it is not checked whether ghost code does not interfere with
    program code.
  \item ghost structure fields are not supported
  \end{itemize}

\end{description}

\section{Command-line options}

\begin{description}
\item[-jessie]
  activates the plug-in, to perform C to Jessie translation

\item[-jessie-project-name=<s>]
  specify project name for Jessie analysis

\item[-jessie-atp=<s>] See Section~\ref{sec:general}. Deprecated.
% do not launch the GUI but run specified
%   automated theorem prover in batch (among \verb|alt-ergo|,
%   \verb|cvc3|, \verb|simplify|, \verb|yices|, \verb|z3|), or just
%   generate the verification conditions (\verb|goals|)

\item[-jessie-cpu-limit=<i>] set the time limit in sec. for proving
  each VC. Only works when \verb|-jessie-atp| is set. Deprecated.

\item[-jessie-behavior=<s>] restrict verification to the given
  behavior (\texttt{safety}, \texttt{default} or a user-defined
  behavior)

\item[-jessie-std-stubs]
  (obsolete) use annotated standard headers

\item[-jessie-hint-level=<i>]
  level of hints, i.e. assertions to help the
  proof (e.g. for string usage)

\item[-jessie-infer-annot=<s>]
  infer function annotations (inv, pre, spre, wpre)

\item[-jessie-abstract-domain=<s>]
  use specified abstract domain (box, oct or poly)

\item[-jessie-jc-opt=<s>] give an option to
  the jessie tool (e.g., -trust-ai)

\item[-jessie-why-opt=<s>]
  give an option to Why (e.g., -fast-wp)
\end{description}

\section{Pragmas}

\begin{description}
\item[Integer model]~\\

  \texttt{\# pragma JessieIntegerModel}(value)

  Possible values: \texttt{math}, \texttt{defensive}, \texttt{modulo}.

  Default value: \texttt{defensive}
  \begin{itemize}
  \item \texttt{math}: all int types are modeled by mathematical,
    unbounded integers ;
  \item \texttt{defensive}: int types are modeled by integers with
    appropriate bounds, and for each arithmetic operations, it is
    mandatory to show that no overflow occur ;
  \item \texttt{modulo}: models exactly machine integer arithmetics,
    allowing overflow, that is results must be taken modulo $2^n$ for
    the appropriate $n$ for each type.
  \end{itemize}

\item[Floating point model] ~\\

  \texttt{\# pragma JessieFloatModel}(value)

  Possible values: \texttt{math}, \texttt{defensive}, \texttt{full},
  \texttt{multirounding}.

  Default value: \texttt{defensive}.

  \begin{itemize}
  \item \texttt{math}: all float types are modeled by
    mathematical unbounded real numbers
  \item \texttt{defensive}: float types are modeled by real numbers
    with appropriate bounds and roundings, and for each floating-point
    arithmetic operations, it is mandatory to show that no overflow
    occur. This model follows the IEEE-754 standard, under its
    \emph{strict} form, as explained in~\cite{ayad09,ayad10ijcar}.
  \item \texttt{full}: models the full IEEE-754 standard, including
    infinite values and NaNs. This model is the \emph{full} model
    discussed in~\cite{ayad09,ayad10ijcar}.
  \item \texttt{multirounding}: models floating-point arithmetics so
    as to support combinations of compilerd and architectures that do
    not strictly follows IEEE-754 standard (e.g. double roundings,
    80-bits extended formats, compilation usinf fused-multiply-add
    instructions). This is based on paper~\cite{boldo09misc,boldo10-nfm}.

  \end{itemize}

\item[Floating point rounding mode] ~\\

  \texttt{\# pragma JessieFloatRoundingMode}(value)

  Possible values: \texttt{nearesteven}, \texttt{down}, \texttt{up},
  \texttt{tozero}, \texttt{nearestaway}.

  Default value: \texttt{nearesteven}.


\item[Separation policy]~\\

  \texttt{\# pragma SeparationPolicy}(value)

  Possible values: \texttt{none}, \texttt{regions}

\item[Invariant policy]~\\

  \texttt{\# pragma InvariantPolicy}(value)

  Possible values: \texttt{none}, \texttt{arguments}, \texttt{ownership}

\item[Termination policy]~\\

  \texttt{\# pragma JessieTerminationPolicy}(value)

  Possible values: \texttt{always}, \texttt{never}, \texttt{user}

  Default: \texttt{always}

  \begin{itemize}
  \item \texttt{always} means that every loop and every recursive
    function should be proved terminating. If they are not annotated
    by variants, then an unprovable VC ($0<0$) is generated.

  \item \texttt{user} means that VCs for termination are generated for
    each case where a loop or function variant is given. Otherwise no
    VC is generated.

  \item \texttt{never} means no VC for termination are ever generated,
    even for annotated loop or recursive function.

  \end{itemize}

\end{description}

% \chapter{Further reading}

% \begin{itemize}
% \item ACSL By Example: Towards a Verified C Standard
%     Library \url{http://www.first.fraunhofer.de/device_soft_en}.
% \item TODO: Moy thesis, Lecture notes of types summer school, voos
%   winter school.
% \end{itemize}

\section{Troubleshooting}

Here is a set of common error messages and possible fix or workaround.
\begin{description}

\item [unsupported "cannot handle this lvalue"]
  this message may appear in the following situations:
  \begin{itemize}
  \item use an array as a parameter of a logic function. You should use
    a pointer instead.
  \end{itemize}

\item[unsupported "this kind of memory access is not currently supported"]
    this message may appear in the following situations:
  \begin{itemize}
  \item equality on structures in the logic. The workaround is to
    check equality field by field. Tip: define field-by-field equality as a
    logic predicate.
  \end{itemize}

\item[unsupported "Jessie plugin does not support struct or union as
  parameter to logic functions."]  This
  is already quite explicit: jessie does not support structures or
  unions as a parameter of logic functions or predicates. You can
  circumvent this limitation by using an indirection via a pointer.

\item[unsupported "cannot take address of a function"] The jessie
  plugin does not support functions as parameters to other
  functions. There is no simple workaround. One thing you can try is
  to remove the function parameter and use a fixed abstract function
  (i.e. with a contract but no body), and then prove that all the
  functions that might be passed as parameters respect this contract.

\item[unsupported "Type builtin\_va\_list not allowed"] Jessie does not
  handle varyadic functions. The same trick as above could be
  attempted.

\item[unsupported "Casting from type <..> to type <..> not allowed"]
  Jessie does not support this cast, typically between pointer and
  integer. There is no simple workaround. One way of proving such kind
  of code is to replace the casts by an abstract function, whose
  post-condition explicitly explains how the conversion is made.

\item[failure: cannot interpreted this lvalue]
  This may happen if
  \begin{itemize}
  \item using a structure in an assigns clause. You need to expand ans
    say which field are assigned.
  \end{itemize}

\end{description}


\bibliographystyle{plain}
\bibliography{biblio}

\end{document}

\documentclass[a4paper]{report}
\usepackage{hevea}

\usepackage{hyperref}

\setlength{\textheight}{240mm}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\newcommand{\version}{1.4}

%BEGIN LATEX
\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}
%END LATEX

\usepackage[T1]{fontenc}
\usepackage{times}
%HEVEA \newcommand{\includegraphics}[2][2]{\imgsrc{#2}}
%HEVEA \newcommand{\hrulefill}{\relax}
%HEVEA \newcommand{\negtenthspace}{\relax}
%BEGIN LATEX
\usepackage{graphicx}
\newcommand{\negtenthspace}{\hspace*{-0.1\linewidth}}
%END LATEX

\newcommand{\Eg}{\mbox{\it E.g.}, }
%OLDHEVEA \newcommand{\land}{\wedge}
%OLDHEVEA \newcommand{\lor}{\vee}

\usepackage{xcolor}
\definecolor{darkgreen}{rgb}{0, 0.5, 0}

\ifhevea%
\makeatletter%
\renewenvironment{document}{%
\@end{document}%
\@atbegindocument%
\@restartoutput\unskip%
\@print{<#def title>Jessie Plug-in Tutorial</#def>
<#def meta><meta name="GENERATOR" content="hevea }%
\@getprint{\usebox{\@heveaversion}}\@print{"></#def>
<#head>
}%
\usebox{\@toplinks}\usebox{\@linkstext}%
\cutdef*[\thecuttingdepth]{\cuttingunit}%
\renewcommand{\addstyle}[1]{\hva@warn{\addstyle{} must be used in document preamble}}%
\@open@par%Open first paragraph
}{%
\@clearstyle\@footnoteflush{\@footnotelevel}\cutend*\title@flush@hook%
\@atenddocument%
\@final@footer%
\@clearstyle%
\@print{<#foot>}%
\@raise@enddocument}%
\makeatother%
\fi

\begin{document}

\ifhevea%
This document is also available in
\ahref{jessie/jessie-tutorial.pdf}{pdf format}.
\else
\sloppy
\hbadness=10000
\begin{titlepage}
\includegraphics[height=14mm]{inriasaclaylogo.png}
\vfill
\begin{center} \Large
{\Huge\bfseries    Jessie Plug-In Tutorial}

\Large Frama-C version: \emph{Nitrogen}

Jessie plug-in version: 2.30

\vfill

\large  Claude March\'e$^{1,3}$, Yannick Moy$^{2,3}$, 

\vfill

\today
\end{center}
\vfill

\vfill
\begin{flushleft}
$^1$ INRIA Saclay - \^Ile-de-France, ProVal, Orsay, F-91893 \\
$^2$ France T\'el\'ecom, Lannion, F-22307 \\
$^3$ LRI, Univ Paris-Sud, CNRS, Orsay, F-91405
\end{flushleft}
  \textcopyright 2009-2011 INRIA

  This work was supported by the `CAT' ANR project
  (ANR-05-RNTL-0030x), the ANRT CIFRE contract 2005/973, and the `U3CAT'
  ANR project.
\end{titlepage}
\fi




\cleardoublepage
\label{chap:contents}
\tableofcontents

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% End:




