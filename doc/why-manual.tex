\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\te}[1]{\texttt{#1}~}
\newcommand{\nt}[1]{\textsl{#1}~}

\begin{document}

\thispagestyle{empty}
\begin{center}
\vfill
\rule\textwidth{0.1cm}\\[0.3cm]
{\Huge\sf WHY Reference Manual}\\[0.5cm]
{\large August 2001}\\
\rule\textwidth{0.1cm}
\vfill
\noindent Jean-Christophe Filli\^atre
\vfill
\end{center}

\tableofcontents

\chapter{The \why\ tool}

\why\ is a tool to generate proof obligations from annotated programs.
Currently, the input syntax is a fragment of \caml\ (with annotations),
and the output is a \pvs\ theory. Syntax is given in chapter~\ref{syntax}.


\section{Usage}

\why\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{why} \textit{file}$_1$\texttt{.ml} $\cdots$
    \textit{file}$_n$\texttt{.ml}
\end{center}
Each file \textit{file}\texttt{.ml} will be compiled into a \pvs\ theory,
in file \textit{file}\texttt{.pvs}.

If no file is given, then standard input is processed and a \pvs\ theory
named \texttt{WhyOutput} is printed on standard output.


\section{Principles}

\subsection{Input files}

The input file may contain the following kinds of declaration:
\begin{itemize}
  \item \te{pvs "}\textit{any \pvs\ material}\te{"} \par
    Copies the \pvs\ material as-is in the output theory.

  \item \te{external} $x_1,\dots,x_n: \tau$ \par 
    Declares some external program values of type $\tau$.
    They may be constants (i.e. of a primitive type), references 
    or functions. This is to introduce values to be used
    in the program part; values to be used in the specification part
    must be introduced using the \te{pvs} declaration.

  \item \te{let $x$ =} \textit{annotated-program} \par
    Generates the lemmas corresponding to the total correctness of
    the given program, and declares it with name $x$.
\end{itemize}

\subsection{Annotations}

Annotations are predicates over the values of the program variables
visible at the corresponding program point.

Any annotation may refer to the value(s) of a variable.  For a mutable
variable $x$ (a reference or an array), the current value is simply
referred to as $x$. Within a postcondition, the value before the
computation (i.e. at the precondition point) is referred to as $x@$.

Additionally, labels may be inserted in programs (using the 
\te{label} keyword; see the syntax chapter) and the value of $x$ at the
program point labelled $L$ is referred to as $x@L$.
A particular label `0' is automatically inserted at the beginning of the 
program, so that the initial value of $x$ can be referred to as $x@0$.

\paragraph{Example.} Here are examples of program annotations:
\begin{enumerate}
\item
  \verb#{ x >= 0 } x := (sqrt !x) { x >= 0 and (x >= 1 -> x <= x@) }# 
\item
  \verb#while !x < N do { invariant x@0 <= x variant N - x } x := !x+1 done#
\end{enumerate}


\section{Installation}

To compile \why, you need both \textsf{Objective Caml} and
\textsf{Camlp4} to be installed, in version at least 3.01.
Then 

\begin{enumerate}
\item Configure with \texttt{./configure}
\item Compile with \texttt{make}
\item \why\ executable \texttt{bin/why}. It is standalone, 
  so you can move it anywhere, or make a symbolic link to it from anywhere.
\end{enumerate}


\chapter{Syntax}
\label{syntax}

\section{Terms}

Syntax of terms is given in Figure~\ref{fig:terms}.
Usual precedences apply to arithmetical operations.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} 
              \te{(} \nt{term} \te{,} \dots \te{,} \nt{term} \te{)} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
  \\[0.1em]

  \nt{constant}
    & $::=$ & \nt{integer-constant} \\
    & $::=$ & \nt{floating-point-constant} \\
    & $::=$ & \te{true} \\
    & $::=$ & \te{false} \\
    & $::=$ & \te{skip} \\
  \\[0.1em]

  \nt{arith\_op}
    & $::=$ & \te{+} $|$~ \te{-} $|$~ \te{*} $|$~ \te{/}
\end{tabular}\\
\hrulefill
\caption{Syntax of terms}
\label{fig:terms}
\end{center}            
\end{figure}

\section{Predicates}

Syntax of predicates is given in Figure~\ref{fig:predicates}.
It is a first-order quantifier-free syntax, independent from the \pvs\ one.

Precedence of \te{and} is stronger than \te{or}'s one, which is
stronger than the implication's one. Implication is right associative.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{predicate}
    & $::=$ & \nt{predicate} \te{->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{or} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{and} \nt{predicate} \\
      & $|$ & \te{not} \nt{predicate} \\
      & $|$ & \nt{term} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} \\
      & $|$ & \te{(} \nt{predicate} \te{)}
  \\[0.1em]

  \nt{relation}
    & $::=$ & \te{=} $|$~ \te{<>} $|$~ 
              \te{<} $|$~ \te{<=} $|$~ \te{>} $|$~ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of predicates}
\label{fig:predicates}
\end{center}            
\end{figure}

\section{Types}

Syntax of types is given in Figure~\ref{fig:types}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{simple\_value\_type}
    & $::=$ & \nt{primitive\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{ref} \\
      & $|$ & \te{array} \nt{term} \te{of} \nt{simple\_value\_type} \\
      & $|$ & \te{(} \nt{value\_type} \te{)} \\
  \\[0.1em]

  \nt{value\_type}
    & $::=$ & \nt{simple\_value\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{->} \nt{computation\_type} \\
      & $|$ & \nt{identifier} \te{:} \nt{simple\_value\_type} 
              \te{->} \nt{computation\_type} \\
  \\[0.1em]

  \nt{computation\_type}
    & $::=$ & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      &     & $[$ \te{returns} \nt{identifier} \te{:} $]$ \nt{value\_type} \\
      &     & $[$~ \te{reads} 
                   \nt{identifier}\te{,}\ldots\te{,}\nt{identifier} $]$~ \\
      &     & $[$~ \te{writes} 
                   \nt{identifier}\te{,}\ldots\te{,}\nt{identifier} $]$~ \\
      &     & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      & $|$ & \nt{value\_type} \\
  \\[0.1em]

  \nt{primitive\_type}
    & $::=$ & \te{int} $|$~ \te{bool} $|$~ \te{float} $|$~ 
              \te{unit} $|$~ \nt{identifier}
\end{tabular}\\
\hrulefill
\caption{Syntax of types}
\label{fig:types}
\end{center}            
\end{figure}

\section{Annotated Caml programs}

Syntax of annotated \caml\ programs is given in Figure~\ref{fig:caml}.
\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{prog} 
    & $::=$ & \te{\{} \nt{predicate} \te{\}}$^*$
              \nt{statement} 
              $[$ \te{\{} \nt{predicate} \te{\}} $]$ \\

       & & \\[0.1em]

  \nt{statement}
    & $::=$ & \nt{expression} \\
      & $|$ & \nt{identifier}  \te{:=}  \nt{prog} \\
      & $|$ & \nt{identifier}  \te{[}  \nt{expression}  \te{]}
              \te{:=}  \nt{prog} \\
      & $|$ & \te{let}  \nt{identifier}  \te{=}  \te{ref} 
              \nt{prog}  \te{in}  \nt{prog} \\
      & $|$ & \te{if}  \nt{prog}  \te{then}  \nt{prog}
              $[$~ \te{else}  \nt{prog} $]$ \\
      & $|$ & \te{while}  \nt{prog}  \te{do}
              \nt{loop\_annot}  \nt{block}  \te{done} \\
      & $|$ & \te{begin}  \nt{block}  \te{end} \\
      & $|$ & \te{let}  \nt{identifier}  \te{=}  \nt{prog} 
              \te{in}  \nt{prog} \\
      & $|$ & \te{fun}  \nt{binders}  \te{->}  \nt{prog} \\
      & $|$ & \te{let}  \te{rec}  \nt{identifier}  \nt{binders}  \te{:}
              value\_type \\
      &     & \te{\{}  \te{variant}  \nt{wf\_arg}  \te{\}}
              \te{=}  \nt{prog}  $[$~ \te{in}  \nt{prog} $]$ \\
      & $|$ & \te{(}  \nt{prog}$^+$~  \te{)} \\

      & & \\[0.1em]

  \nt{expression}
    & $::=$ & \nt{identifier} \\
      & $|$ & \te{!}  \nt{identifier} \\
      & $|$ & \nt{identifier}  \te{[}  \nt{expression}  \te{]} \\
      & $|$ & \nt{integer} \\
      & $|$ & \te{(}  \nt{expression}$^+$~  \te{)} \\

      & & \\[0.1em]

  \nt{block} 
    & $::=$ & \nt{block\_statement}  $[$~ \te{;} \nt{block} $]$ \\

      & & \\[0.1em]

  \nt{block\_statement}
    & $::=$ & \nt{prog} \\
      & $|$ & \te{label}  \nt{identifier} \\
      & $|$ & \te{assert}  \te{\{}  \nt{predicate}  \te{\}} \\

      & & \\[0.1em]

  \nt{binders}
    & $::=$ & \te{(} \nt{identifier}\te{,}\dots\te{,}\nt{identifier}  \te{:}
              \nt{value\_type}  \te{)}$^+$ \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{\{}  \te{invariant}  \nt{predicate} 
              \te{variant}  \nt{wf\_arg}  \te{\}} \\
      & & \\[0.1em]

  \nt{wf\_arg} 
    & $::=$ & \nt{term}  $[$~ \te{for} \nt{term} $]$ \\

\end{tabular}\\
\hrulefill
\caption{Syntax of annotated programs}
\label{fig:caml}
\end{center}
\end{figure}

\section{Input files}

Syntax of input files is given in Figure~\ref{fig:input}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{file}
    & $::=$ & \nt{declaration}$^*$
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \te{let} \nt{identifier} \te{=} \nt{prog} \\
      & $|$ & \te{external} \nt{identifier}\te{,}\dots\te{,}\nt{identifier}
              \te{:} \nt{value\_type} \\
      & $|$ & \te{pvs} \nt{string}
\end{tabular}\\
\hrulefill
\caption{Syntax of input files}
\label{fig:input}
\end{center}            
\end{figure}

\end{document}
