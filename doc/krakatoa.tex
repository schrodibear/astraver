\documentclass[a4paper,11pt,twoside,openright]{report}

\usepackage[a4paper=true,pdftex,colorlinks=true,urlcolor=blue,pdfstartview=FitH]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage{color}
%\usepackage{mathptm}
%\usepackage{xspace}
\usepackage{makeidx}
\makeindex
\input{./version.tex}
\input{./macros.tex}

\setlength{\textheight}{240mm}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}

\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}

\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\footrulewidth}{0.4pt}
\addtolength{\headheight}{2pt}
\addtolength{\headwidth}{1cm}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\chead{}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lfoot{\fancyplain{}{C. March\'e}}
\cfoot{\fancyplain{}{Why platform, Krakatoa tool}}
\rfoot{\fancyplain{}{ProVal, \today}}


\begin{document}
\sloppy
\hbadness=9999

\whytitlepage{The Krakatoa Verification Tool\\~\\for \Java{} programs}{Tutorial and Reference Manual}{\krakatoaversion}{Claude March\'e}


\tableofcontents

\chapter{Introduction}

Krakatoa is a tool for certification of Java programs, annotated using
the Java Modeling Language~\cite{leavens00preliminary} (JML for
short), using the \Why{}~\cite{why} tool for generating proof
obligations.

This version \krakatoaversion{} of Krakatoa is a major rewriting of  
the version 0.x family. Major changes have occured including changes in the syntax of annotations.

Chapter~\ref{chap:tutorial} is a tutorial to introduce the user step
by step to the use of Krakatoa. 

Chapter~\ref{chap:reference} is a reference manual where all options
of the tool are described, and also the modeling of Java objects and
Java memory heap, that you may encounter if you discharge proofs interactively, e.g. using Coq.

In the appendix you will find various additional informations,
including the requirements, a summary of known limitations, and how to
get help. 


\chapter{Tutorial}
\label{chap:tutorial}

Before going to the first lesson, please start by creating a new
directory \verb|tutorial|.

%Notice that the examples of this tutorial are done with version 2.05
%of \Why{}. We recommend to use this version, since with other versions,
%significant differences may exist in the generated proof obligations,
%in particular with hypothesis names, or even the number of proof obligations.

\section{The basics of the methodology}

We start by a very simple static method, that computes the maximum of
two integers. In the \verb|tutorial| sub-directory, write the
following \Java{} program 
%of Figure~\ref{java:max} 
into a new file \verb|Lesson1.java|.
\input{Lesson1_max.pp}
Our aim is to verify that the body of method \texttt{max} is a correct
implementation, in the sense that it satisfies the JML specification
given.

The first step to do is running the \Krakatoa{} tool: execute the
following command in the directory \verb|tutorial|: 
\begin{verbatim}
gvc Lesson1.java
\end{verbatim}
The arguments of that command means that we want to certify the method
\verb|Lesson1.max| in the package \verb|tutorial|. The execution of
that command generates several files in directory \verb|tutorial|,
including a \verb|makefile|. 
% Notice that \Krakatoa{} issues a warning
% about a possible missing assignable clause, you can ignore it, this will be
% explained in Section~\ref{sec:subprograms}.

The next step is the generation of proof obligations, for that purpose
we use the \Why{} tool. This can be done using the generated
\texttt{makefile}, you simply need to type
\begin{verbatim}
make -C tutorial coq
\end{verbatim}
This calls the \Why{} tool with the necessary arguments, and start
compilation of several \Coq{} files. When it is done, please open the file
\verb|tutorial/Lesson1_max_why.v|, for example with \texttt{coqide},
the integrated development environment of \Coq{}. This is the file where \Why{} put the
proof obligations, it should look like the following:
\begin{small}
\begin{verbatim}
(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export Krak_spec_why.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma Lesson1_max_body_po_1 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x > y),
  (x >= x /\ x >= y) /\ (forall (z:Z), (z >= x /\ z >= y -> z >= x)).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma Lesson1_max_body_po_2 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_2: x <= y),
  (y >= x /\ y >= y) /\ (forall (z:Z), (z >= x /\ z >= y -> z >= y)).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.
\end{verbatim}
\end{small}
After the \texttt{Require} command loading some module importations, this
file contains two lemmas with uncomplete proofs. You
essentially have to prove that the post-condition is valid, for each
of the cases $x>y$ and $x\leq y$, coming from the original conditional
statement of the Java program.  

The next step is up to you: you need to fill the proofs of the lemmas.
Notice that in fact, this file compiled entirely without errors,
because in this first lesson, the default tactics \verb|intuition| is
enough to prove the two lemmas. You should anyway remove the comments
\texttt{(* FILL PROOF HERE *)}.

Congratulations! You've made your first \Krakatoa{}-certified program!

% \paragraph{Validation}

% After the proof obligations have been proved, it is possible to
% perform an additional verification step called the \emph{validation}. 
% It is a definition of a \Coq{} function which is a
% functional translation of the original Java method. Its type
% should corresponds quite naturally to the JML specification of that
% method.

% You may ask for generation of this validation by running again
% krakatoa with the additional option \verb|-valid|. This will generate
% a file \verb|Lesson1_max_valid.v| starting as: 
% \begin{small}
% \begin{verbatim}
% Definition Lesson1_max_body (* validation *)
%   : forall (x: Z), forall (y: Z),
%     (sig_1 Z
%      (fun (result: Z)  => ((result >= x /\ result >= y) /\
%       (forall (z:Z), (z >= x /\ z >= y -> z >= result)))))
%   := <body>
% \end{verbatim}
% \end{small}
% that is, a function whose type is the specification of
% \verb|Lesson1.max|. The whole compilation of all the files generated
% will check that this type is actually the type of \verb|<body>|.

\section{Loop invariants}
\index{loop invariant}
\index{invariant clause@\texttt{invariant} clause}

Methods get a bit harder to prove in presence of loops. Below is the
specification of a method for computing the square root of an 
integer (rounded down).
\input{Lesson1_sqrt.pp}
We propose an algorithm based on the following remark: we know that 
\[
\sum_{i=0}^{k-1} 2i+1 = k^2
\]
so the square root of $n$ is the smallest integer $k$ such that
\[
\sum_{i=0}^{k} 2i+1  
\]
is greater than $n$.

Please, add the following to your class \texttt{Lesson1}.
\input{Lesson1_sqrtbody.pp}
If you generate the proof obligations now, using
\begin{verbatim}
krakatoa -p tutorial Lesson1.sqrt
make -C tutorial coq
\end{verbatim}
you will realize soon that they are not provable. Indeed, as usual in
Floyd-Hoare logic, it is required to add a loop invariant to have
enough information. More specifically to \Krakatoa{}, you also need to
add a loop \emph{variant}\index{variant}, an integer expression whose
value decreases at each loop.

In that particular example, the variant is not difficult to find: the
value of \texttt{sum} increases at each loop, until it reaches the
value of \texttt{x}: so \texttt{x-sum} is a good variant.

Finding the right invariant is usually hard, and usually follows from the
principle of the algorithm. Here, \texttt{count} will increase one by
one, whereas \texttt{sum} will always be the sum of odd integers
between \texttt{1} and \texttt{2*count+1}, that is
\texttt{(count+1)*(count+1)}. So we suggest the following
\input{Lesson1_sqrtloopinv.pp}
Now let's go to the proof of obligations, for example by running
\begin{verbatim}
coqide Lesson1_sqrt_why.v
\end{verbatim}
The first proof obligation is 
required to prove that the loop invariant is true when
entering the loop. It is is automatically solved by the
the \verb|intuition| tactic. 
The second proof obligation, after running
the \verb|intuition| tactic, results in two subgoals:
\begin{small}
\begin{verbatim}
x : Z
HW_1 : x >= 0
count : Z
sum : Z
HW_3 : sum <= x
H0 : sum = (count + 1) * (count + 1)
H1 : count >= 0
H2 : x >= count * count
count0 : Z
HW_4 : count0 = count + 1
sum0 : Z
HW_5 : sum0 = sum + 2 * count0 + 1
______________________________________(1/2)
x >= count0 * count0
______________________________________(2/2)
sum0 = (count0 + 1) * (count0 + 1)
\end{verbatim}
\end{small}
These goals are required to prove that the loop invariant remains true
in any execution of the loop body. Think of variables \verb!count! and
\verb!sum! as the values of the corresponding memory cells before the
execution, and 
the ones indexed by 1 as the value after the execution.  Notice that
the proof of decrease of the variant has been solved automatically.

Let's solve the first goal: if you replace \verb|count0| by its value
\verb|count+1| given by \verb|HW_4|, you have to prove 
\verb|x >= (count+1)*(count+1)|, something that follows immediately from
\verb|HW_3| and \verb|H0| by linear arithmetic. So the tactic
\verb|subst count0; omega.| solves the goal. For the second one, if
you replace \verb|sum0|, \verb|sum| and \verb|count0| by there values
in hypotheses, then the goal becomes a trivial ring equality, so the tactic 
\verb|subst sum0 sum count0; ring.| is enough.

% \begin{small}
% \begin{verbatim}
% x : Z
% Pre4 : x >= 0
% sum : Z
% Post5 : sum = 1
% count : Z
% Post4 : count = 0
% ______________________________________(1/2)
% x >= count * count

% ______________________________________(2/2)
% sum = (count + 1) * (count + 1)
% \end{verbatim}
% \end{small}
% these are required to prove that the loop invariant is true when
% entering the loop. Proofs are trivially done by substitution of
% these variables and linear arithmetic:
% \begin{small}
% \begin{verbatim}
% subst count; omega.
% subst count sum; omega.
% \end{verbatim}
% \end{small}

The third and last proof obligation is required to show that the
post-condition of the method is satisfied, provided that the invariant
is true after the loop, and also that the while condition is
false. These are automatically done by the \verb|intuition| tactic. 

\section{Array accesses}

In this lesson, we now consider arrays. You should now create a new
file \verb|Arrays.java|. Here is the specification of a method for computing 
the maximum element of an array of ints, given as argument:
\input{Arrays_findMax.pp}
The precondition is necessary to ensure that \verb|t| is a non-empty
array, so that the maximum exists. An alternative would have been to
raise an exception in that case, but exceptions will be considered
later. 

We propose the following code for that method:
The loop invariant ensures that \verb|r| is always the index of the maximum
element of \verb|t| between \verb|0| and \verb|i-1|. We put also as
invariant the facts that \verb|r| and \verb|i| remain in the bounds of
\verb|t|. 

On this method, \Krakatoa{} and then \Why{} produce six proof
obligations. Let's see them in details. The first one is
\begin{small}
\begin{verbatim}
______________________________________(1/1)
forall (t : value) (alloc : alloc_table),
(t <> Null /\ arraylength alloc t >= 1) /\ instanceof alloc t ArrIntType ->
t <> Null /\ is_valid_index alloc t 0
\end{verbatim}
\end{small}
which must be read as follows: given a value \verb|t| and a store
\verb|alloc|, 0 is a valid index for \verb|t| in \verb|alloc|, provided
three conditions: \verb|t| is not null, \verb|t.length >=1|, and
\verb|t| is an instance of \verb|int[]|.

\index{is_valid_index@\texttt{is\_valid\_index}}
\index{instanceof@\texttt{instanceof}}
\index{arraylength@\texttt{arraylength}} \index{store@\texttt{store}}
In the \Coq{} modeling of Java, generated by \Krakatoa{},
\verb|value|\index{value} is the type of any non-primitive Java value,
that is either the \verb|null| value\index{Null@\texttt{Null}}, or an
object or array \emph{reference} (i.e. a memory address). Primitive
values of type \verb|int| or \verb|boolean| are represented by
elements of \verb|Z| or \verb|bool| (floats are not supported yet).

\begin{figure}[t]
\newcommand{\case}{\multicolumn{1}{|r|}{\phantom{0}}}
\begin{center}
\begin{tabular}{c|c|rrrrrrrrrr}
\multicolumn{3}{r}{} & \qquad & \qquad & \qquad & \qquad & \qquad \\
\multicolumn{2}{r}{\texttt{alloc:alloc\_table}} & \multicolumn{1}{r}{} &
\multicolumn{9}{l}{\texttt{intA : int memarray}} \\
\multicolumn{2}{r}{\qquad\qquad} & & \footnotesize 0 & \footnotesize 1 &
\footnotesize 2 & \footnotesize 3 & \multicolumn{4}{l}{$\cdots$} \\ 
\cline{2-2}\cline{4-8}
$a_1$  & int[5]     & & \case & \case &\case&\case&\case\\
\cline{2-2}\cline{4-11}
$a_2$  & int[8]    & &\case & \case &\case&\case&\case&\case&\case&\case\\ 
\cline{2-2}\cline{4-11}
$a_3$  & int[3]    & &\case& \case &\case \\
\cline{2-2}\cline{4-6}
$\vdots$  & $\vdots$    & & \multicolumn{2}{l}{$\vdots$} 
\end{tabular}
\end{center}
\caption{Modeling of Java memory heap: allocation table and an array
  of integers}
\label{fig:arrays}
\end{figure}

Figure~\ref{fig:arrays} represents roughly the modeling we use for Java
memory heap.  \verb|alloc_table| is the type of allocation tables, an
allocation table is
roughly a map that, given an address, tells if it is allocated, and if
yes what is the type of the structure (object or array) at this
address. The function \verb|arraylength|, of type
\verb|alloc_table->value->Z|, is the \Coq{} function corresponding to
\verb|.length| in \Java{}.  It is defined as a total function on
values (returning the meaningless default value 0 for \verb|null| and
for references that are not allocated as arrays in the given store).
The predicate \verb|is_valid_index|, of type \texttt{alloc\_table -> value ->
  Z -> Prop}, tells if a given index $i$ is valid for a value, i.e.
the value is allocated, as an array of length $n$, such that $0\leq
i<n$. 

\index{ArrayOutOfBoundsException}
This proof obligation is required for validation of the first
statement \verb|int m = t[0];| of the method. You see, on that example
of array access, that you are asked to prove that the index is not
outside the array bounds. This is an important feature of \Krakatoa{}:
you are not supposed to allow the exception
\verb|ArrayOutOfBoundsException| be
thrown by your program.  See~\ref{sec:features} for more details.

Now, how does this should be proved? This is a simple arithmetic fact
since we have by hypothesis that length of \verb|t| is at least 1. The
\verb|intuition| tactics is enough to solve that goal, since
\Krakatoa{} has added for you the necessary lemmas, in the \emph{Hint}
base.

The second proof obligation is required for proving that the loop
invariant is true when entering the loop. i.e. when $i=1$. A first
call to \verb|intuition| solves the invariant except for the last part
which says that for all $j$ such that $0\leq j < i$ we have $t[j]\leq
t[0]$. It is a simple consequence of the fact that $j=0$.
\begin{small}
\begin{verbatim}
intuition.
assert (j=0); subst; intuition.
\end{verbatim}
\end{small}

%%%%
% The second proof obligation asks to prove that \verb|t!=Null| in some
% quite large context. The hypotheses are quite numerous because they
% include in particular the loop invariant. This is a precondition to
% the use of \verb|t.length| in the \verb|for| loop. This is trivial
% since \verb|t| is non null by assumption, so \verb|intuition| solves
% it, indeed even \verb|tauto| is enough.

The third proof obligation asks to show that the
first array access \verb|t[i]|, in the loop's body, is inside the array
bounds.  As for the first proof, the \verb|intuition| tactics solves
it. Notice that you are not asked to prove that the second array access
\verb|t[i]| in the loop's body is inside the array bounds: \Why{} is
smart enough to discharge this proof automatically.

The fourth proof obligation is even larger than the previous ones. It
is in fact the preservation of the loop invariant, and decrease of the
loop variant.  If you execute the default \verb|intuition|
tactic, you end up with two subgoals to solve. The first of them is 
\begin{small}
\begin{verbatim}
...
HW_6 : i < arraylength alloc t
H5 : forall j : Z, 0 <= j < i -> intA : t [j] <= m
H6 : t = Null -> False
H7 : is_valid_index alloc t i
H9 : m = intA : t [r]
H10 : r < arraylength alloc t
H11 : 0 <= r
H : 1 <= i
H12 : i <= arraylength alloc t
result0 : Z
HW_8 : result0 = intA : t [i]
HW_9 : result0 > m
r0 : Z
HW_10 : r0 = i
H8 : t = Null -> False
H13 : is_valid_index alloc t i
result1 : Z
HW_12 : result1 = intA : t [i]
m0 : Z
HW_13 : m0 = result1
i0 : Z
HW_14 : i0 = i + 1
______________________________________(1/2)
m0 = intA : t [r0]
\end{verbatim}
\end{small}
For the first time, we see the \Coq{} notation for array access:
\verb|intA:t[i]| means \verb|t[i]| in the \emph{array memory}
\verb|intA|. Such an array memory has the structure shown on
Figure~\ref{fig:arrays}: it is a map which, to an array reference value
$t$ and a valid index $i$, associates $t[i]$.
So the obligation above is required by the assertion \verb|m == t[r]|
in the loop invariant, when the test inside the loop is true
(hypothesis \verb|HW_8| and \verb|HW_9|), in other words after the statements
\verb|r=i;m=t[i];| are executed. Performing the proof is not so hard,
you need to substitute the new values of \verb|m| and \verb|r|, so
\begin{small}
\begin{verbatim}
subst; trivial.
\end{verbatim}
\end{small}
does the job.

The second subgoal is
\begin{small}
\begin{verbatim}
...
HW_14 : i0 = i + 1
j : Z
H15 : 0 <= j
H16 : j < i0
______________________________________(1/1)
intA : t [j] <= m0
\end{verbatim}
\end{small}
that is to prove that \verb|t[j]<=m| for any \verb|j| between $0$ and
$\verb|i0|-1$.  This is of course to show that the new value of \verb|m| is 
indeed the maximum of the array between those bounds. To prove that,
you have two cases, depending whether \verb|j| is equal to
$\verb|i0|-1$ or less. You should perform this case reasoning in
\Coq{}, for example by introducing an assertion like this :
\begin{small}
\begin{verbatim}
assert (j = i \/ j < i) ; [ omega | intuition ].
\end{verbatim}
\end{small}
(the \verb|omega| tactic will indeed prove the assertion, and the
\verb|intuition| tactic will split the two cases). We have then the
following subgoal~2.1:
\begin{small}
\begin{verbatim}
...
HW_12 : result1 = intA : t [i]
HW_13 : m0 = result1

...
H12 : j = i
______________________________________(1/2)
intA : t [j] <= m0
\end{verbatim}
\end{small}
which is solved by \verb|subst j; omega|, and the subgoal~2.2:
\begin{small}
\begin{verbatim}
...
H5 : forall j : Z, 0 <= j < i -> intA : t [j] <= m
...
...
HW_8 : result0 = intA : t [i]
HW_9 : result0 > m
...
HW_12 : result1 = intA : t [i]
HW_13 : m0 = result1
...
H10 : 0 <= j
...
H12 : j < i
______________________________________(1/1)
intA : t [j] <= m0
\end{verbatim}
\end{small}
which should be proved using the hypothesis \verb|H5| that states that the
 invariant was true at the beginning of the loop. You can do 
\begin{small}
\begin{verbatim}
generalize (H5 j).
omega.
\end{verbatim}
\end{small}
to solve it, or even better, to avoid relying on hypothesis name: 
\begin{small}
\begin{verbatim}
assert ((intA:t[j]) <= m); auto with *.
\end{verbatim}
\end{small}
The fifth proof obligation is quite similar, but in the case the test
inside the loop is false. After \verb|intuition| it becomes:
\begin{small}
\begin{verbatim}
...
H5 : forall j : Z, 0 <= j < i -> intA : t [j] <= m
...
H9 : m = intA : t [r]
H10 : r < arraylength alloc t
H11 : 0 <= r
H : 1 <= i
H12 : i <= arraylength alloc t
result0 : Z
HW_8 : result0 = intA : t [i]
HW_15 : result0 <= m
i0 : Z
HW_16 : i0 = i + 1
j : Z
H13 : 0 <= j
H14 : j < i0
______________________________________(1/1)
intA : t [j] <= m
\end{verbatim}
\end{small}
You should solve that again by case reasoning:
\begin{small}
\begin{verbatim}
assert (j = i \/ j < i) ; [ omega | intuition ].
subst j; omega.
\end{verbatim}
\end{small}
The sixth and last proof obligation is required to show that the
post-condition of \verb|findMax| is true, provided that the loop
invariant is true at the end of the loop. This is quite easy, solved
by:
\begin{small}
\begin{verbatim}
intuition.
subst; auto with *.
\end{verbatim}
\end{small}

\section{Calling pure methods in annotations}

In the previous lessons, we wrote twice an assertion stating that some
integer is the maximum of some part of the array: in the
post-condition and in the loop invariant. Indeed, it is a frequent
case, where one would want to have some sort of abbreviation. In JML,
one way to do it is to use an auxiliary \emph{pure} method. 
Here is what can be done on the \verb|findMax| example:

\input{Arrays_findMax2.pp}
You see that the two assertions with \verb|\forall| have been replaced
by a call to \verb|isMax|. In JML, this is allowed because the
\verb|isMax| method is \emph{pure}, and declared as this, meaning that
it does not modify the global state of the program.

The effect of such a declaration is to introduce in the file 
\verb!Krak_spec.why! a new logical function 
\verb|Arrays_isMax| in \Why{} with an axiom which states that if 
the pre-condition is true, then the post-condition is satisfied by 
the result of this function.
\begin{small}
\begin{verbatim}
Check Arrays_isMax_axiom.
Arrays_isMax_axiom
     : forall (alloc : alloc_table) (intA : memarray Z) (t : value) (i l : Z),
       (t <> Null /\ 0 <= l) /\ l <= arraylength alloc t ->
       (Arrays_isMax alloc intA t i l = true <->
        0 <= i < l /\
        (forall j : Z, 0 <= j < l -> intA : t [j] <= intA : t [i]))
\end{verbatim}
\end{small}
% \verb|Arrays_isMax| in \Coq{}, that has been added in file
%\verb|Krak_model.v|, which is automatically imported at the beginning of file
% \verb|Arrays_findMax2_why.v|: 
%
% The effect of such a declaration is to introduce a new predicate
% \verb|Arrays_isMax| in \Coq{}, that has been added in file
% \verb|Krak_model.v|, which is automatically imported at the beginning of file
% \verb|Arrays_findMax2_why.v|: 
% \begin{small}
% \begin{verbatim}
% Print Arrays_isMax.
% Arrays_isMax = 
% fun (heap:store) (intA:memarray_int) (t:value) (i l:Z) =>
%   (t != Null /\ 0 <= i /\ i < l /\ l <= arraylength heap t) /\
%   (forall j:Z, 0 <= j < l -> intA : t [j] <= intA : t [i])
%      : store -> memarray_int -> value -> Z -> Z -> Prop
% \end{verbatim}
% \end{small}

For the proof the only thing that changes with
respect to the previous lesson, is that some time to time, you will
need to use the axiom for \verb|Arrays_isMax|. The easiest way to do
it is using the \verb!Rewrite Arrays_isMax_axiom! tactic. Proofs are left
as exercise. 
%Some times, it may be a good idea to start a proof as
% \begin{small}
% \begin{verbatim}
% unfold Arrays_isMax; intuition.
% \end{verbatim}
% \end{small}
% to globally unfold the definition of the predicate.

\section{Array updates, the \texttt{Krakatoa} tactic}
\index{Krakatoa tactic@\texttt{Krakatoa} tactic}

So far we have seen examples of array access, we now consider array
modification. Here is a method which shifts to the right all elements
of an array of integers, that we add to our \verb|Arrays| class:
\input{Arrays_shift.pp}
For this method, five obligations are generated. The first three are
done by \verb|intuition|.

The forth obligation is the hard one: the preservation of the loop
invariant. After \verb|intuition|, two subgoals remain, the first one
is 
\begin{small}
\begin{verbatim}
...
HW_6 : result = intA0 : t [j - 1]
...
HW_8 : result0 = array_upd intA0 t j result
HW_9 : intA1 = result0
HW_10 : j0 = j - 1
...
H10 : forall i : Z, 0 <= i <= j -> intA0 : t [i] = intA : t [i]
i : Z
H11 : 0 <= i
H12 : i <= j0
______________________________________(1/2)
intA1 : t [i] = intA : t [i]
\end{verbatim}
\end{small}
that corresponds to the part 
\begin{verbatim}
(\forall int i; 0 <= i && i <= j ; t[i] == \old(t[i]))
\end{verbatim}
of the loop invariant. For the first time, we meet a proof obligation
where several memory states are involved. Here, you may think of
\verb|intA| as the current state of memory at the beginning of the
method, \verb|intA0| as the state at the beginning of the loop's body,
and \verb|intA1| as the state at the end of the loop's body.
\verb|intA1| and \verb|intA0| are related by
\begin{small}
\begin{verbatim}
intA1 = array_update intA0 t j result
\end{verbatim}
\end{small}
%{\Huge plus de syntax pour les updates}
%the syntax \verb|heap/v#c<-r| denotes the new heap obtained from the
%heap \verb|heap| by putting at cell \verb|c| of reference \verb|v|
%the new value \verb|r|. 

We first substitute \verb|intA1| and \verb!result0! by their values to get the goal
\begin{small}
\begin{verbatim}
______________________________________(1/2)
array_upd intA0 t j result : t [i] = intA : t [i]
\end{verbatim}
\end{small}
Now, we have an occurrence of the general scheme 
\begin{verbatim}
(array_upd m t1 i1 r) : t2 [i2]
\end{verbatim}
that is we access to index
\verb|i2| of array \verb|t2| in a memory state where we just have put
value \verb|r| in index \verb|i1| of array \verb|t1|. It is clear that
if \verb|t1=t2| and \verb|i1=i2| then this is equal to \verb|r|, and
otherwise it is equal to \verb|m : t2 [i2]|. There is a tactic that
will do that simplification for you, named \verb|krakatoa|. If you run
it on that example, it will find automatically that \verb|j| is
different from \verb|i|, and moreover will solve the resulting goal 
\begin{small}
\begin{verbatim}
intA0 : t[i] = intA : t[i]
\end{verbatim}
\end{small}
automatically from \verb|H7|. The second subgoal corresponds to part
\begin{small}
\begin{verbatim}
 (\forall int i; j < i && i < t.length ; t[i] == \old(t[i-1]))))
\end{verbatim}
\end{small}
of the loop invariant:
\begin{small}
\begin{verbatim}
...
H11 : j0 < i
H12 : i < arraylength alloc t
______________________________________(1/1)
intA1 : t [i] = intA : t [i - 1]
\end{verbatim}
\end{small}
after \verb|subst intA1 result0| we get
\begin{small}
\begin{verbatim}
______________________________________(1/1)
array_upd intA0 t j result : t [i] = intA : t [i - 1]
\end{verbatim}
\end{small}
We may try the \verb|krakatoa| tactic, but in that case it will do
nothing, because it cannot decide whether \verb|j| and
\verb|i| are equal. Indeed, it depends on \verb|i|, so we need to
reason by cases, whether \verb|i| is equal to \verb|j| or not:
\begin{small}
\begin{verbatim}
assert (j < i \/ i = j) ; [ omega | intuition ].
\end{verbatim}
\end{small}
then two subgoals are generated. The first one is
\begin{small}
\begin{verbatim}
...
H13 : j < i
______________________________________(1/2)
array_upd intA0 t j result : t [i] = intA : t [i - 1]
\end{verbatim}
\end{small}
which can be solved by \verb|krakatoa|. The second one is
\begin{small}
\begin{verbatim}
...
H13 : i = j
______________________________________(1/1)
array_upd intA0 t j result : t [i] = intA : t [i - 1]
\end{verbatim}
\end{small}
we also apply \verb|krakatoa| to get:
\begin{small}
\begin{verbatim}
______________________________________(1/1)
result = intA : t [j - 1]
\end{verbatim}
\end{small}
that is provable by 
\begin{small}
\begin{verbatim}
subst i result.
auto with *.
\end{verbatim}
\end{small}
and the forth proof obligation is proved. The last proof obligation, after \verb|intuition|, is 
\begin{small}
\begin{verbatim}
...
H2 : arraylength alloc t > 0 ->
     (0 <= j /\ (forall i : Z, 0 <= i <= j -> intA0 : t [i] = intA : t [i])) /\
     (forall i : Z,
      j < i < arraylength alloc t -> intA0 : t [i] = intA : t [i - 1])
i : Z
H3 : 0 < i
H4 : i < arraylength alloc t
______________________________________(1/1)
intA0 : t [i] = intA : t [i - 1]
\end{verbatim}
\end{small}
This is almost trivial, but cannot be solved automatically, because
our automatic tactics are not smart enough to see that the hypothesis
\verb|arraylength heap t > 0| of \verb|H2| is true. But with a little
help, it is OK:
\begin{small}
\begin{verbatim}
assert (arraylength alloc t > 0); [ omega | intuition ].
\end{verbatim}
\end{small}


\section{Objects and constructors}

It is time to consider true \Java{} objects. Let's consider the
following class that implements a very simple electronic purse.
\input{Purse.pp}

\begin{figure}[t]
\newcommand{\case}{\multicolumn{1}{|r|}{\phantom{0}}}
\begin{center}
\begin{tabular}{c|c|rlcl}
\multicolumn{3}{r}{} \\
\multicolumn{2}{r}{\texttt{heap:store}} & \multicolumn{1}{r}{} &
\multicolumn{3}{l}{\texttt{balance}} \\
\multicolumn{2}{r}{\qquad\qquad} & & ~ \\
\cline{2-2}\cline{5-5}
$a_1$  & Purse  & & & \case\\
\cline{2-2}\cline{5-5}
$a_2$  & Purse    & & & \case \\
\cline{2-2}\cline{5-5}
$a_3$  & Purse    & & & \case \\
\cline{2-2}\cline{5-5}
$\vdots$  & $\vdots$    & & & \multicolumn{1}{|c|}{$\vdots$} 
\end{tabular}
\end{center}
\caption{Modeling of Java memory heap: memory heaps for object fields}
\label{fig:fields}
\end{figure}

We first try to prove the methods \verb|credit| and \verb|withdraw|.
We type
\begin{verbatim}
krakatoa -p tutorial Purse.credit Purse.withdraw
make -C tutorial coq
\end{verbatim}
The generated file \verb|Purse_credit_why.v| contains one proof
obligation. After \verb|intuition| it splits up
into two subgoals. The first one is:
\begin{small}
\begin{verbatim}
this : value
s : Z
Purse_balance : memory Z
alloc : alloc_table
H : s >= 0
H1 : this = Null -> False
H0 : instanceof alloc this (ClassType Purse)
H2 : Object_invariant this
H4 : Purse_invariant Purse_balance this
result : Z
HW_2 : result = this # Purse_balance
result0 : memory Z
HW_3 : result0 = upd Purse_balance this (result + s)
Purse_balance0 : memory Z
HW_4 : Purse_balance0 = result0
______________________________________(1/3)
this # Purse_balance0 = this # Purse_balance + s
\end{verbatim}
\end{small}
We first meet the notation $v\#f$ which denotes access to the field
$f$ of object $v$, that is $t.v$ in Java. In the \Coq{} modeling, such
a field name is represented by a logical variable of the same name,
which as the structure shown on Figure~\ref{fig:fields}: it is a map
from references to primitive or references values, that we call a
\emph{memory}. In that example, \verb|Purse_balance| has type % 
\verb|memory Z|, a memory which contains integer values.  So the goal
above is to prove the post-condition of the method, where
\verb|Purse_balance| and \verb|Purse_balance0| represent the values of the
\verb|Purse_balance| field respectively at the beginning and at the end of
the method. The first thing to do is \verb|subst Purse_balance0 result0.| to get the
subgoal
\begin{small}
\begin{verbatim}
this # (upd Purse_balance this (result + s)) = this # Purse_balance + s
\end{verbatim}
\end{small}
we find again an occurrence of the scheme ``access to an update'', for
which the \verb|krakatoa| tactic is for: \verb|krakatoa.| solves that
goal. The second subgoal is
\begin{small}
\begin{verbatim}
Purse_invariant Purse_balance0 this
\end{verbatim}
\end{small}
that is to prove that the \verb|Purse| class invariant is
preserved. To perform that, we need to unfold the defintion of this
invariant, but we will also need the fact that it was true at the
beginning of the method, which is hypothesis \verb|H4|. Since we need
to unfold both occurrences of \verb|Purse_invariant|, the best thing
to do is getting back at the beginning of the proof, and start with
\begin{small}
\begin{verbatim}
unfold Purse_invariant; intuition.
\end{verbatim}
\end{small}
the first subgoal is solved with the same tactics, and the second goal
now look like
\begin{small}
\begin{verbatim}
this # Purse_balance0 >= 0
\end{verbatim}
\end{small}
and again, we have an access to an update, so let's do
\begin{small}
\begin{verbatim}
subst Purse_balance0 result0; krakatoa.
\end{verbatim}
\end{small}

The proof obligation of \verb|withdraw| is very similar and left as
exercise. 

In our \verb|Purse| class, let's add a constructor for an empty purse:
\begin{java}

    Purse() \{
        balance = 0;
    \}
\end{java}

You ask \Krakatoa{} to generate proof obligations for this constructor
by giving \verb|Purse.Purse| as argument. It generates one
obligation:
\begin{small}
\begin{verbatim}

\end{verbatim}
\end{small}
to prove that the newly
allocated value satisfies the post-condition of that constructor, 
the class invariant, and additionally is fresh and not null, and has
type \verb|Purse| in the new allocation table \verb|heap0|. 
These last two facts are proved by \verb|intuition|, thanks to
automatic tactics added in the \Krakatoa{} model. To perform the
proof, start with
\begin{small}
\begin{verbatim}
unfold Purse_invariant; intuition.
\end{verbatim}
\end{small}
then, as for heap updates as before, substitute \verb|balance0| by its
value and use the \verb|krakatoa| tactics. 

\section{Calling subprograms}
\label{sec:subprograms}
\label{sec:alloc}

In this next lesson, we now consider the case where the method we want
to certify calls another method. An important thing to understand in
the \Krakatoa{} methodology is that we perform modular certification:
for certify a method $m$ that calls a method $m'$, we assume method
$m'$ correct with respect to its specification, and that's all: we do
not look at the body of $m'$. That means that all the information we
need must be put in its specification.

Let's consider this small test program that uses a purse, that we put
in our class \verb|Purse|:
\input{Purse_test1.pp}
This method requires five proof obligations. The first, second and
third are to check the pre-conditions of the calls
\verb|p.credit(100)|, \verb|p.withdraw(50)| and \verb|p.credit(100)|
respectively. They are solved by \verb|intuition|.
The fourth obligation is a precondition for the access
\verb|p.balance|, that is \verb|p| is not \verb|null|, which is again
solved by \verb|intuition|. 

The last proof obligation is the post-condition of
\verb|test1|. You may notice is also solved automatically by
\verb|intuition|. 
% It is however interesting to see more details, if
% you simply use \verb|intuition auto.|, the following subgoal remains:
% \begin{small}
% \begin{verbatim}
% ...
% H3 : p # balance0 = 0
% ...
% H8 : p # balance1 = p # balance0 + 100
% ...
% H15 : p # balance2 = p # balance1 - 50
% ...
% H21 : p # balance3 = p # balance2 + 100
% ...
% ______________________________________(1/1)
% p # balance3 = 150
% \end{verbatim}
% \end{small}
% that is to show that the field balance of \verb|p| contains 150
% in memory \verb|balance3|. Looking at hypotheses above,
% you understand that \verb|balance3| is the value of the
% \verb|balance| field at the end of the body of \verb|test1|,
% \verb|balance2| is before the last \verb|p.credit(100)|, 
% \verb|balance1| before \verb|p.withdraw(50)|, and
% \verb|balance0| before the first \verb|p.credit(100)|. So to
% prove that we need to apply all these equalities:
% \begin{small}
% \begin{verbatim}
% rewrite H21.
% rewrite H15.
% rewrite H8.
% rewrite H3.
% omega.
% \end{verbatim}
% \end{small}
% or simply, since these are arithmetical equalities, \verb|omega|
% (which is indeed applied by \verb|intuition| by default).

\section{Using \texttt{assignable} clauses}
\index{modifiable@\texttt{modifiable}}
\index{assignable clause@\texttt{assignable} clause}

Let us consider now a slightly more complicated method, that involves
two purses.
\input{Purse_test2.pp}
The first obligation, after \verb|unfold Purse_invariant, Object_invariant; intuition|,
results in: 
\begin{small}
\begin{verbatim}
alloc : alloc_table
result : value
Purse_balance : memory Z
alloc0 : alloc_table
H0 : store_extends alloc alloc0
H1 : result # Purse_balance = 0
H : result = Null -> False
H2 : instanceof alloc0 result (ClassType Purse)
H3 : fresh alloc result
H5 : result # Purse_balance >= 0
result0 : value
Purse_balance0 : memory Z
alloc1 : alloc_table
H6 : store_extends alloc0 alloc1
H7 : result0 # Purse_balance0 = 0
H4 : result0 = Null -> False
H8 : instanceof alloc1 result0 (ClassType Purse)
H9 : fresh alloc0 result0
H11 : result0 # Purse_balance0 >= 0
______________________________________(1/1)
result # Purse_balance0 >= 0
\end{verbatim}
\end{small}
This is not provable, because there is no relation known between
\verb|Purse_balance0| and \verb|Purse_balance|, the state of
\verb|Purse_balance| memory respectively after and before the statement
\verb|p2 = new Purse()|. Indeed, in the specification of the \verb|Purse|
constructor, we specified that the resulting purse has balance 0, but
we did not say anything about other possible side-effects.

JML's \texttt{assignable} clauses, also called \emph{frame
  conditions}, are to express what changes may have occurred to
the heap memory by calls to \verb|Purse| constructor. Generally speaking,
$(\verb|modifiable|~a~m_1~m_2~loc)$ expresses that between memories $m_2$
and $m_1$, only locations given by $loc$ may be modified. More
precisely, it ensures that for any location $l$ that is allocated in
$a$, such that $(loc~l)$ is true, then either $l$ is not allocated
in $m_1$, or it is allocated and has the same value has in $m_2$. In
our example, $loc$ is \verb|everything_loc|, that is everything may
have been modified ($(\verb|everything_loc|~l)$ is false for any $l$),
which is the default when no assignable clause is given. The same
problem will occur for calls to \verb|credit| and \verb|withdraw|. So
at this stage we have to go back and put an assignable clause to each
of these methods. The \verb|Purse| class now looks like
\input{Purse2.pp}
Of course, since we have strengthen the specifications of these
methods, we need to prove them again, but fortunately, in that case,
the lemmas added to the \Coq{} \verb|Hint| base are enough to prove
the additional requirements. 

Now, we can go back to our method \verb|test2|. Seven obligations are
generated. The first one, after %
\verb|unfold Purse_invariant, Object_invariant; intuition.|, results in subgoal
\begin{small}
\begin{verbatim}
alloc : alloc_table
result : value
Purse_balance : memory Z
alloc0 : alloc_table
H0 : store_extends alloc alloc0
H1 : result # Purse_balance = 0
H : result = Null -> False
H2 : instanceof alloc0 result (ClassType Purse)
H3 : fresh alloc result
H5 : result # Purse_balance >= 0
result0 : value
Purse_balance0 : memory Z
alloc1 : alloc_table
H6 : store_extends alloc0 alloc1
H7 : result0 # Purse_balance0 = 0
H4 : result0 = Null -> False
H8 : instanceof alloc1 result0 (ClassType Purse)
H9 : fresh alloc0 result0
H11 : result0 # Purse_balance0 >= 0
______________________________________(1/1)
result # Purse_balance0 >= 0
\end{verbatim}
\end{small}
This is in fact a precondition to the call \verb|p1.credit(100)|: we
need to show that \verb|p1| satisfies its class invariant. What
we need now is to use hypothesis \verb|H10| which tells what has 
been modified by the previous statement %
\verb|Purse p2 = new Purse()|: indeed, nothing has been modified in
the memory heap, only a new object has been allocated. To use \verb|H10| you
need to know that the \verb|modifiable| predicate
\index{modifiable@\texttt{modifiable}} of the Coq
model concludes to an equality:
\begin{verbatim}
(modifiable h m m' mod_spec) := 
   (v:value)
    (alive h v) -> 
    (mod_spec v) -> (m#v)=(m'#v).
\end{verbatim}
So \verb|H10| may be used to rewrite the goal:
\begin{small}
\begin{verbatim}
rewrite <- H10.
\end{verbatim}
\end{small}
this results into three subgoals:
\begin{small}
\begin{verbatim}
_____________________________________(1/3)
p1 # balance0 >= 0


______________________________________(2/3)
alive heap0 p1

______________________________________(3/3)
nothing_loc p1
\end{verbatim}
\end{small}
The first one is the previous one where
\verb|p1 # balance1| is replaced by its value in the previous
state \verb|p1 # balance0|, the second is to show
that \verb|p1| was already allocated in the previous state, and
finally the third goal is to show that
\verb|p1| is not a location specified by \verb|\nothing|, which
is trivial. In fact, all three goals are
solved by \verb|auto|, so in fact you should get 
back one step and finish the proof by
\begin{small}
\begin{verbatim}
rewrite <- H10; auto.
\end{verbatim}
\end{small}

The second obligation is the pre-condition to the call
\verb|p2.credit(200)|. After %
\verb|unfold Purse_invariant; intuition.|, you end up with
\begin{small}
\begin{verbatim}
...
H2 : instanceof heap0 p1 (ClassType Purse)
...
H14 : fresh heap0 p2
H17 : p2 # balance1 >= 0
...
H18 : modifiable heap1 balance1 balance2 (value_loc p1)
...
______________________________________(1/1)
p2 # balance2 >= 0
\end{verbatim}
\end{small}
that is to show that \verb|p2| satisfies
its class invariant, provided it satisfied it before
\verb|p1.credit(100)| (hypothesis \verb|H17|). A rewrite using
\verb|H18| will do the job as 
before, but there is a small difficulty here: we need to know
that \verb|p2| is not a location specified by \verb|(value_loc p1)|, 
that is \verb|p2| and \verb|p1| are different, in other word that
\verb|p2| is not an \emph{alias} for
\verb|p1|\index{alias}\index{variable alias}. Such difficulties with
aliases will occur very often, and you will have to prove the absence
of alias. In our case here, we now (\verb|H14|) that \verb|p2| is a
fresh value, i.e. not allocated, in \verb|heap0|, whereas (\verb|H2|)
\verb|p1| is allocated and of type \verb|Purse| in this heap. In the
\Coq{} modeling are defined necessary lemmas and hints to make this proof
automatic, so you may use
\begin{small}
\begin{verbatim}
assert (p1!=p2); auto.
\end{verbatim}
\end{small}
to end up with the same goal with additional hypothesis \verb|p1!=p2|,
and finish the proof using
\begin{small}
\begin{verbatim}
rewrite <- H18; auto.
\end{verbatim}
\end{small}

The third obligation is the pre-condition to \verb|p1.withdraw(50)|,
and analogously as before, the proof can be made by
\begin{small}
\begin{verbatim}
unfold Purse_invariant; intuition.
assert p1!=p2; auto.
rewrite <- H25; auto with *.
assert p1!=p2; auto.
rewrite <- H25; auto with *.
\end{verbatim}
\end{small}
If you want to factorize the \verb|assert|, you may do
\begin{small}
\begin{verbatim}
unfold Purse_invariant; intros.
assert (p1 != p2); intuition; rewrite <- H11; auto with *.
\end{verbatim}
\end{small}

The fourth obligation is the pre-condition to \verb|p2.withdraw(100)|,
and is solved very similarly to the third. The fifth and sixth
obligations are to show that accesses to \verb|balance| in the
\verb|return| are valid, and are solved by \verb|intuition|. 

The seventh and last obligation is the hard one, to show the
post-condition of \verb|test2|. However, we already have the necessary
knowledge to perform it, by applying the well-chosen rewrites. A
solution is
\begin{small}
\begin{verbatim}
unfold Purse_invariant; intuition.
assert (p1 != p2); auto.
rewrite H42.
rewrite <- H41; auto.
rewrite H36.
rewrite <- H33; auto.
rewrite H28.
rewrite <- H25; auto.
rewrite H21.
rewrite <- H18; auto.
rewrite H10.
rewrite <- H12; auto.
omega.
\end{verbatim}
\end{small}

\section{Programs with exceptions}

In our next lesson we now consider a program where an exception may be
thrown. In fact, we slightly modify our \verb|Purse| class to allow a
call to \verb|withdraw| with a too large argument, which will results
in an exception in such a case. Here is the new method:
\input{Purse_withdraw2.pp}
There are two obligations generated. The first is exactly the
same as for the previous version of \verb|withdraw|, the second
corresponds to the post-condition when the method ends in
exception, and is solved by \verb|intuition.| Notice that the
proof obligations in exceptional case has nothing special,
this is only a different path in the control flow of the method, to reach
the end of its execution.

\section{The Dutch National Flag problem}

We now consider the famous Dutch National Flag
problem~\cite{Dijkstra76,bitner82}: given an array of
colored (blue/white/red) elements, rearrange them so that blue
elements occur first, then white ones, then red ones.  To keep things
short, we consider we have an array of such colors. 

We create a new class \verb|Flag| where we first define the colors:
\input{Flag1.pp}
Our algorithm will work on an array of colors, so we introduce an
instance variable for this array, together with an invariant to
specify that it is made of valid colors:
\input{Flag_inv.pp}
Then we want to specify a method \verb|flag| supposed to solve the
problem. For this purpose, it is simpler to introduce a predicate
\verb|isMonochrome| which says that some part \verb|t[i..j-1]| of our
array is of the same color \verb|c|:
\input{Flag_isMonochrome.pp}
The specification of our main method is then:
\input{Flag_flag.pp}
To provide a body to the \verb|flag| method, it is nice to have a
method \verb|swap| for permuting two elements of array \verb|t|. Here
is its specification:
\input{Flag_swap.pp}
and here is the code we consider for \verb|flag|:
\input{Flag_body.pp}

For method \verb|flag|, ten obligations are generated. The first one,
after %
\verb|unfold Flag_invariant; intuition|, is:
\begin{small}
\begin{verbatim}
...
H2 : this # t != Null
...
Post1 : krak_access = this # t
______________________________________(1/1)
krak_access != Null
\end{verbatim}
\end{small}
that is the validity of access to \verb|t.length|, solved by
\verb|subst; auto|. 


The second obligation is to show that the loop invariant is true
whenever entering the loop. It is not difficult, however there is a
small point here. After
\begin{small}
\begin{verbatim}
unfold Flag_invariant; intuition.
\end{verbatim}
\end{small}
we get 
\begin{small}
\begin{verbatim}
...
Post8 : i = 0
...
______________________________________(1/5)
i <= arraylength heap krak_access
\end{verbatim}
\end{small}
and to prove this we need the fact that the length of an array is
necessarily non-negative. There is a lemma in the \Coq{} modeling for
that purpose, named \verb|array_length_always_pos|, and the goal can
be solved by:
\begin{small}
\begin{verbatim}
subst i; apply arraylength_always_pos.
\end{verbatim}
\end{small}
The remaining of the proof is easy, using this lemma several times:
\begin{small}
\begin{verbatim}
subst krak_access; omega.
unfold Flag_isMonochrome ; intuition.
subst b; apply arraylength_always_pos.
unfold Flag_isMonochrome ; intuition.
subst i; apply arraylength_always_pos.
unfold Flag_isMonochrome ; intuition.
apply arraylength_always_pos.
subst krak_access; omega.
subst krak_access; omega.
\end{verbatim}
\end{small}
It is possible to make the proof nicer by factorizing the use of this
lemma:
\begin{small}
\begin{verbatim}
intros; subst i b krak_access.
assert (0 <= arraylength heap (this # t)).
apply arraylength_always_pos.
unfold Flag_invariant,Flag_isMonochrome in *|-*; intuition.
Q\end{verbatim}
\end{small}
The third obligation is the validity of access to \verb|t[i]|, solved
by \verb|intuition|.

The fourth obligation is the pre-condition to the call %
\verb|swap(b,i)|, solved by \verb|unfold Flag_invariant; intuition|. 

The fifth obligation, after % 
\verb|unfold Flag_invariant, Flag_isMonochrome; intuition|, results in
three subgoals: 
\begin{small}
\begin{verbatim}
...
Test7 : temp_switch = Flag_BLUE
...
H20 : intA1 : (this # t) [b1] = intA0 : (this # t) [i1]
H25 : intA1 : (this # t) [i1] = intA0 : (this # t) [b1]
...
Post2 : b2 = b1 + 1
...
Post3 : i2 = i1 + 1
______________________________________(1/3)
Flag_isMonochrome heap t intA1 this 0 b2 Flag_BLUE

______________________________________(2/3)
Flag_isMonochrome heap t intA1 this b2 i2 Flag_WHITE

______________________________________(3/3)
Flag_isMonochrome heap t intA1 this r1 (arraylength heap (this # t)) Flag_RED
\end{verbatim}
\end{small}
It is to show the preservation of the loop invariant, in the case
\verb|t[i]==BLUE| (as shown by hypotheses). In the context,
\verb|intA0| is the int array memory at the beginning of the loop
body, and \verb|intA1| at the end (i.e. after \verb|swap(b,i)|).  Similarly,
\verb|b1| (resp. \verb|i1|) is the value of \verb|b| (resp. \verb|i|)
at the beginning of the loop body and \verb|b2| (resp. \verb|i2|) at
the end. 

To prove these goals, you will soon notice you should have unfolded
\verb|Flag_isMonochrome| so you should go back and start with
\begin{small}
\begin{verbatim}
Unfold Flag_invariant, Flag_isMonochrome; intuition.
\end{verbatim}
\end{small}
After this, the first subgoal is:
\begin{small}
\begin{verbatim}
...
H13 : forall k:Z, 0 <= k < b1 -> intA0 : (this # t) [k] = Flag_BLUE
...
Post6 : temp_switch = intA0 : (this # t) [i1]
Test7 : temp_switch = Flag_BLUE
...
H31 : array_modifiable heap intA0 intA1
        (array_inter_loc (array_loc (this # t) i1) (array_loc (this # t) b1))
H29 : intA1 : (this # t) [b1] = intA0 : (this # t) [i1]
H34 : intA1 : (this # t) [i1] = intA0 : (this # t) [b1]
...
Post2 : b2 = b1 + 1
...
H37 : 0 <= k
H38 : k < b2
______________________________________(1/3)
intA1 : (this # t) [k] = Flag_BLUE
\end{verbatim}
\end{small}
that is to show that after \verb|swap(b,i); b++; i++|, the subarray
\verb|t[0..b2-1]| is all blue: for \verb|t[0..b2-2]| that follows from
the fact that it was true at the beginning of the loop (\verb|H13|,
and \verb|b2=b1+1|) and for \verb|t[b2-1]|=\verb|t[b1]|, it is true
because it is equal to \verb|t[i1]| before the loop (\verb|H29|),
which was blue because of the switch (\verb|Post6| and
\verb|Test7|). First we need 
to split in the two cases by
\begin{small}
\begin{verbatim}
assert (k=b1 \/ k<b1); [ omega | intuition ].
\end{verbatim}
\end{small}
The case \verb|k=b1| is solve simply by
\begin{small}
\begin{verbatim}
subst k; omega.
\end{verbatim}
\end{small}
and the case \verb|k<b1| is solve by the appropriate rewrite:
\begin{small}
\begin{verbatim}
rewrite <- H31; auto with *.
\end{verbatim}
\end{small}
The second subgoal is to show that \verb|t[b2..i2-1]| is all white,
which is similar as before:
\begin{small}
\begin{verbatim}
assert (k = i1 \/ k < i1); [ omega | intuition ].
subst k; rewrite H34; auto with *.
rewrite <- H31; auto with *.
\end{verbatim}
\end{small}
The third subgoal is to show that \verb|t[r1..t.length-1]| is all
red, which a done simply by:
\begin{small}
\begin{verbatim}
rewrite <- H31; auto with *.
\end{verbatim}
\end{small}

The sixth obligation is the preservation of the loop invariant when
\verb|t[i]| is \verb|WHITE|. It is quite simple and left as an
exercise.

The seventh obligation is the precondition to the call
\verb|swap(r,i)|. It can be done in a similar manner as obligation 3. 

The eighth obligation is the preservation of the loop invariant when
\verb|t[i]| is \verb|RED|. It can be done in a similar manner as obligation 5. 

The ninth obligation is the preservation of the loop invariant when
no switch case apply, i.e. if \verb|t[i]| is not a color. This case
should be absurd thanks to the class invariant. It is not very
difficult and left as an exercise.

The tenth and last obligation is the fact that the post-condition of
\verb|flag| is true at end of its body. After %
\verb|unfold Flag_invariant; intuition.| remains one subgoal solved by
\begin{small}
\begin{verbatim}
exists r1; exists b1; intuition.
assert (i1=r1).
omega.
Subst; Trivial.
\end{verbatim}
\end{small}

\section{\texttt{assignable} clauses and loops}

\index{assignable clause@\texttt{assignable} clause!in loop}
TODO
(*
Of course, there is another
possibility to solves this problem, that is manually insert in the
loop invariant the needed property, that would be in that case 
\begin{small}
\begin{verbatim}
  @  t == \old(t)
\end{verbatim}
\end{small}
but this is certainly not the right way to proceed, first because the
\texttt{assignable} clause is much more general, and second because
adding such a clause in the method's specification may be necessary
later if one wants to call it.

So, after adding that \texttt{assignable} clause, and running
\Krakatoa{} again, we get now the goal
\begin{small}
\begin{verbatim}
...
H4 : (modifiable heap heap0 (allcells_loc //heap//this#t))
...
______________________________________(1/1)
(//heap0//this#t)!=Null
\end{verbatim}
\end{small}
Hence we know from \verb|H4| that only fields of \verb|this.t| may
have been modified, so \verb|this.t| itself should have kept its
initial value which was not \verb|null| thanks to the class invariant.
So the proof should now continue with
\begin{small}
\begin{verbatim}
Rewrite mod_access with 1:=H4; intuition.
\end{verbatim}
\end{small}
which results in the goal
\begin{small}
\begin{verbatim}
...
______________________________________(1/1)
(allcells_loc //heap//this#t this t)
\end{verbatim}
\end{small}
with the same hypotheses. This means to show that the location
\verb|this.t| itself is not equal to any of the fields of
\verb|this.t|. In this example, this cannot be the case for a matter
of typing, since fields of \verb|this.t| are integers whereas
\verb|this.t| is an array. Beware that this could be a difficulty for
similar case where an array contains objects. For example with the
class \verb|Vector|, it is indeed possible that one of the element is
the Vector itself (for example if you execute \verb|v.add(v)| for a
\verb|Vector| \verb|v|), see~\cite{huisman2001sttt} for reference. So
to solve that goal, the first thing is to manually unfold the
definition of \verb|allcells_loc| by
\begin{small}
\begin{verbatim}
Red.
\end{verbatim}
\end{small}
to get 
\begin{small}
\begin{verbatim}
...
______________________________________(1/1)
(//heap//this#t)<>this
\end{verbatim}
\end{small}
and then apply a lemma of the \Coq{} model which ensures that values of
uncomparable types are different. This lemma expects the types of
these values as argument, so you need to use here:
\index{not_comparable_type_diff@\texttt{not\_comparable\_type\_diff}}   
\begin{small}
\begin{verbatim}
Apply not_comparable_type_diff 
  with (ArrayType IntType) (ClassType Flag);
\end{verbatim}
\end{small}
\index{ArrayType@\texttt{ArrayType}}
\index{IntType@\texttt{IntType}}
\index{ClassType@\texttt{ClassType}}
the expression \verb|(ArrayType IntType)| is the coding of type
\verb|int[]| in the \Coq{} model, and \verb|(ClassType Flag)| is the
coding of type \verb|Flag|. See Section~\ref{sec:coqmodel} for more
details. This tactic generates the following subgoals
\begin{small}
\begin{verbatim}
______________________________________(1/4)
(//heap//this#t)<>Null\/this<>Null

______________________________________(2/4)
(instanceof //heap//this#t (ArrayType IntType))

______________________________________(3/4)
(instanceof this (ClassType Flag))

______________________________________(4/4)
(not_comparable (ArrayType IntType) (ClassType Flag))
\end{verbatim}
\end{small}
which are all provable by \verb|intuition|, so in fact we should go
back and finish the proof by
\begin{small}
\begin{verbatim}
Apply not_comparable_type_diff 
  with (ArrayType IntType) (ClassType Flag); intuition.
\end{verbatim}
\end{small}

*)
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 


\chapter{Reference Manual}
\label{chap:reference}

\section{The \texttt{krakatoa} command}

The general form of use of the command \texttt{krakatoa} is:
\begin{flushleft}
\texttt{krakatoa} [\textsl{options}] \textsl{method name specs} 
\end{flushleft}

\textsl{method name specs} is a sequence of expressions of the form
\texttt{Classname.methodname}, to specify which methods you want to
certify. For constructors, use \texttt{Classname.Classname}. There is
a shortcut to ask for every methods in a class, using
\texttt{Classname.*}. 

Notice there is no way to distinguish between overloaded methods: you
need either to certify all of them, or none.

\subsection{Options}
\index{command line options}
\index{options!of the command line}

\paragraph{Input options}

\begin{itemize}

\item \texttt{-I} \textsl{dir}

  Adds \textsl{dir} to the input path. See also \texttt{KRAKATOAPATH}
  variable below.

\item \texttt{-p} \textsl{directory}

  Specifies the directory where resides the main source package of
  your program. Incidentally, every files generated by
  \Krakatoa{} will be put in that directory.

\end{itemize}

\paragraph{Java modeling option}

\begin{itemize}

\item \texttt{-globalmemorymodel}

  Use the ``global memory'' modeling which was the one available as
  default in version 0.55 of \Krakatoa. Deprecated, it will not be
  maintained in future version.

\item \texttt{-localmemorymodel}

  Use the ``local memory'' modeling, described in this document. This
  is the default.
\end{itemize}


\paragraph{Output options}

\begin{itemize}
\item \texttt{-simplify}

  Produce output for the \textsc{Simplify} prover~\cite{nelson81}. 

\item \texttt{-harvey}

  Produce output for the \textsc{haRVey} prover~\cite{ranise03harvey}. 

\item \texttt{-pvs}

  Produce output for \pvs{}.

\item \texttt{-coq}

  Produce output for the \Coq{} proof assistant (default).

\item \texttt{-valid}

  Ask for generation of the so-called \emph{Why validations}. 

\item \texttt{-coqdir}

  Additional input path to pass to \texttt{coqc} using \texttt{-I}.

\item \texttt{-coqopt}
  
  Additional option to give to \texttt{coqc}.

\end{itemize}


\paragraph{Miscellaneous}

\begin{itemize}

\item \texttt{-k}

  Do not stop on first error. Mainly for debugging purposes.

\item \texttt{-v}

  Operate more verbosely. Mainly for debugging purposes.

\item \texttt{-dump}

  Dumps all the environments in the \texttt{krakatoa.log} log
  file. For debugging purposes only. 

\item \texttt{-parse-only}

  Perform only parsing. For debugging purposes only. 

\end{itemize}

\subsection{Environment variables}

\begin{itemize}

\item \texttt{KRAKATOAPATH}\index{KRAKATOAPATH}

  Specifies the input path of classes, analogously to Java's
  \texttt{CLASSPATH} variable.

\item \texttt{KRAKATOALIB}\index{KRAKATOALIB}

  Specifies the path to Krakatoa librairies for \Why{} and \Coq{}. This
  defaults to the path given at installation, so do not need to be set
  for a normally installed krakatoa.

\end{itemize}

\section{Modeling of Java memory heap}
\label{sec:coqmodel}

\begin{figure}[t]
\newcommand{\case}{\multicolumn{1}{|r|}{\phantom{0}}}
\newcommand{\nocase}{\multicolumn{1}{|r}{\phantom{0}}}
\begin{center}
\begin{tabular}{c|c|rlclrrrrrrrrrrrrr}
\multicolumn{3}{r}{} \\
\multicolumn{2}{r}{\texttt{heap}} & \multicolumn{1}{r}{} &
$f_1$ & & $f_2$ & $\cdots$ & 
\multicolumn{6}{l}{\texttt{intA}} &
\multicolumn{3}{l}{\texttt{objA}} &
\multicolumn{1}{l}{\texttt{boolA}} \\
\multicolumn{2}{r}{~`} & & ~ \\
\cline{2-2}\cline{4-4}\cline{6-6}
$a_1$  & $C_1$  & & \case& & \case & & \nocase &&&&&& \nocase \\
\cline{2-2}\cline{4-4}\cline{6-6}
$a_2$  & $C_2$ & & \case & & \case & & \nocase &&&&&& \nocase \\
\cline{2-2}\cline{4-4}\cline{6-6}\cline{8-12}
$a_3$  & int$[5]$    & & \case & & \case & & \case & \case
&\case&\case&\case&&\nocase \\
\cline{2-2}\cline{4-4}\cline{6-6}\cline{8-12}\cline{14-16}
$a_4$  & $C_3[3]$    & & \case & & \case & & \nocase &&&&&&
\case & \case & \case\\
\cline{2-2}\cline{4-4}\cline{6-6}\cline{14-16}
$\vdots$  & $\vdots$    & & \multicolumn{1}{|c|}{$\vdots$} & &
\multicolumn{1}{|c|}{$\vdots$}  
\end{tabular}
\end{center}
\caption{Modeling of Java memory heap}
\label{fig:model}
\end{figure}

The main purpose of this section is to document the definitions
and lemmas generated in the modeling of each application: definitions
that may appear in proof obligations, and lemmas that may be used in
proofs. 

\subsection{Modeling of \Java{} types and values}

\texttt{ArrayType}\index{ArrayType@\texttt{ArrayType}}

\texttt{IntType}\index{IntType@\texttt{IntType}}

\texttt{ClassType}\index{ClassType@\texttt{ClassType}}

% classId\index{classId@\texttt{classId}}

% fieldId\index{fieldId@\texttt{fieldId}}

\texttt{value}\index{value@\texttt{value}}

Null

arraylength


%\index{not_comparable_type_diff@\texttt{not\_comparable\_type\_diff}}   

\subsection{Model of the memory heap, access and update}

\texttt{store}\index{store@\texttt{store}}

%heap\index{heap}

%Index\index{Index}

%Field\index{Field}

\texttt{access}\index{access} and its syntax

\verb|is_valid_cell| \index{is_valid_cell@\texttt{is\_valid\_cell}}

\texttt{update}\index{update} and its syntax

\verb|is_valid_update| \index{is_valid_update@\texttt{is\_valid\_update}}

\subsection{Model of assignable clauses}

\texttt{modifiable} \index{modifiable@\texttt{modifiable}}

\texttt{everything\_loc}

\texttt{nothing\_loc}

\texttt{access\_loc}

\texttt{allcells\_loc}

\texttt{inter\_loc}

mod\_trans mod\_access mod\_after\_new

\subsection{\Coq{} tactics}

\texttt{krakatoa} \index{krakatoa tactic@\texttt{krakatoa} tactic}

\chapter{Appendices}

\section{Requirements}
\label{app:requirements}

User requirements: knowing how to perform proofs using the Coq
system. Knowing how to write JML specifications.

System requirements: \Coq{} version 8.0, \Why{} version 1.32 or higher. For
compiling \Krakatoa{} from sources, you need also the Objective Caml
compiler, version 3.04 or higher.

\section{Installation procedure}

\subsection{From the sources}

Get a copy of sources at the web page. 

Decompress the archive in a directory of your choice.

Run commands
\begin{verbatim}
./configure
make
make install
\end{verbatim}

\subsection{Windows binary}

Not yet available. Please ask if you need it urgently.
% Run the auto-installable krakatoa-\textsl{version}-win.exe

\subsection{Unix binaries}

Not yet available. Please ask if you need it urgently.
%Get the suitable binary krakatoa-\textsl{version}-\textsl{ostype}.gz

\subsection{GNU/Linux i386 packages}

Not yet available. Please ask if you need it urgently.
%RPM package: krakatoa-\textsl{version}-i386.rpm

%Debian package: krakatoa-\textsl{version}-i386.deb

\section{Summary of features and known limitations}
\label{sec:features}

\begin{itemize}
\item No checking of arithmetic overflow

\item Unsupported kind of statements in translation: ...

\item exception NullPointerException and ArrayOutOfBoundsException are
required NOT to be thrown, and consequently should not be catched.

\item Method parameters are not modifiable.

\item For recursive or mutually recursive methods, only partial
correctness is guaranteed.

\item some valid Java identifiers should not be used in your programs,
  unless some name clashes may occur: identifiers starting by
  \verb|krak| ;
  names introduced in the generated model: \verb|access|,
  \verb|update|, etc. ; keywords of \Why: result, parameter, etc.
\end{itemize}

\section{Contacts}

The web page for Krakatoa is at URL
\begin{verbatim}
http://krakatoa.lri.fr/
\end{verbatim}

For general questions regarding the use of the tool, please use the
Krakatoa mailing list. You need to subscribe to the list before
sending a message to it. To subscribe, send a mail to
\begin{verbatim}
majordomo@lri.fr
\end{verbatim}
with 
\begin{verbatim}
subscribe krakatoa
\end{verbatim}
in the body of the message. 

Authors may be contacted directly at the following addresses:
\verb|Claude.Marche@lri.fr|, \verb|Christine.Paulin@lri.fr| and 
\verb|Xavier.Urbain@lri.fr|.

\cleardoublepage

\addcontentsline{toc}{chapter}{\bibname}
\bibliographystyle{plain}
\bibliography{./biblio}
\cleardoublepage

\addcontentsline{toc}{chapter}{\indexname}
\printindex
\cleardoublepage

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% End:
