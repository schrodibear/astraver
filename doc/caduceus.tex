\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}
\usepackage{alltt}
\input{./version.tex}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}\index{PVS@\textsf{PVS}}}
\newcommand{\coq}{\textsf{Coq}\index{Coq@\textsf{Coq}}}
\newcommand{\harvey}{\textsf{haRVey}\index{haRVey@\textsf{haRVey}}}
\newcommand{\simplify}{\textsf{Simplify}\index{Simplify@\textsf{Simplify}}}
\newcommand{\mizar}{\textsf{Mizar}\index{Mizar@\textsf{Mizar}}}
\newcommand{\hollight}{\textsf{HOL Light}\index{HOL Light@\textsf{HOL Light}}}
\newcommand{\krakatoa}{\textsf{Krakatoa}\index{Krakatoa@\textsf{Krakatoa}}}
\newcommand{\java}{\textsc{Java}\index{Java@\textsf{Java}}}
\newcommand{\jml}{\textsc{JML}\index{JML@\textsf{JML}}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\caduceus}{\textsf{Caduceus}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}
\newenvironment{code}{\begin{small}\begin{alltt}%
\begin{tabular}{|p{0.97\textwidth}|}\hline%
}{\\\hline\end{tabular}\end{alltt}\end{small}}
\def\result{\char'134 result}
\def\at{\char'134 at}
\def\forall{\char'134 forall}
\def\old{\char'134 old}
\def\bs{\char'134}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The CADUCEUS verification tool \\[0.5em] for C programs}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[1cm]
Version \caduceusversion\\[3cm]
Jean-Christophe Filli\^atre and Claude March\'e
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Foreword}
\addcontentsline{toc}{chapter}{Foreword}

\caduceus\ is a verification tool for C programs. Programs are
specified using annotations in special comments. Proof obligations are
generated using the \why\ tool~\cite{Why} and then can be validated using
various proof assistants or decision procedures.

\medskip

This manual is organized as follows. Chapter~\ref{tutorial} gives an
overview of \caduceus, illustrating all features with tiny examples.
Chapter~\ref{refman} is a reference manual.


\subsection*{License}

The \caduceus\ certification tool is \copyright\ 2003 Laboratoire de
Recherche en Informatique (\url{www.lri.fr}).
It is open source and freely available under the terms of the GNU
GENERAL PUBLIC LICENSE Version 2. See the files \texttt{COPYING} and
\texttt{GPL} in the distribution.


\subsection*{Authors}

\caduceus\ is developed by Jean-Christophe Filli\^atre and Claude March\'e.

\subsection*{Availability}

The \caduceus\ tool is available from
\url{http://why.lri.fr/caduceus/}, 
in source and binary formats, together with this documentation and
examples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}
\label{tutorial}

This chapter gives an overview of \caduceus\ using trivial programs.

\section{Basics}

Let us start with a trivial function \texttt{max} computing the maximum of two
integers:
\begin{code}
  
/*@ ensures 
  @   \result >= x && \result >= y &&
  @   \forall int z; z >= x && z >= y => z >= \result 
  @*/
int max(int x, int y) \{
  if (x > y) return x; else return y;
\}
\end{code}
The specification is inserted in the source code right before the
function definition in a comment of the shape \texttt{/*@ \dots */}.
Any \caduceus\ annotation is placed in such a comment (or in
a single-line comment \texttt{//@ \dots}).
Note that the character \texttt{@} is considered as a blank inside
annotations.

The specification is here a post-condition, introduced by the keyword
\texttt{ensures}. This is the predicate to be valid when the function
returns. The keyword \texttt{\result} denotes the value returned by
the function, thus of type \texttt{int} in this example. The
post-condition expresses that \texttt{\result} is the smallest integer
greater or equal than \texttt{x} and \texttt{y} (there are plenty
other ways to specify the \texttt{max} function).

The proof obligations are generated in two steps. First, a \why\
program \texttt{max.why} is built from the source \texttt{max.c} with
the command:
\begin{verbatim}
    caduceus max.c
\end{verbatim}
Then the proof obligations are generated from \texttt{max.why}
depending on the selected proof tool. If the proofs are to be made
with the \coq\ proof assistant, the command is:
\begin{verbatim}
    why --coq caduceus.why max.why
\end{verbatim}
The file \texttt{caduceus.why} was generated by the call to
\texttt{caduceus}; it contains all the \why\ declarations which
are necessary to compile \texttt{max.why} (the model).
Two \coq\ files \texttt{caduceus\_why.v} and \texttt{max\_why.v} are
produced. The latter contains two proof
obligations (two lemmas which proofs have to be filled in); see the
\why\ manual for more details~\cite{Why}.

As an alternative to \coq\, let us use the \simplify\ decision procedure.
The \why\ command becomes:
\begin{verbatim}
    why --simplify caduceus.why max.why
\end{verbatim}
and two files \texttt{caduceus\_why.sx} and \texttt{max\_why.sx} are
produced. Then they are passed to \simplify\ which dischargs the two
obligations automatically:
\begin{verbatim}
    cat caduceus_why.sx pointer_why.sx | Simplify
    >       1: Valid.
    >       2: Valid.
\end{verbatim}

\subsection{Loops annotations}
\indextt{invariant}\indextt{variant}

A loop can be annotated with an invariant (a property which holds at
the loop entrance and is preserved by the loop body) and a variant (a
quantity which decreases at each loop step for a well-founded
ordering, thus ensuring termination). The three kinds of C loops can
be annotated (\texttt{while}, \texttt{for}, and \texttt{do \dots\ while}).

A loop annotation is placed right before the loop; the keyword
\texttt{invariant} (resp. \texttt{variant}) introduces the invariant
(resp. the variant). The invariant is optional and must appear before
the variant when present.

Here is an example with a trivial loop:
\begin{code}

  int i = 0;
  int s = 0;
  /*@ invariant s == i variant 10-i */
  while (i++ < 10) s++;
\end{code}

\subsection{Other annotations}

Beside loop annotations, there are three other kinds of inner annotations.

\paragraph{Intermediate assertions.}\indextt{assert}
An assertion can be placed at any statement point. A proof obligation
is generated to show its validity. Example:
\begin{code}

  \dots
  if (a > b) \{ int tmp = a; a = b; b = tmp; \}
  /*@ assert a <= b */
  \dots
\end{code}
Such an assertion can be seen as a cut in the proof. It is a property
available below this program point and, conversely, it is collected by
the upward weakest preconditions computation.

\paragraph{Labels.}\indextt{label}
Usual C labels can be used in annotations to refer to terms or
predicates at a particular program point. Example:
\begin{code}
  
  L:
  /*@ invariant i >= \at(i,L) */
  while (i++ < N) \dots
\end{code}
When there is no available label in the code, it is possible to
insert a ``logical'' label using the following annotation:
\begin{code}
  
  /*@ label L */
  /*@ invariant i >= \at(i,L) */
  while (i++ < N) \dots
\end{code}


\paragraph{Specifying pieces of code.}
It is possible to give a specification to an inner statement (which
may be a block or not). The syntax is the same as a function specification:
\begin{code}

  \dots
  /*@ ensures a <= b */
  if (a > b) \{ int tmp = a; a = b; b = tmp; \}
  \dots
\end{code}
Contrary to the \texttt{assert} annotation, the specified
statement is seen as a black box, as if it would be a
function call.
In particular, the weakest precondition computation
will not enter this statement.

Inner specifications may be used to help automatic decision procedures
or to reduce the size of proof obligations (there would be more
numerous but smaller proof obligations).

\section{Pointers and arrays}
\index{valid@\texttt{\bs{}valid}}
\index{valid\_index@\texttt{\bs{}valid\_index}}
\index{valid\_range@\texttt{\bs{}valid\_range}}

\section{Calling functions}


\section{The \texttt{assigns} clause}
\label{assigns}\indextt{assigns}



\section{Logical declarations}
\indextt{predicate}\indextt{logic}\indextt{axiom}


\section{A complete example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reference manual}
\label{refman}

\caduceus\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{caduceus} [\textit{options}] \textit{file}$_1$\texttt{.c} $\cdots$ \textit{file}$_n$\texttt{.c}
\end{center}

\section{Command line options}
\label{usage}\index{Option, of the command line}

\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--version}]: ~\par    
    Give \caduceus\ version number and exit. 
  \item[\texttt{-v}]: ~\par 
    Verbose mode. 
  \item[\texttt{-q}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--werror}]: ~\par 
    Turn warnings as errors. \caduceus\ will stop on the first warning.
  \item[\texttt{-d}]: ~\par 
    Debugging mode. In this mode, \caduceus\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.

  \item[Overall options:] ~\par
  \item[\texttt{-parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{-type-only}]: ~\par  
    Stop after type-checking.

  \item[Pre-processing options:] ~\par
  \item[\texttt{-no-cpp}]: ~\par  
    Turn off the pre-processing.
  \item[\texttt{-cpp} \textit{command}]: ~\par  
    Set the pre-processor. It must be an executable taking the file
    to be pre-processed on its command line and printing its output
    on the standard output. 
    The default value is \texttt{gcc -C -E}.
  \item[\texttt{-E}]: ~\par  
    Stop after pre-processing and dump the pre-processed file on
    standard output (mainly useful for debugging).

\end{description}

\section{Input Files Syntax}
\label{syntax}\index{Syntax (of input files)}

C files conform to the usual ANSI C
syntax and annotations are inserted in the source as comments.

\subsection{Lexical conventions}
\label{lexical:c}\index{Lexical conventions!C programs}

\subsubsection{Code}

The lexical conventions conform to the ANSI C standard (see
for instance~\cite{KR88}).

\subsubsection{Annotations}
\index{Annotations}

Within annotations the lexical conventions are the same as C ones,
except that:
\begin{itemize}
\item comments are enclosed by \texttt{(*} and \texttt{*)} (so that
  you can put comments inside annotations without messing traditional
  C compilers)
\item the set of keywords is different: \par
  \begin{center}
  \begin{tabular}{l@{\qquad}l@{\qquad}l@{\qquad}l@{\qquad}l}
  \verb!\forall! & \verb!\exists! & \verb!int! & \verb!float! &
  \verb!decreases! \\
  \verb!\true! & \verb!\false! & \verb!if! & \verb!then! & \verb!else! \\
  \verb!invariant! & \verb!variant! & \verb!for! & \verb!label! & 
  \verb!assert! \\ 
  \verb!requires! & \verb!ensures! & \verb!assigns! & \verb!logic! & 
  \verb!axiom! \\
  \verb!predicate! & \verb!\result! & \verb!\old! & 
  \verb!\length! & \verb!\null! \\
  \verb!reads! & \verb!\valid! & \verb!\valid_index! &
  \verb!\valid_range! & \verb!\fresh!
  \end{tabular}
  \end{center}
\end{itemize}

\subsection{Syntax}

Annotations are inserted into programs as special comments of the shape
\texttt{/*@ ... */} or one-line comments of the shape \texttt{//@ ...}
Figure~\ref{fig:cfiles} gives the syntax for the additional C
constructs containing annotations; some are C declarations
(non-terminal \nt{declaration}) and some are C statements (non-terminal
\nt{statement}).
Figure~\ref{fig:logic} gives the syntax for the
annotations. 

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{c\_file}
    & $::=$ & \nt{declaration}\etoile\ \\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \te{;} \\
      & $|$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \nt{block} \te{;} \\
      & $|$ & \te{/*@} \te{logic} \nt{logic\_type} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
              && $[$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{predicate} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
           && $[$ \te{\{} \nt{predicate} \te{\}} $|$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{axiom} \nt{identifier} \te{:} 
              \nt{predicate} \te{*/} \\
  \\[0.1em]

  \nt{spec}
    & $::=$ & \te{/*@} $[$ \te{requires} \nt{predicate} $]$ 
              $[$ \te{assigns} \nt{location}\plussep{\te{,}} $]$ \\
           && $[$ \te{ensures} \nt{predicate} $]$ 
              $[$ \te{decreases} \nt{variant} $]$ \te{*/} \\
                  \indextt{requires}\indextt{assigns}
                  \indextt{ensures}\indextt{decreases}
  \\[0.1em]

  \nt{statement}
    & $::=$ & \nt{loop\_annot} \te{while} \te{(} \nt{expr} \te{)}
              \nt{statement} \\
    &   $|$ & \nt{loop\_annot} \te{do} \nt{statement} 
              \te{while} \te{(} \nt{expr} \te{)} \\
    &   $|$ & \nt{loop\_annot} \te{for} \te{(} \nt{statement} \te{;} \nt{statement} \te{;}
              $[$ \nt{expr} $]$ \te{)} \\
           && \nt{statement} \\
    &   $|$ & \te{/*@} \te{assert} \nt{predicate} \te{*/} \\ \indextt{assert}
    &   $|$ & \te{/*@} \te{label} \nt{identifier} \te{*/} \\ \indextt{label}
    &   $|$ & \nt{spec} \nt{statement} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{/*@} $[$ \te{invariant} \nt{predicate} $]$
              $[$ \te{variant} \nt{variant} $]$ \te{*/}  \\
              \indextt{invariant}\indextt{variant}
  \nt{variant} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{identifier} $]$ \\

  \\[0.1em]
  
  \nt{logic\_type}
    & $::=$ & \te{int} $|$ \te{float} $|$ \nt{logic\_type} \te{[]} 
            $|$ \nt{identifier} \\
  \nt{logic\_parameter}
    & $::=$ & \nt{logic\_type} \nt{identifier} \\

  \\[0.1em]

  \nt{location}
    & $::=$ & \nt{identifier} \\
    &   $|$ & \nt{term} \te{.} \nt{identifier} \\
    &   $|$ & \nt{term} \te{->} \nt{identifier} \\
    &   $|$ & \te{*} \nt{term} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
    &   $|$ & \nt{term} \te{[} \te{*} \te{]} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{..} \nt{term} \te{]} \\
  \\[0.1em]
\end{tabular}\\
\hrulefill
\caption{Annotations within C constructs}
\label{fig:cfiles}
\end{center}           
\end{figure}


\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} $|$ \te{+} \nt{term}  \\
      & $|$ & \te{*} \nt{term} \\
      & $|$ & \nt{term} \te{->} \nt{identifier} \\
      & $|$ & \nt{term} \te{.} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
      & $|$ & \nt{term} \te{?} \nt{term} \te{:} \nt{term} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{term} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\length! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\result! \\
      & $|$ & \verb!\null! \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{floating-point-constant} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%} \\
  \\[0.1em]

  \nt{predicate}\indexnt{predicate}
    & $::=$ & \verb!\true! \\
      & $|$ & \verb!\false! \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{=>} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{||} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{\&\&} \nt{predicate} \\
      & $|$ & \te{!} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \verb!\forall! \nt{logic\_parameter}\plussep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \verb!\exists! \nt{logic\_parameter}\plussep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{predicate} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\valid! \te{(} \nt{term} \te{)}
              \index{valid@\texttt{\bs{}valid}} \\
      & $|$ & \verb!\valid_index! \te{(} \nt{term} \te{,} \nt{term} \te{)}
              \index{valid\_index@\texttt{\bs{}valid\_index}} \\
      & $|$ & \verb!\valid_range! \te{(} \nt{term} \te{,} \nt{term} 
              \te{,} \nt{term} \te{)}
              \index{valid\_range@\texttt{\bs{}valid\_range}} \\
      & $|$ & \verb!\fresh! \te{(} \nt{term} \te{)}
              \index{fresh@\texttt{\bs{}fresh}} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{==} $|$ \te{!=} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of annotations}
\label{fig:logic}
\end{center}            
\end{figure}



\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}


\newpage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
