\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}
\usepackage{alltt}
\input{./version.tex}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}\index{PVS@\textsf{PVS}}}
\newcommand{\coq}{\textsf{Coq}\index{Coq@\textsf{Coq}}}
\newcommand{\harvey}{\textsf{haRVey}\index{haRVey@\textsf{haRVey}}}
\newcommand{\simplify}{\textsf{Simplify}\index{Simplify@\textsf{Simplify}}}
\newcommand{\mizar}{\textsf{Mizar}\index{Mizar@\textsf{Mizar}}}
\newcommand{\hollight}{\textsf{HOL Light}\index{HOL Light@\textsf{HOL Light}}}
\newcommand{\krakatoa}{\textsf{Krakatoa}\index{Krakatoa@\textsf{Krakatoa}}}
\newcommand{\java}{\textsc{Java}\index{Java@\textsf{Java}}}
\newcommand{\jml}{\textsc{JML}\index{JML@\textsf{JML}}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\caduceus}{\textsf{Caduceus}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}
\newenvironment{code}{\begin{small}\begin{alltt}%
\begin{tabular}{|p{0.97\textwidth}|}\hline%
}{\\\hline\end{tabular}\end{alltt}\end{small}}
\def\result{\char'134 result}
\def\at{\char'134 at}
\def\forall{\char'134 forall}
\def\old{\char'134 old}
\def\bs{\char'134}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The CADUCEUS verification tool \\[0.5em] for C programs}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[1cm]
Version \caduceusversion\\[3cm]
Jean-Christophe Filli\^atre and Claude March\'e
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Foreword}
\addcontentsline{toc}{chapter}{Foreword}

\caduceus\ is a verification tool for C programs. Programs are
specified using annotations in special comments. Proof obligations are
generated using the \why\ tool~\cite{Why} and then can be validated using
various proof assistants or decision procedures.

\medskip

This manual is organized as follows. Chapter~\ref{tutorial} is a
tutorial, introducing \caduceus{} features step by step, illustrated
with examples. Chapter~\ref{refman} is a reference manual, providing
the complete syntax of annotations, list of features, etc.

\subsection*{License}

The \caduceus\ certification tool is \copyright\ 2003 Laboratoire de
Recherche en Informatique (\url{www.lri.fr}).
It is open source and freely available under the terms of the GNU
GENERAL PUBLIC LICENSE Version 2. See the files \texttt{COPYING} and
\texttt{GPL} in the distribution.

\subsection*{Authors}

\caduceus\ is developed by Jean-Christophe Filli\^atre and Claude March\'e.

\subsection*{Availability}

The \caduceus\ tool is available from
\url{http://why.lri.fr/caduceus/}, 
in source and binary formats, together with this documentation and
examples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tutorial}
\label{tutorial}

% This chapter gives an overview of \caduceus\ using trivial programs.

\section{Basic use of \caduceus}

To introduce how the \caduceus{} tool must be used in practice, let us
start with a trivial program: function \texttt{max} computing the
maximum of two integers:
\begin{code}
/*@ ensures 
  @   \result >= x && \result >= y &&
  @   \forall int z; z >= x && z >= y => z >= \result 
  @*/
int max(int x, int y) \{
  if (x > y) return x; else return y;
\}
\end{code}
The specification of \texttt{max} is given in the source code right
before the function definition in a comment of the shape \texttt{/*@
  \dots */}.  Any \caduceus\ annotation is placed in such a comment
(or in a single-line comment \texttt{//@ \dots}).  Note that the
character \texttt{@} is considered as a blank inside annotations.

The specification is here a post-condition, introduced by the keyword
\texttt{ensures}. This is the predicate to be valid when the function
returns. The keyword \texttt{\result} denotes the value returned by
the function, thus of type \texttt{int} in this example. The
post-condition expresses that \texttt{\result} is the smallest integer
greater or equal than \texttt{x} and \texttt{y} (there are plenty
other ways to specify the \texttt{max} function).

The proof obligations are generated in two steps. First, the caduceus
tool must be run on the source file \texttt{max.c} with
the command:
\begin{verbatim}
   caduceus max.c
\end{verbatim}
This generates several files, some of them in sub-directories. Among
those files, a file named \texttt{max.makefile} is generated, which
contains several commands to be run using the standard \texttt{make}
tool. 

The second step is then to generate proof obligations for some
prover. If the proofs are to be made with the \coq\ proof assistant, 
the command is:
\begin{verbatim}
    make -f max.makefile coq
\end{verbatim}
This command will generate the proof obligations, together will some
Coq \emph{modeling} of the C program (file \verb|caduceus_why.v|):
\begin{verbatim}
why [...] why/caduceus_spec.why
why [...] why/max.why
\end{verbatim}
and then will try to compile the resulting Coq files:
\begin{verbatim}
coqdep -I coq coq/*.v > max.depend
coqc -I coq coq/caduceus_why.v
coqc -I coq coq/caduceus_tactics.v
coqc -I coq coq/caduceus_spec_why.v
coqc -I coq coq/max_why.v
\end{verbatim}
The last file contains two proof
obligations (two lemmas which proofs have to be filled in); see the
\why\ manual for more details~\cite{Why}. On this example, the
compilation succeeds, because the default tactic given
(\texttt{intuition}) solves the obligations. In general, the proofs of
this file must be filled in manually, using \texttt{coqide} for instance.

As an alternative to \coq\, let us use the \simplify\ decision procedure.
The \texttt{make} command becomes:
\begin{verbatim}
    make -f max.makefile simplify
\end{verbatim}
The obligations are also discharged automatically in that case:
\begin{verbatim}
time make -f max.makefile clean do_simplify > simplify.log

real    0m0.163s
user    0m0.110s
sys     0m0.060s
valid obligations:       2
invalid obligations:       0
\end{verbatim}
When an obligation fails with Simplify, then no manual proof may be
attempted, but counter-examples given in file \texttt{simplify.log}
may be consulted, to discover missing pre-conditions for instance.

\section{Pointer access and modification}
\index{valid@\texttt{\bs{}valid}}

Let us consider now a small program involving a pointer, in a file
\verb|abs.c|: 
\begin{code}
//@ ensures *p >= 0
void abs1(int *p) {
  if (*p < 0) *p = -*p;
}
\end{code}
Running \caduceus{} and then Simplify results in:
\begin{verbatim}
> caduceus abs.c
generating Why code for function abs1
> make -f abs.makefile simplify
make[1]: Entering directory `/home/demons6/marche/recherche/caduceus'
abs.makefile:36: abs.depend: No such file or directory
why -coq-v8 -dir coq -coq-preamble "Require Export caduceus_why. Require Export caduceus_tactics." /usr/local/lib/caduceus/why/caduceus.why why/caduceus_spec.why
why -coq-v8 -dir coq -coq-preamble "Require Export caduceus_spec_why." -coq-tactic "intuition" /usr/local/lib/caduceus/why/caduceus.why why/caduceus_spec.why why/abs.why
coqdep -I coq coq/*.v > abs.depend
make[1]: Leaving directory `/home/demons6/marche/recherche/caduceus'
make[1]: Entering directory `/home/demons6/marche/recherche/caduceus'
time make -f abs.makefile clean do_simplify > simplify.log

real    0m0.244s
user    0m0.170s
sys     0m0.060s
valid obligations:       1
invalid obligations:       1
\end{verbatim}
so it that case, there are two proof obligations and only one of them
has been proved. To investigate the unporved one, we may look at file
\verb|simplify.log|:
\begin{verbatim}
> cat simplify.log
[...]
Simplify simplify/abs_why.sx.all
Counterexample:
  context:
    (AND
      (EQ null p)
      (EQ (ISpointer p) |@true|)
      (EQ (ISalloc alloc) |@true|)
    )

1: Invalid.

2: Valid.
\end{verbatim}
The counter example given contains \verb|(EQ null p)|, meaning that
this program may not run as expected if pointer \verb|p| is
null: indeed, a segmentation would occur in that case. If you try to
use Coq instead of Simplify, you will face the same problem when
trying to prove the first obligation: you will end up with
\begin{verbatim}
1 subgoal
p : pointer
alloc : alloc
______________________________________(1/1)
valid alloc p
\end{verbatim}
which is not provable.

To fix this problem, one should specify a pre-condition to function
\verb|abs|, which can be given using the \verb|\valid| predicate of
\caduceus{} as follows:
\begin{code}
/*@ requires \valid(p)
  @ ensures *p >= 0
  @*/
void abs2(int *p) {
  if (*p < 0) *p = -*p;
}
\end{code}
If you run \caduceus{} again on this version, you will first notice
that the first obligation is now automatically discharge by Why, and
Simplify will succeed to prove the second obligation. If you run Coq
instead, then this obligation will not be proved automatically: you
will have to make the proof by hand. Here is the goal to solve, after
executing the \verb|intuition| tactic:
\begin{verbatim}
1 subgoal
p : pointer
alloc : alloc
intP : memory Z
Pre9 : valid alloc p
Pre3 : valid alloc p
caduceus_1 : Z
Post3 : caduceus_1 = acc intP p
result : bool
Post5 : if result then caduceus_1 < 0 else caduceus_1 >= 0
______________________________________(1/1)
if result
then
 (forall result0 : Z,
  result0 = acc intP p ->
  (forall intP0 : memory Z,
   intP0 = upd intP p (- result0) -> acc intP0 p >= 0) /\ valid alloc p) /\
 valid alloc p
else acc intP p >= 0
\end{verbatim}
It is indeed quite large, because it has two cases depending on the
value of \verb|result|, which is (see \verb|Post5|) the condition of
the \verb|if| in the C program. With Coq, the simplest thing to do
with such a goal shape is to make two cases, with
\begin{verbatim}
destruct result; intuition.
\end{verbatim}
instead of \verb|intuition| alone. This will then result in one
subgoal (the other case has been solved automatically):
\begin{verbatim}
1 subgoal
p : pointer
alloc : alloc
intP : memory Z
Pre9 : valid alloc p
Pre3 : valid alloc p
caduceus_1 : Z
Post3 : caduceus_1 = acc intP p
Post5 : caduceus_1 < 0
result : Z
H : result = acc intP p
intP0 : memory Z
H0 : intP0 = upd intP p (- result)
______________________________________(1/1)
acc intP0 p >= 0
\end{verbatim}

\section{Arrays}
\index{valid\_index@\texttt{\bs{}valid\_index}}
\index{valid\_range@\texttt{\bs{}valid\_range}}

\section{Structures}

\section{Loop annotations}
\indextt{invariant}\indextt{variant}

A loop can be annotated with an invariant (a property which holds at
the loop entrance and is preserved by the loop body) and a variant (a
quantity which decreases at each loop step for a well-founded
ordering, thus ensuring termination). The three kinds of C loops can
be annotated (\texttt{while}, \texttt{for}, and \texttt{do \dots\ while}).

A loop annotation is placed right before the loop; the keyword
\texttt{invariant} (resp. \texttt{variant}) introduces the invariant
(resp. the variant). The invariant is optional and must appear before
the variant when present.

Here is an example with a trivial loop:
\begin{code}

  int i = 0;
  int s = 0;
  /*@ invariant s == i variant 10-i */
  while (i++ < 10) s++;
\end{code}






\section{Calling functions}


\section{The \texttt{assigns} clause}
\label{assigns}\indextt{assigns}


\section{Logical declarations}
\indextt{predicate}\indextt{logic}\indextt{axiom}


\section{A complete example}









\section{Other features not already in the tutorial}

\subsection{Other annotations}

Beside loop annotations, there are three other kinds of inner annotations.

\paragraph{Intermediate assertions.}\indextt{assert}
An assertion can be placed at any statement point. A proof obligation
is generated to show its validity. Example:
\begin{code}

  \dots
  if (a > b) \{ int tmp = a; a = b; b = tmp; \}
  /*@ assert a <= b */
  \dots
\end{code}
Such an assertion can be seen as a cut in the proof. It is a property
available below this program point and, conversely, it is collected by
the upward weakest preconditions computation.

\paragraph{Labels.}\indextt{label}
Usual C labels can be used in annotations to refer to terms or
predicates at a particular program point. Example:
\begin{code}
  
  L:
  /*@ invariant i >= \at(i,L) */
  while (i++ < N) \dots
\end{code}
When there is no available label in the code, it is possible to
insert a ``logical'' label using the following annotation:
\begin{code}
  
  /*@ label L */
  /*@ invariant i >= \at(i,L) */
  while (i++ < N) \dots
\end{code}


\paragraph{Specifying pieces of code.}
It is possible to give a specification to an inner statement (which
may be a block or not). The syntax is the same as a function specification:
\begin{code}

  \dots
  /*@ ensures a <= b */
  if (a > b) \{ int tmp = a; a = b; b = tmp; \}
  \dots
\end{code}
Contrary to the \texttt{assert} annotation, the specified
statement is seen as a black box, as if it would be a
function call.
In particular, the weakest precondition computation
will not enter this statement.

Inner specifications may be used to help automatic decision procedures
or to reduce the size of proof obligations (there would be more
numerous but smaller proof obligations).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reference manual}
\label{refman}

\caduceus\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{caduceus} [\textit{options}] \textit{file}$_1$\texttt{.c} $\cdots$ \textit{file}$_n$\texttt{.c}
\end{center}

\section{Command line options}
\label{usage}\index{Option, of the command line}

\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--version}]: ~\par    
    Give \caduceus\ version number and exit. 
  \item[\texttt{-v}]: ~\par 
    Verbose mode. 
  \item[\texttt{-q}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--werror}]: ~\par 
    Turn warnings as errors. \caduceus\ will stop on the first warning.
  \item[\texttt{-d}]: ~\par 
    Debugging mode. In this mode, \caduceus\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.

  \item[Overall options:] ~\par
  \item[\texttt{-parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{-type-only}]: ~\par  
    Stop after type-checking.

  \item[Pre-processing options:] ~\par
  \item[\texttt{-no-cpp}]: ~\par  
    Turn off the pre-processing.
  \item[\texttt{-cpp} \textit{command}]: ~\par  
    Set the pre-processor. It must be an executable taking the file
    to be pre-processed on its command line and printing its output
    on the standard output. 
    The default value is \texttt{gcc -C -E}.
  \item[\texttt{-E}]: ~\par  
    Stop after pre-processing and dump the pre-processed file on
    standard output (mainly useful for debugging).

\end{description}

\section{Input Files Syntax}
\label{syntax}\index{Syntax (of input files)}

C files conform to the usual ANSI C
syntax and annotations are inserted in the source as comments.

\subsection{Lexical conventions}
\label{lexical:c}\index{Lexical conventions!C programs}

\subsubsection{Code}

The lexical conventions conform to the ANSI C standard (see
for instance~\cite{KR88}).

\subsubsection{Annotations}
\index{Annotations}

Within annotations the lexical conventions are the same as C ones,
except that:
\begin{itemize}
\item comments are enclosed by \texttt{(*} and \texttt{*)} (so that
  you can put comments inside annotations without messing traditional
  C compilers)
\item the set of keywords is different: \par
  \begin{center}
  \begin{tabular}{l@{\qquad}l@{\qquad}l@{\qquad}l@{\qquad}l}
  \verb!\forall! & \verb!\exists! & \verb!int! & \verb!float! &
  \verb!decreases! \\
  \verb!\true! & \verb!\false! & \verb!if! & \verb!then! & \verb!else! \\
  \verb!invariant! & \verb!variant! & \verb!for! & \verb!label! & 
  \verb!assert! \\ 
  \verb!requires! & \verb!ensures! & \verb!assigns! & \verb!logic! & 
  \verb!axiom! \\
  \verb!predicate! & \verb!\result! & \verb!\old! & 
  \verb!\length! & \verb!\null! \\
  \verb!reads! & \verb!\valid! & \verb!\valid_index! &
  \verb!\valid_range! & \verb!\fresh!
  \end{tabular}
  \end{center}
\end{itemize}

\subsection{Syntax}

Annotations are inserted into programs as special comments of the shape
\texttt{/*@ ... */} or one-line comments of the shape \texttt{//@ ...}
Figure~\ref{fig:cfiles} gives the syntax for the additional C
constructs containing annotations; some are C declarations
(non-terminal \nt{declaration}) and some are C statements (non-terminal
\nt{statement}).
Figure~\ref{fig:logic} gives the syntax for the
annotations. 

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{c\_file}
    & $::=$ & \nt{declaration}\etoile\ \\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \te{;} \\
      & $|$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \nt{block} \te{;} \\
      & $|$ & \te{/*@} \te{logic} \nt{logic\_type} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
              && $[$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{predicate} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
           && $[$ \te{\{} \nt{predicate} \te{\}} $|$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{axiom} \nt{identifier} \te{:} 
              \nt{predicate} \te{*/} \\
  \\[0.1em]

  \nt{spec}
    & $::=$ & \te{/*@} $[$ \te{requires} \nt{predicate} $]$ 
              $[$ \te{assigns} \nt{location}\plussep{\te{,}} $]$ \\
           && $[$ \te{ensures} \nt{predicate} $]$ 
              $[$ \te{decreases} \nt{variant} $]$ \te{*/} \\
                  \indextt{requires}\indextt{assigns}
                  \indextt{ensures}\indextt{decreases}
  \\[0.1em]

  \nt{statement}
    & $::=$ & \nt{loop\_annot} \te{while} \te{(} \nt{expr} \te{)}
              \nt{statement} \\
    &   $|$ & \nt{loop\_annot} \te{do} \nt{statement} 
              \te{while} \te{(} \nt{expr} \te{)} \\
    &   $|$ & \nt{loop\_annot} \te{for} \te{(} \nt{statement} \te{;} \nt{statement} \te{;}
              $[$ \nt{expr} $]$ \te{)} \\
           && \nt{statement} \\
    &   $|$ & \te{/*@} \te{assert} \nt{predicate} \te{*/} \\ \indextt{assert}
    &   $|$ & \te{/*@} \te{label} \nt{identifier} \te{*/} \\ \indextt{label}
    &   $|$ & \nt{spec} \nt{statement} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{/*@} $[$ \te{invariant} \nt{predicate} $]$
              $[$ \te{variant} \nt{variant} $]$ \te{*/}  \\
              \indextt{invariant}\indextt{variant}
  \nt{variant} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{identifier} $]$ \\

  \\[0.1em]
  
  \nt{logic\_type}
    & $::=$ & \te{int} $|$ \te{float} $|$ \nt{logic\_type} \te{[]} 
            $|$ \nt{identifier} \\
  \nt{logic\_parameter}
    & $::=$ & \nt{logic\_type} \nt{identifier} \\

  \\[0.1em]

  \nt{location}
    & $::=$ & \nt{identifier} \\
    &   $|$ & \nt{term} \te{.} \nt{identifier} \\
    &   $|$ & \nt{term} \te{->} \nt{identifier} \\
    &   $|$ & \te{*} \nt{term} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
    &   $|$ & \nt{term} \te{[} \te{*} \te{]} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{..} \nt{term} \te{]} \\
  \\[0.1em]
\end{tabular}\\
\hrulefill
\caption{Annotations within C constructs}
\label{fig:cfiles}
\end{center}           
\end{figure}


\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} $|$ \te{+} \nt{term}  \\
      & $|$ & \te{*} \nt{term} \\
      & $|$ & \nt{term} \te{->} \nt{identifier} \\
      & $|$ & \nt{term} \te{.} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
      & $|$ & \nt{term} \te{?} \nt{term} \te{:} \nt{term} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{term} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\length! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\result! \\
      & $|$ & \verb!\null! \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{floating-point-constant} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%} \\
  \\[0.1em]

  \nt{predicate}\indexnt{predicate}
    & $::=$ & \verb!\true! \\
      & $|$ & \verb!\false! \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{=>} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{||} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{\&\&} \nt{predicate} \\
      & $|$ & \te{!} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \verb!\forall! \nt{logic\_parameter}\plussep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \verb!\exists! \nt{logic\_parameter}\plussep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{predicate} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\valid! \te{(} \nt{term} \te{)}
              \index{valid@\texttt{\bs{}valid}} \\
      & $|$ & \verb!\valid_index! \te{(} \nt{term} \te{,} \nt{term} \te{)}
              \index{valid\_index@\texttt{\bs{}valid\_index}} \\
      & $|$ & \verb!\valid_range! \te{(} \nt{term} \te{,} \nt{term} 
              \te{,} \nt{term} \te{)}
              \index{valid\_range@\texttt{\bs{}valid\_range}} \\
      & $|$ & \verb!\fresh! \te{(} \nt{term} \te{)}
              \index{fresh@\texttt{\bs{}fresh}} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{==} $|$ \te{!=} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of annotations}
\label{fig:logic}
\end{center}            
\end{figure}



\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}


\newpage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
