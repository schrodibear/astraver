\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}
\input{./version.tex}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}\index{PVS@\textsf{PVS}}}
\newcommand{\coq}{\textsf{Coq}\index{Coq@\textsf{Coq}}}
\newcommand{\harvey}{\textsf{haRVey}\index{haRVey@\textsf{haRVey}}}
\newcommand{\simplify}{\textsf{Simplify}\index{Simplify@\textsf{Simplify}}}
\newcommand{\mizar}{\textsf{Mizar}\index{Mizar@\textsf{Mizar}}}
\newcommand{\hollight}{\textsf{HOL Light}\index{HOL Light@\textsf{HOL Light}}}
\newcommand{\krakatoa}{\textsf{Krakatoa}\index{Krakatoa@\textsf{Krakatoa}}}
\newcommand{\java}{\textsc{Java}\index{Java@\textsf{Java}}}
\newcommand{\jml}{\textsc{JML}\index{JML@\textsf{JML}}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\caduceus}{\textsf{Caduceus}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}
\newcommand{\bs}{\ensuremath{\backslash}}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The CADUCEUS verification tool \\[0.5em] for C programs}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[1cm]
Version \caduceusversion\\[3cm]
Jean-Christophe Filli\^atre and Claude March\'e
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Foreword}
\addcontentsline{toc}{chapter}{Foreword}

TODO

\medskip

This manual is organized as follows. Chapter~\ref{tutorial} gives an
overview of \caduceus, illustrating all features with one-line examples.
Chapter~\ref{refman} is a reference manual.


\subsection*{License}

The \caduceus\ certification tool is \copyright\ 2002 Laboratoire de
Recherche en Informatique (\url{www.lri.fr}).
It is open source and freely available under the terms of the GNU
GENERAL PUBLIC LICENSE Version 2. See the files \texttt{COPYING} and
\texttt{GPL} in the distribution.


\subsection*{Availability}

The \caduceus\ tool is available from \url{http://why.lri.fr/}, in source
and binary formats, together with this documentation and many
examples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}
\label{tutorial}

% ANSI C file where annotations are inserted as special comments

\section{Verifying C programs}
\label{tutorial:C}\index{C program}

\why\ also handles C programs.
Contrary to ML input files, C input files conform to the usual ANSI C
syntax~\cite{KR88} and annotations are inserted in the source as
special comments of the shape 
\begin{verbatim}
     /*@ ... */
\end{verbatim}
On a C file \texttt{foo.c}, \why\ is invoked as for ML files:
\begin{verbatim}
     why foo.c
\end{verbatim}
and obligations are generated in file \texttt{foo\_why.v} (assuming prover
\coq\ is selected).

\subsection{Input files}
\index{C program!files}

C files contain variable and function declarations, and function
definitions. 
A variable declaration has no particular annotation:
\begin{verbatim}
     int x;
     float t[];
     int* r;
\end{verbatim}
Such a declaration corresponds to a \texttt{parameter} declaration in
an ML input file.

A function declaration can be given a specification:
\begin{verbatim}
     int f(int x);
     int g(int x) /*@ pre x <> 0 */;
     int h(int x) /*@ writes r post x = r */;
\end{verbatim}
The specification is made of an optional precondition (following
the keyword \texttt{pre}), an effect (in the same syntax as in ML
programs), and an optional postcondition (following the keyword
\texttt{post}). 

A function definition is given (optional) pre- and postcondition as
comments preceding and following the function body:
\begin{verbatim}
     void f() /*@ x = 0 */ { y = x++; } /*@ x = 1 and y = 0 */
     void g(int* x) { *x = 0; } /*@ x = 0 */
\end{verbatim}
When the function is recursive, the variant is given right after the
precondition, inside the same comment:
\begin{verbatim}
     int f(int x) /*@ x >= 0 variant x */ {
       if (x == 0) return 0;
       return f(x - 1);
     } /*@ result = 0 */
\end{verbatim}

Finally, \why\ declarations can be inserted in the middle of C
declarations, with comments of the shape \texttt{/*W}\dots\texttt{*/}:
\begin{verbatim}
     int x;
     /*W logic f: int -> int */
     int y;
\end{verbatim}

\subsection{Annotations}
\index{C program!annotations}

\paragraph{Loops annotations.}
\indextt{invariant}\indextt{variant}
Inside C code, annotations must be inserted to give loops invariant and
variant. \texttt{for} loops are given an annotation right before the
loop body:
\begin{verbatim}
     for (i = 0; i < 10; ++i)
       /*@ invariant x = i and i <= 10 variant 10-i */
       { x = x + 1; }
\end{verbatim}
Similarly for \texttt{while} loops:
\begin{verbatim}
     while (n >= 0) 
       /*@ invariant 1 <= n variant n */ { 
       if (n == 1) { n++; break; }
       n--;
     }
\end{verbatim}
On the contrary, \texttt{do} loops are annotated after the loop body:
\begin{verbatim}
     do {
       x = x + 1;
       i = i - 1;
     }
     /*@ invariant x = 10 - i and i >= 0 variant i */
     while (i > 0);
\end{verbatim}

\paragraph{Other annotations.}
\indextt{assert}\indextt{label}
Assertions can be inserted within statements, with the syntax:
\begin{verbatim}
     x = 2 * x;
     /*@ assert even(x) */;
     x = x + 1;
\end{verbatim}
Labels are inserted within statements with a similar syntax:
\begin{verbatim}
     x = 2 * x;
     /*@ label L */;
     x = x + 1;
\end{verbatim}
or using C labels directly:
\begin{verbatim}
     x = 2 * x;
   L:
     x = x + 1;
\end{verbatim}

% \subsection{C fragment currently covered}
% \index{C program!unsupported constructs}

% Section~\ref{syntax:C} gives the syntactic fragment of ANSI C
% currently supported in \why. Additionally, some semantic restrictions
% are added.
% \begin{description}
% \item[No pointer arithmetic.] Pointers are partly supported. They can
%   be used to do reference-passing, as in:
% \begin{verbatim}
%      void g(int* x) { *x = 0; } /*@ x = 0 */
%      void f() { int i = 1; g(&i); }
% \end{verbatim}
%   but pointer arithmetic is not allowed, as in:
% \begin{verbatim}
%      for (p = a; c = *p; p++) ...
% \end{verbatim}

% \item[Types.] Currently, the types \texttt{char},
%   \texttt{short}, \texttt{int} and \texttt{long} are all identified
%   (and modeled as unbound integers as in ML). Similarly, types
%   \texttt{float} and \texttt{double} are identified (and modeled as
%   reals as in ML).

% \end{description}

% Note that \caml\ code can also be generated from C input files, giving
% an ML translation of the C code. (This is not of great use, though,
% since the C input code is already executable.)



\chapter{Reference manual}
\label{refman}

\section{Command line options}
\label{usage}\index{Option, of the command line}


\section{Input Files Syntax}
\label{syntax}\index{Syntax (of input files)}

C files conform to the usual ANSI C
syntax and annotations are inserted in the source as comments.

\subsection{Lexical conventions}
\label{lexical:c}\index{Lexical conventions!C programs}

\subsubsection{Code}

The lexical conventions conform to the ANSI C standard (see
for instance~\cite{KR88}).

\subsubsection{Annotations}
\index{Annotations}

Within annotations the lexical conventions are the same as C ones,
except that:
\begin{itemize}
\item comments are enclosed by \texttt{(*} and \texttt{*)} (so that
  you can put comments inside annotations without messing traditional
  C compilers)
\item the set of keywords is different: \par
  \begin{center}
  \begin{tabular}{l@{\qquad}l@{\qquad}l@{\qquad}l@{\qquad}l}
  \verb!\forall! & \verb!\exists! & \verb!int! & \verb!float! &
  \verb!decreases! \\
  \verb!\true! & \verb!\false! & \verb!if! & \verb!then! & \verb!else! \\
  \verb!invariant! & \verb!variant! & \verb!for! & \verb!label! & 
  \verb!assert! \\ 
  \verb!requires! & \verb!ensures! & \verb!assigns! & \verb!logic! & 
  \verb!axiom! \\
  \verb!predicate! & \verb!\result! & \verb!\old! & 
  \verb!\length! & \verb!\null! \\
  \verb!reads! & \verb!\valid! & \verb!\valid_range!
  \end{tabular}
  \end{center}
\end{itemize}

\subsection{Syntax}

Annotations are inserted into programs as special comments of the shape
\texttt{/*@ ... */} or one-line comments of the shape \texttt{//@ ...}
Figure~\ref{fig:cfiles} gives the syntax for the additional C
constructs containing annotations; some are C declarations
(non-terminal \nt{declaration}) and some are C statements (non-terminal
\nt{statement}).
Figure~\ref{fig:logic} gives the syntax for the
annotations. 

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{c\_file}
    & $::=$ & \nt{declaration}\etoile\ \\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \te{;} \\
      & $|$ & \nt{spec} \nt{type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} 
              \nt{block} \te{;} \\
      & $|$ & \te{/*@} \te{logic} \nt{logic\_type} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
              && $[$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{predicate} \nt{identifier} \te{(} 
              \nt{logic\_parameter}\etoilesep{\te{,}} \te{)} \\
           && $[$ \te{\{} \nt{predicate} \te{\}} $|$ 
              \te{reads} \nt{location}\plussep{\te{,}} $]$ \te{*/} \\
      & $|$ & \te{/*@} \te{axiom} \nt{identifier} \te{:} 
              \nt{predicate} \te{*/} \\
  \\[0.1em]

  \nt{spec}
    & $::=$ & \te{/*@} $[$ \te{requires} \nt{predicate} $]$ 
              $[$ \te{assigns} \nt{location}\plussep{\te{,}} $]$ \\
           && $[$ \te{ensures} \nt{predicate} $]$ 
              $[$ \te{decreases} \nt{variant} $]$ \te{*/} 
                  \indextt{requires}\indextt{assigns}
                  \indextt{ensures}\indextt{decreases} \\
  \\[0.1em]

  \nt{statement}
    & $::=$ & \nt{loop\_annot} \te{while} \te{(} \nt{expr} \te{)}
              \nt{statement} \\
    &   $|$ & \nt{loop\_annot} \te{do} \nt{statement} 
              \te{while} \te{(} \nt{expr} \te{)} \\
    &   $|$ & \nt{loop\_annot} \te{for} \te{(} \nt{statement} \te{;} \nt{statement} \te{;}
              $[$ \nt{expr} $]$ \te{)} \\
           && \nt{statement} \\
    &   $|$ & \te{/*@} \te{assert} \nt{predicate} \te{*/} \\ \indextt{assert}
    &   $|$ & \te{/*@} \te{label} \nt{identifier} \te{*/} \\ \indextt{label}
    &   $|$ & \nt{spec} \nt{statement} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{/*@} $[$ \te{invariant} \nt{predicate} $]$
              $[$ \te{variant} \nt{variant} $]$ \te{*/}  \\
  \nt{variant} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{identifier} $]$ \\

  \\[0.1em]
  
  \nt{logic\_type}
    & $::=$ & \te{int} $|$ \te{float} $|$ \nt{logic\_type} \te{[]} 
            $|$ \nt{identifier} \\
  \nt{logic\_parameter}
    & $::=$ & \nt{logic\_type} \nt{identifier} \\

  \\[0.1em]

  \nt{location}
    & $::=$ & \nt{identifier} \\
    &   $|$ & \nt{term} \te{.} \nt{identifier} \\
    &   $|$ & \nt{term} \te{->} \nt{identifier} \\
    &   $|$ & \te{*} \nt{term} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
    &   $|$ & \nt{term} \te{[} \te{*} \te{]} \\
    &   $|$ & \nt{term} \te{[} \nt{term} \te{..} \nt{term} \te{]} \\
  \\[0.1em]
\end{tabular}\\
\hrulefill
\caption{Annotations within C constructs}
\label{fig:cfiles}
\end{center}           
\end{figure}


\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} $|$ \te{+} \nt{term}  \\
      & $|$ & \te{*} \nt{term} \\
      & $|$ & \nt{term} \te{->} \nt{identifier} \\
      & $|$ & \nt{term} \te{.} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \te{[} \nt{term} \te{]} \\
      & $|$ & \nt{term} \te{?} \nt{term} \te{:} \nt{term} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{term} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\length! \te{(} \nt{term} \te{)} \\
      & $|$ & \verb!\result! \\
      & $|$ & \verb!\null! \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{floating-point-constant} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%} \\
  \\[0.1em]

  \nt{predicate}\indexnt{predicate}
    & $::=$ & \verb!\true! \\
      & $|$ & \verb!\false! \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{=>} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{||} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{\&\&} \nt{predicate} \\
      & $|$ & \te{!} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \verb!\forall! \nt{logic\_parameter}\etoilesep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \verb!\exists! \nt{logic\_parameter}\etoilesep{\te{,}} \te{;} 
              \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\old! \te{(} \nt{predicate} \te{)} \\
      & $|$ & \verb!\at! \te{(} \nt{predicate} \te{,} \nt{identifier} \te{)} \\
      & $|$ & \verb!\valid! \te{(} \nt{term} \te{)}
              \index{valid@\texttt{\bs{}valid}} \\
      & $|$ & \verb!\valid_range! \te{(} \nt{term} \te{,} \nt{term} 
              \te{,} \nt{term} \te{)}
              \index{valid\_range@\texttt{\bs{}valid\_range}} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{==} $|$ \te{!=} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of annotations}
\label{fig:logic}
\end{center}            
\end{figure}



\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}


\newpage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
