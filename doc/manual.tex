\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}}
\newcommand{\coq}{\textsf{Coq}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}

\begin{document}

\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The WHY certification tool}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[3cm]
Jean-Christophe Filli\^atre
\vfill
\today\\
\end{center}

\tableofcontents

\chapter{The \why\ tool}

\why\ is a tool to generate proof obligations from annotated programs.
Currently, the input syntax is a fragment of \caml\ (with annotations),
and the output is a \pvs\ theory or a \coq\ file.


\section{Principles}

\subsection{Input files}

The input file may contain the following kinds of declaration:
\begin{itemize}
  \item \te{pvs "}\textit{any \pvs\ material}\te{"} \par
    Copies the \pvs\ material as-is in the output theory.

  \item \te{external} $x_1,\dots,x_n: \tau$ \par 
    Declares some external program values of type $\tau$.
    They may be constants (i.e. of a primitive type), references 
    or functions. This is to introduce values to be used
    in the program part; values to be used in the specification part
    must be introduced using the \te{pvs} declaration.

  \item \te{let $x$ =} \textit{annotated-program} \par
    Generates the lemmas corresponding to the total correctness of
    the given program, and declares it with name $x$.
\end{itemize}

\subsection{Annotations}

Annotations are predicates over the values of the program variables
visible at the corresponding program point.

Any annotation may refer to the value(s) of a variable.  For a mutable
variable $x$ (a reference or an array), the current value is simply
referred to as $x$. Within a postcondition, the value before the
computation (i.e. at the precondition point) is referred to as $x@$.

Additionally, labels may be inserted in programs (using the 
\te{label} keyword; see the syntax chapter) and the value of $x$ at the
program point labelled $L$ is referred to as $x@L$.
A particular label `0' is automatically inserted at the beginning of the 
program, so that the initial value of $x$ can be referred to as $x@0$.

\paragraph{Example.} Here are examples of program annotations:
\begin{enumerate}
\item
  \verb#{ x >= 0 } x := (sqrt !x) { x >= 0 and (x >= 1 -> x <= x@) }# 
\item
  \verb#while !x < N do { invariant x@0 <= x variant N - x } x := !x+1 done#
\end{enumerate}


\section{Installation}

To compile \why, you need both \textsf{Objective Caml} and
\textsf{Camlp4} to be installed, in version at least 3.01. (Both can
be fetched from \url{http://caml.inria.fr}.)
Then 

\begin{enumerate}
\item Configure with \texttt{./configure}

  The directory for binaries defaults to \texttt{/usr/local/bin}; you
  can specify another directory with the \texttt{-{}-bindir}
  option. Similarly, you can change the directory for man pages with
  \texttt{-{}-mandir}.

\item Compile with \texttt{make}

\item Install with \texttt{make install}

  (Alternatively, you can move/copy the \why\ executable
  \texttt{bin/why} anywhere, or make a symbolic link to it from anywhere.)
\end{enumerate}


\chapter{Reference manual}
\label{refman}

\section{Usage}
\label{usage}

\why\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{why} [\textit{options}] \textit{file}$_1$\texttt{.ml} $\cdots$
    \textit{file}$_n$\texttt{.ml}
\end{center}
Each file \textit{file}\texttt{.ml} will be compiled into a \pvs\ theory
\textit{file}\texttt{\_why.pvs} or a \coq\ module
\textit{file}\texttt{\_why.v}.
If no file is given, then standard input is processed and a \pvs\ theory
named \texttt{WhyOutput} is printed on standard output.

Options are the following:
\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--verbose}]: ~\par 
    Verbose mode. In this mode, \why\ prints on error output
    information like the program being processed, the obligations
    being erased or overwritten, etc.
  \item[\texttt{--quiet}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--debug}]: ~\par 
    Debugging mode. In this mode, \why\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.

  \item[Overall options:] ~\par
  \item[\texttt{--parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{--type-only}]:  ~\par  
    Stop after typing.
  \item[\texttt{--wp-only}]:    ~\par  
    Stop after annotation.

  \item[Prover options:] ~\par
  \item[\texttt{--pvs}, \texttt{--coq}]: ~\par 
    Select the prover; It defaults to \coq.
\end{description}


\section{Logic syntax}
\label{syntax:logic}

\subsection{Terms}

Syntax of terms is given in Figure~\ref{fig:terms}.
Usual precedences apply to arithmetical operations.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{identifier} \te{[} \nt{term} \te{]} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
  \\[0.1em]

  \nt{constant}
    & $::=$ & \nt{integer-constant} \\
    & $::=$ & \nt{floating-point-constant} \\
    & $::=$ & \te{true} \\
    & $::=$ & \te{false} \\
    & $::=$ & \te{void} \\
  \\[0.1em]

  \nt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/}
\end{tabular}\\
\hrulefill
\caption{Syntax of terms}
\label{fig:terms}
\end{center}            
\end{figure}

\subsection{Predicates}

Syntax of predicates is given in Figure~\ref{fig:predicates}.
It is a first-order quantifier-free syntax, independent from the \pvs\ one.

Precedence of \te{and} is stronger than \te{or}'s, which is
stronger than implication's. Implication is right associative.

Syntactic sugar: $t_1 ~ R_1 ~ t_2 ~ R_2 ~ t_3$ is equivalent to
$t_1 ~ R_1 ~ t_2 ~ \texttt{and} ~ t_2 ~ R_2 ~ t_3$.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{predicate}
    & $::=$ & \nt{predicate} \te{->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{or} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{and} \nt{predicate} \\
      & $|$ & \te{not} \nt{predicate} \\
      & $|$ & \nt{term} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \te{(} \nt{predicate} \te{)}
  \\[0.1em]

  \nt{relation}
    & $::=$ & \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of predicates}
\label{fig:predicates}
\end{center}            
\end{figure}


\section{Syntax of ML programs}

\subsection{ML types}

Syntax of types is given in Figure~\ref{fig:types}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{simple\_value\_type}
    & $::=$ & \nt{primitive\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{ref} \\
      & $|$ & \te{array} \nt{term} \te{of} \nt{simple\_value\_type} \\
      & $|$ & \te{(} \nt{value\_type} \te{)} \\
  \\[0.1em]

  \nt{value\_type}
    & $::=$ & \nt{simple\_value\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{->} \nt{computation\_type} \\
      & $|$ & \nt{identifier} \te{:} \nt{simple\_value\_type} 
              \te{->} \nt{computation\_type} \\
  \\[0.1em]

  \nt{computation\_type}
    & $::=$ & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      &     & $[$ \te{returns} \nt{identifier} \te{:} $]$ \nt{value\_type} \\
      &     & $[$ \te{reads} \nt{identifier}\etoilesep{\te{,}} $]$
              $[$ \te{writes}  \nt{identifier}\etoilesep{\te{,}}  $]$ \\
      &     & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      & $|$ & \nt{value\_type} \\
  \\[0.1em]

  \nt{primitive\_type}
    & $::=$ & \te{int} $|$ \te{bool} $|$ \te{float} $|$ 
              \te{unit} $|$ \nt{identifier}
\end{tabular}\\
\hrulefill
\caption{Syntax of types}
\label{fig:types}
\end{center}            
\end{figure}

\subsection{ML expressions}

Syntax of annotated ML programs is given in Figure~\ref{fig:caml}.
\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{prog} 
    & $::=$ & \te{\{} \nt{predicate} \te{\}}\etoile\
              \nt{statement} 
              $[$ \te{\{} \nt{predicate} \te{\}} $]$ \\

       & & \\[0.1em]

  \nt{statement}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \te{!} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{:=} \nt{prog} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \te{:=} \nt{prog} \\
      & $|$ & \nt{prog} \nt{infix} \nt{prog} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \te{ref} 
              \nt{prog} \te{in} \nt{prog} \\
      & $|$ & \te{if} \nt{prog} \te{then} \nt{prog}
              $[$ \te{else} \nt{prog} $]$ \\
      & $|$ & \te{while} \nt{prog} \te{do}
              \nt{loop\_annot} \nt{block} \te{done} \\
      & $|$ & \te{begin} \nt{block} \te{end} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \nt{prog} 
              \te{in} \nt{prog} \\
      & $|$ & \te{fun} \nt{binders} \te{->} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{identifier} \nt{binders} \te{:}
              value\_type \\
      &     & \te{\{} \te{variant} \nt{wf\_arg} \te{\}}
              \te{=} \nt{prog} $[$ \te{in} \nt{prog} $]$ \\
      & $|$ & \te{(} \nt{prog}\plus\  \te{)} \\

      & & \\[0.1em]

  \nt{block} 
    & $::=$ & \nt{block\_statement}\plussep{\te{;}} \\

      & & \\[0.1em]

  \nt{block\_statement}
    & $::=$ & \nt{prog} \\
      & $|$ & \te{label} \nt{identifier} \\
      & $|$ & \te{assert} \te{\{} \nt{predicate} \te{\}} \\

      & & \\[0.1em]
 
  \nt{infix}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ 
              \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=} $|$
              \te{||} $|$ \te{\&\&} \\
      & & \\[0.1em]

  \nt{binders}
    & $::=$ & \te{(} \nt{identifier}\plussep{\te{,}} \te{:}
              \nt{value\_type} \te{)}\plus \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{\{} \te{invariant} \nt{predicate} 
              \te{variant} \nt{wf\_arg} \te{\}} \\
      & & \\[0.1em]

  \nt{wf\_arg} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{term} $]$ \\

\end{tabular}\\
\hrulefill
\caption{Syntax of annotated programs}
\label{fig:caml}
\end{center}
\end{figure}

\subsection{ML files}

Syntax of input files is given in Figure~\ref{fig:input}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{file}
    & $::=$ & \nt{declaration}\etoile\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \te{let} \nt{identifier} \te{=} \nt{prog} \\
      & $|$ & \te{external} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\
      & $|$ & \te{pvs} \nt{string}
\end{tabular}\\
\hrulefill
\caption{Syntax of input files}
\label{fig:input}
\end{center}           
\end{figure}

\end{document}
