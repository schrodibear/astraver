\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}
\input{./version.tex}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}}
\newcommand{\coq}{\textsf{Coq}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The WHY certification tool}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[1cm]
Version \whyversion\\[3cm]
Jean-Christophe Filli\^atre
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Foreword}
\addcontentsline{toc}{chapter}{Foreword}

A computer program is telling the machine \emph{how} to compute some
output from its input. It is not giving the meaning of this
computation, nor the reason \emph{why} the program is correct. In the
best case, comments inserted in the code would give part of this
information. A formal method gives you the ability to tell the
machine both \emph{how} to compute and \emph{why} it is correct; hence
the name of this tool, \why.

% TODO

\medskip

This manual is organized as follows. Chapter~\ref{tutorial} gives an
overview of \why, illustrating all features with one-line examples.
Chapter~\ref{refman} is a reference manual.


\subsection*{License}

The \why\ certification tool is \copyright\ 2002 Laboratoire de
Recherche en Informatique (\url{www.lri.fr}).
It is open source and freely available under the terms of the GNU
GENERAL PUBLIC LICENSE Version 2. See the files \texttt{COPYING} and
\texttt{GPL} in the distribution.


\subsection*{Availability}

The \why\ tool is available from \url{http://why.lri.fr/}, in source
and binary formats, together with this documentation and many
examples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}
\label{tutorial}


\section{Principles}

\why\ acts as a compiler. It takes annotated programs as input and
generates proof obligations as output.
Currently, the input syntax is a dialect of ML (with a syntax close to
\caml's, with annotations on top),
and the output is a \pvs\ theory or a \coq\ file.

If the input file is \texttt{foo.mlw}, \why\ is simply invoked as
\begin{verbatim}
     why foo.mlw
\end{verbatim}
and a \coq\ module \texttt{foo\_why.v} is (re)generated.
Similarly, invoking \why\ as
\begin{verbatim}
     why --pvs foo.mlw
\end{verbatim}
(re)generates a \pvs\ theory \texttt{foo\_why.pvs}.
% Section~\ref{usage} details the various command line options.

The generated \coq\ file can be edited. When regenerated by \why,
edited parts are kept. Only proof obligations are erased or
overwritten. A backup of the old file is also made automatically.

Contrary to the \coq\ file, the \pvs\ file must not be
edited. Instead, the \texttt{pvs} declaration must be used in the
input file (see below).


\section{Input files}

The input file contains the following kinds of declaration:
\begin{itemize}
  \item\indextt{let}
    \texttt{let} $x$ \texttt{=} \textsl{annotated-program} \par
    Declares a program expression, with name $x$.
    The program is typed, added to the context and proof obligations
    are generated. 
    Examples:
\begin{verbatim}
     let c = 1+2
     let f = fun (x:int ref) -> x := !x + c
\end{verbatim}
    Such programs cannot be of mutable types (i.e. references or arrays).

  \item\indextt{parameter}
    \te{parameter} $x_1,\dots,x_n: \tau$ \par
    Declares some parameters for the whole development. They will be
    turned into axioms on the prover part (when not mutable).
    Examples:
\begin{verbatim}
     parameter x,y : int ref
     parameter N : int
     parameter t : array N of int
\end{verbatim}
    (Types are detailed in Section~\ref{types} and their syntax is
    given in Section~\ref{syntax:mltypes}.)

  \item\indextt{external}
    \te{external} $x_1,\dots,x_n: \tau$ \par 
    Declares some external values of type $\tau$, 
    used in the programs but defined on the prover part.
    Examples:
\begin{verbatim}
     external mean : int -> int -> int
     external diff : a:int -> b:int -> { b >= 0 } int { a = b + result }
\end{verbatim}
    External values cannot be mutable.

    Note that material to be used only in specifications must be introduced
    using the \te{pvs} declaration---when the \pvs\ 
    prover is used---or directly into the generated \coq\ module---when
    the \coq\ prover is used.

  \item\indextt{exception}
    \te{exception} $E$ $[$ \te{of} $\tau$ $]$

    Declares a new exception $E$, possibly with an argument of type $\tau$.

  \item\indextt{logic}
    \te{logic} $x$ \te{:} $\tau_1,\dots,\tau_n$ \te{->} $\tau$

    Declares a symbol $x$ belonging to the logic. $x$ is either a
    predicate (when $\tau$ is \te{prop}) or a function symbol.
    Examples:
\begin{verbatim}
     logic max : int,int -> int
     logic is_int : float -> prop
\end{verbatim}

  \item\indextt{pvs}
    \te{pvs "}\textit{any \pvs\ material}\te{"} \par
    Copies the \pvs\ material as-is in the output theory.
\end{itemize}


\section{Annotations}
\label{annotations}\index{Annotation}

Annotations are inserted into the program to give its specification.
Annotations are written in a first-order predicate calculus syntax
which is not related to \pvs\ or \coq\ syntax. Its syntax is given in
Section~\ref{syntax:logic}. 

Annotations are predicates over the values of the variables
visible at the corresponding program point.
Any annotation may refer to the value of a variable.  For a mutable
variable \texttt{x} (i.e. a reference or an array), \texttt{x} always 
denotes the \emph{current} value of \texttt{x}.

\subsection{Pre/postconditions}\index{Precondition}\index{Postcondition}
Pre- and postconditions are written using the traditional Hoare logic
syntax 
\begin{center}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
  \textsl{expression}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
\end{center}
Any subexpression may be given a pre- and/or a postcondition. Both can be
omitted, independently and at any place.
Within a postcondition, the value of a reference \texttt{x} before the
evaluation (i.e. at the precondition point) is referred to as \texttt{x@}.
Examples:
\begin{verbatim}
     begin x := !x + 1 end { x > x@ }
     { x > 0 } begin x := 2 * !x; x := !x - 1 end { x > 0 }
\end{verbatim}
In the postcondition, the result of the expression is bound to the
variable \texttt{result}. \indextt{result} 
Examples:
\begin{verbatim}
     (1 + 2) { result = 3 }
     begin x := !x + 1; !x end { result <> x@ }
\end{verbatim}

\caveat\ Pre- and postcondition apply to the \emph{closest
subexpression}. Thus, in
\begin{verbatim}
     x := !x + 1 { x = x@ + 1 }
\end{verbatim}
the postcondition \texttt{x = x@ + 1} applies to the expression
\texttt{1}, leading to the unprovable obligation $x=x+1$. Therefore,
the above piece of code should be written instead
\begin{verbatim}
     (x := !x + 1) { x = x@ + 1 }
\end{verbatim}
or even better
\begin{verbatim}
     begin x := !x + 1 end { x = x@ + 1 }
\end{verbatim}


\subsection{Assertions}
\index{Assertion}
Assertions can be inserted within sequences using the \texttt{assert}
keyword. Example:
\begin{verbatim}
     begin 
       x := 2 * !x;
       assert { even(x) };
       x := !x - 1
     end
\end{verbatim}
Assertions are not taken into consideration when computing weakest
preconditions, but may help handling the proofs by introducing cuts.


\subsection{Loops annotations}
\index{Loop}\index{Invariant}\index{Variant}\indextt{while}
Loops can (and usually must) be given invariants and must always be
given variants. Both are introduced as a single annotation following
the \texttt{do} keyword:
\begin{center}
  \texttt{while} \textsl{expression} \texttt{do \{ invariant}
  \emph{predicate} \texttt{variant} 
  \textsl{term} \texttt{\}} \textsl{sequence} \texttt{done}
\end{center}
Examples:
\begin{verbatim}
     while !x > 0 do { invariant x >= 0 variant x } x := !x - 1 done

     while !x < 10 do { invariant x <= 10 variant 10-x } x := !x + 1 done
\end{verbatim}
Variants can be of any type and can be associated to any order
relation (see syntax in Section~\ref{syntax:ml}). When not specified,
the type \texttt{int} and the usual order relation over non negative
integers are assumed.


\subsection{Recursive functions}
\index{Recursive function}
Recursive functions are annotated with the result type and a variant.
For instance, the famous Mac Carthy's 91 function is written:
\begin{verbatim}
     let rec f91 (n:int) : int { variant max(0,101-n) } =
       (if n <= 100 then
          (f91 (f91 (n + 11)))
        else
          n - 10)
       { (n <= 100 and result = 91) or (n >= 101 and result = n - 10) }
\end{verbatim}
Variants are similar to the ones for loops.

\subsection{Labels}
\index{Label}
Labels may be inserted within sequences using the 
\te{label} keyword and the value of a reference \texttt{x} at the
program point labelled \texttt{L} is then referred to as \texttt{x@L}.
Example:
\begin{verbatim}
     begin 
       x := y;
       label L; 
       begin x := !x + 1 end { x > x@L }
     end
\end{verbatim}
The visibility of a label is the same as a local variable's one. In
the code above, label \texttt{L} is not visible outside of the
outermost sequence.

\indextt{init}
A particular label \texttt{init} is automatically inserted at the
beginning of the program, so that the initial value of \texttt{x}
can always be referred to as \texttt{x@init}. 
Example:
\begin{verbatim}
     while !x > 0 do 
       { invariant 0 <= x <= x@init  variant x } 
       x := !x - 1 
     done
\end{verbatim}

Labels provide an alternative to the traditional use of
\emph{auxiliary variables}\index{Auxiliary variable}. Indeed, they
allow you to relate the values of references at any points of the
program. 


\subsection{Exceptions (experimental in version \whyversion)}
\label{exception}\index{Exception}

Exceptions are raised with the construct \texttt{raise}:
\begin{verbatim}
     raise E
     raise (F 1)
\end{verbatim}
and caught with the construct \texttt{try \dots\ with \dots\ end}:
\begin{verbatim}
     try (f 0) with E -> 1 end 
     try (f 0) with F x -> x end
\end{verbatim}
It is not possible to catch an exception which is not possibly raised
by the expression following the \texttt{try}.

Postconditions are extended to specify the behavior in case of
uncaught exceptions:
\begin{verbatim}
     (raise E) { false | E => true }
     (raise (F 1)) { false | F => result = 1 }
\end{verbatim}
In a postcondition regarding an exception, \texttt{result} refers to
the value carried by the exception (if any).
In postconditions, it is not possible to mention exceptions which
are not possibly raised by the program.


\section{Types with effect}
\label{types}\index{Type}

Program expressions are given types including side-effects and
specification. Such a type is either inferred by \why\ (for each
\texttt{let} declaration), or given by the user (in an
\texttt{external} or a \texttt{parameter} declaration).

Types syntax follows ML types syntax, with additional information for
side-effects and pre/postconditions. Here are examples of simple types,
i.e. without annotations:
\begin{verbatim}
     int
     int -> int
     int -> int ref -> unit
\end{verbatim}
Pre/postconditions are added with a syntax similar to the one of
programs annotations, and arguments may be given names when needed:
\begin{verbatim}
     x:int -> y:int -> { } int { result = x + y }
\end{verbatim}
Side effects must be explicited beside the result type:
\indextt{reads}\indextt{writes}\indextt{raises}%
\begin{verbatim}
     unit -> { x >= 0 } unit writes x { x < x@ }
     a:int ref -> b:int ref -> { } unit reads b writes a { a = a@ + b }
     n:int -> { } int raises Negative { result = sqrt(n) | Negative => n<0 }
\end{verbatim}
Finally, the result may be given a name other than \texttt{result},
with the following syntax:
\begin{verbatim}
     x:int -> y:int -> { } returns z:int { z = x + y }
\end{verbatim}
Section~\ref{syntax:mltypes} gives the syntax of types.


\section{Weakest preconditions}
\label{wp}\index{Weakest precondition}
To achieve completeness, annotations are propagated inside
subexpressions using a calculus of weakest preconditions.
However, this mechanism does not propagate an annotation inside an
expression if it already has a postcondition. Instead, it propagates
inside the expression its own postcondition. As a result, an
expression with a postcondition appears as a \emph{black box} from the
outside. 

Example: in the following program
\begin{verbatim}
     begin x := 1; (x := !x + 1) { x = 2 }; x := !x + 1 end { x = 3 }
\end{verbatim}
the final postcondition \texttt{x = 3} is propagated through the third
assignment, but then stops at the postcondition \texttt{x = 2};
instead \texttt{x = 2} is propagated through the second
assignment. So we get two proof obligations, which are
\begin{displaymath}
  x=1 \Rightarrow x+1=2 
  \qquad\mbox{and}\qquad
  x=2 \Rightarrow x+1=3
\end{displaymath}
Any program establishing \texttt{x = 2} can be substituted to the
second assignment without changing the second obligation.


\section{Restrictions with respect to ML}
The ML input language is close to (some fragment of) \caml. However,
there are some---more or less significant---differences:
\begin{itemize}
\item There is \textit{no type inference}; binders are explicitly
  typed. 
\item The use of references is constrained: when dereferenced, updated
  or passed to a function, a reference must be a variable. Thus one
  cannot write
\begin{verbatim}
     (if b then x else y) := 1
\end{verbatim}
as in ML, but one must write instead
\begin{verbatim}
     if b then x := 1 else y := 1
\end{verbatim}
\item Array access is written \texttt{t[e]} instead of \texttt{t.(e)},
  and array update is written \texttt{t[e1] := e2} instead of
  \texttt{t.(e1) <- e2}.
\item Array types mention the array size (e.g. \texttt{array 10 of int}).
\end{itemize}
Getting true \caml\ code from a \why\ source is the subject of the
next section.


\section{Caml code generation}
\label{ocamlcode}\index{Caml code generation}
In order to run your \why\ code, true \caml\ code can be
produced with option \texttt{--ocaml}: 
\begin{verbatim}
     why --ocaml foo.mlw
\end{verbatim}
When this option is selected, there is no generation of proof
obligations (\coq\ or \pvs\ files are not produced or updated).
The \caml\ code is written on standard output, unless redirected to
some file with option \texttt{--output} (see Section~\ref{usage}).

Programs' annotations can be inserted as comments in the \caml\ code,
with option \texttt{--ocaml-annot}. The default behavior is no
annotation. 

When the input file contains \texttt{parameter} declarations, the
\caml\ code generated is a functor, with these parameters as
arguments. For instance, the following input file
\begin{verbatim}
     parameter x : int ref
     let f (y:int) = x := !x + y
\end{verbatim}
is translated into the following piece of \caml\ code:
\begin{verbatim}
     module type Parameters = sig
       val x : int ref
     end

     module Make(P : Parameters) = struct
       open P
       let f = fun y (*:int*) -> x := !x + y
     end
\end{verbatim}
\texttt{external} declarations are supposed to be realized by some
external \caml\ code. However, it is possible to make them arguments
of the functor too, with command line option \texttt{--ocaml-ext}.


\section{Installation}
\label{install}\index{Installation}

To compile \why, you need both \textsf{Objective Caml} and
\textsf{Camlp4} to be installed, in version at least 3.01. Both can
be fetched from \url{http://caml.inria.fr}.
Then 

\begin{enumerate}
\item Configure with \texttt{./configure}

  The directory for binaries defaults to \texttt{/usr/local/bin}; you
  can specify another directory with the \texttt{-{}-bindir}
  option. Similarly, you can change the directory for man pages with
  \texttt{-{}-mandir}.

\item Compile with \texttt{make}

\item Install with \texttt{make install}

  (Alternatively, you can move/copy the \why\ executable
  \texttt{bin/why} anywhere, or make a symbolic link to it from anywhere.)
\end{enumerate}


\section{Examples}
\label{examples}\index{Example}

Many examples are delivered with \why\ in the
subdirectory \texttt{examples/} of the distribution.
They are also available on the \why\ web site, at
\url{http://why.lri.fr/examples/}.



\chapter{Reference manual}
\label{refman}


\section{Command line options}
\label{usage}\index{Option, of the command line}

\why\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{why} [\textit{options}] \textit{file}$_1$\texttt{.mlw} $\cdots$
    \textit{file}$_n$\texttt{.mlw}
\end{center}
Each file \textit{file}\texttt{.mlw} will be compiled into a \pvs\ theory
\textit{file}\texttt{\_why.pvs} or a \coq\ module
\textit{file}\texttt{\_why.v}.
If no file is given, then standard input is processed and output is
in a \pvs\ theory (resp. a \coq\ module) named \texttt{Output\_why}.

Options are the following:
\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--verbose}]: ~\par 
    Verbose mode. In this mode, \why\ prints on error output
    information like the program being processed, the obligations
    being erased or overwritten, etc.
  \item[\texttt{--quiet}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--debug}]: ~\par 
    Debugging mode. In this mode, \why\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.

  \item[Overall options:] ~\par
  \item[\texttt{--parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{--type-only}]:  ~\par  
    Stop after typing.
  \item[\texttt{--wp-only}]:    ~\par  
    Stop after annotation.

  \item[Prover options:] ~\par
  \item[\texttt{--pvs}, \texttt{--coq}]: ~\par 
    Select the prover; it defaults to \coq.
  \item[\texttt{--valid}, \texttt{--no-valid}]: ~\par
    Set/Unset the functional validation. Only meaningful with the
    \coq\ prover. When set, \why\ outputs a functional interpretation
    of each program. Default is no validation. 

  \item[Caml code generation options:] ~\par
  \item[\texttt{--ocaml}]: ~\par 
    Select the \caml\ code generation. The code is produced on
    standard output, unless specified otherwise with option \texttt{--output}.
  \item[\texttt{--output}] \textit{file}: ~\par 
    Redirect the output to file \textit{file}.
  \item[\texttt{--ocaml-annot}]: ~\par 
    Decorate the \caml\ code with all annotations as comments. Default
    is no annotation.
  \item[\texttt{--ocaml-ext}]: ~\par 
    Make parameters from \texttt{external} declarations.
    
\end{description}


\section{Library}
\label{library}\index{Library}

\subsection{Logic}

\subsubsection{Predefined functions}
\index{Function!predefined}

These are the functions predefined in \why:
\begin{description}
\item[\texttt{add\_int, sub\_int, mul\_int, div\_int, mod\_int :
    int,int -> int}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and \texttt{\%}.
\item[\texttt{neg\_int : int -> int}] ~\par
  Corresponds to the prefix symbol \texttt{-}.
\item[\texttt{add\_float, sub\_float, mul\_float, div\_float :
    float,float -> float}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}.
\item[\texttt{neg\_float, sqrt\_float : float -> float}] ~\par
  \texttt{neg\_float} corresponds to the prefix symbol \texttt{-}.
\item[\texttt{float\_of\_int : int -> float}]
\end{description}

\subsubsection{Predefined predicates}
\index{Predicate!predefined}

These are the predicates predefined in \why:
\begin{description}
\item[\texttt{lt\_int, le\_int, gt\_int, ge\_int, eq\_int, neq\_int :
    int, int -> prop}] ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{lt\_float, le\_float, gt\_float, ge\_float, eq\_float,
    neq\_float :}] ~\par
  \texttt{float, float -> prop} ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{eq\_bool, neq\_bool : bool, bool -> prop}] ~\par
  Correspond to the infix symbols \texttt{=} and \texttt{<>}.

\item[\texttt{eq\_unit, neq\_unit : unit, unit -> prop}] ~\par
  Correspond to the infix symbols \texttt{=} and \texttt{<>}.

\item[\texttt{sorted\_array : array int, int, int -> prop}] ~\par
  \indextt{sorted\_array}
  \texttt{sorted\_array($t$,$i$,$j$)} states that the sub-array
  $t[i..j]$ is sorted (in increasing order).

\item[\texttt{exchange : array int, array int, int, int -> prop}] ~\par
  \indextt{exchange}
  \texttt{exchange($t_1$,$t_2$,$i$,$j$)} states that arrays $t_1$ and
  $t_2$ differ only by the swapping of the two elements at indexes $i$
  and $j$.

\item[\texttt{sub\_permut : int, int, array int, array int -> prop}] ~\par
  \indextt{sub\_permut }
  \texttt{sub\_permut($i$,$j$,$t_1$,$t_2$)} states that the sub-arrays
  $t_1[i..j]$ and $t_2[i..j]$ are permutations of each other, the
  other parts of these arrays being the same.

\item[\texttt{permut : array int, array int -> prop}] ~\par
  \indextt{permut}
  \texttt{permut($t_1$,$t_2$)} states that the two arrays $t_1$ and
  $t_2$ are permutations of each other.

\item[\texttt{array\_le : array int, int, int, int -> prop}] ~\par
  \indextt{array\_le}
  \texttt{array\_le($t$,$i$,$j$,$v$)} states that $\forall k. ~ i \le
  k \le j \Rightarrow t[i] \le v$.

\item[\texttt{array\_ge : array int, int, int, int -> prop}] ~\par
  \indextt{array\_ge}
  \texttt{array\_ge($t$,$i$,$j$,$v$)} states that $\forall k. ~ i \le
  k \le j \Rightarrow t[i] \ge v$.

\end{description}

\subsection{Coq}
\index{Coq library}
TODO

\subsection{PVS}
\index{PVS library}
TODO


\section{Logic syntax}
\label{syntax:logic}\index{Logic!syntax}


\subsection{Lexical conventions}
\label{lexical:logic}\index{Lexical conventions!logic}

Lexical conventions are the same as \caml's. 

\paragraph{Comments.} Comments are opened with \texttt{(*}, closed
with \texttt{*)} and can be nested.

\paragraph{Identifiers.} Identifiers are made of letters, digits,
the underscore character \texttt{\_} and the single quote \texttt{'},
starting with a letter. Additionally, they can be qualified by a
label (another identifier), using the \texttt{@} notation.

\begin{center}
\begin{tabular}{lrl}
  \nt{identifier}\indexnt{identifier}
    & $::=$ & \nt{letter} (\nt{letter} $|$ \te{0}..\te{9} $|$
              \te{\_} $|$ \te{'})\etoile
  \\[0.1em]
  \nt{letter}
    & $::=$ & \te{A}..\te{Z} $|$ \te{a}..\te{z}
  \\[0.1em]
  \nt{lab\_identifier}\indexnt{lab\_identifier}
    & $::=$ & \nt{identifier} [ \te{@} \nt{identifier} ]
\end{tabular}
\end{center}


\paragraph{Keywords.}

Keywords of the logic are:
\begin{center}
{\tt\begin{tabular}{l@{\qquad}l@{\qquad}l}
and & bool & else \\
exists & false & float \\
forall & if & int  \\
not & or & then  \\
true & unit & void
\end{tabular}}
\end{center}


\subsection{Terms}
\label{syntax:terms}\index{Term!syntax}

Syntax of terms is given in Figure~\ref{fig:terms}.
Arithmetical operations have usual precedences and are left associative.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} \\
      & $|$ & \nt{lab\_identifier} \\
      & $|$ & \nt{lab\_identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{lab\_identifier} \te{[} \nt{term} \te{]} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{floating-point-constant} \\
      & $|$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \te{void} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%}
\end{tabular}\\
\hrulefill
\caption{Syntax of terms}
\label{fig:terms}
\end{center}            
\end{figure}


\subsection{Predicates}
\label{syntax:predicates}\index{Predicate!syntax}

Syntax of predicates is given in Figure~\ref{fig:predicates}.
It is a first-order quantifier-free syntax, independent from the \coq\
and the \pvs\ ones.

Precedences are the following (from strongest to weakest): \te{not}, 
\te{and}, \te{or}, implication, and \te{forall}. 
Implication, conjunction and disjunction are right associative.

Primitive types (non terminal \nt{primitive\_type}) are defined in
Figure~\ref{fig:types}. 

Syntactic sugar: $t_1 ~ R_1 ~ t_2 ~ R_2 ~ t_3$ is equivalent to
$t_1 ~ R_1 ~ t_2 ~ \texttt{and} ~ t_2 ~ R_2 ~ t_3$ for any relations
$R_1$ and $R_2$. Example: \texttt{0 <= x < y}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{predicate}\indexnt{predicate}
    & $::=$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{or} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{and} \nt{predicate} \\
      & $|$ & \te{not} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \te{forall} \nt{identifier} \te{:} \nt{primitive\_type}
              \te{.} \nt{predicate} \\
      & $|$ & \te{exists} \nt{identifier} \te{:} \nt{primitive\_type}
              \te{.} \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of predicates}
\label{fig:predicates}
\end{center}            
\end{figure}


\section{ML programs}
\label{syntax:ml}\index{ML program!syntax}

\subsection{Lexical conventions}
\label{lexical:ml}\index{Lexical conventions!ML programs}

Lexical conventions are the same as for logic (see
Section~\ref{lexical:logic} on page~\pageref{lexical:logic}).
The set of keywords is now:
\begin{center}
{\tt\begin{tabular}{l@{\qquad}l@{\qquad}l@{\qquad}l@{\qquad}l}
and & array & as & assert & begin \\
bool & do & done & else & end \\
exception & exists & external & false & float  \\
for & forall & fun & if & in  \\
int & invariant & label & let & logic \\
not & of & or & parameter & prop  \\
pvs & raise & raises & reads & rec  \\
ref & returns & then & true & try  \\
unit & variant & void & while & with \\
writes
\end{tabular}}
\end{center}

\subsection{ML types}
\label{syntax:mltypes}\index{ML type!syntax}

Syntax of types is given in Figure~\ref{fig:types}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{simple\_value\_type}\indexnt{simple\_value\_type}
    & $::=$ & \nt{primitive\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{ref} \\
      & $|$ & \te{array} \nt{term} \te{of} \nt{simple\_value\_type} \\
      & $|$ & \te{(} \nt{value\_type} \te{)} \\
  \\[0.1em]

  \nt{value\_type}\indexnt{value\_type}
    & $::=$ & \nt{simple\_value\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{->} \nt{computation\_type} \\
      & $|$ & \nt{identifier} \te{:} \nt{simple\_value\_type} 
              \te{->} \nt{computation\_type} \\
  \\[0.1em]

  \nt{computation\_type}\indexnt{computation\_type}
    & $::=$ & \te{\{} $[$ \nt{precondition} $]$ \te{\}} \\
      &     & $[$ \te{returns} \nt{identifier} \te{:} $]$ \nt{value\_type}
              \nt{effects} \\
      &     & \te{\{} $[$ \nt{postcondition} $]$ \te{\}} \\
      & $|$ & \nt{value\_type} \\
  \\[0.1em]

  \nt{effects}
    & $::=$ & $[$ \te{reads} \nt{identifier}\etoilesep{\te{,}} $]$
              $[$ \te{writes}  \nt{identifier}\etoilesep{\te{,}}  $]$ 
              $[$ \te{raises}  \nt{identifier}\etoilesep{\te{,}}  $]$ \\
  \\[0.1em]

  \nt{primitive\_type}\indexnt{primitive\_type}
    & $::=$ & \te{int} $|$ \te{bool} $|$ \te{float} $|$ 
              \te{unit} $|$ \nt{identifier} \\
  \\[0.1em]

  \nt{precondition}\indexnt{precondition}
    & $::=$ & \nt{assertion} \\
  \\[0.1em]

  \nt{postcondition}\indexnt{postcondition}
    & $::=$ & \nt{assertion} \nt{exn\_condition}\etoile \\
  \\[0.1em]

  \nt{exn\_condition} 
    & $::=$ & \te{|} \nt{identifier} \te{=>} \nt{assertion} \\
  \\[0.1em]

  \nt{assertion} 
    & $::=$ & \nt{predicate} $[$ \te{as} \nt{identifier} $]$ \\
\end{tabular}\\
\hrulefill
\caption{Syntax of types}
\label{fig:types}
\end{center}            
\end{figure}


\subsection{ML expressions}
\label{syntax:mlexpr}\index{ML expression!syntax}

Syntax of annotated ML programs is given in Figure~\ref{fig:caml}.
\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{prog}\indexnt{prog}
    & $::=$ & \te{\{} \nt{precondition} \te{\}}\etoile\
              \nt{statement} 
              $[$ \te{\{} \nt{postcondition} \te{\}} $]$ \\
  \\[0.1em]

  \nt{statement}\indexnt{statement}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \te{!} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{:=} \nt{prog} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \te{:=} \nt{prog} \\
      & $|$ & \nt{prog} \nt{infix} \nt{prog} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \te{ref} 
              \nt{prog} \te{in} \nt{prog} \\
      & $|$ & \te{if} \nt{prog} \te{then} \nt{prog}
              $[$ \te{else} \nt{prog} $]$ \\
      & $|$ & \te{while} \nt{prog} \te{do}
              \nt{loop\_annot} \nt{block} \te{done} \\
      & $|$ & \te{begin} \nt{block} \te{end} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \nt{prog} 
              \te{in} \nt{prog} \\
      & $|$ & \te{fun} \nt{binders} \te{->} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} $[$ \te{in} \nt{prog} $]$ \\
      & $|$ & \te{raise} \nt{identifier} $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{raise} \te{(} \nt{identifier} \nt{prog} \te{)}
              $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{try} \nt{prog} \te{with} 
              \nt{handler}\plussep{\te{|}} \te{end} \\
      & $|$ & \te{(} \nt{prog}\plus\  \te{)} \\
  \\[0.1em]

  \nt{block}\indexnt{block}
    & $::=$ & \nt{block\_statement}\plussep{\te{;}} \\
  \\[0.1em]

      \nt{block\_statement}
    & $::=$ & \nt{prog} \\
      & $|$ & \te{label} \nt{identifier} \\
      & $|$ & \te{assert} \te{\{} \nt{assertion} \te{\}} \\
  \\[0.1em]
 
  \nt{infix}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ 
              \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=} $|$
              \te{||} $|$ \te{\&\&} \\
  \\[0.1em]

  \nt{binders}\indexnt{binders}
    & $::=$ & \te{(} \nt{identifier}\plussep{\te{,}} \te{:}
              \nt{value\_type} \te{)}\plus \\
  \\[0.1em]

  \nt{recfun}
    & $::=$ & \nt{identifier} \nt{binders} \te{:}
              value\_type \\
      &     & \te{\{} \te{variant} \nt{wf\_arg} \te{\}}
              \te{=} \nt{prog} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{\{} \te{invariant} \nt{assertion} 
              \te{variant} \nt{wf\_arg} \te{\}} \\
  \\[0.1em]

  \nt{wf\_arg} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{identifier} $]$ \\

  \\[0.1em]

  \nt{handler}\indexnt{handler}
    & $::=$ & \nt{identifier} \te{->} \nt{prog} \\
      & $|$ & \nt{identifier} \nt{identifier} \te{->} \nt{prog} \\
  
\end{tabular}\\
\hrulefill
\caption{Syntax of annotated programs}
\label{fig:caml}
\end{center}
\end{figure}


\subsection{ML files}
\label{syntax:mlfiles}\index{ML file!syntax}

Syntax of input files is given in Figure~\ref{fig:input}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{file}
    & $::=$ & \nt{declaration}\etoile\ \\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \te{let} \nt{identifier} $[$ \nt{binders} $]$ \te{=} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} \\
      & $|$ & \te{parameter} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\ \indextt{parameter}
      & $|$ & \te{external} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\ \indextt{external}
      & $|$ & \te{exception} \nt{identifier} 
              $[$ \te{of} \nt{primitive\_type} $]$ \\ \indextt{exception}
      & $|$ & \te{logic} \nt{identifier} \te{:} \nt{logic\_type} \\
      & $|$ & \te{pvs} \nt{string} \\
   \\[0.1em]

  \nt{logic\_type}
    & $::=$ & \nt{logic\_arg\_type}\etoilesep{\te{,}} \te{->} \te{prop} \\
      & $|$ & \nt{logic\_arg\_type}\etoilesep{\te{,}} \te{->} 
              \nt{primitive\_type} \\ \indextt{logic}
   \\[0.1em]

  \nt{logic\_arg\_type}
    & $::=$ & \nt{primitive\_type} $|$ \te{array} \nt{primitive\_type}
\end{tabular}\\
\hrulefill
\caption{Syntax of input files}
\label{fig:input}
\end{center}           
\end{figure}

\subsection{ML semantics}
\label{semantics:ml}\index{ML program!semantics}

Semantics of ML programs conforms to \caml's one.
More precisely, it obeys the following rules:
\begin{itemize}
\item 
  Logical connective \texttt{\&\&} and \texttt{||} are lazy and
  evaluated from left to right: in $e_1$ \texttt{\&\&} $e_2$, $e_1$ is
  evaluated first and, if \texttt{true}, then $e_2$ is evaluated; in
  $e_1$ \texttt{||} $e_2$, $e_1$ is evaluated first and, if
  \texttt{false}, then $e_2$ is evaluated.
  Stated otherwise, the following identities hold:
  \begin{displaymath}
    \begin{array}{rcl}
      e_1 ~ \te{\&\&} ~ e_2 & \approx & 
      \te{if} ~ e_1 ~ \te{then} ~ e_2 ~ \te{else false} \\[0.5em]
      e_1 ~ \te{||} ~ e_2 & \approx & 
      \te{if} ~ e_1 ~ \te{then true else} ~ e_2
    \end{array}
  \end{displaymath}
\item
  In a function call, the argument is evaluated first, then the
  function; consequently multiple arguments are evaluated from right
  to left. This applies to all infix operators, except
  \texttt{\&\&} and \texttt{||}.
\item
  In array assignment $t$\texttt{[}$e_2$\texttt{] :=} $e_1$,
  expression $e_1$ is evaluated first, then expression $e_2$.
\end{itemize}


\subsection{Predefined functions}

These are the functions predefined in \why:
\begin{description}
\item[\texttt{add\_int, sub\_int, mul\_int, div\_int, mod\_int : int
    -> int -> int}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and \texttt{\%}.

\item[\texttt{neg\_int : int -> int}] ~\par
  Correponds to the prefix symbol \texttt{-}.

\item[\texttt{add\_float, sub\_float, mul\_float, div\_float,
    : float -> float -> float}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}.

\item[\texttt{neg\_float, sqrt\_float : float -> float}] ~\par
  \texttt{neg\_float} correponds to the prefix symbol \texttt{-}.

\item[\texttt{float\_of\_int : int -> float}]

\item[\texttt{lt\_int : x:int -> y:int -> \{\} bool \{if result then x
    < y else x >= y\}}] ~\par
\item[\texttt{le\_int : x:int -> y:int -> \{\} bool \{if result then x
    <= y else x > y\}}] ~\par
\item[\texttt{gt\_int : x:int -> y:int -> \{\} bool \{if result then x
    > y else x <= y\}}] ~\par
\item[\texttt{ge\_int : x:int -> y:int -> \{\} bool \{if result then x
    >= y else x < y\}}] ~\par
\item[\texttt{eq\_int : x:int -> y:int -> \{\} bool \{if result then x
    = y else x <> y\}}] ~\par
\item[\texttt{neq\_int : x:int -> y:int -> \{\} bool \{if result then x
    <> y else x = y\}}] ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{lt\_float, le\_float, gt\_float, ge\_float, eq\_float,
    neq\_float}] ~\par
  As for integers.

\item[\texttt{eq\_bool, neq\_bool, eq\_unit, neq\_unit}] ~\par
  As for integers.

\end{description}


\section{C programs}
\label{syntax:C}\index{C program!syntax}

Contrary to ML input files, C input files conform to the usual ANSI C
syntax and annotations are inserted in the source as comments.

\subsection{Lexical conventions}
\label{lexical:c}\index{Lexical conventions!C programs}

The lexical conventions conform to the ANSI C standard (see
for instance~\cite{KR88}).

\subsection{Annotations}
\index{C program!annotations}

Annotations are inserted as special comments of the shape
\begin{verbatim}
     /*@ ... */
\end{verbatim}
Note that within annotations the syntax in use is the one given in
Section~\ref{syntax:logic}, with its own lexical conventions,
different from the C ones. In particular, comments are enclosed by
\texttt{(*} and \texttt{*)}.

\subsection{Syntax}

The syntax of C files corresponds to a fragment of the ANSI C syntax
and is given in Figure~\ref{fig:cfiles}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{c\_file}
    & $::=$ & \nt{c\_declaration}\etoile\ \\
  \\[0.1em]

  \nt{c\_declaration}
    & $::=$ & \nt{c\_type} \nt{identifier} \\
      & $|$ & \nt{c\_type} \nt{identifier} \te{(} 
              \nt{parameter}\etoilesep{\te{,}} \te{)} $[$ \nt{c\_spec} $]$ \\
  \\[0.1em]

  \nt{c\_type}
    & $::=$ & \nt{void} $|$ \nt{char} $|$ \nt{short} $|$ \nt{int} 
              $|$ \nt{long} $|$ \nt{float} $|$ \nt{double} 
              $|$ \te{identifier} \\
  \\[0.1em]

  \nt{parameter}
    & $::=$ & \nt{c\_type} \nt{identifier} \\
  \\[0.1em]

  \nt{c\_expr}
    & $::=$ & \nt{identifier} \\
    &   $|$ & ... \\
  \\[0.1em]

  \nt{c\_statement}
    & $::=$ & \nt{c\_expr} \\
    &   $|$ & ... \\
  \\[0.1em]

  \nt{c\_spec}
    & $::=$ & \te{/*@} $[$ \te{pre} \nt{precondition} $]$ \nt{effects}
              $[$ \te{post} \nt{postcondition} $]$ \te{*/}  \\
  \nt{c\_pre}
    & $::=$ & \te{/*@} \nt{precondition} \te{*/}  \\
  \nt{c\_post}
    & $::=$ & \te{/*@} \nt{postcondition} \te{*/}  \\
  \nt{c\_loop\_annot}
    & $::=$ & \te{/*@} \te{invariant} \nt{assertion} 
              \te{variant} \nt{wf\_arg} \te{*/}  \\
  \\[0.1em]

\end{tabular}\\
\hrulefill
\caption{Syntax of C files}
\label{fig:cfiles}
\end{center}           
\end{figure}



\bibliographystyle{plain}
\bibliography{./biblio}


\newpage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
