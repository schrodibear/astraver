\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}
\input{./version.tex}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}\index{PVS@\textsf{PVS}}}
\newcommand{\coq}{\textsf{Coq}\index{Coq@\textsf{Coq}}}
\newcommand{\harvey}{\textsf{haRVey}\index{haRVey@\textsf{haRVey}}}
\newcommand{\simplify}{\textsf{Simplify}\index{Simplify@\textsf{Simplify}}}
\newcommand{\mizar}{\textsf{Mizar}\index{Mizar@\textsf{Mizar}}}
\newcommand{\hollight}{\textsf{HOL Light}\index{HOL Light@\textsf{HOL Light}}}
\newcommand{\isabelle}{\textsf{Isabelle/HOL}\index{Isabelle/HOL@\textsf{Isabelle/HOL}}}
\newcommand{\holfour}{\textsf{HOL 4}\index{HOL 4@\textsf{HOL 4}}}
\newcommand{\cvclite}{\textsf{CVC Lite}\index{CVC Lite@\textsf{CVC Lite}}}
\newcommand{\krakatoa}{\textsf{Krakatoa}\index{Krakatoa@\textsf{Krakatoa}}}
\newcommand{\caduceus}{\textsf{Caduceus}\index{Caduceus@\textsf{Caduceus}}}
\newcommand{\java}{\textsc{Java}\index{Java@\textsf{Java}}}
\newcommand{\jml}{\textsc{JML}\index{JML@\textsf{JML}}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The WHY verification tool}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[1cm]
Version \whyversion\\[3cm]
Jean-Christophe Filli\^atre
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Foreword}
\addcontentsline{toc}{chapter}{Foreword}

A computer program is telling the machine \emph{how} to compute some
output from its input. It is not giving the meaning of this
computation, nor the reason \emph{why} the program is correct. In the
best case, comments inserted in the code would give part of this
information. A formal method gives you the ability to tell the
machine both \emph{how} to compute and \emph{why} it is correct; hence
the name of this tool, \why.

% TODO

\medskip

This manual is organized as follows. Chapter~\ref{tutorial} gives an
overview of \why, illustrating all features with one-line examples.
Chapter~\ref{refman} is a reference manual.


\subsection*{License}

The \why\ certification tool is \copyright\ 2002 Laboratoire de
Recherche en Informatique (\url{www.lri.fr}).
It is open source and freely available under the terms of the GNU
GENERAL PUBLIC LICENSE Version 2. See the files \texttt{COPYING} and
\texttt{GPL} in the distribution.


\subsection*{Availability}

The \why\ tool is available from \url{http://why.lri.fr/}, in source
and binary formats, together with this documentation and many
examples.


\subsection*{Contact}

There is a mailing list for \why, which is mainly used to announce the
releases. To subscribe, you need to send an email to
\url{why-request@serveur-listes.lri.fr} with 
\verb+subscribe your@email+ in the mail body. Emails can be sent to
the list at 
\url{why@serveur-listes.lri.fr}. Note: Only the lists members
can send emails to the list.

Bug reports can be sent to \url{filliatr@lri.fr}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}
\label{tutorial}


\section{Principles}

\why\ acts as a compiler. It takes annotated programs as input and
generates proof obligations as output.
The input syntax is a dialect of ML (with a syntax close to
\caml's) with annotations on top.
The output is an input file for \pvs~\cite{PVS}, \coq~\cite{Coq},
\isabelle~\cite{Isabelle}, \holfour~\cite{HOL4},
\hollight~\cite{HOLLight}, \mizar~\cite{Mizar},  
\simplify~\cite{Simplify}, \harvey~\cite{haRVey} or \cvclite~\cite{CVCLite}.

If the input file is \texttt{foo.mlw}, \why\ is simply invoked as
\begin{verbatim}
     why foo.mlw
\end{verbatim}
and a \coq\ module \texttt{foo\_why.v} is (re)generated.
Similarly, invoking \why\ as
\begin{verbatim}
     why --pvs foo.mlw
     why --hol-light foo.mlw
     why --isabelle foo.mlw
     why --hol4 foo.mlw
     why --mizar foo.mlw
     why --simplify foo.mlw
     why --harvey foo.mlw
     why --cvcl foo.mlw
\end{verbatim}
(re)generates an input file for the corresponding proof tool.
The generated file may be edited (depending on the prover). 
When regenerated by \why, edited parts are kept. 
A backup of the old file is also made automatically.

\section{Verifying programs}

\subsection{Input files}

The input file contains the following kinds of declaration:
\begin{itemize}
  \item\indextt{let}
    \texttt{let} $x$ \texttt{=} \textsl{annotated-program} \par
    Declares a program expression, with name $x$.
    The program is typed, added to the context and proof obligations
    are generated. 
    Examples:
\begin{verbatim}
     let c = 1+2
     let f = fun (x:int ref) -> x := !x + c
\end{verbatim}
    Such programs cannot be of mutable types (i.e. references or arrays).

  \item\indextt{parameter}
    \te{parameter} $x_1,\dots,x_n: \tau$ \par
    Declares some parameters for the whole development. They will be
    turned into axioms on the prover part (when not mutable).
    Examples:
\begin{verbatim}
     parameter x,y : int ref
     parameter N : int
     parameter t : int array
\end{verbatim}
    (Types are detailed in Section~\ref{types} and their syntax is
    given in Section~\ref{syntax:types}.)

    The prefix \te{external}\indextt{external} indicates that
    $x_1,\dots,x_n$ are already defined on the prover side (and thus
    nothing is produced). Examples:
\begin{verbatim}
     external parameter mean : int -> int -> int
     external parameter diff : a:int -> b:int -> 
                               { b >= 0 } int { a = b + result }
\end{verbatim}
    External values cannot be mutable.

  \item\indextt{exception}
    \te{exception} $E$ $[$ \te{of} $\tau$ $]$

    Declares a new exception $E$, possibly with an argument of type $\tau$.

  \item\indextt{logic}\indextt{prop}
    \te{logic} $x_1,\dots,x_n$ \te{:} $\tau_1,\dots,\tau_m$ \te{->} $\tau$

    Introduces symbols $x_1,\dots,x_n$ belonging to the logic. 
    The $x_i$ are either
    predicates (when $\tau$ is \te{prop}), constants (when $m=0$) or
    function symbols. 
    Examples:
\begin{verbatim}
     logic max : int,int -> int
     logic is_int : real -> prop
\end{verbatim}

    Similarly to \te{parameter}, the prefix
    \te{external}\indextt{external} indicates that 
    $x_1,\dots,x_n$ are already defined on the prover side (and thus
    nothing is produced).

  \item\indextt{predicate}
    \te{predicate} $p$\te{(} $x_1:\tau_1$, \dots, $x_n:\tau_n$
    \te{) =} \textsl{predicate}

    Defines a predicate $p$. Examples:
\begin{verbatim}
     predicate ge0(x:int, y:int) = x >= y >= 0
\end{verbatim}

  \item\indextt{function}
    \te{function} $f$\te{(} $x_1:\tau_1$, \dots, $x_n:\tau_n$
    \te{) :} $\tau$ \te{=} \textsl{term}

    Defines a logic function $f$. Example:
\begin{verbatim}
     function f(x:int, y:int) : int = x + y
\end{verbatim}

  \item\indextt{axiom} 
    \te{axiom} $x$ \te{:} \textsl{predicate}

    Declares an axiom of name $x$. Example:
\begin{verbatim}
     axiom max_1 : forall x:int. forall y:int. max(x,y) >= x
\end{verbatim}

\end{itemize}


\subsection{Annotations}
\label{annotations}\index{Annotation}

Annotations are inserted into the program to give its specification.
Annotations are written in a first-order predicate calculus syntax
which is not related to any particular prover. Its syntax is given in
Section~\ref{syntax:logic}. 

Annotations are predicates over the values of the variables
visible at the corresponding program point.
Any annotation may refer to the value of a variable.  For a mutable
variable \texttt{x} (i.e. a reference or an array), \texttt{x} always 
denotes the \emph{current} value of \texttt{x}.

\subsubsection{Pre/postconditions}\index{Precondition}\index{Postcondition}
Pre- and postconditions are written using the traditional Hoare logic
syntax 
\begin{center}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
  \textsl{expression}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
\end{center}
Any subexpression may be a Hoare triple. Within a triple, the pre- or
the postcondition may be omitted.
Within a postcondition, the value of a reference \texttt{x} before the
evaluation (i.e. at the precondition point) is referred to as \texttt{x@}.
Examples:
\begin{verbatim}
     { } begin x := !x + 1 end { x > x@ }
     { x > 0 } begin x := 2 * !x; x := !x - 1 end { x > 0 }
\end{verbatim}
In the postcondition, the result of the expression is bound to the
variable \texttt{result}. \indextt{result} 
Examples:
\begin{verbatim}
     { } 1 + 2 { result = 3 }
     { } begin x := !x + 1; !x end { result <> x@ }
\end{verbatim}


\caveat
In the outermost triple of a program (or a function body) the
precondition is an \emph{assumption}. In the declaration
\begin{verbatim}
     let f (u:unit) = { x = 0 } x := x + 1 { x = 1 }
\end{verbatim}
the precondition \texttt{x = 0} is an hypothesis. (The user will be
asked to prove \texttt{x = 0} when \texttt{f} is called.)
But preconditions of inner triples are \emph{obligations} to be
proved. In the declaration 
\begin{verbatim}
     let f (u:unit) = 
       {} begin x := 0; { x = 0 } x := x + 1 {} end { x = 1 }
\end{verbatim}
the precondition \texttt{x = 0} has to be established at the
corresponding program point.
Note that such an obligation can be given to the outermost expression
too, using parentheses:
\begin{verbatim}
     let f (u:unit) = { x = 0 } ({ odd(x) } x := x / 2 {}) {}
\end{verbatim}
Here \texttt{x = 0} is an assumption and \texttt{odd(x)} is an obligation.


\subsubsection{Assertions}
\index{Assertion}\indextt{assert}
Within sequences, a simpler way to insert obligations is to use the
\texttt{assert} construct. Example:
\begin{verbatim}
     begin 
       x := 2 * !x;
       assert { even(x) };
       x := !x - 1
     end
\end{verbatim}
Note that such assertions can be used to introduce \emph{proof cuts},
to ease the discharge of the forthcoming obligations.

\subsubsection{Loops annotations}
\index{Loop}\index{Invariant}\index{Variant}
\indextt{while}\indextt{invariant}\indextt{variant}
Loops can (and usually must) be given invariants and must always be
given variants. Both are introduced as a single annotation following
the \texttt{do} keyword:
\begin{center}
  \texttt{while} \textsl{expression} \texttt{do \{ invariant}
  \emph{predicate} \texttt{variant} 
  \textsl{term} \texttt{\}} \textsl{sequence} \texttt{done}
\end{center}
Examples:
\begin{verbatim}
     while !x > 0 do { invariant x >= 0 variant x } x := !x - 1 done

     while !x < 10 do { invariant x <= 10 variant 10-x } x := !x + 1 done
\end{verbatim}
Variants can be of any type and can be associated to any order
relation (see syntax in Section~\ref{syntax}). When not specified,
the type \texttt{int} and the usual order relation over non negative
integers are assumed.


\subsubsection{Recursive functions}
\index{Recursive function}
Recursive functions are annotated with the result type and a variant.
For instance, the famous Mac Carthy's 91 function is written:
\begin{verbatim}
     let rec f91 (n:int) : int { variant max(0,101-n) } =
       { }
       if n <= 100 then
         (f91 (f91 (n + 11)))
       else
         n - 10
       { (n <= 100 and result = 91) or (n >= 101 and result = n - 10) }
\end{verbatim}
Variants are similar to the ones for loops.

\subsubsection{Labels}
\index{Label}
Labels may be inserted within sequences using the 
\te{label} keyword and the value of a reference \texttt{x} at the
program point labelled \texttt{L} is then referred to as \texttt{x@L}.
Example:
\begin{verbatim}
     begin 
       x := y;
       label L; 
       { } begin x := !x + 1 end { x > x@L }
     end
\end{verbatim}
The visibility of a label is the same as a local variable's one. In
the code above, label \texttt{L} is not visible outside of the
outermost sequence.

Labels provide an alternative to the traditional use of
\emph{auxiliary variables}\index{Auxiliary variable}. Indeed, they
allow you to relate the values of references at any points of the
program. 


\subsubsection{Exceptions}
\label{exception}\index{Exception}

Exceptions are raised with the construct \texttt{raise}:
\begin{verbatim}
     raise E
     raise (F 1)
\end{verbatim}
and caught with the construct \texttt{try \dots\ with \dots\ end}:
\begin{verbatim}
     try (f 0) with E -> 1 end 
     try (f 0) with F x -> x end
\end{verbatim}
It is not possible to catch an exception which is not possibly raised
by the expression following the \texttt{try}.

Postconditions are extended to specify the behavior in case of
uncaught exceptions:
\begin{verbatim}
     { } raise E { false | E => true }
     { } raise (F 1) { false | F => result = 1 }
\end{verbatim}
In a postcondition regarding an exception, \texttt{result} refers to
the value carried by the exception (if any).
In postconditions, it is not possible to mention exceptions which
are not possibly raised by the program.


\subsubsection{Unreachable code}
\label{absurd}\indextt{absurd}

The construct \texttt{absurd} can be used to denote an unreachable
point in the code. Example:
\begin{verbatim}
     { 0 <= x <= 1 }
     if x = 0 then 
       ...
     else if x = 1 then 
       ...
     else 
       absurd
     { ... }
\end{verbatim}
At such program points, the user will be asked to prove that the
context is indeed absurd, which corresponds to the obligation \texttt{false}.

\subsection{Types with effect}
\label{types}\index{Type}

Program expressions are given types including side-effects and
specification. Such a type is either inferred by \why\ (for each
\texttt{let} declaration), or given by the user (in a
\texttt{parameter} declaration).

Types syntax follows ML types syntax, with additional information for
side-effects and pre/postconditions. Here are examples of simple types,
i.e. without annotations:
\begin{verbatim}
     int
     int -> int
     int -> int ref -> unit
\end{verbatim}
Pre/postconditions are added with a syntax similar to the one of
programs annotations, and arguments may be given names when needed:
\begin{verbatim}
     x:int -> y:int -> { } int { result = x + y }
\end{verbatim}
Side effects must be explicited beside the result type:
\indextt{reads}\indextt{writes}\indextt{raises}%
\begin{verbatim}
     unit -> { x >= 0 } unit writes x { x < x@ }
     a:int ref -> b:int ref -> { } unit reads b writes a { a = a@ + b }
     n:int -> { } int raises Negative { result = sqrt(n) | Negative => n<0 }
\end{verbatim}
Finally, the result may be given a name other than \texttt{result},
with the following syntax:
\begin{verbatim}
     x:int -> y:int -> { } returns z:int { z = x + y }
\end{verbatim}
Section~\ref{syntax:types} gives the syntax of types.


\subsection{Weakest preconditions}
\label{wp}\index{Weakest precondition}
To achieve completeness, annotations are propagated inside
subexpressions using a calculus of weakest preconditions.
However, this mechanism does not propagate an annotation inside an
expression if it already has a postcondition. Instead, it propagates
inside the expression its own postcondition. As a result, an
expression with a postcondition appears as a \emph{black box} from the
outside. 

Example: in the following program
\begin{verbatim}
     {} begin x := 1; {} x := !x + 1 { x = 2 }; x := !x + 1 end { x = 3 }
\end{verbatim}
the final postcondition \texttt{x = 3} is propagated through the third
assignment, but then stops at the postcondition \texttt{x = 2};
instead \texttt{x = 2} is propagated through the second
assignment. So we get two proof obligations, which are
\begin{displaymath}
  x=1 \Rightarrow x+1=2 
  \qquad\mbox{and}\qquad
  x=2 \Rightarrow x+1=3
\end{displaymath}
Any program establishing \texttt{x = 2} can be substituted to the
second assignment without changing the second obligation.


\subsection{Restrictions with respect to ML}
The ML input language is close to (some fragment of) \caml. However,
there are some---more or less significant---differences:
\begin{itemize}
\item There is \textit{no type inference}; binders are explicitly
  typed. 
\item The use of references is constrained: when dereferenced, updated
  or passed to a function, a reference must be a variable. Thus one
  cannot write
\begin{verbatim}
     (if b then x else y) := 1
\end{verbatim}
as in ML, but one must write instead
\begin{verbatim}
     if b then x := 1 else y := 1
\end{verbatim}
\item Array access is written \texttt{t[e]} instead of \texttt{t.(e)},
  and array update is written \texttt{t[e1] := e2} instead of
  \texttt{t.(e1) <- e2}.
\end{itemize}
Getting true \caml\ code from a \why\ source is the subject of the
next section.



\section{Tools}

\subsection{Caml code generation}
\label{ocamlcode}\index{Caml code generation}
In order to run your \why\ code, true \caml\ code can be
produced with option \texttt{--ocaml}: 
\begin{verbatim}
     why --ocaml foo.mlw
\end{verbatim}
When this option is selected, there is no generation of proof
obligations (\coq\ or \pvs\ files are not produced or updated).
The \caml\ code is written on standard output, unless redirected to
some file with option \texttt{--output} (see Section~\ref{usage}).

Programs' annotations can be inserted as comments in the \caml\ code,
with option \texttt{--ocaml-annot}. The default behavior is no
annotation. 

When the input file contains \texttt{parameter} declarations, the
\caml\ code generated is a functor, with these parameters as
arguments. For instance, the following input file
\begin{verbatim}
     parameter x : int ref
     let f (y:int) = x := !x + y
\end{verbatim}
is translated into the following piece of \caml\ code:
\begin{verbatim}
     module type Parameters = sig
       val x : int ref
     end

     module Make(P : Parameters) = struct
       open P
       let f = fun y (*:int*) -> x := !x + y
     end
\end{verbatim}
\texttt{external parameter} declarations are supposed to be realized by some
external \caml\ code. However, it is possible to make them arguments
of the functor too, with command line option \texttt{--ocaml-ext}.

\subsection{Why to HTML converter}
A tool to convert \why\ input files to HTML is provided. Its usage is
immediate:
\begin{verbatim}
     why2html [-t title] files...
\end{verbatim}
Each \why\ input file given on the command line, say \textit{foo.mlw},
is translated into a HTML file \textit{foo.mlw.html}. A title for the
HTML page can be specified using command line option \texttt{-t};
otherwise the original file name is used.


\section{Installation}
\label{install}\index{Installation}

To compile \why, you need both \textsf{Objective Caml} to be
installed, in version at least 3.06. Both can 
be fetched from \url{http://caml.inria.fr}.
Then 

\begin{enumerate}
\item Configure with \texttt{./configure}

  The directory for binaries defaults to \texttt{/usr/local/bin}; you
  can specify another directory with the \texttt{-{}-bindir}
  option. Similarly, you can change the directory for man pages with
  \texttt{-{}-mandir}.

\item Compile with \texttt{make}

\item Install with \texttt{make install}

  (Alternatively, you can move/copy the \why\ executable
  \texttt{bin/why.opt} anywhere, or make a symbolic link to it from anywhere.)
\end{enumerate}


\section{Examples}
\label{examples}\index{Example}

Many examples are delivered with \why\ in the
subdirectory \texttt{examples/} of the distribution.
They are also available on the \why\ web site, at
\url{http://why.lri.fr/examples/}.


\section{Verifying C and Java programs}

C and \java\ programs can be verified using other tools in combination
with \why. C programs can be verified using \caduceus\ (see
\url{why.lri.fr/caduceus/}) and \java\ programs using \krakatoa\ (see
\url{krakatoa.lri.fr}). 


\chapter{Reference manual}
\label{refman}


\section{Command line options}
\label{usage}\index{Option, of the command line}

\why\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{why} [\textit{options}] \textit{file}$_1$ $\cdots$ \textit{file}$_n$
\end{center}
If no file is given, then standard input is processed and output is
named \texttt{Output\_why}.
Command line options are the following:
\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--version}]: ~\par    
    Give \why\ version number and exit. 
  \item[\texttt{--verbose}]: ~\par 
    Verbose mode. In this mode, \why\ prints on error output
    information like the program being processed, the obligations
    being erased or overwritten, etc.
  \item[\texttt{--quiet}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--werror}]: ~\par 
    Turn warnings as errors. \why\ will stop on the first warning.
  \item[\texttt{--debug}]: ~\par 
    Debugging mode. In this mode, \why\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.
  \item[\texttt{--where}]: ~\par 
    Print \why\ library path and exit.

  \item[Overall options:] ~\par
  \item[\texttt{--parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{--type-only}]:  ~\par  
    Stop after typing.
  \item[\texttt{--wp-only}]:    ~\par  
    Stop after annotation.
  \item[\texttt{--dir} \textit{dir}]: ~\par
    Output files into directory \texttt{dir}.

  \item[VCG options:] ~\par
  \item[\texttt{--split}]: ~\par
    Split verification conditions into (equi-provable but smaller)
    pieces.
  \item[\texttt{--all-vc}]: ~\par
    Output \emph{all} verification conditions, that is no condition is
    automatically discharged.

  \item[Prover selection:] ~\par
  \item[\texttt{--coq}, \texttt{--pvs}, \texttt{--mizar}, 
        \texttt{--hol-light}, \texttt{--harvey}, \texttt{--simplify}]: ~\par 
    Select the prover; it defaults to \coq.

  \item[Coq-specific options:] ~\par
  \item[\texttt{--valid}, \texttt{--no-valid}]: ~\par
    Set/Unset the functional validation. Only meaningful with the
    \coq\ prover. When set, \why\ outputs a functional interpretation
    of each program (in a file \textit{f}\texttt{\_valid.v} for each
    input file \textit{f}\texttt{.}\textit{xxx}). Default is
    no validation.  
  \item[\texttt{--coq-tactic}] \textit{tactic} : ~\par
    Give a \coq\ tactic to be inserted as proof for new obligations.
  \item[\texttt{--coq-preamble}] \textit{text} : ~\par
    Give some \coq\ preamble to be substituted to \texttt{Require Why}
    when generating a \emph{new} \coq\ file.

  \item[PVS-specific options:] ~\par
  \item[\texttt{--pvs-preamble}] \textit{text} : ~\par
    Give some \pvs\ preamble to be substituted to \texttt{importing why@why}
    when generating a \emph{new} \pvs\ file.

  \item[Simplify-specific options:] ~\par
  \item[\texttt{--no-simplify-prelude}]: ~\par
    Suppress the \simplify\ prelude, that is the set of
    \texttt{BG\_PUSH}s defining \why's predicates and functions symbols.

  \item[Mizar-specific options:] ~\par
  \item[\texttt{--mizar-environ}] \textit{text} : ~\par
    Give the \mizar\ preamble to be used 
    when generating a \emph{new} \mizar\ file.
  \item[\texttt{--mizar-environ-from}] \textit{file} : ~\par
    Extract the \mizar\ preamble from \textit{file}, to be used
    when generating a \emph{new} \mizar\ file.

  \item[Caml code generation options:] ~\par
  \item[\texttt{--ocaml}]: ~\par 
    Select the \caml\ code generation. The code is produced on
    standard output, unless specified otherwise with option \texttt{--output}.
  \item[\texttt{--output}] \textit{file} : ~\par 
    Redirect the output to file \textit{file}.
  \item[\texttt{--ocaml-annot}]: ~\par 
    Decorate the \caml\ code with all annotations as comments. Default
    is no annotation.
  \item[\texttt{--ocaml-ext}]: ~\par 
    Make parameters from \texttt{external parameter} declarations.
    
\end{description}


\section{Library}
\label{library}\index{Library}

\subsection{Logic}
\label{lib:logic}

\subsubsection{Predefined functions}
\index{Function!predefined}

These are the functions predefined in \why:
\begin{description}
\item[\texttt{add\_int, sub\_int, mul\_int, div\_int, mod\_int :
    int,int -> int}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and \texttt{\%}.
\item[\texttt{neg\_int : int -> int}] ~\par
  Corresponds to the prefix symbol \texttt{-}.
\item[\texttt{add\_real, sub\_real, mul\_real, div\_real :
    real,real -> real}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}.
\item[\texttt{neg\_real, sqrt\_real : real -> real}] ~\par
  \texttt{neg\_real} corresponds to the prefix symbol \texttt{-}.
\item[\texttt{real\_of\_int : int -> real}] ~\par
  Conversion of an integer into a real number.
\item[\texttt{array\_length : $\alpha$ array -> int}] ~\par
  The size of an array.
\end{description}

\subsubsection{Predefined predicates}
\index{Predicate!predefined}

These are the predicates predefined in \why:
\begin{description}
\item[\texttt{lt\_int, le\_int, gt\_int, ge\_int, eq\_int, neq\_int :
    int, int -> prop}] ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{lt\_real, le\_real, gt\_real, ge\_real, eq\_real,
    neq\_real :}] ~\par
  \texttt{real, real -> prop} ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{eq\_bool, neq\_bool : bool, bool -> prop}] ~\par
  Correspond to the infix symbols \texttt{=} and \texttt{<>}.

\item[\texttt{eq\_unit, neq\_unit : unit, unit -> prop}] ~\par
  Correspond to the infix symbols \texttt{=} and \texttt{<>}.

\item[\texttt{sorted\_array : int array, int, int -> prop}] ~\par
  \indextt{sorted\_array}
  \texttt{sorted\_array($t$,$i$,$j$)} states that the sub-array
  $t[i..j]$ is sorted (in increasing order).

\item[\texttt{exchange : int array, int array, int, int -> prop}] ~\par
  \indextt{exchange}
  \texttt{exchange($t_1$,$t_2$,$i$,$j$)} states that arrays $t_1$ and
  $t_2$ differ only by the swapping of the two elements at indexes $i$
  and $j$.

\item[\texttt{sub\_permut : int, int, int array, int array -> prop}] ~\par
  \indextt{sub\_permut}
  \texttt{sub\_permut($i$,$j$,$t_1$,$t_2$)} states that the sub-arrays
  $t_1[i..j]$ and $t_2[i..j]$ are permutations of each other, the
  other parts of these arrays being the same.

\item[\texttt{permut : int array, int array -> prop}] ~\par
  \indextt{permut}
  \texttt{permut($t_1$,$t_2$)} states that the two arrays $t_1$ and
  $t_2$ are permutations of each other.

\item[\texttt{array\_id : int array, int array, int, int -> prop}] ~\par
  \indextt{array\_id}
  \texttt{array\_id($t_1$,$t_2$,i,j)} states that the two sub-arrays 
  $t_1[i..j]$ and $t_2[i..j]$ are identical.
\end{description}

\subsection{Coq}
\label{lib:coq}\index{Coq library}

Several \coq\ modules are delivered with \why. If installation is
properly done, they should be found in subdirectory \texttt{user-contrib}
of the \coq\ standard library (usually \texttt{/usr/lib/coq}
unless some other path was specified when installing \coq). 

% \coq\ files generated by \why\ usually start with \texttt{Require Why}
% (unless specified otherwise using command line option
% \texttt{--coq-preamble}). For this module to be found by \coq, the
% \coq\ load path must be set accordingly, either using the \coq\ command
% line option \texttt{-I} or the \coq\ command \texttt{Add LoadPath} (to
% be put in a \texttt{.coqrc} file for instance).

\paragraph{Types.} 
Types are mapped as follows:
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    \why & \coq \\
    \hline
    \texttt{unit} & \texttt{unit} \\
    \hline
    \texttt{bool} & \texttt{bool} \\
    \hline
    \texttt{int} & \texttt{Z} \\
    \hline
    \texttt{real} & \texttt{R} \\
    \hline
    $\tau$ \texttt{array} & \texttt{(array $\tau$)},
                            from module \texttt{WhyArrays} \\
    \hline
  \end{tabular}
\end{center}

\paragraph{Arrays.} 
Arrays are defined in module \texttt{WhyArrays}. Actually, they are
mainly axiomatized; only the length is really represented.
There are three axioms about arrays:
\begin{displaymath}
  \begin{array}{rl}
    (\te{new\_def}) &
    0 \le i < n \Rightarrow (\te{access} ~ (\te{new} ~ n ~ v_0) ~ i) = v_0 
    \\[1em]
    (\te{store\_def\_1}) &
    0 \le i < (\te{array\_length} ~ t) \Rightarrow
                    (\te{access} ~ (\te{store} ~ t ~ i ~ v) ~ i) = v
    \\[1em]
    (\te{store\_def\_2}) &
    0 \le i < (\te{array\_length} ~ t) \Rightarrow
    0 \le j < (\te{array\_length} ~ t) \Rightarrow \\ &
                    i \not= j \Rightarrow
                    (\te{access} ~ (\te{store} ~ t ~ i ~ v) ~ j) =
                    (\te{access} ~ t ~ j)
  \end{array}
\end{displaymath}
and one equality which is provable by convertibility:
\begin{displaymath}
  (\te{array\_length} ~ (\te{store} ~ t ~ i ~ v)) \equiv
  (\te{array\_length} ~ t)
\end{displaymath}

Some tactics are provided to help the user simplifying array expressions
in proof obligations:
\begin{description}
\item[\texttt{WhyArrays}] : repeatedly simplifies using
  \texttt{store\_def\_1} and \texttt{array\_length}
\item[\texttt{AccessSame}] : rewrites using \texttt{store\_def\_1},
  simplifies with \texttt{WhyArrays} and attempts \texttt{Omega} on
  every subgoal
\item[\texttt{AccessOther}] : rewrites using \texttt{store\_def\_2},
  simplifies with \texttt{WhyArrays} and attempts \texttt{Omega} on
  every subgoal
\item[\texttt{ArraySubst} $t$] : similar to \texttt{Subst $t$}, with
  additional simplifications
\end{description}

The following table indicates in which \coq\ modules the predicates
introduced in Section~\ref{lib:logic} are defined. See these modules
to get the associated lemmas.
\begin{center}
  \begin{tabular}{rl}
    \tt WhyPermut: & \tt exchange, sub\_permut, permut, array\_id \\
    \tt WhySorted: & \tt sorted\_array
  \end{tabular}
\end{center}


\subsection{PVS}
\label{lib:pvs}\index{PVS library}

\paragraph{Types.} 
Types are mapped as follows:
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    \why & \coq \\
    \hline
    \texttt{unit} & \texttt{unit}, from theory \texttt{why} \\
    \hline
    \texttt{bool} & \texttt{bool} \\
    \hline
    \texttt{int} & \texttt{int} \\
    \hline
    \texttt{real} & \texttt{real} \\
    \hline
    $\tau$ \texttt{array} & \texttt{warray[$\tau$]},
                            from theory \texttt{why} \\
    \hline
  \end{tabular}
\end{center}

\paragraph{Arrays.} An array whose elements are of type \texttt{T} is a
\pvs\ value of type \texttt{warray[T]}. This type is defined in the
theory \texttt{why\_arrays}, as
a pair of an integer, the array length, and a function mapping
indices to elements :
\begin{verbatim}
     warray: TYPE = [ n:int, [ below(n) -> T ] ]
\end{verbatim}
Two other theories, \texttt{why\_int\_array\_pred} and
\texttt{why\_array\_pred}, introduce the various predicates over
arrays presented in Section~\ref{lib:logic}.


\section{Logic syntax}
\label{syntax:logic}\index{Logic!syntax}


\subsection{Lexical conventions}
\label{lexical:logic}\index{Lexical conventions!logic}

Lexical conventions are the same as \caml's. 

\paragraph{Comments.} Comments are opened with \texttt{(*}, closed
with \texttt{*)} and can be nested.

\paragraph{Identifiers.} Identifiers are made of letters, digits,
the underscore character \texttt{\_} and the single quote \texttt{'},
starting with a letter. Additionally, they can be qualified by a
label (another identifier), using the \texttt{@} notation.

\begin{center}
\begin{tabular}{lrl}
  \nt{identifier}\indexnt{identifier}
    & $::=$ & \nt{letter} (\nt{letter} $|$ \te{0}..\te{9} $|$
              \te{\_} $|$ \te{'})\etoile
  \\[0.1em]
  \nt{letter}
    & $::=$ & \te{A}..\te{Z} $|$ \te{a}..\te{z}
  \\[0.1em]
  \nt{lab\_identifier}\indexnt{lab\_identifier}
    & $::=$ & \nt{identifier} [ \te{@} \nt{identifier} ]
\end{tabular}
\end{center}


\paragraph{Keywords.}

Keywords of the logic are:
\begin{center}
{\tt\begin{tabular}{l@{\qquad}l@{\qquad}l}
and & bool & else \\
exists & false & real \\
forall & if & int  \\
not & or & then  \\
true & unit & void
\end{tabular}}
\end{center}


\subsection{Terms}
\label{syntax:terms}\index{Term!syntax}

Syntax of terms is given in Figure~\ref{fig:terms}.
Arithmetical operations have usual precedences and are left associative.

The conditional construct \texttt{if $t_1$ then $t_2$ else $t_3$} can
be written in prefix notation as \texttt{if\_then\_else($t_1$, $t_2$,
  $t_3$)}. $t_1$ must have type \texttt{bool}, and $t_2$ and $t_3$ must
have the same type.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} \\
      & $|$ & \nt{lab\_identifier} \\
      & $|$ & \nt{lab\_identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{lab\_identifier} \te{[} \nt{term} \te{]} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{term} \te{else} \nt{term} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{real-constant} \\
      & $|$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \te{void} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%}
\end{tabular}\\
\hrulefill
\caption{Syntax of terms}
\label{fig:terms}
\end{center}            
\end{figure}


\subsection{Predicates}
\label{syntax:predicates}\index{Predicate!syntax}

Syntax of predicates is given in Figure~\ref{fig:predicates}.
It is a first-order quantifier-free syntax, independent from the \coq\
and the \pvs\ ones.

Precedences are the following (from strongest to weakest): \te{not}, 
\te{and}, \te{or}, implication, and \te{forall}. 
Implication, conjunction and disjunction are right associative.

In the conditional construct \texttt{if $t$ then $p$ else $q$} the
term $t$ must have type \texttt{bool}.

Primitive types (non terminal \nt{primitive\_type}) are defined in
Figure~\ref{fig:types}. 

Syntactic sugar: $t_1 ~ R_1 ~ t_2 ~ R_2 ~ t_3$ is equivalent to
$t_1 ~ R_1 ~ t_2 ~ \texttt{and} ~ t_2 ~ R_2 ~ t_3$ for any relations
$R_1$ and $R_2$. Example: \texttt{0 <= x < y}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{predicate}\indexnt{predicate}
    & $::=$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{<->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{or} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{and} \nt{predicate} \\
      & $|$ & \te{not} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \te{forall} \nt{identifier} \te{:} \nt{primitive\_type}
              \te{.} \nt{predicate} \\
      & $|$ & \te{exists} \nt{identifier} \te{:} \nt{primitive\_type}
              \te{.} \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of predicates}
\label{fig:predicates}
\end{center}            
\end{figure}


\section{Syntax}
\label{syntax}\index{Program!syntax}

\subsection{Lexical conventions}
\label{lexical}\index{Lexical conventions}

Lexical conventions are the same as for logic (see
Section~\ref{lexical:logic} on page~\pageref{lexical:logic}).
The set of keywords is now:
\begin{center}
{\tt\begin{tabular}{l@{\qquad}l@{\qquad}l@{\qquad}l@{\qquad}l}
absurd & and & array & as & assert  \\
begin & bool & do & done & else  \\
end & exception & exists & external & false  \\
real & for & forall & fun & if  \\
in & int & invariant & label & let  \\
logic & not & of & or & parameter \\
prop & raise & raises & reads \\
rec & ref & returns & then & true \\
try & unit & variant & void & while \\
with & writes
\end{tabular}}
\end{center}

\subsection{Types}
\label{syntax:types}\index{Type!syntax}

Syntax of types is given in Figure~\ref{fig:types}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{simple\_value\_type}\indexnt{simple\_value\_type}
    & $::=$ & \nt{primitive\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{ref} \\
      & $|$ & \nt{simple\_value\_type} \te{array} \\
      & $|$ & \te{(} \nt{value\_type} \te{)} \\
  \\[0.1em]

  \nt{value\_type}\indexnt{value\_type}
    & $::=$ & \nt{simple\_value\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{->} \nt{computation\_type} \\
      & $|$ & \nt{identifier} \te{:} \nt{simple\_value\_type} 
              \te{->} \nt{computation\_type} \\
  \\[0.1em]

  \nt{computation\_type}\indexnt{computation\_type}
    & $::=$ & \te{\{} $[$ \nt{precondition} $]$ \te{\}} \\
      &     & $[$ \te{returns} \nt{identifier} \te{:} $]$ \nt{value\_type}
              \nt{effects} \\
      &     & \te{\{} $[$ \nt{postcondition} $]$ \te{\}} \\
      & $|$ & \nt{value\_type} \\
  \\[0.1em]

  \nt{effects}
    & $::=$ & $[$ \te{reads} \nt{identifier}\etoilesep{\te{,}} $]$
              $[$ \te{writes}  \nt{identifier}\etoilesep{\te{,}}  $]$ 
              $[$ \te{raises}  \nt{identifier}\etoilesep{\te{,}}  $]$ \\
  \\[0.1em]

  \nt{primitive\_type}\indexnt{primitive\_type}
    & $::=$ & \te{int} $|$ \te{bool} $|$ \te{real} $|$ 
              \te{unit} $|$ \nt{identifier} $|$ \te{'} \nt{identifier} \\
    & $|$ & \nt{primitive\_type} \nt{identifier} $|$ \te{(}
    \nt{primitive\_type}\etoilesep{\te{,}} \te{)} \nt{identifier} \\
  \\[0.1em]

  \nt{precondition}\indexnt{precondition}
    & $::=$ & \nt{assertion} \\
  \\[0.1em]

  \nt{postcondition}\indexnt{postcondition}
    & $::=$ & \nt{assertion} \nt{exn\_condition}\etoile \\
  \\[0.1em]

  \nt{exn\_condition} 
    & $::=$ & \te{|} \nt{identifier} \te{=>} \nt{assertion} \\
  \\[0.1em]

  \nt{assertion} 
    & $::=$ & \nt{predicate} $[$ \te{as} \nt{identifier} $]$ \\
\end{tabular}\\
\hrulefill
\caption{Syntax of types}
\label{fig:types}
\end{center}            
\end{figure}


\subsection{Expressions}
\label{syntax:expr}\index{Expression!syntax}

Syntax of annotated programs is given in Figure~\ref{fig:caml}.
\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{prog}\indexnt{prog}
    & $::=$ & \te{\{} $[$ \nt{precondition} $]$ \te{\}}
              \nt{prog} 
              \te{\{} $[$ \nt{postcondition} $]$ \te{\}} \\
      & $|$ & \nt{constant} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \te{!} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{:=} \nt{prog} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \te{:=} \nt{prog} \\
      & $|$ & \nt{prog} \nt{infix} \nt{prog} \\
      & $|$ & \nt{prefix} \nt{prog} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \te{ref} 
              \nt{prog} \te{in} \nt{prog} \\
      & $|$ & \te{if} \nt{prog} \te{then} \nt{prog}
              $[$ \te{else} \nt{prog} $]$ \\
      & $|$ & \te{while} \nt{prog} \te{do}
              \nt{loop\_annot} \nt{block} \te{done} \\
      & $|$ & \te{begin} \nt{block} \te{end} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \nt{prog} 
              \te{in} \nt{prog} \\
      & $|$ & \te{fun} \nt{binders} \te{->} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} $[$ \te{in} \nt{prog} $]$ \\
      & $|$ & \te{raise} \nt{identifier} $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{raise} \te{(} \nt{identifier} \nt{prog} \te{)}
              $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{try} \nt{prog} \te{with} 
              \nt{handler}\plussep{\te{|}} \te{end} \\
      & $|$ & \te{absurd} $[$ \te{:} \nt{value\_type} $]$ \\ \indextt{absurd}
      & $|$ & \te{(} \nt{prog}\plus\  \te{)} \\
  \\[0.1em]

  \nt{block}\indexnt{block}
    & $::=$ & \nt{block\_statement}\plussep{\te{;}} \\
  \\[0.1em]

  \nt{block\_statement}
    & $::=$ & \nt{prog} \\
      & $|$ & \te{label} \nt{identifier} \\ \indextt{label}
      & $|$ & \te{assert} \te{\{} \nt{assertion} \te{\}} \\ \indextt{assert}
  \\[0.1em]
 
  \nt{infix}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%} $|$ 
              \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=} $|$
              \te{||} $|$ \te{\&\&} \\
  \nt{prefix}
    & $::=$ & \te{-} $|$ \te{not} \\
  \\[0.1em]

  \nt{binders}\indexnt{binders}
    & $::=$ & \te{(} \nt{identifier}\plussep{\te{,}} \te{:}
              \nt{value\_type} \te{)}\plus \\
  \\[0.1em]

  \nt{recfun}
    & $::=$ & \nt{identifier} \nt{binders} \te{:}
              value\_type \\
      &     & \te{\{} \te{variant} \nt{wf\_arg} \te{\}}
              \te{=} \nt{prog} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{\{} \te{invariant} \nt{assertion} 
              \te{variant} \nt{wf\_arg} \te{\}} \\
  \\[0.1em]

  \nt{wf\_arg} 
    & $::=$ & \nt{term} $[$ \te{for} \nt{identifier} $]$ \\

  \\[0.1em]

  \nt{handler}\indexnt{handler}
    & $::=$ & \nt{identifier} \te{->} \nt{prog} \\
      & $|$ & \nt{identifier} \nt{identifier} \te{->} \nt{prog} \\
  
\end{tabular}\\
\hrulefill
\caption{Syntax of annotated programs}
\label{fig:caml}
\end{center}
\end{figure}


\subsection{Files}
\label{syntax:files}\index{File!syntax}

Syntax of input files is given in Figure~\ref{fig:input}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{file}
    & $::=$ & \nt{declaration}\etoile\ \\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \te{let} \nt{identifier} $[$ \nt{binders} $]$ \te{=} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} \\
      & $|$ & $[$ \te{external} $]$ 
              \te{parameter} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\ \indextt{parameter}\indextt{external}
      & $|$ & \te{exception} \nt{identifier} 
              $[$ \te{of} \nt{primitive\_type} $]$ \\ \indextt{exception}
      & $|$ & $[$ \te{external} $]$ \te{logic} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{logic\_type} \\\indextt{logic} \indextt{external}
      & $|$ & \te{axiom} \nt{identifier} \te{:} \nt{predicate} \\
      & $|$ & \te{predicate} \nt{identifier}
              \te{(} \nt{logic\_binder}\etoilesep{\te{,}}
              \te{)} \te{=} \nt{predicate} \\ \indextt{predicate}
      & $|$ & \te{function} \nt{identifier}
              \te{(} \nt{logic\_binder}\etoilesep{\te{,}}
              \te{)} \te{:} \nt{primitive\_type} 
              \te{=} \nt{term} \\ \indextt{function}
   \\[0.1em]

  \nt{logic\_type}
    & $::=$ & \nt{logic\_arg\_type}\etoilesep{\te{,}} \te{->} \te{prop} 
              \\ \indextt{prop}
      & $|$ & \nt{logic\_arg\_type}\etoilesep{\te{,}} \te{->} 
              \nt{primitive\_type} \\ \indextt{logic}
   \\[0.1em]

  \nt{logic\_arg\_type}
    & $::=$ & \nt{primitive\_type} $|$ \nt{primitive\_type} \te{array} \\
   \\[0.1em]

   \nt{logic\_binder}
    & $::=$ & \nt{identifier} \te{:} \nt{primitive\_type} \\
\end{tabular}\\
\hrulefill
\caption{Syntax of files}
\label{fig:input}
\end{center}           
\end{figure}

\section{Predefined functions}

These are the functions predefined in \why:
\begin{description}
\item[\texttt{add\_int, sub\_int, mul\_int, div\_int, mod\_int : int
    -> int -> int}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and \texttt{\%}.

\item[\texttt{neg\_int : int -> int}] ~\par
  Correponds to the prefix symbol \texttt{-}.

\item[\texttt{add\_real, sub\_real, mul\_real, div\_real,
    : real -> real -> real}] ~\par
  Correspond to the infix symbols
  \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}.

\item[\texttt{neg\_real, sqrt\_real : real -> real}] ~\par
  \texttt{neg\_real} correponds to the prefix symbol \texttt{-}.

\item[\texttt{real\_of\_int : int -> real}]

\item[\texttt{lt\_int : x:int -> y:int -> \{\} bool \{if result then x
    < y else x >= y\}}] ~\par
\item[\texttt{le\_int : x:int -> y:int -> \{\} bool \{if result then x
    <= y else x > y\}}] ~\par
\item[\texttt{gt\_int : x:int -> y:int -> \{\} bool \{if result then x
    > y else x <= y\}}] ~\par
\item[\texttt{ge\_int : x:int -> y:int -> \{\} bool \{if result then x
    >= y else x < y\}}] ~\par
\item[\texttt{eq\_int : x:int -> y:int -> \{\} bool \{if result then x
    = y else x <> y\}}] ~\par
\item[\texttt{neq\_int : x:int -> y:int -> \{\} bool \{if result then x
    <> y else x = y\}}] ~\par
  Correspond to the infix symbols \texttt{<}, \texttt{<=}, \texttt{>},
  \texttt{>=}, \texttt{=} and \texttt{<>}.

\item[\texttt{lt\_real, le\_real, gt\_real, ge\_real, eq\_real,
    neq\_real}] ~\par
  As for integers.

\item[\texttt{eq\_bool, neq\_bool, eq\_unit, neq\_unit}] ~\par
  As for integers.

\end{description}


\section{Semantics}
\label{semantics}\index{Program!semantics}

Semantics of ML programs conforms to \caml's one.
More precisely, it obeys the following rules:
\begin{itemize}
\item 
  Logical connective \texttt{\&\&} and \texttt{||} are lazy and
  evaluated from left to right: in $e_1$ \texttt{\&\&} $e_2$, $e_1$ is
  evaluated first and, if \texttt{true}, then $e_2$ is evaluated; in
  $e_1$ \texttt{||} $e_2$, $e_1$ is evaluated first and, if
  \texttt{false}, then $e_2$ is evaluated.
  Stated otherwise, the following identities hold:
  \begin{displaymath}
    \begin{array}{rcl}
      e_1 ~ \te{\&\&} ~ e_2 & \approx & 
      \te{if} ~ e_1 ~ \te{then} ~ e_2 ~ \te{else false} \\[0.5em]
      e_1 ~ \te{||} ~ e_2 & \approx & 
      \te{if} ~ e_1 ~ \te{then true else} ~ e_2
    \end{array}
  \end{displaymath}
\item
  In a function call, the argument is evaluated first, then the
  function; consequently multiple arguments are evaluated from right
  to left. This applies to all infix operators, except
  \texttt{\&\&} and \texttt{||}.
\item
  In array assignment $t$\texttt{[}$e_2$\texttt{] :=} $e_1$,
  expression $e_1$ is evaluated first, then expression $e_2$.
\end{itemize}



\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}


\newpage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
