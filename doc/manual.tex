\documentclass[a4paper,12pt]{report}

\usepackage{fullpage}
\usepackage{url}
\usepackage{makeidx}

\newcommand{\caml}{\textsf{Caml}}
\newcommand{\pvs}{\textsf{PVS}}
\newcommand{\coq}{\textsf{Coq}}
\newcommand{\why}{\textsf{Why}}
\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\indexnt}[1]{\index{#1@\textsl{#1}, grammar entry}}
\newcommand{\indextt}[1]{\index{#1@\texttt{#1}}}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\caveat}{\paragraph{Caveat.}}
\newcommand{\caveats}{\paragraph{Caveats.}}

\makeindex

\begin{document}

%%% coverpage
\thispagestyle{empty}
\begin{center}
~\\[3cm]
\rule\textwidth{0.1cm}\\[0.5cm]
{\Huge\sf The WHY certification tool}\\[1cm]
{\Large\sf Tutorial and Reference Manual}\\[0.1cm]
\rule\textwidth{0.1cm}\\[3cm]
Jean-Christophe Filli\^atre
\vfill
\today\\
\end{center}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter*{Foreword}
% \addcontentsline{toc}{chapter}{Foreword}

% \why\ is a certification tool.
% It generates proof obligations from annotated programs.

% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}
\label{tutorial}


\section{Principles}

\why\ acts as a compiler. It takes annotated programs as input and
generates proof obligations as output.
Currently, the input syntax is a dialect of ML (with a syntax close to
\caml's, with annotations on top),
and the output is a \pvs\ theory or a \coq\ file.

If the input file is \texttt{foo.ml}, \why\ is simply invoked as
\begin{verbatim}
     why foo.ml
\end{verbatim}
and a \coq\ module \texttt{foo\_why.v} is (re)generated.
Similarly, invoking \why\ as
\begin{verbatim}
     why --pvs foo.ml
\end{verbatim}
(re)generates a \pvs\ theory \texttt{foo\_why.pvs}.
% Section~\ref{usage} details the various command line options.

The generated \coq\ file can be edited. When regenerated by \why,
edited parts are kept. Only proof obligations are erased or
overwritten. A backup of the old file is also made automatically.

Contrary to the \coq\ file, the \pvs\ file must not be
edited. Instead, the \texttt{pvs} declaration must be used in the
input file (see below).


\section{Input files}

The input file contains the following kinds of declaration:
\begin{itemize}
  \item\indextt{let}
    \texttt{let} $x$ \texttt{=} \textsl{annotated-program} \par
    Declares a program expression, with name $x$.
    The program is typed, added to the context and proof obligations
    are generated. 
    Examples:
\begin{verbatim}
     let c = 1+2
     let f = fun (x:int ref) -> x := !x + c
\end{verbatim}
    Such programs cannot be of mutable types (i.e. references or arrays).

  \item\indextt{parameter}
    \te{parameter} $x_1,\dots,x_n: \tau$ \par
    Declares some parameters for the whole development. They will be
    turned into axioms on the prover part (when not mutable).
    Examples:
\begin{verbatim}
     parameter x,y : int ref
     parameter N : int
     parameter t : array N of int
\end{verbatim}
    (Types are detailed in Section~\ref{types} and their syntax is
    given in Section~\ref{syntax:mltypes}.)

  \item\indextt{external}
    \te{external} $x_1,\dots,x_n: \tau$ \par 
    Declares some external values of type $\tau$, 
    used in the programs but defined on the prover part.
    Examples:
\begin{verbatim}
     external mean : int -> int -> int
     external diff : a:int -> b:int -> { b >= 0 } int { a = b + result }
\end{verbatim}
    External values cannot be mutable.

    Note that material to be used only in specifications must be introduced
    using the \te{pvs} declaration---when the \pvs\ 
    prover is used---or directly into the generated \coq\ module---when
    the \coq\ prover is used.

  \item\indextt{exception}
    \te{exception} $E$ $[$ \te{of} $\tau$ $]$

    Declares a new exception $E$, possibly with an argument of type $\tau$.

  \item\indextt{pvs}
    \te{pvs "}\textit{any \pvs\ material}\te{"} \par
    Copies the \pvs\ material as-is in the output theory.
\end{itemize}


\section{Annotations}
\label{annotations}\index{Annotation}

Annotations are inserted into the program to give its specification.
Annotations are written in a first-order predicate calculus syntax
which is not related to \pvs\ or \coq\ syntax. This syntax is given in
Section~\ref{syntax:logic}. 

Annotations are predicates over the values of the variables
visible at the corresponding program point.
Any annotation may refer to the value of a variable.  For a mutable
variable \texttt{x} (i.e. a reference or an array), \texttt{x} always 
denotes the \emph{current} value of \texttt{x}.

\subsection{Pre/postconditions}\index{Precondition}\index{Postcondition}
Pre- and postconditions are written using the traditional Hoare logic
syntax 
\begin{center}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
  \textsl{expression}
  \texttt{\{} \textsl{predicate} \texttt{\}} 
\end{center}
Any subexpression may be given a pre- and/or a postcondition. Both can be
omitted, independently and at any place.
Within a postcondition, the value of a reference \texttt{x} before the
evaluation (i.e. at the precondition point) is referred to as \texttt{x@}.
Examples:
\begin{verbatim}
     begin x := !x + 1 end { x > x@ }
     { x > 0 } begin x := 2 * !x; x := !x - 1 end { x > 0 }
\end{verbatim}
In the postcondition, the result of the expression is bound to the
variable \texttt{result}. \indextt{result} 
Examples:
\begin{verbatim}
     (1 + 2) { result = 3 }
     begin x := !x + 1; !x end { result <> x@ }
\end{verbatim}

\caveat\ Pre- and postcondition apply to the \emph{closest
subexpression}. Thus, in
\begin{verbatim}
     x := !x + 1 { x = x@ + 1 }
\end{verbatim}
the postcondition \texttt{x = x@ + 1} applies to the expression
\texttt{1}, leading to the unprovable obligation $x=x+1$. Therefore,
the above piece of code should be written instead
\begin{verbatim}
     (x := !x + 1) { x = x@ + 1 }
\end{verbatim}
or even better
\begin{verbatim}
     begin x := !x + 1 end { x = x@ + 1 }
\end{verbatim}


\subsection{Assertions}
\index{Assertion}
Assertions are inserted within sequences using the \texttt{assert}
keyword. Example:
\begin{verbatim}
     begin 
       x := 2 * !x;
       assert { even(x) };
       x := !x - 1
     end
\end{verbatim}
Assertions are not taken into consideration when computing weakest
preconditions, but may help handling the proofs by introducing cuts.


\subsection{Loops annotations}
\index{Loop}\index{Invariant}\index{Variant}\indextt{while}
Loops can (and usually must) be given invariants and must always be
given variants. Both are introduced as a single annotation following
the \texttt{do} keyword:
\begin{center}
  \texttt{while} \textsl{expression} \texttt{do \{ invariant}
  \emph{predicate} \texttt{variant} 
  \textsl{term} \texttt{\}} \textsl{sequence} \texttt{done}
\end{center}
Examples:
\begin{verbatim}
     while !x > 0 do { invariant x >= 0 variant x } x := !x - 1 done

     while !x < 10 do { invariant x <= 10 variant 10-x } x := !x + 1 done
\end{verbatim}
Variants can be of any type and can be associated to any order
relation (see syntax in Section~\ref{syntax:ml}). When not specified,
the type \texttt{int} and the usual order relation over non negative
integers are assumed.


\subsection{Recursive functions}
\index{Recursive function}
Recursive functions are annotated with the result type and a variant.
For instance, the famous Mac Carthy's 91 function is written:
\begin{verbatim}
     let rec f91 (n:int) : int { variant max(0,101-n) } =
       (if n <= 100 then
          (f91 (f91 (n + 11)))
        else
          n - 10)
       { (n <= 100 and result = 91) or (n >= 101 and result = n - 10) }
\end{verbatim}
Variants are similar to the ones annotating loops.

\subsection{Labels}
\index{Label}
Labels may be inserted within sequences using the 
\te{label} keyword and the value of a reference \texttt{x} at the
program point labelled \texttt{L} is then referred to as \texttt{x@L}.
Example:
\begin{verbatim}
     begin 
       x := y;
       label L; 
       begin x := !x + 1 end { x > x@L }
     end
\end{verbatim}
The visibility of a label is the same as a local variable's one. In
the code above, label \texttt{L} is not visible outside of the
outermost sequence.

\indextt{init}
A particular label \texttt{init} is automatically inserted at the
beginning of the program, so that the initial value of \texttt{x}
can always be referred to as \texttt{x@init}. 
Example:
\begin{verbatim}
     while !x > 0 do 
       { invariant 0 <= x <= x@init  variant x } 
       x := !x - 1 
     done
\end{verbatim}

Labels provide an alternative to the traditional use of
\emph{auxiliary variables}\index{Auxiliary variable}. Indeed, they
allow you to relate the values of references at any points of the
program. 


\section{Types with effect}
\label{types}\index{Type}

Program expressions are given types including side-effects and
specification. Such a type is either inferred by \why\ (for each
\texttt{let} declaration), or given by the user (in an
\texttt{external} or a \texttt{parameter} declaration).

Types syntax follows ML types syntax, with additional information for
side-effects and pre/postconditions. Here are examples of simple types,
i.e. without annotations:
\begin{verbatim}
     int
     int -> int
     int -> int ref -> unit
\end{verbatim}
Pre/postconditions are added with a syntax similar to the one of
programs annotations, and arguments may be given names when needed:
\begin{verbatim}
     x:int -> y:int -> { } int { result = x + y }
\end{verbatim}
Side effects must be explicited beside the result type:
\indextt{reads}\indextt{writes}\indextt{raises}%
\begin{verbatim}
     unit -> { x >= 0 } unit writes x { x < x@ }
     a:int ref -> b:int ref -> { } unit reads b writes a { a = a@ + b }
     n:int -> { } int raises Negative { result = sqrt(n) }
\end{verbatim}
Finally, the result may be given a name other than \texttt{result},
with the following syntax:
\begin{verbatim}
     x:int -> y:int -> { } returns z:int { z = x + y }
\end{verbatim}
Section~\ref{syntax:mltypes} gives the syntax of types.


\section{Weakest preconditions}
\label{wp}\index{Weakest precondition}
To achieve completeness, annotations are propagated inside
subexpression using a calculus of weakest preconditions.
However, this mechanism does not propagate an annotation inside an
expression which already has a postcondition. Instead, it propagates
inside the expression its own postcondition. As a result, an
expression with a postcondition appears as a \emph{black box} from the
outside. 

Example: in the following program
\begin{verbatim}
     begin x := 1; (x := !x + 1) { x = 2 }; x := !x + 1 end { x = 3 }
\end{verbatim}
the final postcondition \texttt{x = 3} is propagated through the third
assignment, but then stops at the postcondition \texttt{x = 2};
instead \texttt{x = 2} is propagated through the second
assignment. So we get two proof obligations, which are
\begin{displaymath}
  x=1 \Rightarrow x+1=2 
  \qquad\mbox{and}\qquad
  x=2 \Rightarrow x+1=3
\end{displaymath}
Any program establishing \texttt{x = 2} can be substituted to the
second assignment without changing the second obligation.


\section{Restrictions with respect to ML}
The input language is close to (some fragment of) \caml. However,
there are some---more or less significant---differences:
\begin{itemize}
\item There is \textit{no type inference}; binders are explicitly
  typed. 
\item The use of references is constrained: when dereferenced, updated
  or passed to a function, a reference must be a variable. Thus one
  cannot write
\begin{verbatim}
     (if b then x else y) := 1
\end{verbatim}
as in ML, but one must write instead
\begin{verbatim}
     if b then x := 1 else y := 1
\end{verbatim}
\item Array access is written \texttt{t[e]} instead of \texttt{t.(e)},
  and array update is written \texttt{t[e1] := e2} instead of
  \texttt{t.(e1) <- e2}.
\item Array types mention the array size (e.g. \texttt{array 10 of int}).
\end{itemize}


\section{Installation}
\label{install}\index{Installation}

To compile \why, you need both \textsf{Objective Caml} and
\textsf{Camlp4} to be installed, in version at least 3.01. Both can
be fetched from \url{http://caml.inria.fr}.
Then 

\begin{enumerate}
\item Configure with \texttt{./configure}

  The directory for binaries defaults to \texttt{/usr/local/bin}; you
  can specify another directory with the \texttt{-{}-bindir}
  option. Similarly, you can change the directory for man pages with
  \texttt{-{}-mandir}.

\item Compile with \texttt{make}

\item Install with \texttt{make install}

  (Alternatively, you can move/copy the \why\ executable
  \texttt{bin/why} anywhere, or make a symbolic link to it from anywhere.)
\end{enumerate}


\chapter{Full examples}
\label{examples}\index{Example}

This chapter details the examples delivered with \why\ in the
subdirectory \texttt{examples/} of the distribution.

\newcommand{\exsummary}[2]{%
  \begin{description}
  \item[Directory:] \url{#1}
  \item[Description:] #2
  \end{description}
}

\section{Binary Search}
\label{binarysearch}\index{Binary search}

\exsummary{binary-search}{Binary Search (divide-and-conquer search in
  a sorted array)}

TODO

\section{Bresenham's line drawing algorithm}
\label{bresenham}\index{Bresenham}

\exsummary{bresenham}{Bresenham's line drawing algorithm (proof of optimality)}

TODO

\section{Quicksort}
\label{quicksort}\index{Quicksort}

\exsummary{quicksort}{Quicksort (the famous divide-and-conquer sorting
  algorithm)}

TODO

\section{Heapsort}
\label{heapsort}\index{Heapsort}

\exsummary{heapsort}{Heapsort (in-place implementation)}

TODO

\section{Edit distance}
\label{editdistance}\index{Edit distance}

\exsummary{edit-distance}{Algorithm to compute the edit distance in
  linear space}

This program computes a variant of the Levenshtein distance. Given two
strings $w_1$ and $w_2$ of respective lengths $n_1$ and $n_2$, it
computes the minimal numbers of insertions and deletions to perform in
one of the strings to get the other one.  (The traditional edit
distance also includes substitutions.)

The nice point about this algorithm, due to Claude March\'e, is to work
in linear space, in an array of $\min(n_1,n_2)$ integers. Time
complexity is $O(n_1\times n_2)$, as usual.

Files are organized as follows:
\begin{description}
\item[\texttt{words.v}]: 
  Introduces an abstract type \texttt{A} for
  characters, defines distance between two lists of characters,
  defines suffixes of an array of characters and establishes several
  lemmas.  As a bonus, an alternative definition of distance is
  defined and proved equivalent with the first one.
\item[\texttt{distance.ml}]:
  The program and its specification.  
\end{description}


\chapter{Reference manual}
\label{refman}


\section{Command line options}
\label{usage}\index{Option, of the command line}

\why\ is invoked as a batch compiler, given a list of input files:
\begin{center}
  \texttt{why} [\textit{options}] \textit{file}$_1$\texttt{.ml} $\cdots$
    \textit{file}$_n$\texttt{.ml}
\end{center}
Each file \textit{file}\texttt{.ml} will be compiled into a \pvs\ theory
\textit{file}\texttt{\_why.pvs} or a \coq\ module
\textit{file}\texttt{\_why.v}.
If no file is given, then standard input is processed and a \pvs\ theory
named \texttt{WhyOutput} is printed on standard output.

Options are the following:
\begin{description}
  \item[Generic options:] ~\par
  \item[\texttt{--help}]: ~\par    
    Give usage and exit. 
  \item[\texttt{--verbose}]: ~\par 
    Verbose mode. In this mode, \why\ prints on error output
    information like the program being processed, the obligations
    being erased or overwritten, etc.
  \item[\texttt{--quiet}]: ~\par  
    Quiet mode (default).
  \item[\texttt{--debug}]: ~\par 
    Debugging mode. In this mode, \why\ details everything it does,
    printing a lot of material on error output. Not of use for the
    casual user.

  \item[Overall options:] ~\par
  \item[\texttt{--parse-only}]: ~\par  
    Stop after parsing.
  \item[\texttt{--type-only}]:  ~\par  
    Stop after typing.
  \item[\texttt{--wp-only}]:    ~\par  
    Stop after annotation.

  \item[Prover options:] ~\par
  \item[\texttt{--pvs}, \texttt{--coq}]: ~\par 
    Select the prover; it defaults to \coq.
  \item[\texttt{--valid}, \texttt{--no-valid}]: ~\par
    Set/Unset the functional validation. Only meaningful with the
    \coq\ prover. When set, \why\ outputs a functional interpretation
    of each program. Default is no validation. 
\end{description}


\section{Logic syntax}
\label{syntax:logic}\index{Logic!syntax}


\subsection{Terms}
\label{syntax:terms}\index{Term!syntax}

Syntax of terms is given in Figure~\ref{fig:terms}.
Usual precedences apply to arithmetical operations.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{term}\indexnt{term}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{term} \nt{arith\_op} \nt{term} \\
      & $|$ & \te{-} \nt{term} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{identifier} \te{[} \nt{term} \te{]} \\
      & $|$ & \te{(} \nt{term} \te{)} \\
  \\[0.1em]

  \nt{constant}\indexnt{constant}
    & $::=$ & \nt{integer-constant} \\
      & $|$ & \nt{floating-point-constant} \\
      & $|$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \te{void} \\
  \\[0.1em]

  \nt{arith\_op}\indexnt{arith\_op}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ \te{\%}
\end{tabular}\\
\hrulefill
\caption{Syntax of terms}
\label{fig:terms}
\end{center}            
\end{figure}


\subsection{Predicates}
\label{syntax:predicates}\index{Predicate!syntax}

Syntax of predicates is given in Figure~\ref{fig:predicates}.
It is a first-order quantifier-free syntax, independent from the \coq\
and the \pvs\ ones.

Precedences are the following (from strongest to weakest): \te{not}, 
\te{and}, \te{or}, implication, and \te{forall}. 
Implication is right associative.

Syntactic sugar: $t_1 ~ R_1 ~ t_2 ~ R_2 ~ t_3$ is equivalent to
$t_1 ~ R_1 ~ t_2 ~ \texttt{and} ~ t_2 ~ R_2 ~ t_3$ for any relations
$R_1$ and $R_2$. Example: \texttt{0 <= x < y}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{predicate}\indexnt{predicate}
    & $::=$ & \te{true} \\
      & $|$ & \te{false} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \nt{identifier} \te{(} \nt{term}\plussep{\te{,}} \te{)} \\
      & $|$ & \nt{term} \nt{relation} \nt{term} 
              $[$ \nt{relation} \nt{term} $]$ \\
      & $|$ & \nt{predicate} \te{->} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{or} \nt{predicate} \\
      & $|$ & \nt{predicate} \te{and} \nt{predicate} \\
      & $|$ & \te{not} \nt{predicate} \\
      & $|$ & \te{if} \nt{term} \te{then} \nt{predicate} 
              \te{else} \nt{predicate} \\
      & $|$ & \te{forall} \nt{identifier} \te{:} \nt{primitive\_type}
              \te{.} \nt{predicate} \\
      & $|$ & \te{(} \nt{predicate} \te{)} \\
  \\[0.1em]

  \nt{relation}\indexnt{relation}
    & $::=$ & \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=}
\end{tabular}\\
\hrulefill
\caption{Syntax of predicates}
\label{fig:predicates}
\end{center}            
\end{figure}


\section{Syntax of ML programs}
\label{syntax:ml}\index{ML program!syntax}

\subsection{ML types}
\label{syntax:mltypes}\index{ML type!syntax}

Syntax of types is given in Figure~\ref{fig:types}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{simple\_value\_type}\indexnt{simple\_value\_type}
    & $::=$ & \nt{primitive\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{ref} \\
      & $|$ & \te{array} \nt{term} \te{of} \nt{simple\_value\_type} \\
      & $|$ & \te{(} \nt{value\_type} \te{)} \\
  \\[0.1em]

  \nt{value\_type}\indexnt{value\_type}
    & $::=$ & \nt{simple\_value\_type} \\
      & $|$ & \nt{simple\_value\_type} \te{->} \nt{computation\_type} \\
      & $|$ & \nt{identifier} \te{:} \nt{simple\_value\_type} 
              \te{->} \nt{computation\_type} \\
  \\[0.1em]

  \nt{computation\_type}\indexnt{computation\_type}
    & $::=$ & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      &     & $[$ \te{returns} \nt{identifier} \te{:} $]$ \nt{value\_type} \\
      &     & $[$ \te{reads} \nt{identifier}\etoilesep{\te{,}} $]$
              $[$ \te{writes}  \nt{identifier}\etoilesep{\te{,}}  $]$ 
              $[$ \te{raises}  \nt{identifier}\etoilesep{\te{,}}  $]$ \\
      &     & \te{\{} $[$ \nt{predicate} $]$ \te{\}} \\
      & $|$ & \nt{value\_type} \\
  \\[0.1em]

  \nt{primitive\_type}\indexnt{primitive\_type}
    & $::=$ & \te{int} $|$ \te{bool} $|$ \te{float} $|$ 
              \te{unit} $|$ \nt{identifier}
\end{tabular}\\
\hrulefill
\caption{Syntax of types}
\label{fig:types}
\end{center}            
\end{figure}


\subsection{ML expressions}
\label{syntax:mlexpr}\index{ML expression!syntax}

Syntax of annotated ML programs is given in Figure~\ref{fig:caml}.
\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{prog}\indexnt{prog}
    & $::=$ & \te{\{} \nt{assertion} \te{\}}\etoile\
              \nt{statement} 
              $[$ \te{\{} \nt{assertion} \te{\}} $]$ \\
  \\[0.1em]

  \nt{statement}\indexnt{statement}
    & $::=$ & \nt{constant} \\
      & $|$ & \nt{identifier} \\
      & $|$ & \te{!} \nt{identifier} \\
      & $|$ & \nt{identifier} \te{:=} \nt{prog} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \\
      & $|$ & \nt{identifier} \te{[} \nt{prog} \te{]} \te{:=} \nt{prog} \\
      & $|$ & \nt{prog} \nt{infix} \nt{prog} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \te{ref} 
              \nt{prog} \te{in} \nt{prog} \\
      & $|$ & \te{if} \nt{prog} \te{then} \nt{prog}
              $[$ \te{else} \nt{prog} $]$ \\
      & $|$ & \te{while} \nt{prog} \te{do}
              \nt{loop\_annot} \nt{block} \te{done} \\
      & $|$ & \te{begin} \nt{block} \te{end} \\
      & $|$ & \te{let} \nt{identifier} \te{=} \nt{prog} 
              \te{in} \nt{prog} \\
      & $|$ & \te{fun} \nt{binders} \te{->} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} $[$ \te{in} \nt{prog} $]$ \\
      & $|$ & \te{raise} \nt{identifier} $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{raise} \te{(} \nt{identifier} \nt{prog} \te{)}
              $[$ \te{:} \nt{value\_type} $]$ \\
      & $|$ & \te{(} \nt{prog}\plus\  \te{)} \\
  \\[0.1em]

  \nt{block}
    & $::=$ & \nt{block\_statement}\plussep{\te{;}} \\
  \\[0.1em]

      \nt{block\_statement}
    & $::=$ & \nt{prog} \\
      & $|$ & \te{label} \nt{identifier} \\
      & $|$ & \te{assert} \te{\{} \nt{assertion} \te{\}} \\
  \\[0.1em]
 
  \nt{infix}
    & $::=$ & \te{+} $|$ \te{-} $|$ \te{*} $|$ \te{/} $|$ 
              \te{=} $|$ \te{<>} $|$ 
              \te{<} $|$ \te{<=} $|$ \te{>} $|$ \te{>=} $|$
              \te{||} $|$ \te{\&\&} \\
  \\[0.1em]

  \nt{binders}
    & $::=$ & \te{(} \nt{identifier}\plussep{\te{,}} \te{:}
              \nt{value\_type} \te{)}\plus \\
  \\[0.1em]

  \nt{recfun}
    & $::=$ & \nt{identifier} \nt{binders} \te{:}
              value\_type \\
      &     & \te{\{} \te{variant} \nt{wf\_arg} \te{\}}
              \te{=} \nt{prog} \\
  \\[0.1em]

  \nt{loop\_annot}
    & $::=$ & \te{\{} \te{invariant} \nt{assertion} 
              \te{variant} \nt{wf\_arg} \te{\}} \\
  \\[0.1em]

  \nt{wf\_arg} 
    & $::=$ & \nt{term} $[$ $[$ \te{:} \nt{primitive\_type} $]$
                            \te{for} \nt{term} $]$ \\
  \\[0.1em]

  \nt{assertion} 
    & $::=$ & \nt{predicate} $[$ \te{as} \nt{identifier} $]$ \\

\end{tabular}\\
\hrulefill
\caption{Syntax of annotated programs}
\label{fig:caml}
\end{center}
\end{figure}


\subsection{ML files}
\label{syntax:mlfiles}\index{ML file!syntax}

Syntax of input files is given in Figure~\ref{fig:input}.

\begin{figure}[htbp]
\begin{center}
\hrulefill\\
\begin{tabular}{lrl}
  \nt{file}
    & $::=$ & \nt{declaration}\etoile\
  \\[0.1em]

  \nt{declaration}
    & $::=$ & \te{let} \nt{identifier} \te{=} \nt{prog} \\
      & $|$ & \te{let} \te{rec} \nt{recfun} \\
      & $|$ & \te{parameter} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\ \indextt{parameter}
      & $|$ & \te{external} \nt{identifier}\plussep{\te{,}}
              \te{:} \nt{value\_type} \\ \indextt{external}
      & $|$ & \te{exception} \nt{identifier} 
              $[$ \te{of} \nt{primitive\_type} $]$ \\ \indextt{exception}
      & $|$ & \te{pvs} \nt{string}
\end{tabular}\\
\hrulefill
\caption{Syntax of input files}
\label{fig:input}
\end{center}           
\end{figure}


\printindex

\end{document}
