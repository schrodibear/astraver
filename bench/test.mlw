
include "arrays.why"

axiom good_array_length: forall t:'a farray.  array_length(t)>=0

logic array_create : int,'a -> 'a farray

parameter array_create_ : 
  s:int -> e:'a -> {0<=s} 'a farray { result=array_create(s,e) }

axiom array_create_length :
 forall t:int farray. forall s:int. forall e:'a. array_length(array_create(s,e))=s

axiom array_create_get :
 forall t:int farray. forall s:int. forall e:'a. forall i:int. access(array_create(s,e),i)=e


logic array_create_empty : 'a farray

parameter array_create_empty_ : 
  unit -> {} 'a farray { result=array_create_empty}

axiom array_create_empty_length : array_length(array_create_empty)=0



(*
OCaml :
let map f a =
  let l = length a in
  if l = 0 then [||] else begin
    let r = create l (f(unsafe_get a 0)) in
    for i = 1 to l - 1 do
      unsafe_set r i (f(unsafe_get a i))
    done;
    r
  end
*)

logic f:'a->'b

let map (tab: 'a array) =
 let size = (array_length_ tab) in
 if size=0 
  then array_create_empty 
 else
  let res=ref (array_create size (f tab[0])) in
  init:
   let i = ref 0 in 
   while !i < size do
    {
     invariant 
          0<=i<=size
      and (forall j:int. 0<=j<i -> res[j]=f(tab[j]))
      and (forall j:int. i<=j   -> res[j]=res@init[j])
     variant size - i
    }
    res[!i] := (f tab[!i])
   done;
   !res
   { (forall i:int. 0<=i<array_length(tab) -> result[i]=f(tab[i]))
     or array_length(result)=0 }
