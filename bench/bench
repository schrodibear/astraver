#!/bin/sh

# auto bench for why

pgm=$1
coqc="coqc -R ../lib/coq Coq.why"

goods () {
    for f in $1/*.mlw; do
	echo -n "  "$f"... "
	base=$1/`basename $f .mlw`
	if $pgm --coq $f > /dev/null 2>&1; then
	    echo -n "why ok... "
	    if $coqc "$base"_why.v > /dev/null 2>&1; then
		echo "coq ok"
#  		echo -n "coq ok..."
#  		$pgm --ocaml --ocaml-ext $f > $base.ml 2>/dev/null
#  		if ocamlc -c $base.ml > /dev/null 2>&1; then
#  		    echo "ocaml ok"
#  		else
#  		    echo "ocaml FAILED"
#  		fi
	    else
		echo "coq FAILED"
		$coqc "$base"_why.v
		exit 1
	    fi
	else 
	    echo "why FAILED"
	    $pgm --coq $f
	    exit 1
	fi
    done
}

goods_c () {
    for f in $1/*.c; do
	echo -n "  "$f"... "
	base=$1/`basename $f .c`
	if ! gcc -c $f > /dev/null 2>&1; then
	    echo "GCC failed"
	    gcc -c $f
	    exit 1
	fi
	echo -n "GCC ok... "
	if ! $pgm --coq $f > /dev/null 2>&1; then
	    echo "why FAILED"
	    $pgm --coq $f
	    exit 1
	fi
	echo -n "why ok... "
	if ! $coqc "$base"_why.v > /dev/null 2>&1; then
	    echo "coq FAILED"
	    $coqc "$base"_why.v
	    exit 1
	fi
	echo "coq ok"
    done
}

bads () {
    for f in $1/*.mlw; do
	echo -n "  "$f"... "
	if $pgm $2 $f > /dev/null 2>&1; then 
	    echo "$pgm $2 $f"
	    echo "FAILED!"
	    exit 1 
        else 
	    echo "ok"
	fi
    done
}

if test "$2" == "c"; then goods_c good-c; exit 0; fi

# 1. Syntax
echo "=== Checking parsing errors ==="
bads bad/syntax --parse-only
echo ""

# 2. Typing
echo "=== Checking typing errors ==="
bads bad/typing --type-only
echo ""

# 2. Other
echo "=== Checking other errors ==="
bads bad/other
echo ""

# 3. ML benchmark
echo "=== Checking good files ==="
goods good
echo ""

# 4. C benchmark
echo "=== Checking good C files ==="
goods_c good-c

exit 0

# Showing the results
for f in good/*.mlw; do
    coq=good/`basename $f .mlw`_why.v
    echo "==== "$coq" ===="
    cat $coq
    echo "==== "$f" ===="
    cat $f
    read foo
done

