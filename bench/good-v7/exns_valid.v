(* This file is generated by Why; do not edit *)

Require Why.
Require Export exns_why.

Definition p1 (* validation *)
  : (sig_1 (EM unit unit) [result: (EM unit unit)]
     (((qcomb [result: unit]True [result: unit]False) result)))
  := (exist_1 (qcomb [result: unit]True [result: unit]False) (Exn unit tt) I).

Definition p2 (* validation *)
  : (sig_1 (EM Z unit) [result: (EM Z unit)]
     (((qcomb [result: Z]`result = 1` [result: unit]False) result)))
  := let (result, Post1) = (exist_1 [result: Z]`result = 1` `1`
       (refl_equal ? `1`)) in
     (exist_1 (qcomb [result0: Z]`result0 = 1` [result0: unit]False) 
     (Exn unit result) Post1).

Definition p2a (* validation *)
  : (sig_1 (EM unit (EM Z unit)) [result: (EM unit (EM Z unit))]
     (((qcomb [result: unit]True (qcomb [result: Z]False [result: unit]False))
       result)))
  := let (result, Post1) =
       (exist_1 (qcomb [result: unit]True [result: Z]False) (Exn Z tt) I) in
     Cases (decomp1 Post1) of
     | (Qval (exist result0 Post2)) =>
       (exist_1 (qcomb [result0_0: unit]True
                 (qcomb [result0_0: Z]False [result0_0: unit]False)) 
       (Val unit (Exn unit result0)) (False_ind ? Post2))
     | (Qexn _ Post3) =>
       (exist_1 (qcomb [result0: unit]True
                 (qcomb [result0: Z]False [result0: unit]False)) (Exn
                                                                   (EM Z unit)
                                                                   tt) I)
     end.

Definition p3 (* validation *)
  : (sig_1 (EM Z unit) [result: (EM Z unit)]
     (((qcomb [result: Z]`result = 1` [result: unit]False) result)))
  := let (result, Post1) =
       let (result, Post2) = (exist_1 [result: Z]`result = 1` `1`
         (refl_equal ? `1`)) in
       (exist_1 (qcomb [result0: Z]`result0 = 1` [result0: unit]`2 = 1`) 
       (Exn unit result) Post2) in
     Cases (decomp1 Post1) of
     | (Qval (exist result0 WP2)) =>
       let (result0_0, Post4) =
         let (result0_0, Post5) = (exist_1 [result0_0: Z]`result0_0 = 1` 
           `2` WP2) in
         (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
         (Exn unit result0_0) Post5) in
       Cases (decomp1 Post4) of
       | (Qval (exist result0_1 Post6)) =>
         (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
         (Val Z result0_1) (False_ind ? Post6))
       | (Qexn result0_1 Post7) =>
         (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
         (Exn unit result0_1) Post7)
       end
     | (Qexn result0 Post3) =>
       (exist_1 (qcomb [result0_0: Z]`result0_0 = 1` [result0_0: unit]False) 
       (Exn unit result0) Post3)
     end.

Definition p4 (* validation *)
  : (sig_1 (EM Z unit) [result: (EM Z unit)]
     (((qcomb [result: Z]`result = 1` [result: unit]False) result)))
  := let (result, WP5) = (exist_1 [result: bool]
       (if result then `1 = 1` else `2 = 1`) true (refl_equal ? `1`)) in
     Cases
       (btest [result:bool](if result then `1 = 1` else `2 = 1`) result WP5) of
     | (left WP5_0) =>
         let (result0, Post6) =
           let (result0, Post7) = (exist_1 [result0: Z]`result0 = 1` 
             `1` (refl_equal ? `1`)) in
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Exn unit result0) Post7) in
         Cases (decomp1 Post6) of
         | (Qval (exist result0_0 Post8)) =>
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Val Z result0_0) (False_ind ? Post8))
         | (Qexn result0_0 Post9) =>
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Exn unit result0_0) Post9)
         end
     | (right WP5_0) =>
         let (result0, Post2) =
           let (result0, Post3) = (exist_1 [result0: Z]`result0 = 1` 
             `2` WP5_0) in
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Exn unit result0) Post3) in
         Cases (decomp1 Post2) of
         | (Qval (exist result0_0 Post4)) =>
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Val Z result0_0) (False_ind ? Post4))
         | (Qexn result0_0 Post5) =>
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Exn unit result0_0) Post5)
         end end.

Definition p5 (* validation *)
  : (sig_1 (EM unit (EM Z unit)) [result: (EM unit (EM Z unit))]
     (((qcomb [result: unit]False
        (qcomb [result: Z]`result = 1` [result: unit]False))
       result)))
  := let (result, Post2) =
       let (result, WP5) = (exist_1 [result: bool]
         (if result then `1 = 1` else False) true (refl_equal ? `1`)) in
       Cases
         (btest [result:bool](if result then `1 = 1` else False) result WP5) of
       | (left WP5_0) =>
           let (result0, Post3) =
             let (result0, Post4) = (exist_1 [result0: Z]`result0 = 1` 
               `1` (refl_equal ? `1`)) in
             (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
             (Exn unit result0) Post4) in
           Cases (decomp1 Post3) of
           | (Qval (exist result0_0 WP1)) =>
             (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
             (Val Z result0_0) (False_ind ? WP1))
           | (Qexn result0_0 Post5) =>
             (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
             (Exn unit result0_0) Post5)
           end
       | (right WP5_0) =>
           let (result0, WP1) = (exist_1 [result0: unit]False tt
             (False_ind ? WP5_0)) in
           (exist_1 (qcomb [result1: Z]`result1 = 1` [result1: unit]False) 
           (Val Z result0) (False_ind ? WP1)) end in
     Cases (decomp1 Post2) of
     | (Qval (exist result0 WP1)) =>
       let (result0_0, Post7) =
         (exist_1 (qcomb [result0_0: unit]False [result0_0: unit]False) 
         (Exn unit tt) (False_ind ? WP1)) in
       Cases (decomp1 Post7) of
       | (Qval (exist result0_1 Post8)) =>
         (exist_1 (qcomb [result1: unit]False
                   (qcomb [result1: Z]`result1 = 1` [result1: unit]False)) 
         (Val unit (Val Z result0_1)) (False_ind ? Post8))
       | (Qexn _ Post9) =>
         (exist_1 (qcomb [result1: unit]False
                   (qcomb [result1: Z]`result1 = 1` [result1: unit]False)) 
         (Exn (EM Z unit) tt) (False_ind ? Post9))
       end
     | (Qexn result0 Post6) =>
       (exist_1 (qcomb [result0_0: unit]False
                 (qcomb [result0_0: Z]`result0_0 = 1` [result0_0: unit]False)) 
       (Val unit (Exn unit result0)) Post6)
     end.

Definition p6 (* validation *)
  : (sig_1 (EM unit (EM Z unit)) [result: (EM unit (EM Z unit))]
     (((qcomb [result: unit]True (qcomb [result: Z]False [result: unit]False))
       result)))
  := let (result, Post2) =
       let (result, WP5) = (exist_1 [result: bool]
         (if result then False else True) false I) in
       Cases
         (btest [result:bool](if result then False else True) result WP5) of
       | (left WP5_0) =>
           let (result0, Post3) =
             let (result0, Post4) = (exist_1 [result0: Z]False `1`
               (False_ind ? WP5_0)) in
             (exist_1 (qcomb [result1: Z]False [result1: unit]True) (Exn unit
                                                                    result0)
             (False_ind ? Post4)) in
           Cases (decomp1 Post3) of
           | (Qval (exist result0_0 WP1)) =>
             (exist_1 (qcomb [result1: Z]False [result1: unit]True) (Val Z
                                                                    result0_0)
             I)
           | (Qexn result0_0 Post5) =>
             (exist_1 (qcomb [result1: Z]False [result1: unit]True) (Exn unit
                                                                    result0_0)
             (False_ind ? Post5))
           end
       | (right WP5_0) =>
           let (result0, WP1) = (exist_1 [result0: unit]True tt I) in
           (exist_1 (qcomb [result1: Z]False [result1: unit]True) (Val Z
                                                                    result0)
           I) end in
     Cases (decomp1 Post2) of
     | (Qval (exist result0 WP1)) =>
       let (result0_0, Post7) =
         (exist_1 (qcomb [result0_0: unit]True [result0_0: unit]False) 
         (Exn unit tt) I) in
       Cases (decomp1 Post7) of
       | (Qval (exist result0_1 Post8)) =>
         (exist_1 (qcomb [result1: unit]True
                   (qcomb [result1: Z]False [result1: unit]False)) (Val unit
                                                                    (Val Z
                                                                    result0_1))
         (False_ind ? Post8))
       | (Qexn _ Post9) =>
         (exist_1 (qcomb [result1: unit]True
                   (qcomb [result1: Z]False [result1: unit]False)) (Exn
                                                                    (EM Z
                                                                    unit) 
                                                                    tt) I)
       end
     | (Qexn result0 Post6) =>
       (exist_1 (qcomb [result0_0: unit]True
                 (qcomb [result0_0: Z]False [result0_0: unit]False)) 
       (Val unit (Exn unit result0)) (False_ind ? Post6))
     end.

Definition p7 (* validation *)
  : (x: Z)
    (sig_2 Z (EM unit unit) [x0: Z][result: (EM unit unit)]
     (((qcomb [result: unit]`x0 = 1` [result: unit]False) result)))
  := [x: Z]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `1` result tt Post1) in
       let (result0, Post3) =
         (exist_1 (qcomb [result0: unit]`x0 = 1` [result0: unit]
                   ((x:Z) (x = `2` -> False))) (Exn unit tt)
         (p7_po_1 x0 Post1)) in
       Cases (decomp1 Post3) of
       | (Qval (exist result0_0 WP2)) =>
         let (x1, result1, Post2) =
           let (result1, Post2) = (exist_1 [result1: Z]result1 = `2` 
             `2` (refl_equal ? `2`)) in
           (exist_2 [x2: Z][result2: unit]x2 = `2` result1 tt Post2) in
         (exist_2 [x2: Z]
         (qcomb [result2: unit]`x2 = 1` [result2: unit]False) x1
         (Val unit result1) let HW_1 = (WP2 x1 Post2) in
                            HW_1)
       | (Qexn _ Post4) => (exist_2 [x1: Z]
         (qcomb [result1: unit]`x1 = 1` [result1: unit]False) x0
         (Exn unit tt) Post4)
       end.

Definition p8 (* validation *)
  : (x: Z)
    (sig_2 Z (EM Z unit) [x0: Z][result: (EM Z unit)]
     (((qcomb [result: Z]`x0 = 1` /\ `result = 1` [result: unit]False) result)))
  := [x: Z]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `1` result tt Post1) in
       let (result0, Post3) =
         let (result0, Post4) = (exist_1 [result0: Z]`x0 = 1` /\
           `result0 = 1` x0 (p8_po_1 x0 Post1)) in
         (exist_1 (qcomb [result1: Z]`x0 = 1` /\ `result1 = 1`
                   [result1: unit]((x:Z) (x = `2` -> False))) (Exn unit
                                                                result0)
         Post4) in
       Cases (decomp1 Post3) of
       | (Qval (exist result0_0 WP2)) =>
         let (x1, result1, Post2) =
           let (result1, Post2) = (exist_1 [result1: Z]result1 = `2` 
             `2` (refl_equal ? `2`)) in
           (exist_2 [x2: Z][result2: unit]x2 = `2` result1 tt Post2) in
         (exist_2 [x2: Z]
         (qcomb [result2: Z]`x2 = 1` /\ `result2 = 1` [result2: unit]False) 
         x1 (Val Z result1) let HW_1 = (WP2 x1 Post2) in
                            HW_1)
       | (Qexn result0_0 Post5) => (exist_2 [x1: Z]
         (qcomb [result1: Z]`x1 = 1` /\ `result1 = 1` [result1: unit]False) 
         x0 (Exn unit result0_0) Post5)
       end.

Definition p9 (* validation *)
  : (x: Z)
    (sig_2 Z (EM Z unit) [x0: Z][result: (EM Z unit)]
     (((qcomb [result: Z]`x0 = 1` /\ `result = 1` [result: unit]False) result)))
  := [x: Z]
       let (x0, result, Post2) =
         let (x0, result, Post1) =
           let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
             (refl_equal ? `1`)) in
           (exist_2 [x1: Z][result0: unit]x1 = `1` result tt Post1) in
         let (result0, Post3) = (exist_1 [result0: Z]`x0 = 1` /\
           `result0 = 1` x0 (p9_po_1 x0 Post1)) in
         (exist_2 [x1: Z][result1: Z]`x1 = 1` /\ `result1 = 1` x0 result0
         Post3) in
       (exist_2 [x1: Z]
       (qcomb [result0: Z]`x1 = 1` /\ `result0 = 1` [result0: unit]False) 
       x0 (Exn unit result) Post2).

Definition p10 (* validation *)
  : (sig_1 Z [result: Z](`result = 0`))
  := let (result, Post1) =
       (exist_1 (qcomb [result: unit]`0 = 0` [result: Z]`result = 0`) 
       (Exn Z tt) (refl_equal ? `0`)) in
     Cases (decomp1 Post1) of
     | (Qval (exist result0 Post2)) => (exist_1 [result0_0: Z]
       `result0_0 = 0` result0 Post2)
     | (Qexn _ WP1) =>
       let (result0, Post3) = (exist_1 [result0: Z]`result0 = 0` `0`
         (refl_equal ? `0`)) in
       (exist_1 [result1: Z]`result1 = 0` result0 Post3)
     end.

Definition p11 (* validation *)
  : (sig_1 Z [result: Z](`result = 1`))
  := let (result, Post1) =
       let (result, WP1) = (exist_1 [result: Z]`result = 1` `1`
         (refl_equal ? `1`)) in
       (exist_1 (qcomb [result0: Z]`result0 = 1` [result0: Z]`result0 = 1`) 
       (Exn Z result) WP1) in
     Cases (decomp1 Post1) of
     | (Qval (exist result0 Post2)) => (exist_1 [result0_0: Z]
       `result0_0 = 1` result0 Post2)
     | (Qexn result0 WP1) =>
       let (result0_0, Post3) = (exist_1 [result0_0: Z]
         `result0_0 = 1` result0 WP1) in
       (exist_1 [result1: Z]`result1 = 1` result0_0 Post3)
     end.

Definition p12 (* validation *)
  : (sig_1 Z [result: Z](`result = 2`))
  := let (result, Post1) =
       let (result, Post2) =
         (exist_1 (qcomb [result: unit]`2 = 2` [result: unit]`3 = 2`) 
         (Exn unit tt) (refl_equal ? `2`)) in
       Cases (decomp1 Post2) of
       | (Qval (exist result0 WP5)) =>
         let (result0_0, Post3) =
           let (result0_0, WP2) = (exist_1 [result0_0: Z]`3 = 2` `1` WP5) in
           (exist_1 (qcomb [result1: Z]`3 = 2` [result1: unit]`1 = 2`) 
           (Exn unit result0_0) WP2) in
         Cases (decomp1 Post3) of
         | (Qval (exist result0_1 WP3)) =>
           let (result1, Post4) = (exist_1 [result1: Z]`result1 = 2` 
             `1` WP3) in
           (exist_1 (qcomb [result2: unit]`2 = 2`
                     (qcomb [result2: Z]`3 = 2` [result2: Z]`result2 = 2`)) 
           (Val unit (Val Z result1)) Post4)
         | (Qexn result0_1 WP2) =>
           (exist_1 (qcomb [result1: unit]`2 = 2`
                     (qcomb [result1: Z]`3 = 2` [result1: Z]`result1 = 2`)) 
           (Val unit (Exn Z result0_1)) WP2)
         end
       | (Qexn _ WP1) =>
         (exist_1 (qcomb [result0: unit]`2 = 2`
                   (qcomb [result0: Z]`3 = 2` [result0: Z]`result0 = 2`)) 
         (Exn (EM Z Z) tt) (refl_equal ? `2`))
       end in
     Cases (decomp2 Post1) of
     | (Qval (Qval (exist result0 Post5))) => (exist_1 [result0_0: Z]
       `result0_0 = 2` result0 Post5)
     | (Qexn _ WP1) =>
       let (result0, Post6) = (exist_1 [result0: Z]`result0 = 2` `2`
         (refl_equal ? `2`)) in
       (exist_1 [result1: Z]`result1 = 2` result0 Post6)
     | (Qval (Qexn result0 WP2)) =>
       let (result0_0, Post7) = (exist_1 [result0_0: Z]`result0_0 = 2` 
         `3` WP2) in
       (exist_1 [result1: Z]`result1 = 2` result0_0 Post7)
     end.

Definition p13 (* validation *)
  : (x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = 2`))
  := [x: Z]
       let (x0, result, Post4) =
         let (result, Post5) =
           (exist_1 (qcomb [result: unit]((x:Z) (x = `2` -> `x = 2`))
                     [result: unit]((x:Z) (x = `3` -> `x = 2`))) (Exn unit
                                                                   tt)
           p13_po_1) in
         Cases (decomp1 Post5) of
         | (Qval (exist result0 WP8)) =>
           let (result0_0, Post6) =
             let (result0_0, WP4) = (exist_1 [result0_0: Z]
               ((x:Z) (x = `3` -> `x = 2`)) `1` WP8) in
             (exist_1 (qcomb [result1: Z]((x:Z) (x = `3` -> `x = 2`))
                       [result1: unit]((x:Z) (x = `1` -> `x = 2`))) (Exn unit
                                                                    result0_0)
             WP4) in
           Cases (decomp1 Post6) of
           | (Qval (exist result0_1 WP6)) =>
             let (x0, result1, Post1) =
               let (result1, Post1) = (exist_1 [result1: Z]result1 = `1` 
                 `1` (refl_equal ? `1`)) in
               (exist_2 [x1: Z][result2: unit]x1 = `1` result1 tt Post1) in
             (exist_2 [x1: Z]
             (qcomb [result2: unit]((x:Z) (x = `2` -> `x = 2`))
              (qcomb [result2: Z]((x:Z) (x = `3` -> `x = 2`)) [result2: unit]
               `x1 = 2`)) x0
             (Val unit (Val Z result1)) let HW_2 = (WP6 x0 Post1) in
                                        HW_2)
           | (Qexn result0_1 WP4) => (exist_2 [x0: Z]
             (qcomb [result1: unit]((x:Z) (x = `2` -> `x = 2`))
              (qcomb [result1: Z]((x:Z) (x = `3` -> `x = 2`)) [result1: unit]
               `x0 = 2`)) x (Val unit (Exn unit result0_1)) WP4)
           end
         | (Qexn _ WP2) => (exist_2 [x0: Z]
           (qcomb [result0: unit]((x:Z) (x = `2` -> `x = 2`))
            (qcomb [result0: Z]((x:Z) (x = `3` -> `x = 2`)) [result0: unit]
             `x0 = 2`)) x (Exn (EM Z unit) tt) WP2)
         end in
       Cases (decomp2 Post4) of
       | (Qval (Qval (exist result0 Post7))) => (exist_2 [x1: Z]
         [result0_0: unit]`x1 = 2` x0 result0 Post7)
       | (Qexn _ WP2) =>
         let (x1, result0, Post2) =
           let (result0, Post2) = (exist_1 [result0: Z]result0 = `2` 
             `2` (refl_equal ? `2`)) in
           (exist_2 [x2: Z][result1: unit]x2 = `2` result0 tt Post2) in
         (exist_2 [x2: Z][result1: unit]`x2 = 2` x1 result0
         let HW_3 = (WP2 x1 Post2) in
         HW_3)
       | (Qval (Qexn result0 WP4)) =>
         let (x1, result0_0, Post3) =
           let (result0_0, Post3) = (exist_1 [result0_0: Z]
             result0_0 = `3` `3` (refl_equal ? `3`)) in
           (exist_2 [x2: Z][result1: unit]x2 = `3` result0_0 tt Post3) in
         (exist_2 [x2: Z][result1: unit]`x2 = 2` x1 result0_0
         let HW_4 = (WP4 x1 Post3) in
         HW_4)
       end.

Definition p14 (* validation *)
  : (x: Z)
    (sig_1 (EM unit (EM unit (EM unit (EM unit unit))))
     [result: (EM unit (EM unit (EM unit (EM unit unit))))]
     (((qcomb [result: unit]`x <> 1` /\ `x <> 2` /\ `x <> 3`
        (qcomb [result: unit]`x = 1`
         (qcomb [result: unit]`x = 2`
          (qcomb [result: unit]`x = 3` [result: unit]False))))
       result)))
  := [x: Z]
       let (result, Post4) =
         let (result, Bool1) =
           let (result1, Post5) = (Z_eq_bool x `1`) in
           (exist_1 [result2: bool]
           (if result2 then `x = 1` else `x <> 1`) result1 Post5) in
         Cases
           (btest [result:bool](if result then `x = 1` else `x <> 1`) result
            Bool1) of
         | (left Test2) =>
             let (result0, Post6) =
               (exist_1 (qcomb [result0: unit]`x = 1` [result0: unit]
                         ((`x = 2` -> `x = 2`)) /\
                         ((`x <> 2` -> ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))))) 
               (Exn unit tt) Test2) in
             Cases (decomp1 Post6) of
             | (Qval (exist result0_0 WP11)) =>
               (exist_1 (qcomb [result1: unit]`x = 1` [result1: unit]
                         ((`x = 2` -> `x = 2`)) /\
                         ((`x <> 2` -> ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))))) 
               (Val unit result0_0) WP11)
             | (Qexn _ Post7) =>
               (exist_1 (qcomb [result1: unit]`x = 1` [result1: unit]
                         ((`x = 2` -> `x = 2`)) /\
                         ((`x <> 2` -> ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))))) 
               (Exn unit tt) Post7)
             end
         | (right Test1) =>
             let (result0, WP11) = (exist_1 [result0: unit]
               ((`x = 2` -> `x = 2`)) /\
               ((`x <> 2` -> ((`x = 3` -> `x = 3`)) /\
                 ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`)))) tt
               (p14_po_1 x Test1)) in
             (exist_1 (qcomb [result1: unit]`x = 1` [result1: unit]
                       ((`x = 2` -> `x = 2`)) /\
                       ((`x <> 2` -> ((`x = 3` -> `x = 3`)) /\
                         ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))))) 
             (Val unit result0) WP11) end in
       Cases (decomp1 Post4) of
       | (Qval (exist result0 WP11)) =>
         let (result0_0, Post9) =
           let (result0_0, Bool2) =
             let (result2, Post10) = (Z_eq_bool x `2`) in
             (exist_1 [result3: bool]
             (if result3 then `x = 2` else `x <> 2`) result2 Post10) in
           Cases
             (btest
              [result0_0:bool](if result0_0 then `x = 2` else `x <> 2`) result0_0
              Bool2) of
           | (left Test4) =>
               let (result1, Post11) =
                 (exist_1 (qcomb [result1: unit]`x = 2` [result1: unit]
                           ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))) 
                 (Exn unit tt) Test4) in
               Cases (decomp1 Post11) of
               | (Qval (exist result1_0 WP6)) =>
                 (exist_1 (qcomb [result2: unit]`x = 2` [result2: unit]
                           ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))) 
                 (Val unit result1_0) WP6)
               | (Qexn _ Post12) =>
                 (exist_1 (qcomb [result2: unit]`x = 2` [result2: unit]
                           ((`x = 3` -> `x = 3`)) /\
                           ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))) 
                 (Exn unit tt) Post12)
               end
           | (right Test3) =>
               let (result1, WP6) = (exist_1 [result1: unit]
                 ((`x = 3` -> `x = 3`)) /\
                 ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`)) tt
                 let HW_1 =
                   (why_boolean_forall
                     [result: bool]
                       (((if result then `x = 2` else `x <> 2`)) ->
                        (if result then `x = 2`
                         else ((`x = 3` -> `x = 3`)) /\
                         ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))))
                     WP11 false Test3) in
                 HW_1) in
               (exist_1 (qcomb [result2: unit]`x = 2` [result2: unit]
                         ((`x = 3` -> `x = 3`)) /\
                         ((`x <> 3` -> `x <> 1` /\ `x <> 2` /\ `x <> 3`))) 
               (Val unit result1) WP6) end in
         Cases (decomp1 Post9) of
         | (Qval (exist result0_1 WP6)) =>
           let (result1, Post14) =
             let (result1, Bool3) =
               let (result3, Post15) = (Z_eq_bool x `3`) in
               (exist_1 [result4: bool]
               (if result4 then `x = 3` else `x <> 3`) result3 Post15) in
             Cases
               (btest
                [result1:bool](if result1 then `x = 3` else `x <> 3`) result1
                Bool3) of
             | (left Test6) =>
                 let (result2, Post16) =
                   (exist_1 (qcomb [result2: unit]`x = 3` [result2: unit]
                             `x <> 1` /\ `x <> 2` /\ `x <> 3`) (Exn unit tt)
                   Test6) in
                 Cases (decomp1 Post16) of
                 | (Qval (exist result2_0 WP1)) =>
                   (exist_1 (qcomb [result3: unit]`x = 3` [result3: unit]
                             `x <> 1` /\ `x <> 2` /\ `x <> 3`) (Val unit
                                                                 result2_0)
                   WP1)
                 | (Qexn _ Post17) =>
                   (exist_1 (qcomb [result3: unit]`x = 3` [result3: unit]
                             `x <> 1` /\ `x <> 2` /\ `x <> 3`) (Exn unit tt)
                   Post17)
                 end
             | (right Test5) =>
                 let (result2, WP1) = (exist_1 [result2: unit]`x <> 1` /\
                   `x <> 2` /\ `x <> 3` tt
                   let HW_2 =
                     (why_boolean_forall
                       [result: bool]
                         (((if result then `x = 3` else `x <> 3`)) ->
                          (if result then `x = 3` else `x <> 1` /\
                           `x <> 2` /\ `x <> 3`)) WP6 false Test5) in
                   HW_2) in
                 (exist_1 (qcomb [result3: unit]`x = 3` [result3: unit]
                           `x <> 1` /\ `x <> 2` /\ `x <> 3`) (Val unit
                                                               result2)
                 WP1) end in
           Cases (decomp1 Post14) of
           | (Qval (exist result1_0 WP1)) =>
             let (result2, Post19) =
               (exist_1 (qcomb [result2: unit]`x <> 1` /\ `x <> 2` /\
                         `x <> 3` [result2: unit]False) (Exn unit tt) WP1) in
             Cases (decomp1 Post19) of
             | (Qval (exist result2_0 Post20)) =>
               (exist_1 (qcomb [result3: unit]`x <> 1` /\ `x <> 2` /\
                         `x <> 3`
                         (qcomb [result3: unit]`x = 1`
                          (qcomb [result3: unit]`x = 2`
                           (qcomb [result3: unit]`x = 3` [result3: unit]False)))) 
               (Val unit (Val unit (Val unit (Val unit result2_0))))
               (False_ind ? Post20))
             | (Qexn _ Post21) =>
               (exist_1 (qcomb [result3: unit]`x <> 1` /\ `x <> 2` /\
                         `x <> 3`
                         (qcomb [result3: unit]`x = 1`
                          (qcomb [result3: unit]`x = 2`
                           (qcomb [result3: unit]`x = 3` [result3: unit]False)))) 
               (Exn (EM unit (EM unit (EM unit unit))) tt) Post21)
             end
           | (Qexn _ Post18) =>
             (exist_1 (qcomb [result2: unit]`x <> 1` /\ `x <> 2` /\ `
                       x <> 3`
                       (qcomb [result2: unit]`x = 1`
                        (qcomb [result2: unit]`x = 2`
                         (qcomb [result2: unit]`x = 3` [result2: unit]False)))) 
             (Val unit (Val unit (Val unit (Exn unit tt)))) Post18)
           end
         | (Qexn _ Post13) =>
           (exist_1 (qcomb [result1: unit]`x <> 1` /\ `x <> 2` /\ `x <> 3`
                     (qcomb [result1: unit]`x = 1`
                      (qcomb [result1: unit]`x = 2`
                       (qcomb [result1: unit]`x = 3` [result1: unit]False)))) 
           (Val unit (Val unit (Exn (EM unit unit) tt))) Post13)
         end
       | (Qexn _ Post8) =>
         (exist_1 (qcomb [result0: unit]`x <> 1` /\ `x <> 2` /\ `x <> 3`
                   (qcomb [result0: unit]`x = 1`
                    (qcomb [result0: unit]`x = 2`
                     (qcomb [result0: unit]`x = 3` [result0: unit]False)))) 
         (Val unit (Exn (EM unit (EM unit unit)) tt)) Post8)
       end.

