(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

(* Why obligation from file "good-c/continue.c", characters 130-139 *)
Lemma f1_po_1 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (Test3: `n0 = 5`)
  (n1: Z)
  (Post1: n1 = `0`)
  `0 <= n1` /\ (Zwf `0` n1 n0).
Proof.
Unfold Zwf; Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 109-141 *)
Lemma f1_po_2 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (Test2: `n0 <> 5`)
  ((n:Z) (n = `n0 - 1` -> `0 <= n` /\ (Zwf `0` n n0))).
Proof.
Unfold Zwf; Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 103-154 *)
Lemma f1_po_3 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (n1: Z)
  (Post17: ((n:Z) (n = `n1 - 1` -> `0 <= n` /\ (Zwf `0` n n0))))
  (n2: Z)
  (Post2: n2 = `n1 - 1`)
  `0 <= n2` /\ (Zwf `0` n2 n0).
Proof.
Unfold Zwf; Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 84-90 *)
Lemma f1_po_4 : 
  (result: Z)
  (Post4: result = `10`)
  `0 <= result`.
Proof.
Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 164-165 *)
Lemma f1_po_5 : 
  (result: Z)
  (Post4: result = `10`)
  (n0: Z)
  (Post3: `0 <= n0` /\ `n0 <= 0`)
  `n0 = 0`.
Proof.
Intuition.
Save.

Definition f1 := (* validation *)
  [_: unit]
    let (result, Post4) = (exist_1 [result: Z]result = `10` `10`
      (refl_equal ? `10`)) in
    let (n0, result0, Post7) =
      let (n0, result0, Post3) =
        (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
          [Variant1: Z](n0: Z)(_0: Variant1 = n0)(_1: `0 <= n0`)
          (sig_2 Z unit [n1: Z][result0: unit](`0 <= n1` /\ `n1 <= 0`))
          [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
           (n0: Z)(_0: Variant2 = n0)(_1: `0 <= n0`)
           (sig_2 Z unit [n1: Z][result0: unit](`0 <= n1` /\ `n1 <= 0`));
           n0: Z; Pre3: Variant1 = n0; Pre2: `0 <= n0`]
            let (result0, Bool2) =
              let (result2, Post8) = (Z_gt_le_bool n0 `0`) in
              (exist_1 [result3: bool]
              (if result3 then `n0 > 0` else `n0 <= 0`) result2 Post8) in
            (Cases (btest
                    [result0:bool](if result0 then `n0 > 0` else `n0 <= 0`)
                    result0 Bool2) of
            | (left Test4) =>
                let (n1, result1, Post3) =
                  let (n1, result1, Post5) =
                    let (n1, result1, Post9) =
                      let (n1, result1, Post10) =
                        let (result1, Bool1) =
                          let (result3, Post11) = (Z_eq_bool n0 `5`) in
                          (exist_1 [result4: bool]
                          (if result4 then `n0 = 5` else `n0 <> 5`) result3
                          Post11) in
                        (Cases (btest
                                [result1:bool](if result1 then `n0 = 5`
                                               else `n0 <> 5`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (n1, result2, Post13) =
                              let (n1, result2, Post1) =
                                let (result2, Post1) = (exist_1 [result2: Z]
                                  result2 = `0` `0` (refl_equal ? `0`)) in
                                (exist_2 [n2: Z][result3: unit]
                                n2 = `0` result2 tt Post1) in
                              let (result3, Post14) =
                                (exist_1 (qcomb [result3: unit]`0 <= n1` /\
                                          (Zwf `0` n1 n0) [result3: unit]
                                          False) (Exn unit tt)
                                (f1_po_1 result Post4 Variant1 n0 Pre3 Pre2
                                Test4 Test3 n1 Post1)) in
                              Cases (decomp1 Post14) of
                              | (Qval (exist result4 Post15)) =>
                                (exist_2 [n2: Z]
                                (qcomb [result5: unit]`0 <= n2` /\
                                 (Zwf `0` n2 n0) [result5: unit]
                                 ((n:Z)
                                  (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                                n1 (Val unit result4) (False_ind ? Post15))
                              | (Qexn _0 Post5) => (exist_2 [n2: Z]
                                (qcomb [result4: unit]`0 <= n2` /\
                                 (Zwf `0` n2 n0) [result4: unit]
                                 ((n:Z)
                                  (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                                n1 (Exn unit tt) Post5)
                              end in
                            Cases (decomp1 Post13) of
                            | (Qval (exist result3 Post16)) =>
                              (exist_2 [n2: Z]
                              (qcomb [result4: unit]`0 <= n2` /\
                               (Zwf `0` n2 n0) [result4: unit]
                               ((n:Z)
                                (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                              n1 (Val unit result3) Post16)
                            | (Qexn _0 Post5) => (exist_2 [n2: Z]
                              (qcomb [result3: unit]`0 <= n2` /\
                               (Zwf `0` n2 n0) [result3: unit]
                               ((n:Z)
                                (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                              n1 (Exn unit tt) Post5)
                            end
                        | (right Test2) =>
                            let (result2, Post12) = (exist_1 [result2: unit]
                              ((n:Z)
                               (n = `n0 - 1` -> `0 <= n` /\ (Zwf `0` n n0))) 
                              tt
                              (f1_po_2 result Post4 Variant1 n0 Pre3 Pre2
                              Test4 Test2)) in
                            (exist_2 [n1: Z]
                            (qcomb [result3: unit]`0 <= n1` /\
                             (Zwf `0` n1 n0) [result3: unit]
                             ((n:Z)
                              (n = `n1 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                            n0 (Val unit result2) Post12) end) in
                      Cases (decomp1 Post10) of
                      | (Qval (exist result2 Post17)) =>
                        let (n2, result3, Post2) =
                          let (result3, Post2) = (exist_1 [result3: Z]
                            result3 = `n1 - 1` `n1 - 1`
                            (refl_equal ? `n1 - 1`)) in
                          (exist_2 [n3: Z][result4: unit]
                          n3 = `n1 - 1` result3 tt Post2) in
                        (exist_2 [n3: Z]
                        (qcomb [result4: unit]`0 <= n3` /\ (Zwf `0` n3 n0)
                         [result4: unit]`0 <= n3` /\ (Zwf `0` n3 n0)) 
                        n2 (Val unit result3)
                        (f1_po_3 result Post4 Variant1 n0 Pre3 Pre2 Test4 n1
                        Post17 n2 Post2))
                      | (Qexn _0 Post5) => (exist_2 [n2: Z]
                        (qcomb [result2: unit]`0 <= n2` /\ (Zwf `0` n2 n0)
                         [result2: unit]`0 <= n2` /\ (Zwf `0` n2 n0)) 
                        n1 (Exn unit tt) Post5)
                      end in
                    Cases (decomp1 Post9) of
                    | (Qval (exist result2 Post5)) => (exist_2 [n2: Z]
                      [result3: unit]`0 <= n2` /\ (Zwf `0` n2 n0) n1 
                      result2 Post5)
                    | (Qexn _0 Post5) =>
                      let (result2, Post6) = (exist_1 [result2: unit]
                        `0 <= n1` /\ (Zwf `0` n1 n0) tt Post5) in
                      (exist_2 [n2: Z][result3: unit]`0 <= n2` /\
                      (Zwf `0` n2 n0) n1 result2 Post6)
                    end in
                  ((wf1 n1) (loop_variant_1 Pre3 Post5) n1 (refl_equal ? n1)
                    (proj1 ? ? Post5)) in
                (exist_2 [n2: Z][result2: unit]`0 <= n2` /\ `n2 <= 0` 
                n1 result1 Post3)
            | (right Test1) =>
                let (n1, result1, Post3) = (exist_2 [n1: Z][result1: unit]
                  `0 <= n1` /\ `n1 <= 0` n0 tt (conj ? ? Pre2 Test1)) in
                (exist_2 [n2: Z][result2: unit]`0 <= n2` /\ `n2 <= 0` 
                n1 result1 Post3) end) result result (refl_equal ? result)
          (f1_po_4 result Post4)) in
      let (result1, Post18) = (exist_1 [result1: Z]`result1 = 0` n0
        (f1_po_5 result Post4 n0 Post3)) in
      (exist_2 [n1: Z][result2: Z]`result2 = 0` n0 result1 Post18) in
    (exist_1 [result1: Z]`result1 = 0` result0 Post7).

(* Why obligation from file "good-c/continue.c", characters 312-321 *)
Lemma f2_po_1 : 
  (result: Z)
  (Post5: result = `17`)
  (i0: Z)
  (Post1: i0 = `0`)
  (Variant1: Z)
  (i1: Z)
  (Pre3: Variant1 = `10 - i1`)
  (Pre2: `i1 <= 10`)
  (Test4: `i1 < 10`)
  (Test3: `i1 = 5`)
  (i2: Z)
  (Post2: i2 = `6`)
  `i2 <= 10` /\ (Zwf `0` `10 - i2` `10 - i1`).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "good-c/continue.c", characters 291-323 *)
Lemma f2_po_2 : 
  (result: Z)
  (Post5: result = `17`)
  (i0: Z)
  (Post1: i0 = `0`)
  (Variant1: Z)
  (i1: Z)
  (Pre3: Variant1 = `10 - i1`)
  (Pre2: `i1 <= 10`)
  (Test4: `i1 < 10`)
  (Test2: `i1 <> 5`)
  ((i:Z) (i = `i1 + 1` -> `i <= 10` /\ (Zwf `0` `10 - i` `10 - i1`))).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "good-c/continue.c", characters 216-327 *)
Lemma f2_po_3 : 
  (result: Z)
  (Post5: result = `17`)
  (i0: Z)
  (Post1: i0 = `0`)
  (Variant1: Z)
  (i1: Z)
  (Pre3: Variant1 = `10 - i1`)
  (Pre2: `i1 <= 10`)
  (Test4: `i1 < 10`)
  (i2: Z)
  (Post18: ((i:Z) (i = `i2 + 1` -> `i <= 10` /\ (Zwf `0` `10 - i` `10 - i1`))))
  (i3: Z)
  (Post3: i3 = `i2 + 1`)
  `i3 <= 10` /\ (Zwf `0` `10 - i3` `10 - i1`).
Proof.
Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 260-267 *)
Lemma f2_po_4 : 
  (result: Z)
  (Post5: result = `17`)
  (i0: Z)
  (Post1: i0 = `0`)
  `i0 <= 10`.
Proof.
Intuition.
Save.

(* Why obligation from file "good-c/continue.c", characters 337-338 *)
Lemma f2_po_5 : 
  (result: Z)
  (Post5: result = `17`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (Post4: `i1 <= 10` /\ `i1 >= 10`)
  `i1 = 10`.
Proof.
Intuition.
Save.

Definition f2 := (* validation *)
  [_: unit]
    let (result, Post5) = (exist_1 [result: Z]result = `17` `17`
      (refl_equal ? `17`)) in
    let (i0, result0, Post8) =
      let (i0, result0, Post1) =
        let (result0, Post1) = (exist_1 [result0: Z]result0 = `0` `0`
          (refl_equal ? `0`)) in
        (exist_2 [i1: Z][result1: unit]i1 = `0` result0 tt Post1) in
      let (i1, result1, Post4) =
        (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
          [Variant1: Z](i1: Z)(_0: Variant1 = `10 - i1`)(_1: `i1 <= 10`)
          (sig_2 Z unit [i2: Z][result1: unit](`i2 <= 10` /\ `i2 >= 10`))
          [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
           (i1: Z)(_0: Variant2 = `10 - i1`)(_1: `i1 <= 10`)
           (sig_2 Z unit [i2: Z][result1: unit](`i2 <= 10` /\ `i2 >= 10`));
           i1: Z; Pre3: Variant1 = `10 - i1`; Pre2: `i1 <= 10`]
            let (result1, Bool2) =
              let (result3, Post9) = (Z_lt_ge_bool i1 `10`) in
              (exist_1 [result4: bool]
              (if result4 then `i1 < 10` else `i1 >= 10`) result3 Post9) in
            (Cases (btest
                    [result1:bool](if result1 then `i1 < 10` else `i1 >= 10`)
                    result1 Bool2) of
            | (left Test4) =>
                let (i2, result2, Post4) =
                  let (i2, result2, Post6) =
                    let (i2, result2, Post10) =
                      let (i2, result2, Post11) =
                        let (result2, Bool1) =
                          let (result4, Post12) = (Z_eq_bool i1 `5`) in
                          (exist_1 [result5: bool]
                          (if result5 then `i1 = 5` else `i1 <> 5`) result4
                          Post12) in
                        (Cases (btest
                                [result2:bool](if result2 then `i1 = 5`
                                               else `i1 <> 5`)
                                result2 Bool1) of
                        | (left Test3) =>
                            let (i2, result3, Post14) =
                              let (i2, result3, Post2) =
                                let (result3, Post2) = (exist_1 [result3: Z]
                                  result3 = `6` `6` (refl_equal ? `6`)) in
                                (exist_2 [i3: Z][result4: unit]
                                i3 = `6` result3 tt Post2) in
                              let (result4, Post15) =
                                (exist_1 (qcomb [result4: unit]`i2 <= 10` /\
                                          (Zwf `0` `10 - i2` `10 - i1`)
                                          [result4: unit]False) (Exn unit tt)
                                (f2_po_1 result Post5 i0 Post1 Variant1 i1
                                Pre3 Pre2 Test4 Test3 i2 Post2)) in
                              Cases (decomp1 Post15) of
                              | (Qval (exist result5 Post16)) =>
                                (exist_2 [i3: Z]
                                (qcomb [result6: unit]`i3 <= 10` /\
                                 (Zwf `0` `10 - i3` `10 - i1`)
                                 [result6: unit]
                                 ((i:Z)
                                  (i = `i3 + 1` -> `i <= 10` /\
                                   (Zwf `0` `10 - i` `10 - i1`)))) i2
                                (Val unit result5) (False_ind ? Post16))
                              | (Qexn _0 Post6) => (exist_2 [i3: Z]
                                (qcomb [result5: unit]`i3 <= 10` /\
                                 (Zwf `0` `10 - i3` `10 - i1`)
                                 [result5: unit]
                                 ((i:Z)
                                  (i = `i3 + 1` -> `i <= 10` /\
                                   (Zwf `0` `10 - i` `10 - i1`)))) i2
                                (Exn unit tt) Post6)
                              end in
                            Cases (decomp1 Post14) of
                            | (Qval (exist result4 Post17)) =>
                              (exist_2 [i3: Z]
                              (qcomb [result5: unit]`i3 <= 10` /\
                               (Zwf `0` `10 - i3` `10 - i1`) [result5: unit]
                               ((i:Z)
                                (i = `i3 + 1` -> `i <= 10` /\
                                 (Zwf `0` `10 - i` `10 - i1`)))) i2
                              (Val unit result4) Post17)
                            | (Qexn _0 Post6) => (exist_2 [i3: Z]
                              (qcomb [result4: unit]`i3 <= 10` /\
                               (Zwf `0` `10 - i3` `10 - i1`) [result4: unit]
                               ((i:Z)
                                (i = `i3 + 1` -> `i <= 10` /\
                                 (Zwf `0` `10 - i` `10 - i1`)))) i2
                              (Exn unit tt) Post6)
                            end
                        | (right Test2) =>
                            let (result3, Post13) = (exist_1 [result3: unit]
                              ((i:Z)
                               (i = `i1 + 1` -> `i <= 10` /\
                                (Zwf `0` `10 - i` `10 - i1`))) tt
                              (f2_po_2 result Post5 i0 Post1 Variant1 i1 Pre3
                              Pre2 Test4 Test2)) in
                            (exist_2 [i2: Z]
                            (qcomb [result4: unit]`i2 <= 10` /\
                             (Zwf `0` `10 - i2` `10 - i1`) [result4: unit]
                             ((i:Z)
                              (i = `i2 + 1` -> `i <= 10` /\
                               (Zwf `0` `10 - i` `10 - i1`)))) i1
                            (Val unit result3) Post13) end) in
                      Cases (decomp1 Post11) of
                      | (Qval (exist result3 Post18)) =>
                        let (i3, result4, Post3) =
                          let (result4, Post3) = (exist_1 [result4: Z]
                            result4 = `i2 + 1` `i2 + 1`
                            (refl_equal ? `i2 + 1`)) in
                          (exist_2 [i4: Z][result5: unit]
                          i4 = `i2 + 1` result4 tt Post3) in
                        (exist_2 [i4: Z]
                        (qcomb [result5: unit]`i4 <= 10` /\
                         (Zwf `0` `10 - i4` `10 - i1`) [result5: unit]
                         `i4 <= 10` /\ (Zwf `0` `10 - i4` `10 - i1`)) 
                        i3 (Val unit result4)
                        (f2_po_3 result Post5 i0 Post1 Variant1 i1 Pre3 Pre2
                        Test4 i2 Post18 i3 Post3))
                      | (Qexn _0 Post6) => (exist_2 [i3: Z]
                        (qcomb [result3: unit]`i3 <= 10` /\
                         (Zwf `0` `10 - i3` `10 - i1`) [result3: unit]
                         `i3 <= 10` /\ (Zwf `0` `10 - i3` `10 - i1`)) 
                        i2 (Exn unit tt) Post6)
                      end in
                    Cases (decomp1 Post10) of
                    | (Qval (exist result3 Post6)) => (exist_2 [i3: Z]
                      [result4: unit]`i3 <= 10` /\
                      (Zwf `0` `10 - i3` `10 - i1`) i2 result3 Post6)
                    | (Qexn _0 Post6) =>
                      let (result3, Post7) = (exist_1 [result3: unit]
                        `i2 <= 10` /\ (Zwf `0` `10 - i2` `10 - i1`) tt
                        Post6) in
                      (exist_2 [i3: Z][result4: unit]`i3 <= 10` /\
                      (Zwf `0` `10 - i3` `10 - i1`) i2 result3 Post7)
                    end in
                  ((wf1 `10 - i2`) (loop_variant_1 Pre3 Post6) i2
                    (refl_equal ? `10 - i2`) (proj1 ? ? Post6)) in
                (exist_2 [i3: Z][result3: unit]`i3 <= 10` /\ `i3 >= 10` 
                i2 result2 Post4)
            | (right Test1) =>
                let (i2, result2, Post4) = (exist_2 [i2: Z][result2: unit]
                  `i2 <= 10` /\ `i2 >= 10` i1 tt (conj ? ? Pre2 Test1)) in
                (exist_2 [i3: Z][result3: unit]`i3 <= 10` /\ `i3 >= 10` 
                i2 result2 Post4) end) `10 - i0` i0 (refl_equal ? `10 - i0`)
          (f2_po_4 result Post5 i0 Post1)) in
      let (result2, Post19) = (exist_1 [result2: Z]`result2 = 10` i1
        (f2_po_5 result Post5 i0 Post1 i1 Post4)) in
      (exist_2 [i2: Z][result3: Z]`result3 = 10` i1 result2 Post19) in
    (exist_1 [result1: Z]`result1 = 10` result0 Post8).

