(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

Lemma f1_po_1 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (Test3: `n0 = 5`)
  (n1: Z)
  (Post1: n1 = `0`)
  `0 <= n1` /\ (Zwf `0` n1 n0).
Proof.
Unfold Zwf; Intuition.
Save.

Lemma f1_po_2 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (Test2: `n0 <> 5`)
  ((n:Z) (n = `n0 - 1` -> `0 <= n` /\ (Zwf `0` n n0))).
Proof.
Unfold Zwf; Intuition.
Save.

Lemma f1_po_3 : 
  (result: Z)
  (Post4: result = `10`)
  (Variant1: Z)
  (n0: Z)
  (Pre3: Variant1 = n0)
  (Pre2: `0 <= n0`)
  (Test4: `n0 > 0`)
  (n1: Z)
  (Post17: ((n:Z) (n = `n1 - 1` -> `0 <= n` /\ (Zwf `0` n n0))))
  (n2: Z)
  (Post2: n2 = `n1 - 1`)
  `0 <= n2` /\ (Zwf `0` n2 n0).
Proof.
Unfold Zwf; Intuition.
Save.

Lemma f1_po_4 : 
  (result: Z)
  (Post4: result = `10`)
  `0 <= result`.
Proof.
Intuition.
Save.

Lemma f1_po_5 : 
  (result: Z)
  (Post4: result = `10`)
  (n0: Z)
  (Post3: `0 <= n0` /\ `n0 <= 0`)
  `n0 = 0`.
Proof.
Intuition.
Save.

Definition f1 := (* validation *)
  [_: unit]
    let (result, Post4) = (exist_1 [result: Z]result = `10` `10`
      (refl_equal ? `10`)) in
    let (n0, result0, Post7) =
      let (n0, result0, Post3) =
        (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
          [Variant1: Z](n0: Z)(_0: Variant1 = n0)(_1: `0 <= n0`)
          (sig_2 Z unit [n1: Z][result0: unit](`0 <= n1` /\ `n1 <= 0`))
          [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
           (n0: Z)(_0: Variant2 = n0)(_1: `0 <= n0`)
           (sig_2 Z unit [n1: Z][result0: unit](`0 <= n1` /\ `n1 <= 0`));
           n0: Z; Pre3: Variant1 = n0; Pre2: `0 <= n0`]
            let (result0, Bool2) =
              let (result2, Post8) = (Z_gt_le_bool n0 `0`) in
              (exist_1 [result3: bool]
              (if result3 then `n0 > 0` else `n0 <= 0`) result2 Post8) in
            (Cases (btest
                    [result0:bool](if result0 then `n0 > 0` else `n0 <= 0`)
                    result0 Bool2) of
            | (left Test4) =>
                let (n1, result1, Post3) =
                  let (n1, result1, Post5) =
                    let (n1, result1, Post9) =
                      let (n1, result1, Post10) =
                        let (result1, Bool1) =
                          let (result3, Post11) = (Z_eq_bool n0 `5`) in
                          (exist_1 [result4: bool]
                          (if result4 then `n0 = 5` else `n0 <> 5`) result3
                          Post11) in
                        (Cases (btest
                                [result1:bool](if result1 then `n0 = 5`
                                               else `n0 <> 5`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (n1, result2, Post13) =
                              let (n1, result2, Post1) =
                                let (result2, Post1) = (exist_1 [result2: Z]
                                  result2 = `0` `0` (refl_equal ? `0`)) in
                                (exist_2 [n2: Z][result3: unit]
                                n2 = `0` result2 tt Post1) in
                              let (result3, Post14) =
                                (exist_1 (qcomb [result3: unit]`0 <= n1` /\
                                          (Zwf `0` n1 n0) [result3: unit]
                                          False) (Exn unit tt)
                                (f1_po_1 result Post4 Variant1 n0 Pre3 Pre2
                                Test4 Test3 n1 Post1)) in
                              Cases (decomp1 Post14) of
                              | (Qval (exist result4 Post15)) =>
                                (exist_2 [n2: Z]
                                (qcomb [result5: unit]`0 <= n2` /\
                                 (Zwf `0` n2 n0) [result5: unit]
                                 ((n:Z)
                                  (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                                n1 (Val unit result4) (False_ind ? Post15))
                              | (Qexn _0 Post5) => (exist_2 [n2: Z]
                                (qcomb [result4: unit]`0 <= n2` /\
                                 (Zwf `0` n2 n0) [result4: unit]
                                 ((n:Z)
                                  (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                                n1 (Exn unit tt) Post5)
                              end in
                            Cases (decomp1 Post13) of
                            | (Qval (exist result3 Post16)) =>
                              (exist_2 [n2: Z]
                              (qcomb [result4: unit]`0 <= n2` /\
                               (Zwf `0` n2 n0) [result4: unit]
                               ((n:Z)
                                (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                              n1 (Val unit result3) Post16)
                            | (Qexn _0 Post5) => (exist_2 [n2: Z]
                              (qcomb [result3: unit]`0 <= n2` /\
                               (Zwf `0` n2 n0) [result3: unit]
                               ((n:Z)
                                (n = `n2 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                              n1 (Exn unit tt) Post5)
                            end
                        | (right Test2) =>
                            let (result2, Post12) = (exist_1 [result2: unit]
                              ((n:Z)
                               (n = `n0 - 1` -> `0 <= n` /\ (Zwf `0` n n0))) 
                              tt
                              (f1_po_2 result Post4 Variant1 n0 Pre3 Pre2
                              Test4 Test2)) in
                            (exist_2 [n1: Z]
                            (qcomb [result3: unit]`0 <= n1` /\
                             (Zwf `0` n1 n0) [result3: unit]
                             ((n:Z)
                              (n = `n1 - 1` -> `0 <= n` /\ (Zwf `0` n n0)))) 
                            n0 (Val unit result2) Post12) end) in
                      Cases (decomp1 Post10) of
                      | (Qval (exist result2 Post17)) =>
                        let (n2, result3, Post2) =
                          let (result3, Post2) = (exist_1 [result3: Z]
                            result3 = `n1 - 1` `n1 - 1`
                            (refl_equal ? `n1 - 1`)) in
                          (exist_2 [n3: Z][result4: unit]
                          n3 = `n1 - 1` result3 tt Post2) in
                        (exist_2 [n3: Z]
                        (qcomb [result4: unit]`0 <= n3` /\ (Zwf `0` n3 n0)
                         [result4: unit]`0 <= n3` /\ (Zwf `0` n3 n0)) 
                        n2 (Val unit result3)
                        (f1_po_3 result Post4 Variant1 n0 Pre3 Pre2 Test4 n1
                        Post17 n2 Post2))
                      | (Qexn _0 Post5) => (exist_2 [n2: Z]
                        (qcomb [result2: unit]`0 <= n2` /\ (Zwf `0` n2 n0)
                         [result2: unit]`0 <= n2` /\ (Zwf `0` n2 n0)) 
                        n1 (Exn unit tt) Post5)
                      end in
                    Cases (decomp1 Post9) of
                    | (Qval (exist result2 Post5)) => (exist_2 [n2: Z]
                      [result3: unit]`0 <= n2` /\ (Zwf `0` n2 n0) n1 
                      result2 Post5)
                    | (Qexn _0 Post5) =>
                      let (result2, Post6) = (exist_1 [result2: unit]
                        `0 <= n1` /\ (Zwf `0` n1 n0) tt Post5) in
                      (exist_2 [n2: Z][result3: unit]`0 <= n2` /\
                      (Zwf `0` n2 n0) n1 result2 Post6)
                    end in
                  ((wf1 n1) (loop_variant_1 Pre3 Post5) n1 (refl_equal ? n1)
                    (proj1 ? ? Post5)) in
                (exist_2 [n2: Z][result2: unit]`0 <= n2` /\ `n2 <= 0` 
                n1 result1 Post3)
            | (right Test1) =>
                let (n1, result1, Post3) = (exist_2 [n1: Z][result1: unit]
                  `0 <= n1` /\ `n1 <= 0` n0 tt (conj ? ? Pre2 Test1)) in
                (exist_2 [n2: Z][result2: unit]`0 <= n2` /\ `n2 <= 0` 
                n1 result1 Post3) end) result result (refl_equal ? result)
          (f1_po_4 result Post4)) in
      let (result1, Post18) = (exist_1 [result1: Z]`result1 = 0` n0
        (f1_po_5 result Post4 n0 Post3)) in
      (exist_2 [n1: Z][result2: Z]`result2 = 0` n0 result1 Post18) in
    (exist_1 [result1: Z]`result1 = 0` result0 Post7).

