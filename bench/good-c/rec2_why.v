(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

(* Why obligation from file "good-c/rec2.c", characters 70-91 *)
Lemma f_po_1 : 
  (x: Z)
  (Pre8: `x >= 0`)
  (Variant1: Z)
  (x0: Z)
  (Pre7: Variant1 = x0)
  (Pre6: `x0 >= 0`)
  (Test1: `x0 <> 0`)
  ((result:Z) (`result = 0` -> `result = 0`)) /\ `x0 - 1 >= 0`.
Proof.
Intuition.
Save.

(* Why obligation from file "good-c/rec2.c", characters 46-130 *)
Lemma f_po_2 : 
  (x: Z)
  (Pre8: `x >= 0`)
  (Variant1: Z)
  (x0: Z)
  (Pre7: Variant1 = x0)
  (Pre6: `x0 >= 0`)
  (Post10: ((result:Z) (`result = 0` -> `result = 0`)) /\ `x0 - 1 >= 0`)
  (Pre5: `x0 - 1 >= 0`)
  (Pre3: `x0 - 1 >= 0`)
  (Pre4: `x0 - 1 >= 0`)
  (Zwf `0` `x0 - 1` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

Definition f (* validation *)
  : (x: Z)(_: `x >= 0`)(sig_1 Z [result: Z](`result = 0`))
  := [x: Z; Pre8: `x >= 0`]
       (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
         [Variant1: Z](x0: Z)(_: Variant1 = x0)(_0: `x0 >= 0`)
         (sig_1 Z [result: Z](`result = 0`))
         [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
          (x0: Z)(_: Variant2 = x0)(_0: `x0 >= 0`)
          (sig_1 Z [result: Z](`result = 0`)); x0: Z; Pre7: Variant1 = x0;
          Pre6: `x0 >= 0`]
           let (result, Post2) =
             let (result, Post3) =
               let (result, Bool3) =
                 let (result1, Post4) = (Z_eq_bool x0 `0`) in
                 (exist_1 [result2: bool]
                 (if result2 then `x0 = 0` else `x0 <> 0`) result1 Post4) in
               (Cases (btest
                       [result:bool](if result then `x0 = 0` else `x0 <> 0`)
                       result Bool3) of
               | (left Test2) =>
                   let (result0, Post6) =
                     let (result0, Post7) = (exist_1 [result0: Z]
                       `result0 = 0` `0` (refl_equal ? `0`)) in
                     (exist_1 (qcomb [result1: Z]`result1 = 0`
                               [result1: unit]False) (Exn unit result0)
                     Post7) in
                   Cases (decomp1 Post6) of
                   | (Qval (exist result1 Post8)) =>
                     (exist_1 (qcomb [result2: Z]`result2 = 0`
                               [result2: unit]
                               ((result:Z) (`result = 0` -> `result = 0`)) /\
                               `x0 - 1 >= 0`) (Val Z result1)
                     (False_ind ? Post8))
                   | (Qexn result1 Post9) =>
                     (exist_1 (qcomb [result2: Z]`result2 = 0`
                               [result2: unit]
                               ((result:Z) (`result = 0` -> `result = 0`)) /\
                               `x0 - 1 >= 0`) (Exn unit result1) Post9)
                   end
               | (right Test1) =>
                   let (result0, Post5) = (exist_1 [result0: unit]
                     ((result:Z) (`result = 0` -> `result = 0`)) /\
                     `x0 - 1 >= 0` tt
                     (f_po_1 x Pre8 Variant1 x0 Pre7 Pre6 Test1)) in
                   (exist_1 (qcomb [result1: Z]`result1 = 0` [result1: unit]
                             ((result:Z) (`result = 0` -> `result = 0`)) /\
                             `x0 - 1 >= 0`) (Val Z result0)
                   Post5) end) in
             Cases (decomp1 Post3) of
             | (Qval (exist result0 Post10)) =>
               let Pre5 = let (HW_1, HW_2) = Post10 in
                          HW_2 in
               let (result1, Post12) =
                 let Pre3 = Pre5 in
                 let Pre4 = Pre3 in
                 let (result3, Post13) =
                   ((wf1 `x0 - 1`)
                     (f_po_2 x Pre8 Variant1 x0 Pre7 Pre6 Post10 Pre5 Pre3
                     Pre4) `x0 - 1` (refl_equal ? `x0 - 1`) Pre4) in
                 (exist_1 [result4: Z]`result4 = 0` result3 Post13) in
               (exist_1 (qcomb [result2: Z]`result2 = 0` [result2: Z]
                         `result2 = 0`) (Val Z result1)
               Post12)
             | (Qexn result0 Post11) =>
               (exist_1 (qcomb [result1: Z]`result1 = 0` [result1: Z]
                         `result1 = 0`) (Exn Z result0) Post11)
             end in
           Cases (decomp1 Post2) of
           | (Qval (exist result0 Post14)) => (exist_1 [result1: Z]
             `result1 = 0` result0 Post14)
           | (Qexn result0 Post15) =>
             let (result1, Post16) = (exist_1 [result1: Z]
               `result1 = 0` result0 Post15) in
             (exist_1 [result2: Z]`result2 = 0` result1 Post16)
           end x x (refl_equal ? x) Pre8).

