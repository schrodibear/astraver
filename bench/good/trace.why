
(* Example 1 
 * We want the message: 
 *  "assertion `x < 9' cannot be established"
 * localized on `x < 9' 
 *)
let f1 = fun (x : int) ->
  { x > 0 }
  assert { x >= 0 and x < 9};
  x+1
  { true }

(* Example 2 
 * We want the message: 
 *  "post-condition `result > 10' of function f2 cannot be established"
 * localized on `x+1'
 * Bonus: all lines involved in the execution path should be ~underlined 
 *)

let f2 = fun (x : int) ->
  { x > 0 and x < 100 }
  if x < 50 then x+1 else x-1
  { result <> 0 and result > 10 }

(* Example 3 
 * We want the message: 
 *  "pre-condition `x > 0' for call to function f2 cannot be established"
 * localized on `(f2 x)' 
 *)

let f3 = fun (x : int) ->
  { x >= 0 and x < 50 }
  (f2 x)
  { true }

(* Example 4 
 * Explanation expected: 
 *   "validity of loop invariant `0 <= y' at loop entrance"
 * localized on `while ...' 
 *)
let f4 = fun (x : int) ->
  { true }
  let y = ref x in
  while !y > 0 do
    { invariant 0 <= y and y <= x variant y }
    y := !y - 1
  done
  { true }

(* Example 5 
 * Explanation expected:
 *   "preservation of loop invariant `y = x'"
 * localized on the '}' closing the loop body 
 *)
let f5 = fun (x : int) ->
  { true }
  let y = ref x in
  while !y > 0 do
     { invariant y = x }
     y := !y - 1
  done	
  { true }


(*
Local Variables: 
mode: why
compile-command: "../../bin/gwhy.byte trace.why"
End: 
*)
