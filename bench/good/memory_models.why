
(* C types *)

type ctype = 
  | Void 
  | Int8 | Int16 | Int32 | Int64 
  | Float32 | Float64 
  | Pointer(ctype)
  | StructList

function sizeof(t:ctype):int =
  match t with
  | Void -> 0
  | Int8 -> 1
  | Int16 -> 2
  | Int32 -> 4
  | Int64 -> 8
  | Float32 -> 4
  | Float64 -> 8
  | Pointer(_) -> 4 
  | StructList -> 8   
 end

logic compatible : ctype, ctype -> prop

axiom compatible_refl: forall t:ctype. compatible(t,t)

axiom compatible_pointers: 
  forall tau,tau':ctype. compatible(Pointer(tau),Pointer(tau'))

(* memory *)

type block_identifier (* Z ? *)

type pointer = Mk_ptr(block_identifier,int)

function addr(p:pointer) : block_identifier = 
  match p with Mk_ptr(a,off) -> a end      

function shift(p:pointer,o:int) : pointer =
  match p with
   | Mk_ptr(addr,off) -> Mk_ptr(addr,off+o)
  end      
       
axiom shift_zero:
  forall p:pointer.
   shift(p,0) = p

axiom shift_shift:
  forall p:pointer. forall i,j:int.
   shift(shift(p,i),j) = shift(p,i+j)

type tagged_value = Undef | Int(int) | Float(real) | Ptr(pointer)

logic ptr_of : tagged_value -> pointer

axiom ptr_of_def: forall p:pointer. ptr_of(Ptr(p)) = p

logic cast: ctype, tagged_value -> tagged_value

axiom cast_pointer: 
  forall tau:ctype. forall p:pointer.
   cast(Pointer(tau),Ptr(p)) = Ptr(p)




(*

example 2: wild pointer arithmetic





struct data { int tag; int payload[10]; } d;

(int * ) ((char * ) d + 4 * sizeof(int)) == &d.payload[3];

*)

let example2 (d:pointer) =
 begin
  let p = ptr_of(cast (Pointer Int8) (Ptr d)) in
  let p = shift p (4 * sizeof Int32) in  
  assert { ptr_of(cast(Pointer(Int32),Ptr(p))) = shift(shift(d,4),3 * sizeof(Int32)) };
  void
 end







      
type byte_content = Empty | Data(ctype,tagged_value) | Cont

type memory_state
(*
  { next: int; (* block_identifier ? *)
    bounds : block_identifier -> int * int;
    contents : pointer -> byte_content;
  }
*)

logic next : memory_state -> int
logic min_offset : memory_state, block_identifier -> int
logic max_offset : memory_state, block_identifier -> int
logic contents : memory_state, pointer -> byte_content


logic load : memory_state, ctype, pointer -> tagged_value

axiom load_ok:
 forall m:memory_state. forall p : pointer.
  forall tau,tau':ctype. forall v:tagged_value. 
  contents(m,p) = Data(tau',v) and
  compatible(tau,tau') and
  (forall i:int. 1 <= i <= sizeof(tau) - 1 -> contents(m,shift(p,i)) = Cont)
  -> load(m,tau,p) = cast(tau,v)

(*
axiom load_undef:
 forall m:memory_state. forall p : pointer.
  forall tau,tau':ctype. forall v:tagged_value. 
  not (contents(m,p) = Data(tau',v) and
  compatible(tau,tau') and
  (match p with
    | Mk_ptr(addr,off) ->
        forall i:int. 1 <= i <= sizeof(tau) - 1 ->
           contents(m,Mk_ptr(addr,off+i)) = Cont 
   end))
  -> load(m,tau,p) = Undef
*)



logic store : memory_state, ctype, pointer, tagged_value ->  memory_state

axiom store_contents:
  forall m,m':memory_state. forall tau:ctype. forall p:pointer.
  forall v:tagged_value.
   m' = store(m,tau,p,v) ->
     contents(m',p) = Data(tau,v) 
   and
     (forall i:int. 1 <= i <= sizeof(tau) - 1 -> 
         contents(m',shift(p,i)) = Cont)
(*
   and
     (forall i:int. (i <= 0 or i >= sizeof(tau)) -> 
         contents(m',shift(p,i)) = contents(m,shift(p,i)))
   and
     (forall q:pointer. addr(q) <> addr(p) -> 
         contents(m',q) = contents(m,q))
*)

(*
axiom store_shift_contents:
  forall m,m':memory_state. forall tau:ctype. forall p:pointer.
  forall o:int. forall v:tagged_value.
   m' = store(m,tau,shift(p,o),v) ->
     contents(m',shift(p,o)) = Data(tau,v) 
   and
     (forall i:int. 1 <= i <= sizeof(tau) - 1 -> 
         contents(m',shift(p,o+i)) = Cont)
   and
     (forall i:int. (i <= 0 or i >= sizeof(tau)) -> 
         contents(m',shift(p,o+i)) = contents(m,shift(p,o+i)))
   and
     (forall q:pointer. addr(q) <> addr(p) -> 
         contents(m',q) = contents(m,q))
*)

axiom store_shift_outside:
  forall m,m':memory_state. forall tau:ctype. forall p:pointer.
  forall o,i:int. forall v:tagged_value.
   m' = store(m,tau,shift(p,o),v) and
   i < o or i >= o + sizeof(tau) - 1 -> 
         contents(m',shift(p,i)) = contents(m,shift(p,i))


(*


Example 1: 


struct list { void * hd; struct list * tl; } * l;
int i, *p;

l->hd = (void * ) &i;
l->tl = NULL
p = (int * ) l->hd;
*p = 42;
//@ assert i == 42;

*)

parameter m : memory_state ref

logic null : pointer

let example1 (l:pointer) (i:pointer) (p:pointer ref) =
  begin
   m := (store !m (Pointer Void) (shift l 0) (cast (Pointer Void) (Ptr i)));
   assert { contents(m,shift(l,0)) = Data(Pointer(Void),Ptr(i)) };
   assert { contents(m,shift(l,1)) = Cont };
   assert { contents(m,shift(l,2)) = Cont };
   assert { contents(m,shift(l,3)) = Cont };
   assert { load(m,Pointer(Int32),shift(l,0)) = Ptr(i) };
   L:
   m := (store !m (Pointer StructList) (shift l 4) (Ptr null));
   assert { contents(m,shift(l,4+(-4))) = contents(m@L,shift(l,4+(-4))) };
   assert { contents(m,shift(shift(l,4),-4)) = Data(Pointer(Void),Ptr(i)) };
   assert { contents(m,shift(l,0)) = Data(Pointer(Void),Ptr(i)) };
   assert { contents(m,shift(l,1)) = Cont };
   assert { contents(m,shift(l,2)) = Cont };
   assert { contents(m,shift(l,3)) = Cont };
   assert { load(m,Pointer(Int32),shift(l,0)) = Ptr(i) };
   p := ptr_of (cast (Pointer Int32) (load !m (Pointer Void) (shift l 0)));
   assert { p = ptr_of(Ptr(i)) };
   assert { p = i };
   m := (store !m Int32 !p (Int 42))
  end  
  { load(m,Int32,i) = Int(42) }






  




(*
Local Variables: 
compile-command: "../../bin/gwhy.byte ../../lib/why/bitvector.why memory_models.why"
End: 
*)

    
   







