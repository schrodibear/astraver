(* abstract IntSetInterface *)

  (* Logic *)

  type intset

  logic emptyset : -> intset
  logic singleton : int -> intset
  logic union : intset, intset -> intset
  logic In : int, intset -> prop

  axiom In_emptyset :
    forall n : int.
      In(n, emptyset) <-> false

  axiom In_singleton :
    forall n : int.
      forall k : int.
        In(n, singleton(k)) <-> n = k

  axiom In_union :
    forall s1 : intset.
      forall s2 : intset.
        forall n : int.
          In(n, union(s1, s2)) <-> In(n, s1) or In(n, s2)

  axiom intset_ext :
    forall s1 : intset.
      forall s2 : intset.
        (forall n : int. In(n, s1) <-> In(n, s2)) -> s1 = s2

  (* Representation variables *)

  parameter s :  intset ref

  (* Operations (types) *)

  parameter init :
    unit ->
      { } unit reads s writes s { s = emptyset }

  parameter mem :
    n : int ->
      { } bool reads s { result = true <-> In(n,s) }
        
  parameter add :
    n : int ->
      { } unit reads s writes s { s = union(s@,singleton(n)) }

(* end *)

(* concrete IntSetImpl implements IntSetInterface *)

  (* Logic *)

  axiom mean1 : 
    forall x : int.
      forall y : int.
        x <= y -> x <= (x + y) / 2

  axiom mean2 : 
    forall x : int.
      forall y : int.
        x < y -> (x + y) / 2 < y

  (* Array allocation *)
  parameter alloc :
    n : int ->
      { n >= 0 } int farray { array_length(result) = n }

  (* Representation  variables *)  

  parameter size : int ref
  parameter t : int array

  (* Coupling invariant *)

  predicate I(s : intset, t : int array, size : int) = 
    forall n : int. In(n, s) <->
      (exists i : int. 0 <= i and i < size -> n = t[i])

  axiom I_empty : 
    forall t : int farray. 0 <= array_length(t) -> I(emptyset,t,0)

  (* Representation invariant *)

  predicate Inv(t : int array, size : int) =
    0 <= size and size <= array_length(t) and
    forall i : int.
      forall j : int. 0 <= i and i <= j and j < size -> t[i] <= t[j]

  axiom Inv_empty : 
    forall t : int farray. 0 <= array_length(t) -> Inv(t,0)

  (* Aiding the proof for memC *)

  axiom memC_th7_ax :
    forall s : intset.
      forall size : int.
        forall t : int farray.
          forall n : int.
    I(s,t,size) and
    (forall i : int. 0 <= i and i < size -> t[i] < n)
    ->
    not In(n,s)

  (* Operations (bodies) *)

  let initC ( ) =
    {  }
    size := 0 ; t := alloc(10)
    { exists s : intset. I(s,t,size) and Inv(t,size) and s = emptyset}

  let index ( n : int ) = 
    { Inv(t,size) } 
    let a = ref 0 in let b = ref !size in let m = ref 0 in
      while !a < !b do  
        { invariant 0 <= a and a <= b and b <= size and
	            (forall i : int. 0 <= i and i < a -> t[i] < n) and 
	            (forall i : int. b <= i and i < size -> t[i] >= n) 
          variant b-a }
        m := (!a+!b)/2;
        if t[!m] < n then 
          a := !m+1 
        else 
          b := !m
      done
      ; !a
    { Inv(t,size) and 0 <= result and result <= size and
      (forall i : int. 0 <= i and i < result -> t[i] < n) and 
      (forall i : int. result <= i and i < size -> t[i] >= n)
    }

  let memC ( n : int ) =
    { I(s,t,size) and Inv(t,size) }
    let i = index(n) in 
      i < !size && t[i] = n
    (* memC does not modify s *)
    { I(s,t,size) and Inv(t,size) and (result = true <-> In(n,s)) }

  (*
     copy(src,dest,a,b,c) copies src[a..b] to dest[c..c+b-a]
     if src and dest are the same, c is assumed greater than or equal to a.
  *)
  let copy(src : int farray)(dest : int array)(a, b, c : int) =
    { 0 <= a and a-1 <= b and b < array_length(src) and 0 <= c and 
      c+b-a < array_length(dest) and (dest = src -> c >= a)
    }
    let j = ref b in
      init :
      while !j >= a do
        { invariant 
	    a-1 <= j and j <= b and
	    (forall i : int. j < i and i <= b -> dest[i+c-a] = access(src,i)) and
            (forall i : int. 0 <= i and i <= j+c-a -> dest[i] = dest@init[i]) and
            (forall i : int. c+b-a+1 <= i and i < array_length(dest) -> dest[i] = dest@init[i])
            and array_length(dest) = array_length(dest@init)
          variant j
        }
        dest[!j+c-a] := access src !j
        ; j := !j-1
      done
    { (forall i : int. c <= i and i <= c+b-a -> dest[i] = access(src,i+a-c)) and
      (forall i : int. 0 <= i and i < c -> dest[i] = dest@[i]) and
      (forall i : int. c+b-a+1 <= i and i < array_length(dest) -> dest[i] = dest@[i]) and 
      array_length(dest) = array_length(dest@) }

  let addC ( n : int ) =	
    { I(s,t,size) and Inv(t,size) }
    let i = index(n) in
      if i < !size && t[i] = n then
        void
      else begin
        if !size < array_length(!t) then
	  let u = !t in
            copy u t i (!size-1) (i+1)
        else begin
          let old = !t in
            t := alloc(2*!size+1) ;
	    copy old t 0 (i-1) 0 ;
	    copy old t i (!size-1) (i+1)
        end ;
        t[i] := n ; 
        size := !size + 1
      end 
    { exists s : intset. I(s,t,size) and Inv(t,size) and s = union(s@,singleton(n))}

(* end *)

(*
  axiom addC_th3_ax1 :
    forall s : intset.
      forall size : int.
        forall t : int farray.
          forall n : int.
            forall i : int.
    0 <= i and i < size and
    I(s,t,size) and
    n = t[i]
    ->
    In(n,s)

  axiom addC_th3_ax2 :
    forall s : intset.
      forall n : int.
    In(n,s)
    ->
    s = union(s,singleton(n))

  axiom addC_th3_ax3 :
    forall s : intset.
      forall size : int.
        forall t : int farray.
          forall n : int.
            forall i : int.
    0 <= i and i < size and
    I(s,t,size) and
    n = t[i]
    ->
    exists s : intset. I(s,t,size) and s = union(s,singleton(n))
*)
