
goal helper_for_multiplication_goal: 
      forall x:real. forall y:real. forall z:real. forall t:real.
   (0.0 <= x <= y and 0.0 <= z <= t) -> x*z <= y*t

axiom helper_for_multiplication: 
      forall x:real. forall y:real. forall z:real. forall t:real.
   (0.0 <= x <= y and 0.0 <= z <= t) -> x*z <= y*t

goal help3_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (0.0 <= a <= x and y <= b and y < 0.0) -> x*y <= a*b 

axiom help3: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (0.0 <= a <= x and y <= b and y < 0.0) -> x*y <= a*b 

goal  help5_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (a <= x and x > 0.0 and y <= b <= 0.0 ) -> x*y <= a*b

axiom help5: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (a <= x and x > 0.0 and y <= b <= 0.0 ) -> x*y <= a*b

(*c'est le meme que help5 mais Z3 n'arrive pas à prouver certaines postconditions sans help6 !! bizare *)
goal help6_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (b <= y and y > 0.0 and x <= a <= 0.0 ) -> x*y <= a*b

axiom help6: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (b <= y and y > 0.0 and x <= a <= 0.0 ) -> x*y <= a*b

goal help7_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (x <= a <= 0.0 and y <= b and y < 0.0) -> a*b <= x*y

axiom help7: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (x <= a <= 0.0 and y <= b and y < 0.0) -> a*b <= x*y

(*c'est le meme que help7 mais Z3 n'arrive pas à prouver certaines postconditions sans help8 !! bizare *)
goal help8_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (x <= a and x < 0.0 and y <= b <= 0.0 ) -> a*b <= x*y

axiom help8: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (x <= a and x < 0.0 and y <= b <= 0.0 ) -> a*b <= x*y

goal help9_goal: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (a <= x and x > 0.0 and 0.0 <= b <= y ) -> a*b <= x*y 

axiom help9: forall x:real. forall y:real. forall a:real. 
             forall b:real.
   (a <= x and x > 0.0 and 0.0 <= b <= y ) -> a*b <= x*y 




let min (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (lt_gen_float x y) then x else y
 { float_le_float(result,x) and float_le_float(result,y)
} 


let max (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (gt_gen_float x y) then x else y
{  float_le_float(x,result) and float_le_float(y,result)
}



predicate float_less_than_real(x:gen_float,y:real) = 
       (is_finite(x) and float_value(x) <= y)  or is_minus_infinity(x)

predicate real_less_than_float(x:real,y:gen_float) = 
       (is_finite(y) and x <= float_value(y)) or is_plus_infinity(y)

	
let mul_dn (x:gen_float) (y:gen_float) =

{
 is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> diff_sign(x,y))
and               
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0) 
and
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0)
 }
 (mul_gen_float Double down x y)
 {
  float_less_than_real(result,float_value(x)*float_value(y)) and
(is_infinite(x) or is_infinite(y) -> is_minus_infinity(result)) 
}



parameter a:gen_float ref
parameter b:gen_float ref
parameter z:gen_float ref


let mul_up (x:gen_float) (y:gen_float) =
 {

 is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> same_sign(x,y)) 
  and
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0 )
  and 
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0)
}
begin
a := (neg_gen_float Double down y);
assert { 
  is_finite(y) -> is_finite(a) and float_value(a) = - float_value(y) };
b := (mul_gen_float Double down x !a);
z := (neg_gen_float Double down !b) ;
assert { 
  is_finite(b) -> is_finite(z) and float_value(z) = - float_value(b) };
!z
end
{
real_less_than_float(float_value(x)*float_value(y),result) and
((is_infinite(x) or is_infinite(y)) -> is_plus_infinity(result)) 

}



(*********************


  intervals


**********************)



predicate is_interval(l:gen_float,u:gen_float)= (is_finite(l) or (is_infinite(l) and float_sign(l) = Negative))
                                                 and 
						(is_finite(u) or (is_infinite(u) and float_sign(u) = Positive))

predicate in_interval(a:real,l:gen_float,u:gen_float) = float_less_than_real(l,a) and real_less_than_float(a,u)



parameter zl:gen_float ref
parameter zu:gen_float ref

let add (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ }
begin
zl := (add_gen_float Double down xl yl);
zu := (neg_gen_float Double down (sub_gen_float Double down (neg_gen_float Double down xu) yu))
end
{ forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a+b,zl,zu)
}






parameter tl:gen_float ref
parameter tu:gen_float ref
parameter zero:gen_float ref

let mul (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ is_interval(xl,xu) and is_interval(yl,yu) 
}
  zero := gen_float_of_real Double down 0.0;
assert {float_value(zero)=0.0};
  begin
  if (lt_gen_float xl !zero) then
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin (* xl,yl< 0 et xu,yu > 0 *)
	    tl := min (mul_dn xl yu) (mul_dn xu yl);
            tu := max (mul_up xl yl) (mul_up xu yu)
	    end
        else           
            begin (* xl,yl< 0 et xu > 0 et yu <=0 *)
	    tl := mul_dn xu yl;
	    tu := mul_up xl yl
            end
      else 
        begin
        if (gt_gen_float yu !zero) then
            begin (* xl< 0 et yl >=0 et xu > 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xu yu
	    end
        else
            begin (* xl< 0 et yl >=0 et xu > 0 et yu <=0 *)          
            tl := !zero;
            tu := !zero 
	    end
	end
    else
      begin
      if (lt_gen_float yl !zero) then
        begin
	if (gt_gen_float yu !zero) then
            begin (* xl,yl< 0 et xu <= 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xl yl
	    end
        else           
            begin (* xl,yl< 0 et xu <= 0 et yu <=0 *)
	    tl := mul_dn xu yu;
            tu := mul_up xl yl
	    end
	end
      else 
        if (gt_gen_float yu !zero) then
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu >0 *) 
	    tl := mul_dn xl yu;
            tu := mul_up xu yl
	    end
        else          
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu <=0 *)
	    tl := !zero;
            tu := !zero
	    end
      end
  else
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin (* xl>=0 et yl<0 et xu > 0 et yu >0 *)
	    tl := mul_dn xu yl;
            tu := mul_up xu yu
	    end
        else           
            begin (* xl>=0 et yl<0 et xu > 0 et yu <=0*)
	    tl := mul_dn xu yl;
            tu := mul_up xl yu
	    end
      else 
        if (gt_gen_float yu !zero) then
            begin (* xl>=0 et yl >=0 et xu > 0 et yu >0*)
     	    tl := mul_dn xl yl;
	    tu := mul_up xu yu
            end
        else           
            begin  (* xl>=0 et yl >=0 et xu > 0 et yu <=0*)
	    tl := !zero;
            tu := !zero
	    end
    else   (* xl>=0 et yl qlq et xu <= 0 et yu qlq *)             
        begin
	tl := !zero;
        tu := !zero
        end
  end;
  void       
{ is_interval(tl,tu) and 
 
  forall a:real. forall b:real. 
      in_interval(a,xl,xu) and in_interval(b,yl,yu) -> 
         (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

(*
completement prouvé par Z3 sauf postconditions 63, 110, 157 et 160 prouvés par cvc3
*)






(*  Borne inférieure: Il ne faut pas considerer la borne inf toute seule parce que 
    le calcul de tl parfois depend de xu et/ou yu

forall a:real. forall b:real. 
       float_less_than_real(xl,a) and float_less_than_real(yl,b) ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)
forall a:real. forall b:real. 
       is_minus_infinity(xl) and is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)

completement prouvés par Z3 !
*)







(* Les deux bornes ensembles:

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_finite(xu) and a <= float_value(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition)

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_plus_infinity(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)





***************aussi *******************



forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_plus_infinity(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3





***************aussi *******************


forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3




*******************aussi************************





forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par tous

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions) 

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

*)

}


