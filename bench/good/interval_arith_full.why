


let min (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (lt_gen_float x y) then x else y
 { float_le_float(result,x) and float_le_float(result,y)
} 


let max (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (gt_gen_float x y) then x else y
{  float_le_float(x,result) and float_le_float(y,result)
}



predicate float_less_than_real(x:gen_float,y:real) = 
       (is_finite(x) and float_value(x) <= y)  or is_minus_infinity(x)

predicate real_less_than_float(x:real,y:gen_float) = 
       (is_finite(y) and x <= float_value(y)) or is_plus_infinity(y)

	
let mul_dn (x:gen_float) (y:gen_float) =

 { is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> diff_sign(x,y))
and               
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0) 
and
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0)
 }
 (mul_gen_float Double down x y)
 {
  float_less_than_real(result,float_value(x)*float_value(y)) and
(is_infinite(x) or is_infinite(y) -> is_minus_infinity(result))
}



(* obsolete ???

 forall x1:real. forall y1:real. 
     (* x: <0 borne inf, y: >0 borne sup -> result: borne inf *) 
     (float_sign(x) = Negative and float_sign(y) = Positive and
      float_less_than_real(x,x1) and real_less_than_float(y1,y) ->
      float_less_than_real(result,x1*y1))
    and 
     (* x: >0 borne sup, y: <0 borne inf -> result: borne inf *) 
     (float_sign(x) = Positive and float_sign(y) = Negative and
      real_less_than_float(x1,x) and float_less_than_real(y,y1) ->
      float_less_than_real(result,x1*y1))
    and
     (* x: <0 borne sup, y: <0 borne sup -> result: borne inf *) 
     (float_sign(x) = Negative and float_sign(y) = Negative and
      real_less_than_float(x1,x) and real_less_than_float(y1,y) ->
      float_less_than_real(result,x1*y1))
    and 
     (* x: >0 borne inf, y: >0 borne inf -> result: borne inf *) 
     (float_sign(x) = Positive and float_sign(y) = Positive and
      float_less_than_real(x,x1) and float_less_than_real(y,y1) ->
      float_less_than_real(result,x1*y1))

*)




let mul_up (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> same_sign(x,y)) 
  and
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0 and abs_real(float_value(y)) >= 0x1.0p-1074 )
  and 
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0) 
  and 
  (is_finite(x) and is_finite(y) and not no_overflow(Double,down,-float_value(y)) and float_sign(y) = Positive 
        -> float_value(x) > 0.0)
}
(neg_gen_float Double down (mul_gen_float Double down x (neg_gen_float Double down y)))
 {
real_less_than_float(float_value(x)*float_value(y),result) and
((is_infinite(x) and is_infinite(y)) -> is_infinite(result)) and
((is_plus_infinity(x) or is_plus_infinity(y)) -> is_plus_infinity(result)) and
((is_minus_infinity(x) or is_minus_infinity(y)) -> is_plus_infinity(result))

(*
and 
(is_finite(x) and is_infinite(y) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_finite(y) and no_overflow(Double,down,-float_value(y)) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_finite(y) and not no_overflow(Double,down,-float_value(y)) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_infinite(y) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 

*)
}



(*********************


  intervals


**********************)



predicate is_interval(l:gen_float,u:gen_float)= (is_finite(l) or (is_infinite(l) and float_sign(l) = Negative))
                                                 and 
						(is_finite(u) or (is_infinite(u) and float_sign(u) = Positive))

predicate in_interval(a:real,l:gen_float,u:gen_float) = float_less_than_real(l,a) and real_less_than_float(a,u)



parameter zl:gen_float ref
parameter zu:gen_float ref

let add (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ }
begin
zl := (add_gen_float Double down xl yl);
zu := (neg_gen_float Double down (sub_gen_float Double down (neg_gen_float Double down xu) yu))
end
{ forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a+b,zl,zu)
}




axiom axo1: forall x:gen_float. forall a:real. forall b:real.
(float_less_than_real(x,a) and a <= b) -> float_less_than_real(x,b)

axiom axo2: forall x:gen_float. forall a:real. forall b:real.
(a <= b and real_less_than_float(b,x)) -> real_less_than_float(a,x)

axiom axo3: forall x:gen_float. forall y:gen_float. forall a:real. 
(float_le_float(x,y) and float_less_than_real(y,a)) -> float_less_than_real(x,a)

axiom axo4: forall x:gen_float. forall y:gen_float. forall a:real. 
(real_less_than_float(a,x) and float_le_float(x,y)) -> real_less_than_float(a,y)



axiom help1: forall x:real. forall y:real. forall z:real. forall t:real.
   (0.0 <= x <= y and 0.0 <= z <= t) -> x*z <= y*t

(* pas besoin de help2 !!
axiom help2: forall x:real. forall y:real. forall z:real. forall t:real.
   (x <= y <= 0.0 and z <= t <= 0.0) -> x*z >= y*t
*)

axiom help3: forall x:real. forall y:real. forall a:real. forall b:real.
   (0.0 <= a <= x and y <= b and y < 0.0) -> x*y <= a*b 
(*
(*c'est le meme que help3, pas besoin de help4 *)
axiom help4: forall x:real. forall y:real. forall a:real. forall b:real.
   (x <= a and x < 0.0 and 0.0 <= b <= y) -> x*y <= a*b 
*)
	
axiom help5: forall x:real. forall y:real. forall a:real. forall b:real.
   (a <= x and x > 0.0 and y <= b <= 0.0 ) -> x*y <= a*b

(*c'est le meme que help5 mais Z3 n'arrive pas à prouver certaines postconditions sans help6 !! bizare *)
axiom help6: forall x:real. forall y:real. forall a:real. forall b:real.
   (b <= y and y > 0.0 and x <= a <= 0.0 ) -> x*y <= a*b

axiom help7: forall x:real. forall y:real. forall a:real. forall b:real.
   (x <= a <= 0.0 and y <= b and y < 0.0) -> a*b <= x*y

(*c'est le meme que help7 mais Z3 n'arrive pas à prouver certaines postconditions sans help8 !! bizare *)
axiom help8: forall x:real. forall y:real. forall a:real. forall b:real.
   (x <= a and x < 0.0 and y <= b <= 0.0 ) -> a*b <= x*y

axiom help9: forall x:real. forall y:real. forall a:real. forall b:real.
   (a <= x and x > 0.0 and 0.0 <= b <= y ) -> a*b <= x*y 




axiom help10: forall x:real. forall y:real. forall z:real. 
   (0.0 <= x and y <= z) -> x*y <= x*z

axiom help11: forall x:real. forall y:real. forall z:real. 
   (0.0 < x and y <= z) -> x*y <= x*z

axiom help12: forall x:real. forall y:real. forall z:real. 
   (0.0 < x and y < z) -> x*y < x*z

axiom help13: forall x:real. forall y:real. forall z:real. 
   (0.0 <= x and y < z) -> x*y <= x*z

axiom help14: forall x:real. forall y:real. forall z:real. 
   (x <= 0.0 and y <= z) -> x*y >= x*z

axiom help15: forall x:real. forall y:real. forall z:real. 
   (x < 0.0 and y <= z) -> x*y >= x*z

axiom help16: forall x:real. forall y:real. forall z:real. 
   (x < 0.0 and y < z) -> x*y > x*z

axiom help17: forall x:real. forall y:real. forall z:real. 
   (x <= 0.0 and y < z) -> x*y >= x*z




parameter tl:gen_float ref
parameter tu:gen_float ref
parameter zero:gen_float ref

let mul (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ is_interval(xl,xu) and is_interval(yl,yu) 
}
  zero := gen_float_of_real Double down 0.0;
assert {float_value(zero)=0.0};
  begin
  if (lt_gen_float xl !zero) then
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin (* xl,yl< 0 et xu,yu > 0 *)
	    tl := min (mul_dn xl yu) (mul_dn xu yl);
            tu := max (mul_up xl yl) (mul_up xu yu)
	    end
        else           
            begin (* xl,yl< 0 et xu > 0 et yu <=0 *)
	    tl := mul_dn xu yl;
	    tu := mul_up xl yl
            end
      else 
        begin
        if (gt_gen_float yu !zero) then
            begin (* xl< 0 et yl >=0 et xu > 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xu yu
	    end
        else
            begin (* xl< 0 et yl >=0 et xu > 0 et yu <=0 *)          
            tl := !zero;
            tu := !zero 
	    end
	end
    else
      begin
      if (lt_gen_float yl !zero) then
        begin
	if (gt_gen_float yu !zero) then
            begin (* xl,yl< 0 et xu <= 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xl yl
	    end
        else           
            begin (* xl,yl< 0 et xu <= 0 et yu <=0 *)
	    tl := mul_dn xu yu;
            tu := mul_up xl yl
	    end
	end
      else 
        if (gt_gen_float yu !zero) then
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu >0 *) 
	    tl := mul_dn xl yu;
            tu := mul_up xu yl
	    end
        else          
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu <=0 *)
	    tl := !zero;
            tu := !zero
	    end
      end
  else
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin (* xl>=0 et yl<0 et xu > 0 et yu >0 *)
	    tl := mul_dn xu yl;
            tu := mul_up xu yu
	    end
        else           
            begin (* xl>=0 et yl<0 et xu > 0 et yu <=0*)
	    tl := mul_dn xu yl;
            tu := mul_up xl yu
	    end
      else 
        if (gt_gen_float yu !zero) then
            begin (* xl>=0 et yl >=0 et xu > 0 et yu >0*)
     	    tl := mul_dn xl yl;
	    tu := mul_up xu yu
            end
        else           
            begin  (* xl>=0 et yl >=0 et xu > 0 et yu <=0*)
	    tl := !zero;
            tu := !zero
	    end
    else   (* xl>=0 et yl qlq et xu <= 0 et yu qlq *)             
        begin
	tl := !zero;
        tu := !zero
        end
  end;
  void       
{ is_interval(tl,tu) and 


 forall a:real. forall b:real. 
      in_interval(a,xl,xu) and in_interval(b,yl,yu) -> 
         (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

(*
completement prouvé par Z3 sauf postconditions 63, 110, 157 et 160 prouvés par cvc3
*)






(*  Borne inférieure: Il ne faut pas considerer la borne inf toute seule parce que 
    le calcul de tl parfois depend de xu et/ou yu

forall a:real. forall b:real. 
       float_less_than_real(xl,a) and float_less_than_real(yl,b) ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)
forall a:real. forall b:real. 
       is_minus_infinity(xl) and is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)

completement prouvés par Z3 !
*)







(* Les deux bornes ensembles:

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_finite(xu) and a <= float_value(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition)

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and
       is_plus_infinity(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)





***************aussi *******************



forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b and 
       is_plus_infinity(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3





***************aussi *******************


forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3




*******************aussi************************





forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and  
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par tous

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions) 

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_plus_infinity(xu) and 
       is_finite(yu) and b <= float_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

forall a:real. forall b:real. 
       (is_minus_infinity(xl) and 
       is_minus_infinity(yl) and 
       is_finite(xu) and a <= float_value(xu) and 
       is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

*)

}


