


let min (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (lt_gen_float x y) then x else y
 { float_le_float(result,x) and float_le_float(result,y)
} 


let max (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) 
}
if (gt_gen_float x y) then x else y
{  float_le_float(x,result) and float_le_float(y,result)
} 



predicate float_less_than_real(x:gen_float,y:real) = 
       (is_finite(x) and float_value(x) <= y)  or is_minus_infinity(x)

predicate real_less_than_float(x:real,y:gen_float) = 
       (is_finite(y) and x <= float_value(y)) or is_plus_infinity(y)

	
let mul_dn (x:gen_float) (y:gen_float) =

 { is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> diff_sign(x,y))
and               
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0) 
and
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0)
 }
 (mul_gen_float Double down x y)
 {
  float_less_than_real(result,float_value(x)*float_value(y)) and
(is_infinite(x) or is_infinite(y) -> is_minus_infinity(result))
}



(* obsolete ???

 forall x1:real. forall y1:real. 
     (* x: <0 borne inf, y: >0 borne sup -> result: borne inf *) 
     (float_sign(x) = Negative and float_sign(y) = Positive and
      float_less_than_real(x,x1) and real_less_than_float(y1,y) ->
      float_less_than_real(result,x1*y1))
    and 
     (* x: >0 borne sup, y: <0 borne inf -> result: borne inf *) 
     (float_sign(x) = Positive and float_sign(y) = Negative and
      real_less_than_float(x1,x) and float_less_than_real(y,y1) ->
      float_less_than_real(result,x1*y1))
    and
     (* x: <0 borne sup, y: <0 borne sup -> result: borne inf *) 
     (float_sign(x) = Negative and float_sign(y) = Negative and
      real_less_than_float(x1,x) and real_less_than_float(y1,y) ->
      float_less_than_real(result,x1*y1))
    and 
     (* x: >0 borne inf, y: >0 borne inf -> result: borne inf *) 
     (float_sign(x) = Positive and float_sign(y) = Positive and
      float_less_than_real(x,x1) and float_less_than_real(y,y1) ->
      float_less_than_real(result,x1*y1))

*)




let mul_up (x:gen_float) (y:gen_float) =
 { is_not_NaN(x) and is_not_NaN(y) and
  ((is_infinite(x) or is_infinite(y)) -> same_sign(x,y)) 
  and
  (is_infinite(x) and is_finite(y) -> float_value(y) <> 0.0 and abs_real(float_value(y)) >= 0x1.0p-1074 )
  and 
  (is_infinite(y) and is_finite(x) -> float_value(x) <> 0.0) 
  and 
  (is_finite(x) and is_finite(y) and not no_overflow(Double,down,-float_value(y)) and float_sign(y) = Positive 
        -> float_value(x) > 0.0)
}
(neg_gen_float Double down (mul_gen_float Double down x (neg_gen_float Double down y)))
 {
real_less_than_float(float_value(x)*float_value(y),result) 

(*
and 
(is_finite(x) and is_infinite(y) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_finite(y) and no_overflow(Double,down,-float_value(y)) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_finite(y) and not no_overflow(Double,down,-float_value(y)) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 
(is_infinite(x) and is_infinite(y) -> real_less_than_float(float_value(x)*float_value(y),result)) 
and 

*)
}



(*********************


  intervals


**********************)



predicate is_interval(l:gen_float,u:gen_float)= (is_finite(l) or (is_infinite(l) and float_sign(l) = Negative))
                                                 and 
						(is_finite(u) or (is_infinite(u) and float_sign(u) = Positive))

predicate in_interval(a:real,l:gen_float,u:gen_float) = float_less_than_real(l,a) and real_less_than_float(a,u)



parameter zl:gen_float ref
parameter zu:gen_float ref

let add (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ }
begin
zl := (add_gen_float Double down xl yl);
zu := (neg_gen_float Double down (sub_gen_float Double down (neg_gen_float Double down xu) yu))
end
{ forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a+b,zl,zu)
}



axiom help: forall x:real. forall y:real. forall z:real. forall t:real.
   (0.0 <= x <= y and 0.0 <= z <= t) -> x*z <= y*t



parameter tl:gen_float ref
parameter tu:gen_float ref
parameter zero:gen_float ref

let mul (xl:gen_float) (xu:gen_float) (yl:gen_float) (yu:gen_float) =
{ is_interval(xl,xu) and is_interval(yl,yu) 
}
  zero := gen_float_of_real Double down 0.0;
assert {float_value(zero)=0.0};
  begin
  if (lt_gen_float xl !zero) then
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin
	    tl := min (mul_dn xl yu) (mul_dn xu yl);
            tu := max (mul_up xl yl) (mul_up xu yu)
	    end
        else           
            begin
	    tl := mul_dn xu yl;
            tu := mul_up xl yl
	    end
      else
        begin
        if (gt_gen_float yu !zero) then
            begin
	    tl := mul_dn xl yu;
            tu := mul_up xu yu
	    end
        else
            begin           
            tl := !zero;
            tu := !zero 
	    end
	end
    else
      begin
      if (lt_gen_float yl !zero) then
        begin
	if (gt_gen_float yu !zero) then
            begin
	    tl := mul_dn xl yu;
            tu := mul_up xl yl
	    end
        else           
            begin
	    tl := mul_dn xu yu;
            tu := mul_up xl yl
	    end
	end
      else
        if (gt_gen_float yu !zero) then
            begin 
	    tl := mul_dn xl yu;
            tu := mul_up xu yl
	    end
        else          
            begin
	    tl := !zero;
            tu := !zero
	    end
      end
  else
    if (gt_gen_float xu !zero) then
      if (lt_gen_float yl !zero) then
        if (gt_gen_float yu !zero) then
            begin
	    tl := mul_dn xu yl;
            tu := mul_up xu yu
	    end
        else   (*yu <=0*)        
            begin
	    tl := mul_dn xu yl;
            tu := mul_up xl yu
	    end
      else (* yl >=0* et xl>=0*)
        if (gt_gen_float yu !zero) then
            begin
          assert {is_finite(xl) and 0.0 <= float_value(xl)};
	  assert {is_finite(yl) and 0.0 <= float_value(yl)};
          assert {is_plus_infinity(yu) or (is_finite(yu) and 
                     float_value(yu)> 0.0)};
          assert {is_plus_infinity(xu) or (is_finite(xu) and 
                     float_value(xu)> 0.0)};
            tl := mul_dn xl yl;
            assert { float_value(tl) <= float_value(xl) * float_value(yl) };
            tu := mul_up xu yu;
	    (* xu > 0 et yu > 0*)
	    assert { real_less_than_float(float_value(xu) * float_value(yu), tu) };
            void
	    end
        else           
            begin
	    tl := !zero;
            tu := !zero
	    end
    else               
        begin
	tl := !zero;
        tu := !zero
        end
  end;
  void       
{ is_interval(tl,tu) and 


(*
  forall a:real. forall b:real. 
      in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a*b,tl,tu)

*)

(*
  forall a:real. forall b:real. 
       float_less_than_real(xl,a) and float_less_than_real(yl,b) ->
           float_less_than_real(tl,a*b)
       and float_less_than_real(tl,float_value(xl)*float_value(yl)) 
*)

(*
 forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

prouvé par ergo !
*)



 forall a:real. forall b:real. 
       (is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b ->
        float_less_than_real(tl,float_value(xl)*float_value(yl)) 
        and float_value(xl) * float_value(yl) <= a*b)
and 
       (is_finite(xu) and a <= float_value(xu) and 
       is_finite(yu) and b <= float_value(yu) ->
        real_less_than_float(float_value(xu)*float_value(yu),tu) 
        and a*b <= float_value(xu) * float_value(yu))

(*
forall a:real. forall b:real. 
       is_finite(xl) and float_value(xl) <= a and 
       is_finite(yl) and float_value(yl) <= b and is_finite(tl) ->
           float_value(tl) <= a*b

*)


(*
 forall a:real. forall b:real. 
       is_minus_infinity(xl) and 
       is_finite(yl) and float_value(yl) <= b ->
           float_less_than_real(tl,a*b)

prouvé par tous

*)

(*
 forall a:real. forall b:real. 
       is_minus_infinity(yl) and 
       is_finite(xl) and float_value(xl) <= a ->
           float_less_than_real(tl,a*b)

prouvé par tous
*)

(*
 forall a:real. forall b:real. 
       is_minus_infinity(yl) and 
       is_minus_infinity(xl) ->
           float_less_than_real(tl,a*b)

prouve par tous 

*)

(*
  forall a:real. forall b:real. 
       float_less_than_real(xl,a) and float_less_than_real(yl,b) ->
           float_less_than_real(tl,a*b)

*)

}


