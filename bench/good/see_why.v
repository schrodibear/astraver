(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

(* Why obligation from file "good/see.mlw", characters 138-140 *)
Lemma f_po_1 : 
  (b: Z)
  (b0: Z)
  (Post1: b0 = `1 - b`)
  `b0 = b0` /\ `b0 = 1 - b`.
Proof.
Intuition.
Save.

Definition f (* validation *)
  : (u: unit)(b: Z)
    (sig_2 Z Z [b0: Z][result: Z](`result = b0` /\ `b0 = 1 - b`))
  := [u: unit; b: Z]
       let (b0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1 - b` `1 - b`
           (refl_equal ? `1 - b`)) in
         (exist_2 [b3: Z][result0: unit]b3 = `1 - b` result tt Post1) in
       let (result0, Post2) = (exist_1 [result0: Z]`result0 = b0` /\
         `b0 = 1 - b` b0 (f_po_1 b b0 Post1)) in
       (exist_2 [b3: Z][result1: Z]`result1 = b3` /\ `b3 = 1 - b` b0 
       result0 Post2).

(* Why obligation from file "good/see.mlw", characters 230-242 *)
Lemma k_po_1 : 
  (b0: Z)
  (Post1: b0 = `1`)
  (b3: Z)
  (aux_4: Z)
  (Post4: `aux_4 = b3` /\ `b3 = 1 - b0`)
  (b4: Z)
  (aux_2: Z)
  (Post8: `aux_2 = b4` /\ `b4 = 1 - b3`)
  ((result:Z)
   ((b:Z)
    (`result = b` /\ `b = 1 - b4` ->
     ((result0:Z)
      ((b0:Z)
       (`result0 = b0` /\ `b0 = 1 - b` -> `1 - aux_2 + aux_4 = 0` /\
        `result0 * (1 - result) = 1`)))))).
Proof.
Intuition.
Subst result result0 b b0 b1 b3 b4; Ring.
Save.

(* Why obligation from file "good/see.mlw", characters 278-290 *)
Lemma k_po_2 : 
  (b0: Z)
  (Post1: b0 = `1`)
  (b4: Z)
  (b3: Z)
  (Post2: ((result:Z)
           ((b:Z)
            (`result = b` /\ `b = 1 - b4` ->
             ((result0:Z)
              ((b0:Z)
               (`result0 = b0` /\ `b0 = 1 - b` -> `b3 = 0` /\
                `result0 * (1 - result) = 1`)))))))
  (b5: Z)
  (aux_6: Z)
  (Post15: `aux_6 = b5` /\ `b5 = 1 - b4`)
  ((result:Z)
   ((b:Z)
    (`result = b` /\ `b = 1 - b5` -> `b3 = 0` /\ `result * (1 - aux_6) = 1`))).
Proof.
LinearIntuition.
Save.

(* Why obligation from file "good/see.mlw", characters 266-291 *)
Lemma k_po_3 : 
  (b0: Z)
  (Post1: b0 = `1`)
  (b4: Z)
  (b3: Z)
  (Post2: ((result:Z)
           ((b:Z)
            (`result = b` /\ `b = 1 - b4` ->
             ((result0:Z)
              ((b0:Z)
               (`result0 = b0` /\ `b0 = 1 - b` -> `b3 = 0` /\
                `result0 * (1 - result) = 1`)))))))
  (b5: Z)
  (aux_7: Z)
  (Post14: ((result:Z)
            ((b:Z)
             (`result = b` /\ `b = 1 - b5` -> `b3 = 0` /\
              `result * aux_7 = 1`))))
  (b6: Z)
  (aux_5: Z)
  (Post19: `aux_5 = b6` /\ `b6 = 1 - b5`)
  `b3 = 0` /\ `aux_5 * aux_7 = 1`.
Proof.
LinearIntuition.
Save.

Definition k (* validation *)
  : (u: unit)(b: Z)(b1: Z)(b2: Z)
    (sig_4 Z Z Z unit [b0: Z][b4: Z][b3: Z][result: unit](`b4 = 0` /\
     `b3 = 1`))
  := [u: unit; b: Z; b1: Z; b2: Z]
       let (b0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [b3: Z][result0: unit]b3 = `1` result tt Post1) in
       let (b4, b3, result0, Post2) =
         let (b3, result0, Post3) =
           let (b3, aux_4, Post4) =
             let (b3, result2, Post5) = (f tt b0) in
             (exist_2 [b4: Z][result3: Z]`result3 = b4` /\ `b4 = 1 - b0` 
             b3 result2 Post5) in
           let (b4, result0, Post6) =
             let (b4, aux_3, Post7) =
               let (b4, aux_2, Post8) =
                 let (b4, result2, Post9) = (f tt b3) in
                 (exist_2 [b5: Z][result3: Z]`result3 = b5` /\
                 `b5 = 1 - b3` b4 result2 Post9) in
               let (result0, Post10) = (exist_1 [result0: Z]
                 ((result:Z)
                  ((b:Z)
                   (`result = b` /\ `b = 1 - b4` ->
                    ((result1:Z)
                     ((b0:Z)
                      (`result1 = b0` /\ `b0 = 1 - b` ->
                       `result0 + aux_4 = 0` /\ `result1 * (1 - result) = 1`)))))) 
                 `1 - aux_2`
                 (k_po_1 b0 Post1 b3 aux_4 Post4 b4 aux_2 Post8)) in
               (exist_2 [b5: Z][result1: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b5` ->
                  ((result0:Z)
                   ((b0:Z)
                    (`result0 = b0` /\ `b0 = 1 - b` ->
                     `result1 + aux_4 = 0` /\ `result0 * (1 - result) = 1`)))))) 
               b4 result0 Post10) in
             let (result0, Post11) = (exist_1 [result0: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b4` ->
                  ((result1:Z)
                   ((b0:Z)
                    (`result1 = b0` /\ `b0 = 1 - b` -> `result0 = 0` /\
                     `result1 * (1 - result) = 1`)))))) `aux_3 + aux_4`
               Post7) in
             (exist_2 [b5: Z][result1: Z]
             ((result:Z)
              ((b:Z)
               (`result = b` /\ `b = 1 - b5` ->
                ((result0:Z)
                 ((b0:Z)
                  (`result0 = b0` /\ `b0 = 1 - b` -> `result1 = 0` /\
                   `result0 * (1 - result) = 1`)))))) b4
             result0 Post11) in
           (exist_2 [b5: Z][result1: Z]
           ((result:Z)
            ((b:Z)
             (`result = b` /\ `b = 1 - b5` ->
              ((result0:Z)
               ((b0:Z)
                (`result0 = b0` /\ `b0 = 1 - b` -> `result1 = 0` /\
                 `result0 * (1 - result) = 1`)))))) b4
           result0 Post6) in
         (exist_3 [b6: Z][b5: Z][result1: unit]
         ((result:Z)
          ((b:Z)
           (`result = b` /\ `b = 1 - b6` ->
            ((result0:Z)
             ((b0:Z)
              (`result0 = b0` /\ `b0 = 1 - b` -> `b5 = 0` /\
               `result0 * (1 - result) = 1`)))))) b3
         result0 tt Post3) in
       let (b6, b5, result1, Post12) =
         let (b5, result1, Post13) =
           let (b5, aux_7, Post14) =
             let (b5, aux_6, Post15) =
               let (b5, result3, Post16) = (f tt b4) in
               (exist_2 [b6: Z][result4: Z]`result4 = b6` /\ `b6 = 1 - b4` 
               b5 result3 Post16) in
             let (result1, Post17) = (exist_1 [result1: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b5` -> `b3 = 0` /\
                  `result * result1 = 1`))) `1 - aux_6`
               (k_po_2 b0 Post1 b4 b3 Post2 b5 aux_6 Post15)) in
             (exist_2 [b6: Z][result2: Z]
             ((result:Z)
              ((b:Z)
               (`result = b` /\ `b = 1 - b6` -> `b3 = 0` /\
                `result * result2 = 1`))) b5
             result1 Post17) in
           let (b6, result1, Post18) =
             let (b6, aux_5, Post19) =
               let (b6, result3, Post20) = (f tt b5) in
               (exist_2 [b7: Z][result4: Z]`result4 = b7` /\ `b7 = 1 - b5` 
               b6 result3 Post20) in
             let (result1, Post21) = (exist_1 [result1: Z]`b3 = 0` /\
               `result1 = 1` `aux_5 * aux_7`
               (k_po_3 b0 Post1 b4 b3 Post2 b5 aux_7 Post14 b6 aux_5 Post19)) in
             (exist_2 [b7: Z][result2: Z]`b3 = 0` /\ `result2 = 1` b6 
             result1 Post21) in
           (exist_2 [b7: Z][result2: Z]`b3 = 0` /\ `result2 = 1` b6 result1
           Post18) in
         (exist_3 [b8: Z][b7: Z][result2: unit]`b3 = 0` /\ `b7 = 1` b5
         result1 tt Post13) in
       (exist_4 [b9: Z][b8: Z][b7: Z][result2: unit]`b8 = 0` /\ `b7 = 1` 
       b6 b3 b5 result1 Post12).

