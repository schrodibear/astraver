(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Why.
Require Export JessieGappa.



Lemma round_down_less: forall f x, (round_float f down x <= x)%R.
intros;case f;unfold round_float.
unfold gappa_rounding.
unfold rounding_float.
Admitted.


(*Why predicate*) Definition float_less_than_real  (x:gen_float) (y:R)
  := (is_finite x) /\ (Rle (float_value x) y) \/ (is_minus_infinity x).

(*Why predicate*) Definition real_less_than_float  (x:R) (y:gen_float)
  := (is_finite y) /\ (Rle x (float_value y)) \/ (is_plus_infinity y).

(* Why obligation from file "interval_arith_full.why", line 18, characters 2-60: *)
(*Why goal*) Lemma mul_dn_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_not_NaN x) /\ (is_not_NaN y) /\
                (((is_infinite x) -> ~(eq (float_value y) (0)%R) /\
                  (diff_sign x y))) /\
                (((is_infinite y) -> ~(eq (float_value x) (0)%R) /\
                  (diff_sign x y)))),
  forall (result: gen_float),
  forall (HW_2: (((is_NaN x) \/ (is_NaN y) -> (is_NaN result))) /\
                (((is_gen_zero x) /\ (is_infinite y) -> (is_NaN result))) /\
                (((is_finite x) /\ (is_infinite y) /\
                  ~(eq (float_value x) (0)%R) -> (is_infinite result))) /\
                (((is_infinite x) /\ (is_gen_zero y) -> (is_NaN result))) /\
                (((is_infinite x) /\ (is_finite y) /\
                  ~(eq (float_value y) (0)%R) -> (is_infinite result))) /\
                (((is_infinite x) /\ (is_infinite y) -> (is_infinite result))) /\
                (((is_finite x) /\ (is_finite y) /\
                  (no_overflow
                   Double down (Rmult (float_value x) (float_value y))) ->
                  (is_finite result) /\
                  (eq (float_value result) (round_float
                                            Double down (Rmult
                                                         (float_value x) (
                                                         float_value y)))))) /\
                (((is_finite x) /\ (is_finite y) /\
                  ~(no_overflow
                    Double down (Rmult (float_value x) (float_value y))) ->
                  (overflow_value Double down result))) /\
                (product_sign result x y) /\
                (eq (exact_value result) (Rmult
                                          (exact_value x) (exact_value y))) /\
                (eq (model_value result) (Rmult
                                          (model_value x) (model_value y)))),
  (float_less_than_real result (Rmult (float_value x) (float_value y))).
Proof.
unfold float_less_than_real,product_sign, is_not_NaN,is_finite,is_minus_infinity.
intros.
decompose [and or] HW_2; clear HW_2.
decompose [and] HW_1; clear HW_1.
elim H9.
elim H13.
intros.
case (overflow_dec Double down (float_value x * float_value y)).
intros.
left.
generalize (H5 (conj H16 (conj H14 H17))).
intros (H18,H19).
split; trivial.
rewrite H19.
apply round_down_less (* Admitted above *).
intros.
generalize (proj1 (H6 (conj H16 (conj H14 H17))) (refl_equal _)).
clear H6.
intros H6.
case (same_sign_dec x y).
intros.
rewrite H8 in *;auto.
left.
split.
clear -H6.
intuition.
generalize (proj2 H6 (refl_equal _)); clear H6; intros (H6, h1).
rewrite h1.
unfold no_overflow in H17.
unfold same_sign in H18.
case (Req_dec (genf x) 0%R).
intro.
contradiction H17.
unfold float_value.
rewrite H19.
rewrite Rmult_0_l.
rewrite round_of_zero,Rabs_R0.
unfold max_gen_float.
admit. (*as in JessieGappa*)
intro x_not_zero.
case (Req_dec (genf y) 0%R).
intro.
contradiction H17.
unfold float_value.
rewrite H19.
rewrite Rmult_0_r.
rewrite round_of_zero,Rabs_R0.
admit. (*as in JessieGappa*)
intro y_not_zero.
generalize (sign_invariant x H16 x_not_zero); intro x_sign_inv.
generalize (sign_invariant y H14 y_not_zero); intro y_sign_inv.
destruct (float_sign x).
destruct (float_sign y).
unfold same_sign_real_bool in *.
unfold float_value in *.
clear -x_sign_inv y_sign_inv H17.
apply Rnot_lt_le.
intros H.
apply H17.
rewrite Rabs_right.
apply Rlt_le.
apply Rle_lt_trans with (2 := H).
apply round_down_less (* Admitted above *).
replace R0 with (round_float Double down 0).
unfold round_float.
apply Rle_ge.
apply Gappa_round.round_extension_monotone.
apply Rlt_le.
admit.
apply round_of_zero.
discriminate.
destruct (float_sign y).
discriminate.
unfold same_sign_real_bool in *.
unfold float_value.
admit. (* reasoning of reals and Rabs as above *)


intro; right.
clear -H10 H6 H18;intuition.

intros; right.
clear -H15 H10 H14 H16 H0;intuition.

elim H13.
intros; right.
clear -H12 H10 H14 H16 H3;intuition.

intros; right.
clear -H12 H15 H10 H14 H16 H4; intuition.

Qed.



(* Why obligation from file "interval_arith_full.why", line 57, characters 0-58: *)
(*Why goal*) Lemma mul_up_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_not_NaN x) /\ (is_not_NaN y) /\
                (((is_infinite x) -> ~(eq (float_value y) (0)%R) /\
                  (diff_sign x y))) /\
                (((is_infinite y) -> ~(eq (float_value x) (0)%R) /\
                  (diff_sign x y)))),
  forall (result: gen_float),
  forall (HW_2: (((is_NaN y) -> (is_NaN result))) /\
                (((is_infinite y) -> (is_infinite result))) /\
                (((is_finite y) /\
                  (no_overflow Double down (Ropp (float_value y))) ->
                  (is_finite result) /\
                  (eq (float_value result) (round_float
                                            Double down (Ropp (float_value y)))))) /\
                (((is_finite y) /\
                  ~(no_overflow Double down (Ropp (float_value y))) ->
                  (overflow_value Double down result))) /\
                (diff_sign result y) /\
                (eq (exact_value result) (Ropp (exact_value y))) /\
                (eq (model_value result) (Ropp (model_value y)))),
  forall (result0: gen_float),
  forall (HW_3: (((is_NaN x) \/ (is_NaN result) -> (is_NaN result0))) /\
                (((is_gen_zero x) /\ (is_infinite result) -> (is_NaN result0))) /\
                (((is_finite x) /\ (is_infinite result) /\
                  ~(eq (float_value x) (0)%R) -> (is_infinite result0))) /\
                (((is_infinite x) /\ (is_gen_zero result) -> (is_NaN result0))) /\
                (((is_infinite x) /\ (is_finite result) /\
                  ~(eq (float_value result) (0)%R) -> (is_infinite result0))) /\
                (((is_infinite x) /\ (is_infinite result) ->
                  (is_infinite result0))) /\
                (((is_finite x) /\ (is_finite result) /\
                  (no_overflow
                   Double down (Rmult (float_value x) (float_value result))) ->
                  (is_finite result0) /\
                  (eq (float_value result0) (round_float
                                             Double down (Rmult
                                                          (float_value x) (
                                                          float_value result)))))) /\
                (((is_finite x) /\ (is_finite result) /\
                  ~(no_overflow
                    Double down (Rmult (float_value x) (float_value result))) ->
                  (overflow_value Double down result0))) /\
                (product_sign result0 x result) /\
                (eq (exact_value result0) (Rmult
                                           (exact_value x) (exact_value
                                                            result))) /\
                (eq (model_value result0) (Rmult
                                           (model_value x) (model_value
                                                            result)))),
  forall (result1: gen_float),
  forall (HW_4: (((is_NaN result0) -> (is_NaN result1))) /\
                (((is_infinite result0) -> (is_infinite result1))) /\
                (((is_finite result0) /\
                  (no_overflow Double down (Ropp (float_value result0))) ->
                  (is_finite result1) /\
                  (eq (float_value result1) (round_float
                                             Double down (Ropp
                                                          (float_value
                                                           result0)))))) /\
                (((is_finite result0) /\
                  ~(no_overflow Double down (Ropp (float_value result0))) ->
                  (overflow_value Double down result1))) /\
                (diff_sign result1 result0) /\
                (eq (exact_value result1) (Ropp (exact_value result0))) /\
                (eq (model_value result1) (Ropp (model_value result0)))),
  (real_less_than_float (Rmult (float_value x) (float_value y)) result1).
Proof.
Admitted.



(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma min_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_not_NaN x) /\ (is_not_NaN y)),
  forall (result: bool),
  forall (HW_2: (((is_NaN x) \/ (is_NaN y) -> result = false)) /\
                (((is_finite x) /\ (is_infinite y) ->
                  (if result then (float_sign y) = Positive
                   else (float_sign y) = Negative))) /\
                (((is_infinite x) /\ (is_finite y) ->
                  (if result then (float_sign x) = Negative
                   else (float_sign x) = Positive))) /\
                (((is_infinite x) /\ (is_infinite y) ->
                  (if result then (float_sign x) = Negative /\
                   (float_sign y) = Positive
                   else (float_sign x) = Positive \/
                   (float_sign y) = Negative))) /\
                (((is_finite x) /\ (is_finite y) ->
                  (if result then (Rlt (float_value x) (float_value y))
                   else (Rge (float_value x) (float_value y)))))),
  (if result then ((float_le_float x x) /\ (float_le_float x y))
   else ((float_le_float y x) /\ (float_le_float y y))).
Proof.
(*
destruct result.
ergo.
simplify.
ergo.
simplify.
*)
unfold float_le_float,is_not_NaN,is_plus_infinity,is_minus_infinity.
intros.
decompose [and or] HW_1; clear HW_1;
decompose [and or] HW_2; clear HW_2.

destruct result;split;left; intuition.

destruct result; [split; [left;intuition | repeat right; intuition] |  
split; right;left;intuition].

destruct result; [split; right;left;intuition | split; [repeat right;intuition | 
left;intuition]].

destruct result; split; right;intuition.
destruct (float_sign y); intuition.
Save.


(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma max_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_not_NaN x) /\ (is_not_NaN y)),
  forall (result: bool),
  forall (HW_2: (((is_NaN x) \/ (is_NaN y) -> result = false)) /\
                (((is_finite x) /\ (is_infinite y) ->
                  (if result then (float_sign y) = Negative
                   else (float_sign y) = Positive))) /\
                (((is_infinite x) /\ (is_finite y) ->
                  (if result then (float_sign x) = Positive
                   else (float_sign x) = Negative))) /\
                (((is_infinite x) /\ (is_infinite y) ->
                  (if result then (float_sign x) = Positive /\
                   (float_sign y) = Negative
                   else (float_sign x) = Negative \/
                   (float_sign y) = Positive))) /\
                (((is_finite x) /\ (is_finite y) ->
                  (if result then (Rgt (float_value x) (float_value y))
                   else (Rle (float_value x) (float_value y)))))),
  (if result then ((float_le_float x x) /\ (float_le_float y x))
   else ((float_le_float x y) /\ (float_le_float y y))).
Proof.
unfold float_le_float,is_not_NaN,is_plus_infinity,is_minus_infinity.
intros.
decompose [and or] HW_1; clear HW_1;
decompose [and or] HW_2; clear HW_2.

destruct result; split;left; intuition.

destruct result; [split; [left;intuition | right; left; intuition] | 
split; repeat right; intuition].

destruct result; [split; repeat right; intuition | split; [right;left;intuition | 
left;intuition]].

destruct result;split;right; intuition.
destruct (float_sign y); intuition.
Save.


(*Why predicate*) Definition is_interval  (l:gen_float) (u:gen_float)
  := ((is_finite l) \/ (is_infinite l) /\ (float_sign l) = Negative) /\
     ((is_finite u) \/ (is_infinite u) /\ (float_sign u) = Positive).

(*Why predicate*) Definition in_interval  (a:R) (l:gen_float) (u:gen_float)
  := (float_less_than_real l a) /\ (real_less_than_float a u).


(* Why obligation from file "interval_arith_full.why", line 106, characters 2-113: *)
(*Why goal*) Lemma add_po_1 : 
  forall (xl: gen_float),
  forall (xu: gen_float),
  forall (yl: gen_float),
  forall (yu: gen_float),
  forall (result: gen_float),
  forall (HW_1: (((is_NaN xl) \/ (is_NaN yl) -> (is_NaN result))) /\
                (((is_finite xl) /\ (is_infinite yl) ->
                  (is_infinite result) /\ (same_sign result yl))) /\
                (((is_infinite xl) /\ (is_finite yl) ->
                  (is_infinite result) /\ (same_sign result xl))) /\
                (((is_infinite xl) /\ (is_infinite yl) /\
                  (same_sign xl yl) -> (is_infinite result) /\
                  (same_sign result xl))) /\
                (((is_infinite xl) /\ (is_infinite yl) /\
                  (diff_sign xl yl) -> (is_NaN result))) /\
                (((is_finite xl) /\ (is_finite yl) /\
                  (no_overflow
                   Double down (Rplus (float_value xl) (float_value yl))) ->
                  (is_finite result) /\
                  (eq (float_value result) (round_float
                                            Double down (Rplus
                                                         (float_value xl) (
                                                         float_value yl)))) /\
                  (sign_zero_result down result))) /\
                (((is_finite xl) /\ (is_finite yl) /\
                  ~(no_overflow
                    Double down (Rplus (float_value xl) (float_value yl))) ->
                  (same_sign_real
                   result (Rplus (float_value xl) (float_value yl))) /\
                  (overflow_value Double down result))) /\
                (eq (exact_value result) (Rplus
                                          (exact_value xl) (exact_value yl))) /\
                (eq (model_value result) (Rplus
                                          (model_value xl) (model_value yl)))),
  forall (zl: gen_float),
  forall (HW_2: zl = result),
  forall (result0: gen_float),
  forall (HW_3: (((is_NaN xu) -> (is_NaN result0))) /\
                (((is_infinite xu) -> (is_infinite result0))) /\
                (((is_finite xu) /\
                  (no_overflow Double down (Ropp (float_value xu))) ->
                  (is_finite result0) /\
                  (eq (float_value result0) (round_float
                                             Double down (Ropp
                                                          (float_value xu)))))) /\
                (((is_finite xu) /\
                  ~(no_overflow Double down (Ropp (float_value xu))) ->
                  (overflow_value Double down result0))) /\
                (diff_sign result0 xu) /\
                (eq (exact_value result0) (Ropp (exact_value xu))) /\
                (eq (model_value result0) (Ropp (model_value xu)))),
  forall (result1: gen_float),
  forall (HW_4: (((is_NaN result0) \/ (is_NaN yu) -> (is_NaN result1))) /\
                (((is_finite result0) /\ (is_infinite yu) ->
                  (is_infinite result1) /\ (diff_sign result1 yu))) /\
                (((is_infinite result0) /\ (is_finite yu) ->
                  (is_infinite result1) /\ (same_sign result1 result0))) /\
                (((is_infinite result0) /\ (is_infinite yu) /\
                  (same_sign result0 yu) -> (is_NaN result1))) /\
                (((is_infinite result0) /\ (is_infinite yu) /\
                  (diff_sign result0 yu) -> (is_infinite result1) /\
                  (same_sign result1 result0))) /\
                (((is_finite result0) /\ (is_finite yu) /\
                  (no_overflow
                   Double down (Rminus (float_value result0) (float_value yu))) ->
                  (is_finite result1) /\
                  (eq (float_value result1) (round_float
                                             Double down (Rminus
                                                          (float_value
                                                           result0) (
                                                          float_value yu)))) /\
                  (sign_zero_result down result1))) /\
                (((is_finite result0) /\ (is_finite yu) /\
                  ~(no_overflow
                    Double down (Rminus
                                 (float_value result0) (float_value yu))) ->
                  (same_sign_real
                   result1 (Rminus (float_value result0) (float_value yu))) /\
                  (overflow_value Double down result1))) /\
                (eq (exact_value result1) (Rminus
                                           (exact_value result0) (exact_value
                                                                  yu))) /\
                (eq (model_value result1) (Rminus
                                           (model_value result0) (model_value
                                                                  yu)))),
  forall (result2: gen_float),
  forall (HW_5: (((is_NaN result1) -> (is_NaN result2))) /\
                (((is_infinite result1) -> (is_infinite result2))) /\
                (((is_finite result1) /\
                  (no_overflow Double down (Ropp (float_value result1))) ->
                  (is_finite result2) /\
                  (eq (float_value result2) (round_float
                                             Double down (Ropp
                                                          (float_value
                                                           result1)))))) /\
                (((is_finite result1) /\
                  ~(no_overflow Double down (Ropp (float_value result1))) ->
                  (overflow_value Double down result2))) /\
                (diff_sign result2 result1) /\
                (eq (exact_value result2) (Ropp (exact_value result1))) /\
                (eq (model_value result2) (Ropp (model_value result1)))),
  forall (zu: gen_float),
  forall (HW_6: zu = result2),
  forall (a: R),
  forall (b: R),
  forall (HW_7: (in_interval a xl xu) /\ (in_interval b yl yu)),
  (in_interval (Rplus a b) zl zu).
Proof.
unfold in_interval, float_less_than_real, real_less_than_float.
intros.
decompose [and or] HW_1; clear HW_1.
decompose [and or] HW_3; clear HW_3.
decompose [and or] HW_4; clear HW_4.
decompose [and or] HW_5; clear HW_5.
decompose [and or] HW_7; clear HW_7.
subst.
unfold is_finite,is_infinite,is_plus_infinity,is_minus_infinity in *.
split.
case (overflow_dec Double down (float_value xl + float_value yl)).
intro.
left.
generalize (H4 (conj H33 (conj H30 H32))); intros (h1,h2).
split;trivial.
rewrite h2.
apply Rle_trans with (float_value xl + float_value yl)%R.
apply round_down_less (* Admitted above *).
auto with real.
intro.
generalize (H5 (conj H33 (conj H30 H32)));intros (h2, h3).
unfold same_sign_real in h2.
unfold overflow_value in h3.
destruct h3;clear H41.
unfold float_value in *.
unfold no_overflow in H32.
case (Req_dec (genf xl) 0).
intro.
case (Req_dec (genf yl) 0).
intro.
contradiction H32.
rewrite H41, H42.
rewrite Rplus_0_l.
rewrite round_of_zero,Rabs_R0.
admit. (*as in JessieGappa *)
intro.
rewrite H41 in h2.
rewrite Rplus_0_l in h2.
case (sign_dec yl).
intro.
generalize (sign_invariant yl H30 H42);intro yl_sign.
rewrite H43 in yl_sign.
unfold same_sign_real_bool in yl_sign.
right.
generalize ((proj1 (same_sign_real_bool_correct2 (float_sign result) 
(genf yl) h2)) yl_sign);intro.
clear -H40 H44; intuition.
intro.
generalize (sign_invariant yl H30 H42);intro yl_sign.
rewrite H43 in yl_sign.
unfold same_sign_real_bool in yl_sign.
left.
generalize ((proj1 (same_sign_real_bool_correct3 (float_sign result) 
(genf yl) h2)) yl_sign);intro.
clear -H40 H44 H41 H32 H35 H38 yl_sign.
split;intuition.
rewrite H2.
rewrite Rabs_right in H32.
rewrite H41, Rplus_0_l in H32.
apply Rle_trans with (round_float Double down (genf yl)).
apply Rge_le.
apply Rgt_ge; apply Rnot_le_gt;auto.
apply Rle_trans with (genf yl).
apply round_down_less. (* Admitted above *) 
rewrite <- Rplus_0_l with (genf yl); rewrite <- H41; auto with real.
rewrite H41, Rplus_0_l.
admit. (* round_float_of_pos_real_underflow in JessieGappa *)
intro.
case (Req_dec (genf yl) 0).
intro.
admit. (* as above *)

intro.
case (Rtotal_order (genf xl + genf yl) 0).
intro.
right.
generalize ((proj1 (same_sign_real_bool_correct2 (float_sign result) 
(genf xl + genf yl) h2)) H43);intro.
split;auto.
clear -H40 H44;intuition.
intro h3.
destruct h3.
rewrite H43 in h2.
generalize (same_sign_real_bool_zero1 (float_sign result));intro.
contradiction H44.
generalize ((proj1 (same_sign_real_bool_correct3 (float_sign result) 
(genf xl + genf yl) h2)) H43);intro.
left.
rewrite H44 in H40.
clear -H40 H35 H38 H32 H43.
split;intuition.
rewrite H2.
rewrite Rabs_right in H32.
apply Rle_trans with (round_float Double down (genf xl + genf yl)).
apply Rlt_le.
apply Rnot_le_lt;auto.
apply Rle_trans with (genf xl + genf yl)%R.
apply round_down_less (* Admitted above *).
auto with real.
admit. (* round_float_of_pos_real_underflow in JessieGappa *)

case (overflow_dec Double down (- float_value xu)).
intro.
generalize (H9 (conj H34 H32));intros (h1,h2).
case (overflow_dec Double down (float_value result0 - float_value yu)).
intro.
generalize (H20 (conj h1 (conj H37 H40)));intros (h3,h4).
unfold no_overflow in H40.
rewrite <- h4 in H40.
generalize (bounded_real_no_overflow Double down 
(float_value result1) H40);intro.
case (overflow_dec Double down (-float_value result1)).
intro.
generalize (H25 (conj h3 H42));intros (h5,h6).
left.
split;auto.
rewrite h6,h4,h2.
apply Rle_trans with (- ((- (float_value xu)) - float_value yu))%R.
rewrite (Ropp_minus_distr (-float_value xu) (float_value yu)).
admit.
admit. (*apply round_down_less:Admitted above with some modification *)
intro.
generalize (proj1 (H27 (conj h3 H42)));intro.
case (Rtotal_order (float_value result1) 0);intro.
generalize (finite_sign_neg1 result1 (conj h3 H44));intro.
unfold diff_sign in H28.
rewrite H45 in H28.
generalize (sign_not_neg_pos result2 H28);intro.
rewrite H46 in H43.
left.
clear -H43 H36 H39 H32 H40 H41 H42.
split; intuition.
rewrite H2.
unfold no_overflow in *.
apply Rle_trans with (float_value xu + float_value yu)%R.
auto with real.
admit. (* !!!!*)
destruct H44.
contradiction H42.
rewrite H44,Ropp_0.
apply bounded_real_no_overflow.
rewrite Rabs_R0.
admit.
generalize (finite_sign_pos1 result1 (conj h3 H44));intro.
unfold diff_sign in H28.
rewrite H45 in H28.
generalize (sign_not_pos_neg result2 H28);intro.
rewrite H46 in H43.
right.

 







H28 : diff_sign result2 result1


generalize (H21 (conj h1 (conj H37 H40)));intros (h5,h6).
unfold overflow_value in h6.
destruct h6; clear H42.
unfold same_sign_real in h5.
unfold no_overflow in H40.
generalize (same_sign_real_bool_zero3 (float_sign result1) 
(float_value result0 - float_value yu) h5);intro.
case (Req_dec (float_value xu) 0).
intro.
rewrite H43 in h2.
rewrite Ropp_0 in h2.
assert (float_value result0= 0)%R.
rewrite h2.
unfold round_float,down;gappa.
rewrite H44 in h5.
case (sign_dec yu).
intro.

rewrite Rminus_0_l in h2.




case (Req_dec (genf yu) 0).
intro.
rewrite H43 in h5


destruct 
unfold no_overflow in H41.
unfold diff_sign,float_value in *.
case (Req_dec (genf result0 - genf yu) 0).
intro.
rewrite H42 in h4.
(*sign of 0=result1 ????).
 

case (sign_dec xu).
intro.
assert (float_sign result0=Positive).
rewrite H42 in H12;apply (sign_not_neg_pos result0 H12).
case (Rtotal_order (genf result0 - genf yu) 0).


admit.
admit.
admit.

intros.
destruct H32.
destruct H36.
destruct H37.
destruct H38.
split.
admit. (*as above *)
case (overflow_dec Double down (- float_value xu)).
intro.
generalize (H9 (conj H36 H43));intros (h1,h2).
generalize (H17 (conj h1 H32));intros (h3,h4).
generalize (H26 (h3)); intros (h5,h6).
right.
split;auto.
unfold diff_sign in *.
rewrite H39 in h4.
clear -h4 h6;
assert (float_sign result1=Negative) by (apply (sign_not_pos_neg result1 h4));
rewrite H in h6;apply (sign_not_neg_pos result2 h6).
intro.
generalize (proj1 (H11 (conj H36 H43)) (refl_equal _)).
clear H11;intros.
case (sign_dec xu).
intro.
unfold diff_sign in*.
rewrite H44 in H12.
assert (float_sign result0 =Positive).
apply (sign_not_neg_pos result0 H12).
generalize ((proj2 H11) H45);intros (h1,h2).
generalize (H17 (conj h1 H32));intros (h3,h4).
generalize (H26 (h3)); intros (h5,h6).
right.
split;auto.
rewrite H39 in h4.
assert (float_sign result1=Negative) by (apply (sign_not_pos_neg result1 h4)).
rewrite H46 in h6.
apply (sign_not_neg_pos result2 h6).
intro.
unfold diff_sign in*.
rewrite H44 in H12.
assert (float_sign result0 =Negative).
apply (sign_not_pos_neg result0 H12).
generalize ((proj1 H11) H45); intro h.
assert (float_sign result0 <> float_sign yu).
rewrite H45,H39;discriminate.
generalize (H19 (conj h (conj H32 H46)));intros (h1,h2).
unfold same_sign in h2;rewrite H45 in h2.
generalize (H26 (h1)); intros (h4,h5).
right;rewrite h2 in h5.
split;auto.
apply (sign_not_neg_pos result2 h5).


intros.
destruct H32.
destruct H36.
destruct H37.
split.
admit.  (*as above *)







(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma mul_po_1 : 
  forall (xl: gen_float),
  forall (xu: gen_float),
  forall (yl: gen_float),
  forall (yu: gen_float),
  forall (zl: gen_float),
  forall (zu: gen_float),
  forall (HW_1: (is_interval xl xu) /\ (is_interval yl yu)),
  forall (result: gen_float),
  forall (HW_2: result = (gen_float_of_real_logic Double down (0)%R)),
  forall (zero: gen_float),
  forall (HW_3: zero = result),
  forall (result0: bool),
  forall (HW_4: (((is_NaN xl) \/ (is_NaN zero) -> result0 = false)) /\
                (((is_finite xl) /\ (is_infinite zero) ->
                  (if result0 then (float_sign zero) = Positive
                   else (float_sign zero) = Negative))) /\
                (((is_infinite xl) /\ (is_finite zero) ->
                  (if result0 then (float_sign xl) = Negative
                   else (float_sign xl) = Positive))) /\
                (((is_infinite xl) /\ (is_infinite zero) ->
                  (if result0 then (float_sign xl) = Negative /\
                   (float_sign zero) = Positive
                   else (float_sign xl) = Positive \/
                   (float_sign zero) = Negative))) /\
                (((is_finite xl) /\ (is_finite zero) ->
                  (if result0 then (Rlt (float_value xl) (float_value zero))
                   else (Rge (float_value xl) (float_value zero)))))),
  (if result0
   then (forall (result:bool),
         ((((is_NaN xu) \/ (is_NaN zero) -> result = false)) /\
          (((is_finite xu) /\ (is_infinite zero) ->
            (if result then (float_sign zero) = Negative
             else (float_sign zero) = Positive))) /\
          (((is_infinite xu) /\ (is_finite zero) ->
            (if result then (float_sign xu) = Positive
             else (float_sign xu) = Negative))) /\
          (((is_infinite xu) /\ (is_infinite zero) ->
            (if result then (float_sign xu) = Positive /\
             (float_sign zero) = Negative else (float_sign xu) = Negative \/
             (float_sign zero) = Positive))) /\
          (((is_finite xu) /\ (is_finite zero) ->
            (if result then (Rgt (float_value xu) (float_value zero))
             else (Rle (float_value xu) (float_value zero))))) ->
          (if result
           then (forall (result:bool),
                 ((((is_NaN yl) \/ (is_NaN zero) -> result = false)) /\
                  (((is_finite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign zero) = Positive
                     else (float_sign zero) = Negative))) /\
                  (((is_infinite yl) /\ (is_finite zero) ->
                    (if result then (float_sign yl) = Negative
                     else (float_sign yl) = Positive))) /\
                  (((is_infinite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign yl) = Negative /\
                     (float_sign zero) = Positive
                     else (float_sign yl) = Positive \/
                     (float_sign zero) = Negative))) /\
                  (((is_finite yl) /\ (is_finite zero) ->
                    (if result then (Rlt (float_value yl) (float_value zero))
                     else (Rge (float_value yl) (float_value zero))))) ->
                  (if result
                   then (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xl) /\
                           (is_not_NaN yu) /\
                           (((is_infinite xl) ->
                             ~(eq (float_value yu) (0)%R) /\
                             (diff_sign xl yu))) /\
                           (((is_infinite yu) ->
                             ~(eq (float_value xl) (0)%R) /\
                             (diff_sign xl yu)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xl) (float_value yu))) ->
                             (((is_not_NaN xu) /\ (is_not_NaN yl) /\
                             (((is_infinite xu) ->
                               ~(eq (float_value yl) (0)%R) /\
                               (diff_sign xu yl))) /\
                             (((is_infinite yl) ->
                               ~(eq (float_value xu) (0)%R) /\
                               (diff_sign xu yl)))) /\
                             (forall (result0:gen_float),
                              ((float_less_than_real
                                result0 (Rmult
                                         (float_value xu) (float_value yl))) ->
                               (((is_not_NaN result) /\
                               (is_not_NaN result0)) /\
                               (forall (result1:gen_float),
                                ((float_le_float result1 result) /\
                                 (float_le_float result1 result0) ->
                                 (forall (tl:gen_float),
                                  (tl = result1 -> (((is_not_NaN xl) /\
                                   (is_not_NaN yl) /\
                                   (((is_infinite xl) ->
                                     ~(eq (float_value yl) (0)%R) /\
                                     (diff_sign xl yl))) /\
                                   (((is_infinite yl) ->
                                     ~(eq (float_value xl) (0)%R) /\
                                     (diff_sign xl yl)))) /\
                                   (forall (result:gen_float),
                                    ((real_less_than_float
                                      (Rmult
                                       (float_value xl) (float_value yl)) result) ->
                                     (((is_not_NaN xu) /\ (is_not_NaN yu) /\
                                     (((is_infinite xu) ->
                                       ~(eq (float_value yu) (0)%R) /\
                                       (diff_sign xu yu))) /\
                                     (((is_infinite yu) ->
                                       ~(eq (float_value xu) (0)%R) /\
                                       (diff_sign xu yu)))) /\
                                     (forall (result0:gen_float),
                                      ((real_less_than_float
                                        (Rmult
                                         (float_value xu) (float_value yu)) result0) ->
                                       (((is_not_NaN result) /\
                                       (is_not_NaN result0)) /\
                                       (forall (result1:gen_float),
                                        ((float_le_float result result1) /\
                                         (float_le_float result0 result1) ->
                                         (forall (tu:gen_float),
                                          (tu = result1 ->
                                           ((is_interval zl zu) /\
                                           (forall (a:R),
                                            (forall (b:R),
                                             ((in_interval a xl xu) /\
                                              (in_interval b yl yu) ->
                                              (in_interval (Rmult a b) tl tu)))))))))))))))))))))))))))
                           else (((is_not_NaN xu) /\ (is_not_NaN yl) /\
                           (((is_infinite xu) ->
                             ~(eq (float_value yl) (0)%R) /\
                             (diff_sign xu yl))) /\
                           (((is_infinite yl) ->
                             ~(eq (float_value xu) (0)%R) /\
                             (diff_sign xu yl)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xu) (float_value yl))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xl) /\
                               (is_not_NaN yl) /\
                               (((is_infinite xl) ->
                                 ~(eq (float_value yl) (0)%R) /\
                                 (diff_sign xl yl))) /\
                               (((is_infinite yl) ->
                                 ~(eq (float_value xl) (0)%R) /\
                                 (diff_sign xl yl)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xl) (float_value yl)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu))))))))))))))))))
                   else (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xl) /\
                           (is_not_NaN yu) /\
                           (((is_infinite xl) ->
                             ~(eq (float_value yu) (0)%R) /\
                             (diff_sign xl yu))) /\
                           (((is_infinite yu) ->
                             ~(eq (float_value xl) (0)%R) /\
                             (diff_sign xl yu)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xl) (float_value yu))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xu) /\
                               (is_not_NaN yu) /\
                               (((is_infinite xu) ->
                                 ~(eq (float_value yu) (0)%R) /\
                                 (diff_sign xu yu))) /\
                               (((is_infinite yu) ->
                                 ~(eq (float_value xu) (0)%R) /\
                                 (diff_sign xu yu)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xu) (float_value yu)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu)))))))))))))))
                           else (forall (tl:gen_float),
                                 (tl = zero ->
                                  (forall (tu:gen_float),
                                   (tu = zero -> ((is_interval zl zu) /\
                                    (forall (a:R),
                                     (forall (b:R),
                                      ((in_interval a xl xu) /\
                                       (in_interval b yl yu) ->
                                       (in_interval (Rmult a b) tl tu)))))))))))))))
           else (forall (result:bool),
                 ((((is_NaN yl) \/ (is_NaN zero) -> result = false)) /\
                  (((is_finite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign zero) = Positive
                     else (float_sign zero) = Negative))) /\
                  (((is_infinite yl) /\ (is_finite zero) ->
                    (if result then (float_sign yl) = Negative
                     else (float_sign yl) = Positive))) /\
                  (((is_infinite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign yl) = Negative /\
                     (float_sign zero) = Positive
                     else (float_sign yl) = Positive \/
                     (float_sign zero) = Negative))) /\
                  (((is_finite yl) /\ (is_finite zero) ->
                    (if result then (Rlt (float_value yl) (float_value zero))
                     else (Rge (float_value yl) (float_value zero))))) ->
                  (if result
                   then (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xl) /\
                           (is_not_NaN yu) /\
                           (((is_infinite xl) ->
                             ~(eq (float_value yu) (0)%R) /\
                             (diff_sign xl yu))) /\
                           (((is_infinite yu) ->
                             ~(eq (float_value xl) (0)%R) /\
                             (diff_sign xl yu)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xl) (float_value yu))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xl) /\
                               (is_not_NaN yl) /\
                               (((is_infinite xl) ->
                                 ~(eq (float_value yl) (0)%R) /\
                                 (diff_sign xl yl))) /\
                               (((is_infinite yl) ->
                                 ~(eq (float_value xl) (0)%R) /\
                                 (diff_sign xl yl)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xl) (float_value yl)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu)))))))))))))))
                           else (((is_not_NaN xu) /\ (is_not_NaN yu) /\
                           (((is_infinite xu) ->
                             ~(eq (float_value yu) (0)%R) /\
                             (diff_sign xu yu))) /\
                           (((is_infinite yu) ->
                             ~(eq (float_value xu) (0)%R) /\
                             (diff_sign xu yu)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xu) (float_value yu))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xl) /\
                               (is_not_NaN yl) /\
                               (((is_infinite xl) ->
                                 ~(eq (float_value yl) (0)%R) /\
                                 (diff_sign xl yl))) /\
                               (((is_infinite yl) ->
                                 ~(eq (float_value xl) (0)%R) /\
                                 (diff_sign xl yl)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xl) (float_value yl)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu))))))))))))))))))
                   else (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xl) /\
                           (is_not_NaN yu) /\
                           (((is_infinite xl) ->
                             ~(eq (float_value yu) (0)%R) /\
                             (diff_sign xl yu))) /\
                           (((is_infinite yu) ->
                             ~(eq (float_value xl) (0)%R) /\
                             (diff_sign xl yu)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xl) (float_value yu))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xu) /\
                               (is_not_NaN yl) /\
                               (((is_infinite xu) ->
                                 ~(eq (float_value yl) (0)%R) /\
                                 (diff_sign xu yl))) /\
                               (((is_infinite yl) ->
                                 ~(eq (float_value xu) (0)%R) /\
                                 (diff_sign xu yl)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xu) (float_value yl)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu)))))))))))))))
                           else (forall (tl:gen_float),
                                 (tl = zero ->
                                  (forall (tu:gen_float),
                                   (tu = zero -> ((is_interval zl zu) /\
                                    (forall (a:R),
                                     (forall (b:R),
                                      ((in_interval a xl xu) /\
                                       (in_interval b yl yu) ->
                                       (in_interval (Rmult a b) tl tu))))))))))))))))))
   else (forall (result:bool),
         ((((is_NaN xu) \/ (is_NaN zero) -> result = false)) /\
          (((is_finite xu) /\ (is_infinite zero) ->
            (if result then (float_sign zero) = Negative
             else (float_sign zero) = Positive))) /\
          (((is_infinite xu) /\ (is_finite zero) ->
            (if result then (float_sign xu) = Positive
             else (float_sign xu) = Negative))) /\
          (((is_infinite xu) /\ (is_infinite zero) ->
            (if result then (float_sign xu) = Positive /\
             (float_sign zero) = Negative else (float_sign xu) = Negative \/
             (float_sign zero) = Positive))) /\
          (((is_finite xu) /\ (is_finite zero) ->
            (if result then (Rgt (float_value xu) (float_value zero))
             else (Rle (float_value xu) (float_value zero))))) ->
          (if result
           then (forall (result:bool),
                 ((((is_NaN yl) \/ (is_NaN zero) -> result = false)) /\
                  (((is_finite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign zero) = Positive
                     else (float_sign zero) = Negative))) /\
                  (((is_infinite yl) /\ (is_finite zero) ->
                    (if result then (float_sign yl) = Negative
                     else (float_sign yl) = Positive))) /\
                  (((is_infinite yl) /\ (is_infinite zero) ->
                    (if result then (float_sign yl) = Negative /\
                     (float_sign zero) = Positive
                     else (float_sign yl) = Positive \/
                     (float_sign zero) = Negative))) /\
                  (((is_finite yl) /\ (is_finite zero) ->
                    (if result then (Rlt (float_value yl) (float_value zero))
                     else (Rge (float_value yl) (float_value zero))))) ->
                  (if result
                   then (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xu) /\
                           (is_not_NaN yl) /\
                           (((is_infinite xu) ->
                             ~(eq (float_value yl) (0)%R) /\
                             (diff_sign xu yl))) /\
                           (((is_infinite yl) ->
                             ~(eq (float_value xu) (0)%R) /\
                             (diff_sign xu yl)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xu) (float_value yl))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xu) /\
                               (is_not_NaN yu) /\
                               (((is_infinite xu) ->
                                 ~(eq (float_value yu) (0)%R) /\
                                 (diff_sign xu yu))) /\
                               (((is_infinite yu) ->
                                 ~(eq (float_value xu) (0)%R) /\
                                 (diff_sign xu yu)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xu) (float_value yu)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu)))))))))))))))
                           else (((is_not_NaN xu) /\ (is_not_NaN yl) /\
                           (((is_infinite xu) ->
                             ~(eq (float_value yl) (0)%R) /\
                             (diff_sign xu yl))) /\
                           (((is_infinite yl) ->
                             ~(eq (float_value xu) (0)%R) /\
                             (diff_sign xu yl)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xu) (float_value yl))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xl) /\
                               (is_not_NaN yu) /\
                               (((is_infinite xl) ->
                                 ~(eq (float_value yu) (0)%R) /\
                                 (diff_sign xl yu))) /\
                               (((is_infinite yu) ->
                                 ~(eq (float_value xl) (0)%R) /\
                                 (diff_sign xl yu)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xl) (float_value yu)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu))))))))))))))))))
                   else (forall (result:bool),
                         ((((is_NaN yu) \/ (is_NaN zero) -> result = false)) /\
                          (((is_finite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign zero) = Negative
                             else (float_sign zero) = Positive))) /\
                          (((is_infinite yu) /\ (is_finite zero) ->
                            (if result then (float_sign yu) = Positive
                             else (float_sign yu) = Negative))) /\
                          (((is_infinite yu) /\ (is_infinite zero) ->
                            (if result then (float_sign yu) = Positive /\
                             (float_sign zero) = Negative
                             else (float_sign yu) = Negative \/
                             (float_sign zero) = Positive))) /\
                          (((is_finite yu) /\ (is_finite zero) ->
                            (if result
                             then (Rgt (float_value yu) (float_value zero))
                             else (Rle (float_value yu) (float_value zero))))) ->
                          (if result then (((is_not_NaN xl) /\
                           (is_not_NaN yl) /\
                           (((is_infinite xl) ->
                             ~(eq (float_value yl) (0)%R) /\
                             (diff_sign xl yl))) /\
                           (((is_infinite yl) ->
                             ~(eq (float_value xl) (0)%R) /\
                             (diff_sign xl yl)))) /\
                           (forall (result:gen_float),
                            ((float_less_than_real
                              result (Rmult (float_value xl) (float_value yl))) ->
                             (forall (tl:gen_float),
                              (tl = result -> (((is_not_NaN xu) /\
                               (is_not_NaN yu) /\
                               (((is_infinite xu) ->
                                 ~(eq (float_value yu) (0)%R) /\
                                 (diff_sign xu yu))) /\
                               (((is_infinite yu) ->
                                 ~(eq (float_value xu) (0)%R) /\
                                 (diff_sign xu yu)))) /\
                               (forall (result:gen_float),
                                ((real_less_than_float
                                  (Rmult (float_value xu) (float_value yu)) result) ->
                                 (forall (tu:gen_float),
                                  (tu = result -> ((is_interval zl zu) /\
                                   (forall (a:R),
                                    (forall (b:R),
                                     ((in_interval a xl xu) /\
                                      (in_interval b yl yu) ->
                                      (in_interval (Rmult a b) tl tu)))))))))))))))
                           else (forall (tl:gen_float),
                                 (tl = zero ->
                                  (forall (tu:gen_float),
                                   (tu = zero -> ((is_interval zl zu) /\
                                    (forall (a:R),
                                     (forall (b:R),
                                      ((in_interval a xl xu) /\
                                       (in_interval b yl yu) ->
                                       (in_interval (Rmult a b) tl tu)))))))))))))))
           else (forall (tl:gen_float),
                 (tl = zero ->
                  (forall (tu:gen_float),
                   (tu = zero -> ((is_interval zl zu) /\
                    (forall (a:R),
                     (forall (b:R),
                      ((in_interval a xl xu) /\ (in_interval b yl yu) ->
                       (in_interval (Rmult a b) tl tu))))))))))))).
Proof.



Save.

