(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.

Parameter q : Z -> Prop.

Lemma p1_po_1 : 
  (x: Z)
  (Pre1: (q `x + 1`))
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (q x0).
Proof. 
Intros; Rewrite Post1; Assumption.
Save.


















Lemma p2_po_1 : 
  (Pre1: (q `7`))
  (x0: Z)
  (Post1: x0 = `3 + 4`)
  (q x0).
Proof.
Intros; Rewrite Post1; Assumption.
Save.


















Lemma p3_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (x1: Z)
  (Post2: x1 = `x0 + 2`)
  x1 = `x + 3`.
Proof. 
Intros; Omega.
Save.


















Lemma p4_po_1 : 
  (x0: Z)
  (Post1: x0 = `7`)
  (x1: Z)
  (Post2: x1 = `2 * x0`)
  x1 = `14`.
Proof. 
Intros; Omega.
Save.


















Lemma p5_po_1 : 
  `3 + 4` = `7`.
Proof.
Omega.
Save.


















Lemma p6_po_1 : 
  (result: Z)
  (Post1: result = `3`)
  `result + 4` = `7`.
Proof.
Intros; Omega.
Save.


















Lemma p7_po_1 : 
  (result: Z)
  (Post1: result = `4`)
  `3 + (result + result)` = `11`.
Proof.
Intros; Omega.
Save.


















Lemma p8_po_1 : 
  (x: Z)
  (Pre1: (q `x + 1`))
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (q x0) /\ `3 + x0` = `x + 4`.
Proof.
Intuition; Rewrite Post1; Assumption.
Save.


















Lemma p9_po_1 : 
  (x0: Z)
  (Post2: x0 = `2`)
  ((x:Z) (x = `1` -> `1 + 1` = `2` /\ x = `1`)).
Proof.
Intuition.
Save.

Lemma p9_po_2 : 
  (result: Z)
  (Post3: ((x:Z) (x = `1` -> `1 + result` = `2` /\ x = `1`)))
  (x1: Z)
  (Post1: x1 = `1`)
  `1 + result` = `2` /\ x1 = `1`.
Proof.
Intuition.
Save.


















Lemma p9a_po_1 : 
  (x0: Z)
  (Post1: x0 = `1`)
  `1 + 1` = `2` /\ x0 = `1`.
Proof.
Intuition.
Save.










(*Why*) Parameter fsucc : (x: Z)(sig_1 Z [result:Z](result = `x + 1`)).

Lemma p10_po_1 : 
  (result1: Z)
  (Post1: result1 = `0 + 1`)
  result1 = `1`.
Proof.
Intros; Omega.
Save.


















Lemma p11_po_1 : 
  (result: Z)
  (Post1: result = `3 + 1`)
  (result0: Z)
  (Post4: result0 = `0 + 1`)
  `result0 + result` = `5`.
Proof.
Intros; Omega.
Save.


















Lemma p11a_po_1 : 
  (result: Z)
  (Post1: result = `1 + 1`)
  `result + result` = `4`.
Proof.
Intros; Omega.
Save.


















(*Why*) Parameter incrx :
  (_: unit)(x: Z)(sig_2 Z unit [x0:Z][result:unit](x0 = `x + 1`)).

Lemma p12_po_1 : 
  (x: Z)
  (Pre1: x = `0`)
  (x0: Z)
  (Post1: x0 = `x + 1`)
  x0 = `1`.
Proof.
Intros; Omega.
Save.


















Lemma p13_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (x1: Z)
  (Post3: x1 = `x0 + 1`)
  x1 = `x + 2`.
Proof.
Intros; Omega.
Save.


















Lemma p13a_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (x1: Z)
  (Post3: x1 = `x0 + 1`)
  x1 = `x + 2`.
Proof.
Intros; Omega.
Save.


















(*Why*) Parameter incrx2 :
  (_: unit)(x: Z)(sig_2 Z Z [x0:Z][result:Z](x0 = `x + 1` /\ result = x0)).

Lemma p14_po_1 : 
  (x: Z)
  (Pre1: x = `0`)
  (x0: Z)
  (result1: Z)
  (Post1: x0 = `x + 1` /\ result1 = x0)
  result1 = `1`.
Proof.
Intros; Omega.
Save.


















Lemma p15_po_1 : 
  `0 <= 0` /\ `0 < 10`.
Proof. (* p15_po_1 *)
Omega.
Save.


















Lemma p16_po_1 : 
  (t: (array `10` Z))
  (result: Z)
  (Post1: (store t `9` result) = (store t `9` `1`))
  `0 <= 9` /\ `9 < 10`.
Proof. (* p16_po_1 *)
Intros; Omega.
Save.


















Lemma p17_po_1 : 
  (t: (array `10` Z))
  (Pre3: `0 <= (access t 0)` /\ `(access t 0) < 10`)
  `0 <= 0` /\ `0 < 10`.
Proof. (* p17_po_1 *)
Intros; Omega.
Save.


(* 
 Local Variables:
 mode: coq 
  coq-prog-name: "coqtop -emacs -q -I ../../lib/coq"
 End:
*)


















