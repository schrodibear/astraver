(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.

Parameter q : Z -> Prop.

(* Why obligation from file "good/po.mlw", characters 153-194 *)
Lemma p1_po_1 : 
  (x: Z)
  (Pre1: (q `x + 1`))
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (q x0).
Proof. 
Intros; Rewrite Post1; Assumption.
Save.



Definition p1 := (* validation *)
  [x: Z; Pre1: (q `x + 1`)]
    let (x0, result, Post1) =
      let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
        (refl_equal ? `x + 1`)) in
      (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
    (exist_2 [x1: Z][result0: unit](q x1) x0 result
    (p1_po_1 x Pre1 x0 Post1)).

(* Why obligation from file "good/po.mlw", characters 205-243 *)
Lemma p2_po_1 : 
  (Pre1: (q `7`))
  (x0: Z)
  (Post1: x0 = `3 + 4`)
  (q x0).
Proof.
Intros; Rewrite Post1; Assumption.
Save.



Definition p2 := (* validation *)
  [x: Z; Pre1: (q `7`)]
    let (x0, result, Post1) =
      let (result, Post1) = (exist_1 [result: Z]result = `3 + 4` `3 + 4`
        (refl_equal ? `3 + 4`)) in
      (exist_2 [x1: Z][result0: unit]x1 = `3 + 4` result tt Post1) in
    (exist_2 [x1: Z][result0: unit](q x1) x0 result (p2_po_1 Pre1 x0 Post1)).

(* Why obligation from file "good/po.mlw", characters 254-303 *)
Lemma p3_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (x1: Z)
  (Post2: x1 = `x0 + 2`)
  `x1 = x + 3`.
Proof. 
Intros; Omega.
Save.



Definition p3 := (* validation *)
  [x: Z]
    let (x0, result, Post1) =
      let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
        (refl_equal ? `x + 1`)) in
      (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
    let (x1, result0, Post2) =
      let (result0, Post2) = (exist_1 [result0: Z]result0 = `x0 + 2` 
        `x0 + 2` (refl_equal ? `x0 + 2`)) in
      (exist_2 [x2: Z][result1: unit]x2 = `x0 + 2` result0 tt Post2) in
    (exist_2 [x2: Z][result1: unit]`x2 = x + 3` x1 result0
    (p3_po_1 x x0 Post1 x1 Post2)).

(* Why obligation from file "good/po.mlw", characters 314-354 *)
Lemma p4_po_1 : 
  (x0: Z)
  (Post1: x0 = `7`)
  (x1: Z)
  (Post2: x1 = `2 * x0`)
  `x1 = 14`.
Proof. 
Intros; Omega.
Save.



Definition p4 := (* validation *)
  [x: Z]
    let (x0, result, Post1) =
      let (result, Post1) = (exist_1 [result: Z]result = `7` `7`
        (refl_equal ? `7`)) in
      (exist_2 [x1: Z][result0: unit]x1 = `7` result tt Post1) in
    let (x1, result0, Post2) =
      let (result0, Post2) = (exist_1 [result0: Z]result0 = `2 * x0` 
        `2 * x0` (refl_equal ? `2 * x0`)) in
      (exist_2 [x2: Z][result1: unit]x2 = `2 * x0` result0 tt Post2) in
    (exist_2 [x2: Z][result1: unit]`x2 = 14` x1 result0
    (p4_po_1 x0 Post1 x1 Post2)).

(* Why obligation from file "good/po.mlw", characters 365-387 *)
Lemma p5_po_1 : 
  `3 + 4 = 7`.
Proof.
Omega.
Save.



Definition p5 := (* validation *)
  (exist_1 [result: Z]`result = 7` `3 + 4` p5_po_1).

(* Why obligation from file "good/po.mlw", characters 412-417 *)
Lemma p6_po_1 : 
  (a: Z)
  (Post1: a = `3`)
  `a + 4 = 7`.
Proof.
Intros; Omega.
Save.



Definition p6 := (* validation *)
  let (a, Post1) = (exist_1 [result: Z]result = `3` `3`
    (refl_equal ? `3`)) in
  let (result, Post2) = (exist_1 [result: Z]`result = 7` `a + 4`
    (p6_po_1 a Post1)) in
  (exist_1 [result0: Z]`result0 = 7` result Post2).

(* Why obligation from file "good/po.mlw", characters 463-468 *)
Lemma p7_po_1 : 
  (a: Z)
  (Post1: a = `4`)
  `3 + (a + a) = 11`.
Proof.
Intros; Omega.
Save.



Definition p7 := (* validation *)
  let (aux_1, Post2) =
    let (a, Post1) = (exist_1 [result: Z]result = `4` `4`
      (refl_equal ? `4`)) in
    let (result, Post3) = (exist_1 [result: Z]`3 + result = 11` `a + a`
      (p7_po_1 a Post1)) in
    (exist_1 [result0: Z]`3 + result0 = 11` result Post3) in
  let (result, Post4) = (exist_1 [result: Z]`result = 11` `3 + aux_1`
    Post2) in
  (exist_1 [result0: Z]`result0 = 11` result Post4).

(* Why obligation from file "good/po.mlw", characters 577-579 *)
Lemma p8_po_1 : 
  (x: Z)
  (Pre1: (q `x + 1`))
  (x0: Z)
  (Post1: x0 = `x + 1`)
  (q x0) /\ `3 + x0 = x + 4`.
Proof.
Intuition; Rewrite Post1; Assumption.
Save.



Definition p8 := (* validation *)
  [x: Z; Pre1: (q `x + 1`)]
    let (x0, aux_1, Post2) =
      let (x0, result, Post1) =
        let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
          (refl_equal ? `x + 1`)) in
        (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
      let (result0, Post3) = (exist_1 [result0: Z](q x0) /\
        `3 + result0 = x + 4` x0 (p8_po_1 x Pre1 x0 Post1)) in
      (exist_2 [x1: Z][result1: Z](q x1) /\ `3 + result1 = x + 4` x0 
      result0 Post3) in
    let (result, Post4) = (exist_1 [result: Z](q x0) /\
      `result = x + 4` `3 + aux_1` Post2) in
    (exist_2 [x1: Z][result0: Z](q x1) /\ `result0 = x + 4` x0 result Post4).

(* Why obligation from file "good/po.mlw", characters 702-703 *)
Lemma p9_po_1 : 
  (x0: Z)
  (Post3: x0 = `2`)
  ((x:Z) (x = `1` -> `1 + 1 = 2` /\ `x = 1`)).
Proof.
Intuition.
Save.

(* Why obligation from file "good/po.mlw", characters 680-681 *)
Lemma p9_po_2 : 
  (aux_2: Z)
  (Post4: ((x:Z) (x = `1` -> `1 + aux_2 = 2` /\ `x = 1`)))
  (x1: Z)
  (Post2: x1 = `1`)
  `1 + aux_2 = 2` /\ `x1 = 1`.
Proof.
Intuition.
Save.



Definition p9 := (* validation *)
  [x: Z]
    let (x0, aux_2, Post4) =
      let (x0, result, Post3) =
        let (result, Post3) = (exist_1 [result: Z]result = `2` `2`
          (refl_equal ? `2`)) in
        (exist_2 [x1: Z][result0: unit]x1 = `2` result tt Post3) in
      let (result0, Post5) = (exist_1 [result0: Z]
        ((x:Z) (x = `1` -> `1 + result0 = 2` /\ `x = 1`)) `1`
        (p9_po_1 x0 Post3)) in
      (exist_2 [x1: Z][result1: Z]
      ((x:Z) (x = `1` -> `1 + result1 = 2` /\ `x = 1`)) x0 result0 Post5) in
    let (x1, result, Post6) =
      let (x1, aux_1, Post7) =
        let (x1, result, Post2) =
          let (result, Post2) = (exist_1 [result: Z]result = `1` `1`
            (refl_equal ? `1`)) in
          (exist_2 [x2: Z][result0: unit]x2 = `1` result tt Post2) in
        let (result0, Post8) = (exist_1 [result0: Z]`result0 + aux_2 = 2` /\
          `x1 = 1` `1` (p9_po_2 aux_2 Post4 x1 Post2)) in
        (exist_2 [x2: Z][result1: Z]`result1 + aux_2 = 2` /\ `x2 = 1` 
        x1 result0 Post8) in
      let (result, Post9) = (exist_1 [result: Z]`result = 2` /\
        `x1 = 1` `aux_1 + aux_2` Post7) in
      (exist_2 [x2: Z][result0: Z]`result0 = 2` /\ `x2 = 1` x1 result Post9) in
    (exist_2 [x2: Z][result0: Z]`result0 = 2` /\ `x2 = 1` x1 result Post6).

(* Why obligation from file "good/po.mlw", characters 760-761 *)
Lemma p9a_po_1 : 
  (x0: Z)
  (Post2: x0 = `1`)
  `1 + 1 = 2` /\ `x0 = 1`.
Proof.
Intuition.
Save.



Definition p9a := (* validation *)
  [x: Z]
    let (x0, aux_1, Post3) =
      let (x0, result, Post2) =
        let (result, Post2) = (exist_1 [result: Z]result = `1` `1`
          (refl_equal ? `1`)) in
        (exist_2 [x1: Z][result0: unit]x1 = `1` result tt Post2) in
      let (result0, Post4) = (exist_1 [result0: Z]`result0 + 1 = 2` /\
        `x0 = 1` `1` (p9a_po_1 x0 Post2)) in
      (exist_2 [x1: Z][result1: Z]`result1 + 1 = 2` /\ `x1 = 1` x0 result0
      Post4) in
    let (result, Post5) = (exist_1 [result: Z]`result = 2` /\
      `x0 = 1` `aux_1 + 1` Post3) in
    (exist_2 [x1: Z][result0: Z]`result0 = 2` /\ `x1 = 1` x0 result Post5).

(*Why*) Parameter fsucc : (x: Z)(sig_1 Z [result: Z](`result = x + 1`)).

(* Why obligation from file "good/po.mlw", characters 900-924 *)
Lemma p10_po_1 : 
  (result1: Z)
  (Post1: `result1 = 0 + 1`)
  `result1 = 1`.
Proof.
Intros; Omega.
Save.



Definition p10 := (* validation *)
  let (result1, Post1) = (fsucc `0`) in
  (exist_1 [result2: Z]`result2 = 1` result1 (p10_po_1 result1 Post1)).

(* Why obligation from file "good/po.mlw", characters 936-974 *)
Lemma p11_po_1 : 
  (aux_2: Z)
  (Post1: `aux_2 = 3 + 1`)
  (aux_1: Z)
  (Post4: `aux_1 = 0 + 1`)
  `aux_1 + aux_2 = 5`.
Proof.
Intros; Omega.
Save.



Definition p11 := (* validation *)
  let (aux_2, Post1) =
    let (result1, Post2) = (fsucc `3`) in
    (exist_1 [result2: Z]`result2 = 3 + 1` result1 Post2) in
  let (result, Post3) =
    let (aux_1, Post4) =
      let (result1, Post5) = (fsucc `0`) in
      (exist_1 [result2: Z]`result2 = 0 + 1` result1 Post5) in
    let (result, Post6) = (exist_1 [result: Z]`result = 5` `aux_1 + aux_2`
      (p11_po_1 aux_2 Post1 aux_1 Post4)) in
    (exist_1 [result0: Z]`result0 = 5` result Post6) in
  (exist_1 [result0: Z]`result0 = 5` result Post3).

(* Why obligation from file "good/po.mlw", characters 1009-1014 *)
Lemma p11a_po_1 : 
  (a: Z)
  (Post1: `a = 1 + 1`)
  `a + a = 4`.
Proof.
Intros; Omega.
Save.



Definition p11a := (* validation *)
  let (a, Post1) =
    let (result1, Post2) = (fsucc `1`) in
    (exist_1 [result2: Z]`result2 = 1 + 1` result1 Post2) in
  let (result, Post3) = (exist_1 [result: Z]`result = 4` `a + a`
    (p11a_po_1 a Post1)) in
  (exist_1 [result0: Z]`result0 = 4` result Post3).

(*Why*) Parameter incrx :
  (_: unit)(x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = x + 1`)).

(* Why obligation from file "good/po.mlw", characters 1157-1189 *)
Lemma p12_po_1 : 
  (x: Z)
  (Pre1: `x = 0`)
  (x0: Z)
  (Post1: `x0 = x + 1`)
  `x0 = 1`.
Proof.
Intros; Omega.
Save.



Definition p12 := (* validation *)
  [x: Z; Pre1: `x = 0`]
    let (x0, result1, Post1) = (incrx tt x) in
    (exist_2 [x1: Z][result2: unit]`x1 = 1` x0 result1
    (p12_po_1 x Pre1 x0 Post1)).

(* Why obligation from file "good/po.mlw", characters 1201-1256 *)
Lemma p13_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: `x0 = x + 1`)
  (x1: Z)
  (Post3: `x1 = x0 + 1`)
  `x1 = x + 2`.
Proof.
Intros; Omega.
Save.



Definition p13 := (* validation *)
  [x: Z]
    let (x0, result, Post1) =
      let (x0, result1, Post2) = (incrx tt x) in
      (exist_2 [x1: Z][result2: unit]`x1 = x + 1` x0 result1 Post2) in
    let (x1, result0, Post3) =
      let (x1, result2, Post4) = (incrx tt x0) in
      (exist_2 [x2: Z][result3: unit]`x2 = x0 + 1` x1 result2 Post4) in
    (exist_2 [x2: Z][result1: unit]`x2 = x + 2` x1 result0
    (p13_po_1 x x0 Post1 x1 Post3)).

(* Why obligation from file "good/po.mlw", characters 1269-1308 *)
Lemma p13a_po_1 : 
  (x: Z)
  (x0: Z)
  (Post1: `x0 = x + 1`)
  (x1: Z)
  (Post3: `x1 = x0 + 1`)
  `x1 = x + 2`.
Proof.
Intros; Omega.
Save.



Definition p13a := (* validation *)
  [x: Z]
    let (x0, aux_1, Post1) =
      let (x0, result1, Post2) = (incrx tt x) in
      (exist_2 [x1: Z][result2: unit]`x1 = x + 1` x0 result1 Post2) in
    let (x1, result, Post3) =
      let (x1, result1, Post4) = (incrx aux_1 x0) in
      (exist_2 [x2: Z][result2: unit]`x2 = x0 + 1` x1 result1 Post4) in
    (exist_2 [x2: Z][result0: unit]`x2 = x + 2` x1 result
    (p13a_po_1 x x0 Post1 x1 Post3)).

(*Why*) Parameter incrx2 :
  (_: unit)(x: Z)
  (sig_2 Z Z [x0: Z][result: Z](`x0 = x + 1` /\ `result = x0`)).

(* Why obligation from file "good/po.mlw", characters 1456-1494 *)
Lemma p14_po_1 : 
  (x: Z)
  (Pre1: `x = 0`)
  (x0: Z)
  (result1: Z)
  (Post1: `x0 = x + 1` /\ `result1 = x0`)
  `result1 = 1`.
Proof.
Intros; Omega.
Save.



Definition p14 := (* validation *)
  [x: Z; Pre1: `x = 0`]
    let (x0, result1, Post1) = (incrx2 tt x) in
    (exist_2 [x1: Z][result2: Z]`result2 = 1` x0 result1
    (p14_po_1 x Pre1 x0 result1 Post1)).

(* Why obligation from file "good/po.mlw", characters 1545-1574 *)
Lemma p15_po_1 : 
  (t: (array Z))
  (Pre2: `(array_length t) = 10`)
  `0 <= 0` /\ `0 < (array_length t)`.
Proof. (* p15_po_1 *)
Intros; Omega.
Save.



Definition p15 := (* validation *)
  [t: (array Z); Pre2: `(array_length t) = 10`]
    let Pre1 = (p15_po_1 t Pre2) in
    (access t `0`).

(* Why obligation from file "good/po.mlw", characters 1586-1619 *)
Lemma p16_po_1 : 
  (t: (array Z))
  (Pre2: `(array_length t) = 10`)
  `0 <= 9` /\ `9 < (array_length t)`.
Proof. (* p16_po_1 *)
Intros; Simpl; Omega.
Save.



Definition p16 := (* validation *)
  [t: (array Z); Pre2: `(array_length t) = 10`]
    let Pre1 = (p16_po_1 t Pre2) in
    (exist_2 [t1: (array Z)][result1: unit]
    t1 = (store t `9` `1`) (store t `9` `1`) tt
    (refl_equal ? (store t `9` `1`))).

(* Why obligation from file "good/po.mlw", characters 1631-1687 *)
Lemma p17_po_1 : 
  (t: (array Z))
  (Pre3: `(array_length t) = 10` /\ `0 <= (access t 0)` /\
         `(access t 0) < 10`)
  `0 <= (access t 0)` /\ `(access t 0) < (array_length t)`.
Proof. (* p17_po_1 *)
Intros; Omega.
Save.


(* 
 Local Variables:
 mode: coq 
  coq-prog-name: "coqtop -emacs -q -I ../../lib/coq"
 End:
*)


(* Why obligation from file "good/po.mlw", characters 1677-1681 *)
Lemma p17_po_2 : 
  (t: (array Z))
  (Pre3: `(array_length t) = 10` /\ `0 <= (access t 0)` /\
         `(access t 0) < 10`)
  (Pre2: `0 <= (access t 0)` /\ `(access t 0) < (array_length t)`)
  `0 <= 0` /\ `0 < (array_length t)`.
Proof.
Intros; Simpl; Omega.
Save.

Definition p17 := (* validation *)
  [t: (array Z); Pre3: `(array_length t) = 10` /\ `0 <= (access t 0)` /\
   `(access t 0) < 10`]
    let Pre2 = (p17_po_1 t Pre3) in
    let Pre1 = (p17_po_2 t Pre3 Pre2) in
    (exist_2 [t1: (array Z)][result1: unit]
    t1 = (store t (access t `0`) `1`) (store t (access t `0`) `1`) tt
    (refl_equal ? (store t (access t `0`) `1`))).

(* Why obligation from file "good/po.mlw", characters 1741-1743 *)
Lemma p18_po_1 : 
  (t: (array Z))
  (x: Z)
  (Pre2: `(array_length t) = 10`)
  (aux_2: Z)
  (Post2: aux_2 = x)
  (x0: Z)
  (Post1: x0 = `0`)
  `(access (store t x0 aux_2) 0) = x` /\ `0 <= x0` /\ `x0 < (array_length t)`.
Proof.
Intuition.
Subst x0; AccessSame.
Save.

(* Why obligation from file "good/po.mlw", characters 1699-1769 *)
Lemma p18_po_2 : 
  (t: (array Z))
  (x: Z)
  (Pre2: `(array_length t) = 10`)
  (aux_2: Z)
  (Post2: aux_2 = x)
  (aux_1: Z)
  (Post4: `(access (store t aux_1 aux_2) 0) = x` /\ `0 <= aux_1` /\
          `aux_1 < (array_length t)`)
  `0 <= aux_1` /\ `aux_1 < (array_length t)`.
Proof.
Intuition.
Save.

Definition p18 := (* validation *)
  [t: (array Z); x: Z; Pre2: `(array_length t) = 10`]
    let (aux_2, Post2) = (exist_1 [result: Z]result = x x
      (refl_equal ? x)) in
    let (t0, x0, result, Post3) =
      let (x0, aux_1, Post4) =
        let (x0, result, Post1) =
          let (result, Post1) = (exist_1 [result: Z]result = `0` `0`
            (refl_equal ? `0`)) in
          (exist_2 [x1: Z][result0: unit]x1 = `0` result tt Post1) in
        let (result0, Post5) = (exist_1 [result0: Z]
          `(access (store t result0 aux_2) 0) = x` /\ `0 <= result0` /\
          `result0 < (array_length t)` x0
          (p18_po_1 t x Pre2 aux_2 Post2 x0 Post1)) in
        (exist_2 [x1: Z][result1: Z]
        `(access (store t result1 aux_2) 0) = x` /\ `0 <= result1` /\
        `result1 < (array_length t)` x0 result0 Post5) in
      let Pre1 = (p18_po_2 t x Pre2 aux_2 Post2 aux_1 Post4) in
      let (t0, result, Post6) = (exist_2 [t1: (array Z)][result1: unit]
        `(access t1 0) = x` (store t aux_1 aux_2) tt (proj1 ? ? Post4)) in
      (exist_3 [t1: (array Z)][x1: Z][result0: unit]`(access t1 0) = x` 
      t0 x0 result Post6) in
    (exist_3 [t1: (array Z)][x1: Z][result0: unit]`(access t1 0) = x` 
    t0 x0 result Post3).

