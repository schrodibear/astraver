(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export Why.
Set Implicit Arguments.

(*Why*) Parameter any_int : forall (_: unit), Z.

(*Why*) Parameter any_pointer : forall (_: unit), pointer.

(*Why logic*) Definition null : pointer.
Admitted.

Admitted.

(*Why logic*) Definition block_length : pointer -> Z.
Admitted.

(*Why logic*) Definition offset : pointer -> Z.
Admitted.

(*Why logic*) Definition shift : pointer -> Z -> pointer.
Admitted.

(*Why logic*) Definition valid : pointer -> Prop.
Admitted.

(*Why logic*) Definition valid_index : pointer -> Z -> Prop.
Admitted.

(*Why logic*) Definition valid_range : pointer -> Z -> Z -> Prop.
Admitted.

(*Why axiom*) Lemma offset_shift :
  (forall (p:pointer),
   (forall (i:Z), (offset (shift p i)) = ((offset p) + i))).
Admitted.

Admitted.

(*Why axiom*) Lemma block_length_shift :
  (forall (p:pointer),
   (forall (i:Z), (block_length (shift p i)) = (block_length p))).
Admitted.

(*Why axiom*) Lemma shift_null :
  (forall (p:pointer), (forall (i:Z), (p = null -> (shift p i) = null))).
Admitted.

(*Why axiom*) Lemma shift_not_null :
  (forall (p:pointer), (forall (i:Z), (~(p = null) -> ~((shift p i) = null)))).
Admitted.

(*Why axiom*) Lemma valid_def :
  (forall (p:pointer),
   (~(p = null) /\ 0 <= (offset p) /\ (offset p) < (block_length p) ->
    (valid p))).
Admitted.

(*Why axiom*) Lemma valid_not_null :
  (forall (p:pointer), ((valid p) -> ~(p = null))).
Admitted.

(*Why axiom*) Lemma valid1 :
  (forall (p:pointer), ((valid p) -> 0 <= (offset p))).
Admitted.

(*Why axiom*) Lemma valid2 :
  (forall (p:pointer), ((valid p) -> (offset p) < (block_length p))).
Admitted.

(*Why axiom*) Lemma valid_index_def :
  (forall (p:pointer),
   (forall (i:Z),
    (~(p = null) /\ 0 <= ((offset p) + i) /\ ((offset p) + i) <
     (block_length p) -> (valid_index p i)))).
Admitted.

(*Why axiom*) Lemma valid_index_not_null :
  (forall (p:pointer), (forall (i:Z), ((valid_index p i) -> ~(p = null)))).
Admitted.

(*Why axiom*) Lemma valid_index1 :
  (forall (p:pointer),
   (forall (i:Z), ((valid_index p i) -> 0 <= ((offset p) + i)))).
Admitted.

(*Why axiom*) Lemma valid_index2 :
  (forall (p:pointer),
   (forall (i:Z), ((valid_index p i) -> ((offset p) + i) < (block_length p)))).
Admitted.

(*Why axiom*) Lemma valid_range_def :
  (forall (p:pointer),
   (forall (i:Z),
    (forall (j:Z),
     (~(p = null) /\ 0 <= ((offset p) + i) /\ i <= j /\ ((offset p) + j) <
      (block_length p) -> (valid_range p i j))))).
Admitted.

(*Why axiom*) Lemma valid_range_not_null :
  (forall (p:pointer),
   (forall (i:Z), (forall (j:Z), ((valid_range p i j) -> ~(p = null))))).
Admitted.

(*Why axiom*) Lemma valid_range1 :
  (forall (p:pointer),
   (forall (i:Z),
    (forall (j:Z), ((valid_range p i j) -> 0 <= ((offset p) + i))))).
Admitted.

(*Why axiom*) Lemma valid_range2 :
  (forall (p:pointer),
   (forall (i:Z), (forall (j:Z), ((valid_range p i j) -> i <= j)))).
Admitted.

(*Why axiom*) Lemma valid_range3 :
  (forall (p:pointer),
   (forall (i:Z),
    (forall (j:Z),
     ((valid_range p i j) -> ((offset p) + j) < (block_length p))))).
Admitted.

(*Why*) Parameter shift_ :
  forall (p: pointer), forall (i: Z),
  (sig_1 pointer (fun (result: pointer)  => (result = (shift p i)))).

Parameter memory: Set -> Set.


(*Why logic*) Definition acc :
  forall (A23:Set), ((memory) A23) -> pointer -> A23.
Admitted.


(*Why*) Parameter acc_ :
  forall (A5: Set), forall (p: pointer), forall (m: ((memory) A5)),
  forall (H: ~(p = null) /\ 0 <= (offset p) /\ (offset p) <
  (block_length p)), (sig_1 A5 (fun (result: A5)  => (result = (acc m p)))).

(*Why logic*) Definition upd :
  forall (A24:Set), ((memory) A24) -> pointer -> A24 -> ((memory) A24).
Admitted.

(*Why*) Parameter upd_ :
  forall (A11: Set), forall (p: pointer), forall (v: A11),
  forall (m: ((memory) A11)), forall (H: ~(p = null) /\ 0 <= (offset p) /\
  (offset p) < (block_length p)),
  (sig_2 ((memory) A11) unit
   (fun (m0: ((memory) A11)) (result: unit)  => (m0 = (upd m p v)))).

(*Why axiom*) Lemma acc_upd_eq :
  forall (A25:Set),
  (forall (m:((memory) A25)),
   (forall (p:pointer), (forall (a:A25), (acc (upd m p a) p) = a))).
Admitted.

(*Why axiom*) Lemma acc_upd_neq :
  forall (A26:Set),
  (forall (m:((memory) A26)),
   (forall (p1:pointer),
    (forall (p2:pointer),
     (forall (a:A26), (~(p1 = p2) -> (acc (upd m p1 a) p2) = (acc m p2)))))).
Admitted.

