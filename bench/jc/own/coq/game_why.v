(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export jessie_why.

(*Why type*) Definition Hero: Set.
Admitted.

(*Why type*) Definition Sword: Set.
Admitted.

(*Why logic*) Definition Hero_tag : (tag_id Hero).
Admitted.

(*Why logic*) Definition Sword_tag : (tag_id Sword).
Admitted.

(*Why logic*) Definition assoc :
  forall (A1:Set), forall (A2:Set), Z -> (memory A1 A2) -> Prop.
Admitted.
Implicit Arguments assoc.

(*Why predicate*) Definition damage_inv  (damage:(memory Sword Z))
  (this:(pointer Sword)) := (select damage this) > 0.

(*Why axiom*) Lemma axiom_damage_inv :
  (forall (damage:(memory Sword Z)),
   (forall (mutable:(memory Sword bool)),
    (forall (program_point:Z),
     (forall (this:(pointer Sword)),
      ((assoc program_point damage) ->
       ((assoc program_point mutable) ->
        (false = (select mutable this) -> (damage_inv damage this)))))))).
Admitted.

(*Why predicate*) Definition life_inv  (dead:(memory Hero bool))
  (life:(memory Hero Z)) (this:(pointer Hero))
  := (select life this) >= 0 /\ (select life this) <= 100 /\
     (((select life this) = 0 -> (select dead this) = true)).

(*Why axiom*) Lemma axiom_life_inv :
  (forall (life:(memory Hero Z)),
   (forall (dead:(memory Hero bool)),
    (forall (mutable:(memory Hero bool)),
     (forall (program_point:Z),
      (forall (this:(pointer Hero)),
       ((assoc program_point dead) ->
        ((assoc program_point life) ->
         ((assoc program_point mutable) ->
          (false = (select mutable this) -> (life_inv dead life this)))))))))).
Admitted.

(*Why predicate*) Definition sword_inv  (Sword_alloc_table:(alloc_table Sword))
  (sword:(memory Hero (pointer Sword))) (this:(pointer Hero))
  := (offset_min Sword_alloc_table (select sword this)) <= 0 /\
     (offset_max Sword_alloc_table (select sword this)) >= 0.

(*Why axiom*) Lemma axiom_sword_inv :
  (forall (sword:(memory Hero (pointer Sword))),
   (forall (Sword_alloc_table:(alloc_table Sword)),
    (forall (mutable:(memory Hero bool)),
     (forall (program_point:Z),
      (forall (this:(pointer Hero)),
       ((assoc program_point mutable) ->
        ((assoc program_point sword) ->
         (false = (select mutable this) ->
          (sword_inv Sword_alloc_table sword this))))))))).
Admitted.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_1 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  (select life this) >= 0.
Proof.
intuition.
(* FILL PROOF HERE *)
admit.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_2 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  (valid Hero_alloc_table target).
Proof.
intuition.
(* FILL PROOF HERE *)
admit.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_3 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  (valid Hero_alloc_table this).
Proof.
intuition.
(* FILL PROOF HERE *)
admit.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_4 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (Sword_alloc_table: (alloc_table Sword)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  forall (HW_6: (valid Hero_alloc_table this)),
  forall (result0: (pointer Sword)),
  forall (HW_7: result0 = (select sword this)),
  (valid Sword_alloc_table result0).
Proof.
intros; subst.
unfold valid.
refine (axiom_sword_inv _ _ mutable_Hero 4 _ _ _ _); intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_5 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (Sword_alloc_table: (alloc_table Sword)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  forall (HW_6: (valid Hero_alloc_table this)),
  forall (result0: (pointer Sword)),
  forall (HW_7: result0 = (select sword this)),
  forall (HW_8: (valid Sword_alloc_table result0)),
  forall (result1: Z),
  forall (HW_9: result1 = (select damage result0)),
  forall (HW_10: (valid Hero_alloc_table target)),
  forall (life0: (memory Hero Z)),
  forall (HW_11: life0 = (store life target (result - result1))),
  forall (HW_12: (assoc 3 dead) /\ (assoc 3 life0) /\ (assoc 3 mutable_Hero)),
  forall (HW_13: (valid Hero_alloc_table target)),
  forall (result2: Z),
  forall (HW_14: result2 = (select life0 target)),
  forall (HW_15: result2 <= 0),
  forall (HW_16: (valid Hero_alloc_table target)),
  forall (life1: (memory Hero Z)),
  forall (HW_17: life1 = (store life0 target 0)),
  forall (HW_18: (assoc 2 dead) /\ (assoc 2 life1) /\ (assoc 2 mutable_Hero)),
  forall (HW_19: (valid Hero_alloc_table target)),
  forall (dead0: (memory Hero bool)),
  forall (HW_20: dead0 = (store dead target true)),
  forall (HW_21: (assoc 1 dead0) /\ (assoc 1 life1) /\ (assoc 1 mutable_Hero)),
  (select mutable_Hero this) = false.
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_6 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (Sword_alloc_table: (alloc_table Sword)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  forall (HW_6: (valid Hero_alloc_table this)),
  forall (result0: (pointer Sword)),
  forall (HW_7: result0 = (select sword this)),
  forall (HW_8: (valid Sword_alloc_table result0)),
  forall (result1: Z),
  forall (HW_9: result1 = (select damage result0)),
  forall (HW_10: (valid Hero_alloc_table target)),
  forall (life0: (memory Hero Z)),
  forall (HW_11: life0 = (store life target (result - result1))),
  forall (HW_12: (assoc 3 dead) /\ (assoc 3 life0) /\ (assoc 3 mutable_Hero)),
  forall (HW_13: (valid Hero_alloc_table target)),
  forall (result2: Z),
  forall (HW_14: result2 = (select life0 target)),
  forall (HW_15: result2 <= 0),
  forall (HW_16: (valid Hero_alloc_table target)),
  forall (life1: (memory Hero Z)),
  forall (HW_17: life1 = (store life0 target 0)),
  forall (HW_18: (assoc 2 dead) /\ (assoc 2 life1) /\ (assoc 2 mutable_Hero)),
  forall (HW_19: (valid Hero_alloc_table target)),
  forall (dead0: (memory Hero bool)),
  forall (HW_20: dead0 = (store dead target true)),
  forall (HW_21: (assoc 1 dead0) /\ (assoc 1 life1) /\ (assoc 1 mutable_Hero)),
  (select mutable_Hero target) = false.
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_7 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (Sword_alloc_table: (alloc_table Sword)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  forall (HW_6: (valid Hero_alloc_table this)),
  forall (result0: (pointer Sword)),
  forall (HW_7: result0 = (select sword this)),
  forall (HW_8: (valid Sword_alloc_table result0)),
  forall (result1: Z),
  forall (HW_9: result1 = (select damage result0)),
  forall (HW_10: (valid Hero_alloc_table target)),
  forall (life0: (memory Hero Z)),
  forall (HW_11: life0 = (store life target (result - result1))),
  forall (HW_12: (assoc 3 dead) /\ (assoc 3 life0) /\ (assoc 3 mutable_Hero)),
  forall (HW_13: (valid Hero_alloc_table target)),
  forall (result2: Z),
  forall (HW_14: result2 = (select life0 target)),
  forall (HW_22: result2 > 0),
  (select mutable_Hero this) = false.
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma attack_ensures_ok_po_8 : 
  forall (this: (pointer Hero)),
  forall (target: (pointer Hero)),
  forall (Hero_alloc_table: (alloc_table Hero)),
  forall (Hero_tag_table: (tag_table Hero)),
  forall (Sword_alloc_table: (alloc_table Sword)),
  forall (damage: (memory Sword Z)),
  forall (dead: (memory Hero bool)),
  forall (life: (memory Hero Z)),
  forall (mutable_Hero: (memory Hero bool)),
  forall (mutable_Sword: (memory Sword bool)),
  forall (sword: (memory Hero (pointer Sword))),
  forall (HW_1: (((offset_min Hero_alloc_table this) <= 0 /\
                (offset_max Hero_alloc_table this) >= 0) /\
                (instanceof Hero_tag_table this Hero_tag)) /\
                (((offset_min Hero_alloc_table target) <= 0 /\
                (offset_max Hero_alloc_table target) >= 0) /\
                (instanceof Hero_tag_table target Hero_tag)) /\
                (select mutable_Hero this) = false /\
                (select mutable_Hero target) = false),
  forall (HW_2: (assoc 4 damage) /\ (assoc 4 dead) /\ (assoc 4 life) /\
                (assoc 4 sword) /\ (assoc 4 mutable_Hero) /\
                (assoc 4 mutable_Sword)),
  forall (HW_3: (select life this) >= 0),
  forall (HW_4: (valid Hero_alloc_table target)),
  forall (result: Z),
  forall (HW_5: result = (select life target)),
  forall (HW_6: (valid Hero_alloc_table this)),
  forall (result0: (pointer Sword)),
  forall (HW_7: result0 = (select sword this)),
  forall (HW_8: (valid Sword_alloc_table result0)),
  forall (result1: Z),
  forall (HW_9: result1 = (select damage result0)),
  forall (HW_10: (valid Hero_alloc_table target)),
  forall (life0: (memory Hero Z)),
  forall (HW_11: life0 = (store life target (result - result1))),
  forall (HW_12: (assoc 3 dead) /\ (assoc 3 life0) /\ (assoc 3 mutable_Hero)),
  forall (HW_13: (valid Hero_alloc_table target)),
  forall (result2: Z),
  forall (HW_14: result2 = (select life0 target)),
  forall (HW_22: result2 > 0),
  (select mutable_Hero target) = false.
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

