
/* Dijkstra's dutch flag */

/*

type color = enum { BLUE, WHITE, RED }
   
predicate isMonochrome(color t[..], integer i, integer j, color c[0]) =
    \offset_min(t) <= i && i <= j && j <= \offset_max(t) &&
    \forall int k; i <= k && k <= j => t[k] == c

type flag = {
    /*    integer t_length; */

    color t[0..];

    /*
      invariant isColorArray(this) = this.t_length == \offset_max(this.t) */
    /* inutile !
       t != null &&
       \forall int k; 0 <= k && k <= \offset_max(t) =>  isColor(t[k]));
   */

}


unit swap(color t, integer i, integer j) 
    requires \valid(t+i) && \valid(t+j)
    behavior swaps_i_and_j:
      assigns t[i],t[j]
      ensures t[i] == \old(t[j]) && t[j] == \old(t[i])
{
    integer z = t[i];
    t[i] = t[j];
    t[j] = z;
}

unit flag(flag f[0]) 
    behavior sorts_f:
      assigns f.t[0..f.t_length];
      ensures 
        \exists integer b,r; 
            isMonochrome(0,b-1,BLUE) &&
	    isMonochrome(b,r-1,WHITE) &&
            isMonochrome(r,t.length-1,RED)
{
    integer b = 0;
    integer i = 0;
    integer r = \offset_max(t)+1;
    while (i < r) 
	loop_invariant
	    /* (\forall int k; 0 <= k && k < t.length; isColor(t[k])) */
	    0 <= b && b <= i && i <= r && r <= \offset_max(t)+1 &&
	    isMonochrome(0,b-1,BLUE) &&
	    isMonochrome(b,i-1,WHITE) &&
	    isMonochrome(r,\offset_max(t),RED);
        loop_decreases r - i; 
	{
	    switch (t[i]) {
	    case BLUE:  
		swap(b++, i++);
		break;	    
	    case WHITE: 
		i++; 
		break;
	    case RED: 
		swap(--r, i);
		break;
	    }
	}
}

*/


/*
Local Variables: 
mode: java
compile-command: "make flag"
End: 
*/

