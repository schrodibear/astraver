
type int_array

logic array_length : int_array -> int

logic acc : int_array, int -> int

logic upd : int_array, int, int -> int_array

axiom access_update : 
  forall t : int_array. forall i : int. forall v : int.
  acc(upd(t,i,v), i) = v

axiom access_update_neq : 
  forall t : int_array. forall i : int. forall j : int. forall v : int.
  i <> j -> acc(upd(t,i,v), j) = acc(t,j)

axiom array_length_update :
  forall t:int_array. forall i:int. forall v:int.
    array_length(upd(t,i,v)) = array_length(t)

logic exchange : int_array, int_array, int, int -> prop

axiom exchange_def :
  forall t1:int_array. forall t2:int_array. forall i:int. forall j:int.
    exchange(t1,t2,i,j) <-> 
    (array_length(t1) = array_length(t2) and
    acc(t1,i) = acc(t2,j) and acc(t2,i) = acc(t1,j) and
    forall k:int. (k <> i and k <> j) -> acc(t1,k) = acc(t2,k))

goal test : 
  forall i: int.
  forall j: int.
  forall t: int_array.
  ((0 <= i and i < array_length(t)) and 0 <= j and j < array_length(t)) ->
  (0 <= i and i < array_length(t)) ->
  forall result: int.
  result = acc(t, i) ->
  (0 <= j and j < array_length(t)) ->
  forall result0: int.
  result0 = acc(t, j) ->
  (0 <= i and i < array_length(t)) ->
  forall t0: int_array.
  t0 = upd(t, i, result0) ->
  (0 <= j and j < array_length(t0)) ->
  forall t1: int_array.
  t1 = upd(t0, j, result) ->
  exchange(t1, t, i, j)
