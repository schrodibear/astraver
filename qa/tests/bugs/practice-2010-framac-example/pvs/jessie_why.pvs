jessie_why: THEORY
BEGIN

  IMPORTING why@jessie

  %% DO NOT EDIT BELOW THIS LINE

  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_alloc_fresh, jessie_why_fully_packed,
    jessie_why_root_tag, jessie_why_instanceof, jessie_why_not_assigns,
    jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  IMPORTING jessie_why_axioms0, jessie_why_axioms1, jessie_why_axioms2

END jessie_why

jessie_why_axioms2[A1,A2: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_alloc_fresh, jessie_why_fully_packed,
    jessie_why_root_tag, jessie_why_instanceof, jessie_why_not_assigns,
    jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  %% Why axiom select_store_eq
  select_store_eq: AXIOM
    (FORALL (m: memory[A1, A2]):
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (FORALL (a: A2):
    (p1 = p2 IMPLIES select[A2, A1](store[A1, A2](m, p1, a), p2) = a)))))

  %% Why axiom select_store_neq
  select_store_neq: AXIOM
    (FORALL (m: memory[A1, A2]):
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (FORALL (a: A2):
    (p1 /= p2 IMPLIES
    select[A2, A1](store[A1, A2](m, p1, a), p2) = select[A2, A1](m, p2))))))

  %% Why axiom in_pset_deref
  in_pset_deref: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (m: memory[A2, pointer[A1]]):
    (FORALL (q: pset[A2]):
    (in_pset[A1](p, pset_deref[A1, A2](m, q)) IFF
    (EXISTS (r: pointer[A2]): in_pset[A2](r, q) AND
     p = select[pointer[A1], A2](m, r))))))

  %% Why axiom valid_pset_deref
  valid_pset_deref: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (m: memory[A2, pointer[A1]]):
    (FORALL (q: pset[A2]):
    (valid_pset[A1](a, pset_deref[A1, A2](m, q)) IFF
    (FORALL (r: pointer[A2]):
    (FORALL (p: pointer[A1]):
    (in_pset[A2](r, q) AND p = select[pointer[A1], A2](m, r) IMPLIES
    valid[A1](a, p))))))))

  %% Why axiom not_assigns_refl
  not_assigns_refl: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (m: memory[A1, A2]):
    (FORALL (l: pset[A1]): not_assigns[A1, A2](a, m, m, l))))

  %% Why axiom not_assigns_trans
  not_assigns_trans: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (m3: memory[A1, A2]):
    (FORALL (l: pset[A1]):
    (not_assigns[A1, A2](a, m1, m2, l) IMPLIES
    (not_assigns[A1, A2](a, m2, m3, l) IMPLIES not_assigns[A1,
    A2](a, m1, m3, l))))))))

  %% Why axiom alloc_extends_not_assigns_empty
  alloc_extends_not_assigns_empty: AXIOM
    (FORALL (a1: alloc_table[A1]):
    (FORALL (a2: alloc_table[A1]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (l: pset[A1]):
    (FORALL (p: pointer[A1]):
    (FORALL (n: int):
    (alloc_extends[A1](a1, a2) AND (alloc_fresh[A1](a1, p, n) AND
    (not_assigns[A1, A2](a2, m1, m2, l) AND
    pset_included[A1](l, pset_all[A1](pset_singleton[A1](p))))) IMPLIES
    not_assigns[A1, A2](a1, m1, m2, pset_empty[A1])))))))))

  %% Why axiom frame_between_refl
  frame_between_refl: AXIOM
    (FORALL (sa: mybag[pointer[A1]]):
    (FORALL (m: memory[A1, A2]): frame_between[A1, A2](sa, m, m)))

  %% Why axiom frame_between_gen
  frame_between_gen: AXIOM
    (FORALL (sa: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (p: pointer[A1]):
    (FORALL (v: A2):
    (frame_between[A1, A2](sa, m1, m2) IMPLIES
    (in_mybag[pointer[A1]](p, sa) IMPLIES frame_between[A1,
    A2](sa, store[A1, A2](m1, p, v), m2))))))))

  %% Why axiom frame_between_gen2
  frame_between_gen2: AXIOM
    (FORALL (sa: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (m3: memory[A1, A2]):
    (frame_between[A1, A2](sa, m1, m2) IMPLIES
    (frame_between[A1, A2](sa, m2, m3) IMPLIES frame_between[A1,
    A2](sa, m1, m3)))))))

  %% Why axiom frame_between_gen_sub1
  frame_between_gen_sub1: AXIOM
    (FORALL (s12: mybag[pointer[A1]]):
    (FORALL (s23: mybag[pointer[A1]]):
    (FORALL (s13: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (m3: memory[A1, A2]):
    (sub_mybag[pointer[A1]](s12, s13) IMPLIES
    (frame_between[A1, A2](s12, m1, m2) IMPLIES
    (frame_between[A1, A2](s23, m2, m3) IMPLIES frame_between[A1,
    A2](s13, m1, m3))))))))))

  %% Why axiom frame_between_gen_sub2
  frame_between_gen_sub2: AXIOM
    (FORALL (s12: mybag[pointer[A1]]):
    (FORALL (s23: mybag[pointer[A1]]):
    (FORALL (s13: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (m3: memory[A1, A2]):
    (frame_between[A1, A2](s12, m1, m2) IMPLIES
    (sub_mybag[pointer[A1]](s23, s13) IMPLIES
    (frame_between[A1, A2](s23, m2, m3) IMPLIES frame_between[A1,
    A2](s13, m1, m3))))))))))

  %% Why axiom frame_between_pointer
  frame_between_pointer: AXIOM
    (FORALL (sa: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (FORALL (p: pointer[A1]):
    (FORALL (v: A2):
    (frame_between[A1, A2](sa, m1, m2) IMPLIES
    (NOT in_mybag[pointer[A1]](p, sa) IMPLIES
    select[A2, A1](m1, p) = select[A2, A1](m2, p))))))))

  %% Why axiom frame_between_sub
  frame_between_sub: AXIOM
    (FORALL (sa: mybag[pointer[A1]]):
    (FORALL (sb: mybag[pointer[A1]]):
    (FORALL (m1: memory[A1, A2]):
    (FORALL (m2: memory[A1, A2]):
    (frame_between[A1, A2](sa, m1, m2) IMPLIES
    (sub_mybag[pointer[A1]](sa, sb) IMPLIES frame_between[A1,
    A2](sb, m1, m2)))))))

END jessie_why_axioms2

jessie_why_axioms0: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_alloc_fresh, jessie_why_fully_packed,
    jessie_why_root_tag, jessie_why_instanceof, jessie_why_not_assigns,
    jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  %% Why axiom bool_and_def
  bool_and_def: AXIOM
    (FORALL (a: bool):
    (FORALL (b: bool): ((a AND b) = true IFF a = true AND b = true)))

  %% Why axiom bool_or_def
  bool_or_def: AXIOM
    (FORALL (a: bool):
    (FORALL (b: bool): ((a OR b) = true IFF a = true OR b = true)))

  %% Why axiom bool_xor_def
  bool_xor_def: AXIOM
    (FORALL (a: bool): (FORALL (b: bool): ((a /= b) = true IFF a /= b)))

  %% Why axiom bool_not_def
  bool_not_def: AXIOM (FORALL (a: bool): ((NOT(a)) = true IFF a = false))

  %% Why axiom lt_int_bool_axiom
  lt_int_bool_axiom: AXIOM
    (FORALL (x: int): (FORALL (y: int): ((x < y) = true IFF x < y)))

  %% Why axiom le_int_bool_axiom
  le_int_bool_axiom: AXIOM
    (FORALL (x: int): (FORALL (y: int): ((x <= y) = true IFF x <= y)))

  %% Why axiom gt_int_bool_axiom
  gt_int_bool_axiom: AXIOM
    (FORALL (x: int): (FORALL (y: int): ((x > y) = true IFF x > y)))

  %% Why axiom ge_int_bool_axiom
  ge_int_bool_axiom: AXIOM
    (FORALL (x: int): (FORALL (y: int): ((x >= y) = true IFF x >= y)))

  %% Why axiom eq_int_bool_axiom
  eq_int_bool_axiom: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): (eq_int_bool(x, y) = true IFF x = y)))

  %% Why axiom neq_int_bool_axiom
  neq_int_bool_axiom: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): (neq_int_bool(x, y) = true IFF x /= y)))

  %% Why axiom abs_int_pos
  abs_int_pos: AXIOM (FORALL (x: int): (x >= 0 IMPLIES abs_int(x) = x))

  %% Why axiom abs_int_neg
  abs_int_neg: AXIOM (FORALL (x: int): (x <= 0 IMPLIES abs_int(x) = -x))

  %% Why axiom int_max_is_ge
  int_max_is_ge: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): int_max(x, y) >= x AND int_max(x, y) >= y))

  %% Why axiom int_max_is_some
  int_max_is_some: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): int_max(x, y) = x OR int_max(x, y) = y))

  %% Why axiom int_min_is_le
  int_min_is_le: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): int_min(x, y) <= x AND int_min(x, y) <= y))

  %% Why axiom int_min_is_some
  int_min_is_some: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): int_min(x, y) = x OR int_min(x, y) = y))

  %% Why axiom real_of_int_zero
  real_of_int_zero: AXIOM 0 = 0.0

  %% Why axiom real_of_int_one
  real_of_int_one: AXIOM 1 = 1.0

  %% Why axiom real_of_int_add
  real_of_int_add: AXIOM
    (FORALL (x: int): (FORALL (y: int): (x + y) = x + y))

  %% Why axiom real_of_int_sub
  real_of_int_sub: AXIOM
    (FORALL (x: int): (FORALL (y: int): (x - y) = x - y))

  %% Why axiom truncate_down_pos
  truncate_down_pos: AXIOM
    (FORALL (x: real):
    (x >= 0.0 IMPLIES truncate_real_to_int(x) <= x AND
    x < (truncate_real_to_int(x) + 1)))

  %% Why axiom truncate_up_neg
  truncate_up_neg: AXIOM
    (FORALL (x: real):
    (x <= 0.0 IMPLIES (truncate_real_to_int(x) - 1) < x AND
    x <= truncate_real_to_int(x)))

  %% Why axiom lt_real_bool_axiom
  lt_real_bool_axiom: AXIOM
    (FORALL (x: real): (FORALL (y: real): ((x < y) = true IFF x < y)))

  %% Why axiom le_real_bool_axiom
  le_real_bool_axiom: AXIOM
    (FORALL (x: real): (FORALL (y: real): ((x <= y) = true IFF x <= y)))

  %% Why axiom gt_real_bool_axiom
  gt_real_bool_axiom: AXIOM
    (FORALL (x: real): (FORALL (y: real): ((x > y) = true IFF x > y)))

  %% Why axiom ge_real_bool_axiom
  ge_real_bool_axiom: AXIOM
    (FORALL (x: real): (FORALL (y: real): ((x >= y) = true IFF x >= y)))

  %% Why axiom eq_real_bool_axiom
  eq_real_bool_axiom: AXIOM
    (FORALL (x: real):
    (FORALL (y: real): (eq_real_bool(x, y) = true IFF x = y)))

  %% Why axiom neq_real_bool_axiom
  neq_real_bool_axiom: AXIOM
    (FORALL (x: real):
    (FORALL (y: real): (neq_real_bool(x, y) = true IFF x /= y)))

  %% Why axiom real_max_is_ge
  real_max_is_ge: AXIOM
    (FORALL (x: real): (FORALL (y: real): max(x, y) >= x AND max(x, y) >= y))

  %% Why axiom real_max_is_some
  real_max_is_some: AXIOM
    (FORALL (x: real): (FORALL (y: real): max(x, y) = x OR max(x, y) = y))

  %% Why axiom real_min_is_le
  real_min_is_le: AXIOM
    (FORALL (x: real): (FORALL (y: real): min(x, y) <= x AND min(x, y) <= y))

  %% Why axiom real_min_is_some
  real_min_is_some: AXIOM
    (FORALL (x: real): (FORALL (y: real): min(x, y) = x OR min(x, y) = y))

  %% Why axiom sqrt_pos
  sqrt_pos: AXIOM (FORALL (x: real): (x >= 0.0 IMPLIES sqrt(x) >= 0.0))

  %% Why axiom sqrt_sqr
  sqrt_sqr: AXIOM
    (FORALL (x: real): (x >= 0.0 IMPLIES sqr_real(sqrt(x)) = x))

  %% Why axiom sqr_sqrt
  sqr_sqrt: AXIOM (FORALL (x: real): (x >= 0.0 IMPLIES sqrt(x * x) = x))

  %% Why axiom abs_real_pos
  abs_real_pos: AXIOM (FORALL (x: real): (x >= 0.0 IMPLIES abs(x) = x))

  %% Why axiom abs_real_neg
  abs_real_neg: AXIOM (FORALL (x: real): (x <= 0.0 IMPLIES abs(x) = -x))

  %% Why axiom log_exp
  log_exp: AXIOM (FORALL (x: real): log(exp(x)) = x)

  %% Why axiom exp_log
  exp_log: AXIOM (FORALL (x: real): (x > 0.0 IMPLIES exp(log(x)) = x))

  %% Why axiom prod_pos
  prod_pos: AXIOM
    (FORALL (x: real):
    (FORALL (y: real): ((x > 0.0 AND y > 0.0 IMPLIES x * y > 0.0)) AND
    ((x < 0.0 AND y < 0.0 IMPLIES x * y > 0.0))))

  %% Why axiom abs_minus
  abs_minus: AXIOM (FORALL (x: real): abs(-x) = abs(x))

  %% Why axiom math_div_mod
  math_div_mod: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (y /= 0 IMPLIES x = y * math_div(x, y) + math_mod(x, y))))

  %% Why axiom math_mod_bound
  math_mod_bound: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (y /= 0 IMPLIES 0 <= math_mod(x, y) AND math_mod(x, y) < abs_int(y))))

  %% Why axiom computer_div_mod
  computer_div_mod: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (y /= 0 IMPLIES x = y * computer_div(x, y) + computer_mod(x, y))))

  %% Why axiom computer_div_bound
  computer_div_bound: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (x >= 0 AND y > 0 IMPLIES 0 <= computer_div(x, y) AND
    computer_div(x, y) <= x)))

  %% Why axiom computer_mod_bound
  computer_mod_bound: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (y /= 0 IMPLIES abs_int(computer_mod(x, y)) < abs_int(y))))

  %% Why axiom computer_mod_sign_pos
  computer_mod_sign_pos: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): (x >= 0 AND y /= 0 IMPLIES computer_mod(x, y) >= 0)))

  %% Why axiom computer_mod_sign_neg
  computer_mod_sign_neg: AXIOM
    (FORALL (x: int):
    (FORALL (y: int): (x <= 0 AND y /= 0 IMPLIES computer_mod(x, y) <= 0)))

  %% Why axiom computer_rounds_toward_zero
  computer_rounds_toward_zero: AXIOM
    (FORALL (x: int):
    (FORALL (y: int):
    (y /= 0 IMPLIES abs_int(computer_div(x, y) * y) <= abs_int(x))))

  %% Why axiom bw_and_not_null
  bw_and_not_null: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (bw_and(a, b) /= 0 IMPLIES a /= 0 AND b /= 0)))

  %% Why axiom lsl_left_positive_returns_positive
  lsl_left_positive_returns_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES 0 <= lsl(a, b))))

  %% Why axiom lsl_left_positive_monotone
  lsl_left_positive_monotone: AXIOM
    (FORALL (a1: int):
    (FORALL (a2: int):
    (FORALL (b: int):
    (0 <= a1 AND (a1 <= a2 AND 0 <= b) IMPLIES lsl(a1, b) <= lsl(a2, b)))))

  %% Why axiom lsr_left_positive_returns_positive
  lsr_left_positive_returns_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES 0 <= lsr(a, b))))

  %% Why axiom lsr_left_positive_decreases
  lsr_left_positive_decreases: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES lsr(a, b) <= a)))

  %% Why axiom asr_positive_on_positive
  asr_positive_on_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES 0 <= asr(a, b))))

  %% Why axiom asr_decreases_on_positive
  asr_decreases_on_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES asr(a, b) <= a)))

  %% Why axiom asr_lsr_same_on_positive
  asr_lsr_same_on_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES asr(a, b) = lsr(a, b))))

  %% Why axiom lsl_of_lsr_decreases_on_positive
  lsl_of_lsr_decreases_on_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES lsl(lsr(a, b), b) <= a)))

  %% Why axiom lsr_of_lsl_identity_on_positive
  lsr_of_lsl_identity_on_positive: AXIOM
    (FORALL (a: int):
    (FORALL (b: int): (0 <= a AND 0 <= b IMPLIES lsr(lsl(a, b), b) = a)))

END jessie_why_axioms0

jessie_why_axioms1[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_alloc_fresh, jessie_why_fully_packed,
    jessie_why_root_tag, jessie_why_instanceof, jessie_why_not_assigns,
    jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  %% Why axiom ite_true
  ite_true: AXIOM
    (FORALL (x: A1): (FORALL (y: A1): (IF true THEN x ELSE y ENDIF) = x))

  %% Why axiom ite_false
  ite_false: AXIOM
    (FORALL (x: A1): (FORALL (y: A1): (IF false THEN x ELSE y ENDIF) = y))

  %% Why axiom address_injective
  address_injective: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]): (p = q IFF address[A1](p) = address[A1](q))))

  %% Why axiom address_null
  address_null: AXIOM address[A1](null[A1]) = 0

  %% Why axiom address_shift_lt
  address_shift_lt: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (address[A1](shift[A1](p, i)) < address[A1](shift[A1](p, j)) IFF i < j))))

  %% Why axiom address_shift_le
  address_shift_le: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (address[A1](shift[A1](p, i)) <= address[A1](shift[A1](p, j)) IFF i <= j))))

  %% Why axiom shift_zero
  shift_zero: AXIOM (FORALL (p: pointer[A1]): shift[A1](p, 0) = p)

  %% Why axiom shift_shift
  shift_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int): shift[A1](shift[A1](p, i), j) = shift[A1](p, i + j))))

  %% Why axiom offset_max_shift
  offset_max_shift: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    offset_max[A1](a, shift[A1](p, i)) = offset_max[A1](a, p) - i)))

  %% Why axiom offset_min_shift
  offset_min_shift: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    offset_min[A1](a, shift[A1](p, i)) = offset_min[A1](a, p) - i)))

  %% Why axiom neq_shift
  neq_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int): (i /= j IMPLIES shift[A1](p, i) /= shift[A1](p, j)))))

  %% Why axiom null_not_valid
  null_not_valid: AXIOM
    (FORALL (a: alloc_table[A1]): NOT valid[A1](a, null[A1]))

  %% Why axiom null_pointer
  null_pointer: AXIOM
    (FORALL (a: alloc_table[A1]): offset_min[A1](a, null[A1]) >= 0 AND
    offset_max[A1](a, null[A1]) <= -2)

  %% Why axiom eq_pointer_bool_def
  eq_pointer_bool_def: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (eq_pointer_bool[A1](p1, p2) = true IFF p1 = p2)))

  %% Why axiom neq_pointer_bool_def
  neq_pointer_bool_def: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (neq_pointer_bool[A1](p1, p2) = true IFF p1 /= p2)))

  %% Why axiom same_block_shift_right
  same_block_shift_right: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (same_block[A1](p, q) IMPLIES same_block[A1](p, shift[A1](q, i))))))

  %% Why axiom same_block_shift_left
  same_block_shift_left: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (same_block[A1](q, p) IMPLIES same_block[A1](shift[A1](q, i), p)))))

  %% Why axiom sub_pointer_shift
  sub_pointer_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (same_block[A1](p, q) IMPLIES p = shift[A1](q, sub_pointer[A1](p, q)))))

  %% Why axiom sub_pointer_self
  sub_pointer_self: AXIOM
    (FORALL (p: pointer[A1]): sub_pointer[A1](p, p) = 0)

  %% Why axiom sub_pointer_zero
  sub_pointer_zero: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (same_block[A1](p, q) IMPLIES (sub_pointer[A1](p, q) = 0 IMPLIES p = q))))

  %% Why axiom sub_pointer_shift_left
  sub_pointer_shift_left: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    sub_pointer[A1](shift[A1](p, i), q) = sub_pointer[A1](p, q) + i)))

  %% Why axiom sub_pointer_shift_right
  sub_pointer_shift_right: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    sub_pointer[A1](p, shift[A1](q, i)) = sub_pointer[A1](p, q) - i)))

  %% Why axiom pset_included_self
  pset_included_self: AXIOM
    (FORALL (ps: pset[A1]): pset_included[A1](ps, ps))

  %% Why axiom pset_included_range
  pset_included_range: AXIOM
    (FORALL (ps: pset[A1]):
    (FORALL (a: int):
    (FORALL (b: int):
    (FORALL (c: int):
    (FORALL (d: int):
    (c <= a AND b <= d IMPLIES
    pset_included[A1](pset_range[A1](ps, a, b), pset_range[A1](ps, c, d))))))))

  %% Why axiom pset_included_range_all
  pset_included_range_all: AXIOM
    (FORALL (ps: pset[A1]):
    (FORALL (a: int):
    (FORALL (b: int):
    (FORALL (c: int):
    (FORALL (d: int):
    pset_included[A1](pset_range[A1](ps, a, b), pset_all[A1](ps)))))))

  %% Why axiom in_pset_empty
  in_pset_empty: AXIOM
    (FORALL (p: pointer[A1]): NOT in_pset[A1](p, pset_empty[A1]))

  %% Why axiom in_pset_singleton
  in_pset_singleton: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (in_pset[A1](p, pset_singleton[A1](q)) IFF p = q)))

  %% Why axiom in_pset_all
  in_pset_all: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pset[A1]):
    (in_pset[A1](p, pset_all[A1](q)) IFF
    (EXISTS (i: int):
     (EXISTS (r: pointer[A1]): in_pset[A1](r, q) AND p = shift[A1](r, i))))))

  %% Why axiom in_pset_range
  in_pset_range: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pset[A1]):
    (FORALL (a: int):
    (FORALL (b: int):
    (in_pset[A1](p, pset_range[A1](q, a, b)) IFF
    (EXISTS (i: int):
     (EXISTS (r: pointer[A1]): a <= i AND (i <= b AND (in_pset[A1](r, q) AND
      p = shift[A1](r, i))))))))))

  %% Why axiom in_pset_range_left
  in_pset_range_left: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pset[A1]):
    (FORALL (b: int):
    (in_pset[A1](p, pset_range_left[A1](q, b)) IFF
    (EXISTS (i: int):
     (EXISTS (r: pointer[A1]): i <= b AND (in_pset[A1](r, q) AND
      p = shift[A1](r, i))))))))

  %% Why axiom in_pset_range_right
  in_pset_range_right: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pset[A1]):
    (FORALL (a: int):
    (in_pset[A1](p, pset_range_right[A1](q, a)) IFF
    (EXISTS (i: int):
     (EXISTS (r: pointer[A1]): a <= i AND (in_pset[A1](r, q) AND
      p = shift[A1](r, i))))))))

  %% Why axiom in_pset_union
  in_pset_union: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (s1: pset[A1]):
    (FORALL (s2: pset[A1]):
    (in_pset[A1](p, pset_union[A1](s1, s2)) IFF in_pset[A1](p, s1) OR
    in_pset[A1](p, s2)))))

  %% Why axiom valid_pset_empty
  valid_pset_empty: AXIOM
    (FORALL (a: alloc_table[A1]): valid_pset[A1](a, pset_empty[A1]))

  %% Why axiom valid_pset_singleton
  valid_pset_singleton: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (p: pointer[A1]):
    (valid_pset[A1](a, pset_singleton[A1](p)) IFF valid[A1](a, p))))

  %% Why axiom valid_pset_range
  valid_pset_range: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (q: pset[A1]):
    (FORALL (c: int):
    (FORALL (d: int):
    (valid_pset[A1](a, pset_range[A1](q, c, d)) IFF
    (FORALL (i: int):
    (FORALL (r: pointer[A1]):
    (in_pset[A1](r, q) AND (c <= i AND i <= d) IMPLIES
    valid[A1](a, shift[A1](r, i))))))))))

  %% Why axiom valid_pset_union
  valid_pset_union: AXIOM
    (FORALL (a: alloc_table[A1]):
    (FORALL (s1: pset[A1]):
    (FORALL (s2: pset[A1]):
    (valid_pset[A1](a, pset_union[A1](s1, s2)) IFF valid_pset[A1](a, s1) AND
    valid_pset[A1](a, s2)))))

  %% Why axiom full_separated_shift1
  full_separated_shift1: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (full_separated[A1, A1](p, q) IMPLIES full_separated[A1,
    A1](p, shift[A1](q, i))))))

  %% Why axiom full_separated_shift2
  full_separated_shift2: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (full_separated[A1, A1](p, q) IMPLIES full_separated[A1,
    A1](shift[A1](q, i), p)))))

  %% Why axiom full_separated_shift3
  full_separated_shift3: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (full_separated[A1, A1](q, p) IMPLIES full_separated[A1,
    A1](shift[A1](q, i), p)))))

  %% Why axiom full_separated_shift4
  full_separated_shift4: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (full_separated[A1, A1](q, p) IMPLIES full_separated[A1,
    A1](p, shift[A1](q, i))))))

  %% Why axiom subtag_bool_def
  subtag_bool_def: AXIOM
    (FORALL (t1: tag_id[A1]):
    (FORALL (t2: tag_id[A1]):
    (subtag_bool[A1](t1, t2) = true IFF subtag[A1](t1, t2))))

  %% Why axiom subtag_refl
  subtag_refl: AXIOM (FORALL (t: tag_id[A1]): subtag[A1](t, t))

  %% Why axiom subtag_parent
  subtag_parent: AXIOM
    (FORALL (t1: tag_id[A1]):
    (FORALL (t2: tag_id[A1]):
    (FORALL (t3: tag_id[A1]):
    (subtag[A1](t1, t2) IMPLIES
    (parenttag[A1](t2, t3) IMPLIES subtag[A1](t1, t3))))))

  %% Why axiom downcast_instanceof
  downcast_instanceof: AXIOM
    (FORALL (a: tag_table[A1]):
    (FORALL (p: pointer[A1]):
    (FORALL (s: tag_id[A1]):
    (instanceof[A1](a, p, s) IMPLIES downcast[A1](a, p, s) = p))))

  %% Why axiom bottom_tag_axiom
  bottom_tag_axiom: AXIOM
    (FORALL (t: tag_id[A1]): subtag[A1](t, bottom_tag[A1]))

  %% Why axiom root_subtag
  root_subtag: AXIOM
    (FORALL (a: tag_id[A1]):
    (FORALL (b: tag_id[A1]):
    (FORALL (c: tag_id[A1]):
    (root_tag[A1](a) IMPLIES
    (root_tag[A1](b) IMPLIES
    (a /= b IMPLIES (subtag[A1](c, a) IMPLIES NOT subtag[A1](c, b))))))))

  %% Why axiom alloc_extends_offset_min
  alloc_extends_offset_min: AXIOM
    (FORALL (a1: alloc_table[A1]):
    (FORALL (a2: alloc_table[A1]):
    (alloc_extends[A1](a1, a2) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a1, p) IMPLIES offset_min[A1](a1, p) = offset_min[A1](a2, p))))))

  %% Why axiom alloc_extends_offset_max
  alloc_extends_offset_max: AXIOM
    (FORALL (a1: alloc_table[A1]):
    (FORALL (a2: alloc_table[A1]):
    (alloc_extends[A1](a1, a2) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a1, p) IMPLIES offset_max[A1](a1, p) = offset_max[A1](a2, p))))))

  %% Why axiom alloc_extends_except_offset_min
  alloc_extends_except_offset_min: AXIOM
    (FORALL (a1: alloc_table[A1]):
    (FORALL (a2: alloc_table[A1]):
    (FORALL (l: pset[A1]):
    (alloc_extends_except[A1](a1, a2, l) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a1, p) AND NOT in_pset[A1](p, l) IMPLIES
    offset_min[A1](a1, p) = offset_min[A1](a2, p)))))))

  %% Why axiom alloc_extends_except_offset_max
  alloc_extends_except_offset_max: AXIOM
    (FORALL (a1: alloc_table[A1]):
    (FORALL (a2: alloc_table[A1]):
    (FORALL (l: pset[A1]):
    (alloc_extends_except[A1](a1, a2, l) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a1, p) AND NOT in_pset[A1](p, l) IMPLIES
    offset_max[A1](a1, p) = offset_max[A1](a2, p)))))))

  %% Why axiom disj_sym
  disj_sym: AXIOM
    (FORALL (s1: mybag[A1]):
    (FORALL (s2: mybag[A1]):
    (disj_mybag[A1](s1, s2) IMPLIES disj_mybag[A1](s2, s1))))

  %% Why axiom sub_refl
  sub_refl: AXIOM
    (FORALL (sa: mybag[pointer[A1]]): sub_mybag[pointer[A1]](sa, sa))

  %% Why axiom sub_disj
  sub_disj: AXIOM
    (FORALL (s1: mybag[A1]):
    (FORALL (s2: mybag[A1]):
    (FORALL (s3: mybag[A1]):
    (disj_mybag[A1](s1, s3) IMPLIES
    (sub_mybag[A1](s2, s3) IMPLIES disj_mybag[A1](s1, s2))))))

  %% Why axiom sub_in
  sub_in: AXIOM
    (FORALL (s1: mybag[A1]):
    (FORALL (s2: mybag[A1]):
    (FORALL (p: A1):
    (NOT in_mybag[A1](p, s2) IMPLIES
    (sub_mybag[A1](s1, s2) IMPLIES NOT in_mybag[A1](p, s1))))))

  %% Why axiom sub_sub
  sub_sub: AXIOM
    (FORALL (s1: mybag[A1]):
    (FORALL (s2: mybag[A1]):
    (FORALL (s3: mybag[A1]):
    (sub_mybag[A1](s1, s2) IMPLIES
    (sub_mybag[A1](s2, s3) IMPLIES sub_mybag[A1](s1, s3))))))

END jessie_why_axioms1

jessie_why_sqr_real: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  sqr_real(x:real) : real = x * x

END jessie_why_sqr_real

jessie_why_valid[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_sqr_real

  valid(a:alloc_table[A1], p:pointer[A1]) : bool =
    offset_min[A1](a, p) <= 0 AND offset_max[A1](a, p) >= 0

END jessie_why_valid

jessie_why_same_block[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_valid, jessie_why_sqr_real

  same_block(p:pointer[A1], q:pointer[A1]) : bool =
    base_block[A1](p) = base_block[A1](q)

END jessie_why_same_block

jessie_why_pset_disjoint[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  pset_disjoint(ps1:pset[A1], ps2:pset[A1]) : bool =
    (FORALL (p: pointer[A1]): NOT (in_pset[A1](p, ps1) AND
    in_pset[A1](p, ps2)))

END jessie_why_pset_disjoint

jessie_why_pset_included[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_pset_disjoint, jessie_why_same_block,
    jessie_why_valid, jessie_why_sqr_real

  pset_included(ps1:pset[A1], ps2:pset[A1]) : bool =
    (FORALL (p: pointer[A1]):
    (in_pset[A1](p, ps1) IMPLIES in_pset[A1](p, ps2)))

END jessie_why_pset_included

jessie_why_not_assigns[A1,A2: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  not_assigns(a:alloc_table[A1], m1:memory[A1, A2], m2:memory[A1, A2],
              l:pset[A1]) : bool =
    (FORALL (p: pointer[A1]):
    (valid[A1](a, p) AND NOT in_pset[A1](p, l) IMPLIES
    select[A2, A1](m2, p) = select[A2, A1](m1, p)))

END jessie_why_not_assigns

jessie_why_instanceof[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_not_assigns, jessie_why_pset_included,
    jessie_why_pset_disjoint, jessie_why_same_block, jessie_why_valid,
    jessie_why_sqr_real

  instanceof(a:tag_table[A1], p:pointer[A1], t:tag_id[A1]) : bool =
    subtag[A1](typeof[A1](a, p), t)

END jessie_why_instanceof

jessie_why_root_tag[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_instanceof, jessie_why_not_assigns,
    jessie_why_pset_included, jessie_why_pset_disjoint,
    jessie_why_same_block, jessie_why_valid, jessie_why_sqr_real

  root_tag(t:tag_id[A1]) : bool = parenttag[A1](t, bottom_tag[A1])

END jessie_why_root_tag

jessie_why_fully_packed[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_root_tag, jessie_why_instanceof,
    jessie_why_not_assigns, jessie_why_pset_included,
    jessie_why_pset_disjoint, jessie_why_same_block, jessie_why_valid,
    jessie_why_sqr_real

  fully_packed(tag_table:tag_table[A1], mutable:memory[A1, tag_id[A1]],
               this:pointer[A1]) : bool =
    select[tag_id[A1], A1](mutable, this) = typeof[A1](tag_table, this)

END jessie_why_fully_packed

jessie_why_alloc_fresh[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  IMPORTING jessie_why_decls0, jessie_why_decls1, jessie_why_decls2

  IMPORTING jessie_why_fully_packed, jessie_why_root_tag,
    jessie_why_instanceof, jessie_why_not_assigns, jessie_why_pset_included,
    jessie_why_pset_disjoint, jessie_why_same_block, jessie_why_valid,
    jessie_why_sqr_real

  alloc_fresh(a:alloc_table[A1], p:pointer[A1], n:int) : bool =
    (FORALL (i: int):
    (0 <= i AND i < n IMPLIES NOT valid[A1](a, shift[A1](p, i))))

END jessie_why_alloc_fresh

jessie_why_decls2[A1,A2: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  %% Why logic select
  select: [memory[A2, A1], pointer[A2] -> A1]

  %% Why logic store
  store: [memory[A1, A2], pointer[A1], A2 -> memory[A1, A2]]

  %% Why logic pset_deref
  pset_deref: [memory[A2, pointer[A1]], pset[A2] -> pset[A1]]

  %% Why logic full_separated
  full_separated: [pointer[A1], pointer[A2] -> bool]

  %% Why logic frame_between
  frame_between: [mybag[pointer[A1]], memory[A1, A2], memory[A1, A2] -> bool]

END jessie_why_decls2

jessie_why_decls0: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  %% Why logic bool_and
  bool_and: [bool, bool -> bool]

  %% Why logic bool_or
  bool_or: [bool, bool -> bool]

  %% Why logic bool_xor
  bool_xor: [bool, bool -> bool]

  %% Why logic bool_not
  bool_not: [bool -> bool]

  %% Why logic lt_int_bool
  lt_int_bool: [int, int -> bool]

  %% Why logic le_int_bool
  le_int_bool: [int, int -> bool]

  %% Why logic gt_int_bool
  gt_int_bool: [int, int -> bool]

  %% Why logic ge_int_bool
  ge_int_bool: [int, int -> bool]

  %% Why logic eq_int_bool
  eq_int_bool: [int, int -> bool]

  %% Why logic neq_int_bool
  neq_int_bool: [int, int -> bool]

  %% Why logic abs_int
  abs_int: [int -> int]

  %% Why logic int_max
  int_max: [int, int -> int]

  %% Why logic int_min
  int_min: [int, int -> int]

  %% Why logic lt_real
  lt_real: [real, real -> bool]

  %% Why logic le_real
  le_real: [real, real -> bool]

  %% Why logic gt_real
  gt_real: [real, real -> bool]

  %% Why logic ge_real
  ge_real: [real, real -> bool]

  %% Why logic eq_real
  eq_real: [real, real -> bool]

  %% Why logic neq_real
  neq_real: [real, real -> bool]

  %% Why logic add_real
  add_real: [real, real -> real]

  %% Why logic sub_real
  sub_real: [real, real -> real]

  %% Why logic mul_real
  mul_real: [real, real -> real]

  %% Why logic div_real
  div_real: [real, real -> real]

  %% Why logic neg_real
  neg_real: [real -> real]

  %% Why logic real_of_int
  real_of_int: [int -> real]

  %% Why logic truncate_real_to_int
  truncate_real_to_int: [real -> int]

  %% Why logic floor_real_to_int
  floor_real_to_int: [real -> int]

  %% Why logic ceil_real_to_int
  ceil_real_to_int: [real -> int]

  %% Why logic lt_real_bool
  lt_real_bool: [real, real -> bool]

  %% Why logic le_real_bool
  le_real_bool: [real, real -> bool]

  %% Why logic gt_real_bool
  gt_real_bool: [real, real -> bool]

  %% Why logic ge_real_bool
  ge_real_bool: [real, real -> bool]

  %% Why logic eq_real_bool
  eq_real_bool: [real, real -> bool]

  %% Why logic neq_real_bool
  neq_real_bool: [real, real -> bool]

  %% Why logic real_max
  real_max: [real, real -> real]

  %% Why logic real_min
  real_min: [real, real -> real]

  %% Why logic sqrt_real
  sqrt_real: [real -> real]

  %% Why logic abs_real
  abs_real: [real -> real]

  %% Why logic exp
  exp: [real -> real]

  %% Why logic log
  log: [real -> real]

  %% Why logic log10
  log10: [real -> real]

  %% Why logic pow_real_int
  pow_real_int: [real, int -> real]

  %% Why logic pow_real
  pow_real: [real, real -> real]

  %% Why logic cos
  cos: [real -> real]

  %% Why logic sin
  sin: [real -> real]

  %% Why logic tan
  tan: [real -> real]

  %% Why logic pi
  pi: real

  %% Why logic cosh
  cosh: [real -> real]

  %% Why logic sinh
  sinh: [real -> real]

  %% Why logic tanh
  tanh: [real -> real]

  %% Why logic acos
  acos: [real -> real]

  %% Why logic asin
  asin: [real -> real]

  %% Why logic atan
  atan: [real -> real]

  %% Why logic atan2
  atan2: [real, real -> real]

  %% Why logic hypot
  hypot: [real, real -> real]

  %% Why logic computer_div
  computer_div: [int, int -> int]

  %% Why logic computer_mod
  computer_mod: [int, int -> int]

  %% Why logic math_div
  math_div: [int, int -> int]

  %% Why logic math_mod
  math_mod: [int, int -> int]

  %% Why logic absolute_address
  absolute_address: [int -> pointer[unit]]

  %% Why logic bw_compl
  bw_compl: [int -> int]

  %% Why logic bw_and
  bw_and: [int, int -> int]

  %% Why logic bw_xor
  bw_xor: [int, int -> int]

  %% Why logic bw_or
  bw_or: [int, int -> int]

  %% Why logic lsl
  lsl: [int, int -> int]

  %% Why logic lsr
  lsr: [int, int -> int]

  %% Why logic asr
  asr: [int, int -> int]

END jessie_why_decls0

jessie_why_decls1[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  IMPORTING jessie_why_types1, jessie_why_types2

  %% Why logic ite
  ite: [bool, A1, A1 -> A1]

  %% Why logic base_block
  base_block: [pointer[A1] -> block[A1]]

  %% Why logic offset_max
  offset_max: [alloc_table[A1], pointer[A1] -> int]

  %% Why logic offset_min
  offset_min: [alloc_table[A1], pointer[A1] -> int]

  %% Why logic sub_pointer
  sub_pointer: [pointer[A1], pointer[A1] -> int]

  %% Why logic shift
  shift: [pointer[A1], int -> pointer[A1]]

  %% Why logic null
  null: pointer[A1]

  %% Why logic pointer_address
  pointer_address: [pointer[A1] -> pointer[unit]]

  %% Why logic address
  address: [pointer[A1] -> int]

  %% Why logic eq_pointer_bool
  eq_pointer_bool: [pointer[A1], pointer[A1] -> bool]

  %% Why logic neq_pointer_bool
  neq_pointer_bool: [pointer[A1], pointer[A1] -> bool]

  %% Why logic pset_empty
  pset_empty: pset[A1]

  %% Why logic pset_singleton
  pset_singleton: [pointer[A1] -> pset[A1]]

  %% Why logic pset_union
  pset_union: [pset[A1], pset[A1] -> pset[A1]]

  %% Why logic pset_all
  pset_all: [pset[A1] -> pset[A1]]

  %% Why logic pset_range
  pset_range: [pset[A1], int, int -> pset[A1]]

  %% Why logic pset_range_left
  pset_range_left: [pset[A1], int -> pset[A1]]

  %% Why logic pset_range_right
  pset_range_right: [pset[A1], int -> pset[A1]]

  %% Why logic in_pset
  in_pset: [pointer[A1], pset[A1] -> bool]

  %% Why logic valid_pset
  valid_pset: [alloc_table[A1], pset[A1] -> bool]

  %% Why logic int_of_tag
  int_of_tag: [tag_id[A1] -> int]

  %% Why logic typeof
  typeof: [tag_table[A1], pointer[A1] -> tag_id[A1]]

  %% Why logic parenttag
  parenttag: [tag_id[A1], tag_id[A1] -> bool]

  %% Why logic subtag
  subtag: [tag_id[A1], tag_id[A1] -> bool]

  %% Why logic subtag_bool
  subtag_bool: [tag_id[A1], tag_id[A1] -> bool]

  %% Why logic downcast
  downcast: [tag_table[A1], pointer[A1], tag_id[A1] -> pointer[A1]]

  %% Why logic bottom_tag
  bottom_tag: tag_id[A1]

  %% Why logic alloc_extends
  alloc_extends: [alloc_table[A1], alloc_table[A1] -> bool]

  %% Why logic alloc_extends_except
  alloc_extends_except: [alloc_table[A1], alloc_table[A1], pset[A1] -> bool]

  %% Why logic in_mybag
  in_mybag: [A1, mybag[A1] -> bool]

  %% Why logic disj_mybag
  disj_mybag: [mybag[A1], mybag[A1] -> bool]

  %% Why logic sub_mybag
  sub_mybag: [mybag[A1], mybag[A1] -> bool]

END jessie_why_decls1

jessie_why_types2[A1,A2: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  memory: TYPE+;

END jessie_why_types2

jessie_why_types1[A1: TYPE]: THEORY
BEGIN

  IMPORTING why@jessie
  alloc_table: TYPE+;

  pointer: TYPE+;

  block: TYPE+;

  pset: TYPE+;

  tag_table: TYPE+;

  tag_id: TYPE+;

  mybag: TYPE+;

END jessie_why_types1

