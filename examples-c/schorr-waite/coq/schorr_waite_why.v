(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export caduceus_spec_why.
Require Import BinTree.


(* Why obligation from file "why/schorr_waite.why", characters 296-617 *)
Lemma schorr_waite_impl_po_1 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  (p1 = null -> (~(t1 = null) -> (valid alloc t1))).
Proof.
(* validity of access t->m in the condition of while *)
intuition.
inversion_clear H2;intuition.
apply H4;intuition.
Admitted.

(* Why obligation from file "why/schorr_waite.why", characters 2639-2757 *)
Lemma schorr_waite_impl_po_2 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  (~(t1 = null) -> (valid alloc t1)).
Proof.
(* validity of access to t->m in the condition of the first if *)
intuition.
Admitted.

(* Why obligation from file "why/schorr_waite.why", characters 2779-2836 *)
Lemma schorr_waite_impl_po_3 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test5: t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0),
  (valid alloc p1).
Proof.
(* validity of access to p->c in the condition of the second if *)
intuition.
Admitted.

(* Why obligation from file "why/schorr_waite.why", characters 2977-3001 *)
Lemma schorr_waite_impl_po_4 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test5: t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0),
  forall (Pre32: (valid alloc p1)),
  forall (Test4: (acc c0 p1) <> 0),
  forall (q: pointer),
  forall (Post31: q = t1),
  forall (t2: pointer),
  forall (Post26: t2 = p1),
  forall (p2: pointer),
  forall (Post27: p2 = (acc r0 p1)),
  forall (caduceus_7: pointer),
  forall (Post30: caduceus_7 = t2),
  (valid alloc caduceus_7).
Proof.
(* validity of t in 't->r = q' in the first branch of if *)
 intuition;subst;auto.
Save.

Lemma l1 : forall (alloc : alloc_table) ( l r : memory pointer) (p:pointer)(lp : list pointer)(p1 p0 p2:pointer)  , 
~ In p lp ->reachable alloc l r p1 p0 lp -> reachable alloc l (upd r p p2) p1 p0 lp.
induction lp.
intros.
inversion H0;subst.
constructor.
intros.
inversion H0;subst.
constructor 2;auto.
apply IHlp.
intro;apply H.
right.
auto.
auto.
constructor 3;auto.
assert (p <> a).
intro.
apply H.
left.
auto.
replace (acc (upd r p null) a) with (acc r a ).
apply IHlp.
intro;apply H.
right.
auto.
auto.
rewrite acc_upd_neq;auto.
symmetry.
apply acc_upd_neq.
auto.
Qed.

Lemma l1bis : forall (alloc : alloc_table) ( l r : memory pointer) (p:pointer)(lp : list pointer)(p1 p0 p2:pointer)  , 
~ In p lp ->reachable alloc l r p1 p0 lp -> reachable alloc (upd l p p2) r p1 p0 lp.
induction lp.
intros.
inversion H0;subst.
constructor.
intros.
inversion H0;subst.
constructor 2;auto.
apply IHlp.
intro;apply H.
right.
auto.
rewrite acc_upd_neq;auto.
intro;subst.
apply H.
left;auto.
constructor 3;auto.
apply IHlp.
intro;apply H.
right.
auto.
auto.
Qed.

Lemma l2 :
forall (alloc : alloc_table) (c0: memory Z) (l0 r0: memory pointer)
( l2 : list pointer) (p1 t1: pointer) ,~In p1 l2->lpath alloc
       (fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0)
       (p1 # r0) l2 null ->
lpath alloc
  (fun t : pointer =>
   if Z_eq_dec (t # c0) 0 then t # l0 else t # (upd r0 p1 t1)) (p1 # r0) l2
  null.
intros.
induction H0.
constructor.
constructor 2;auto.
replace (p0 # (upd r0 p1 p2)) with (p0 # r0).
rewrite acc_upd_neq.
apply IHlpath.
intuition.
intro;subst;elim H;left;auto.
symmetry.
apply acc_upd_neq.
intuition.
apply H.
left.
auto.
Qed.

Axiom termination_admitted: (Zwf 0 0 0).

(* Why obligation from file "why/schorr_waite.why", characters 2954-3001 *)
Lemma schorr_waite_impl_po_5 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test5: t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0),
  forall (Pre32: (valid alloc p1)),
  forall (Test4: (acc c0 p1) <> 0),
  forall (q: pointer),
  forall (Post31: q = t1),
  forall (t2: pointer),
  forall (Post26: t2 = p1),
  forall (p2: pointer),
  forall (Post27: p2 = (acc r0 p1)),
  forall (caduceus_7: pointer),
  forall (Post30: caduceus_7 = t2),
  forall (Pre31: (valid alloc caduceus_7)),
  forall (r1: ((memory) pointer)),
  forall (Post64: r1 = (upd r0 caduceus_7 q)),
  ((forall (x_7:pointer),
    ((isreachable alloc l r root x_7) -> (isreachable alloc l0 r1 t2 x_7) \/
     (isreachable alloc l0 r1 p2 x_7))) /\
  (exists stack:plist, ((((((clr_list alloc c0 l0 r1 p2 stack) /\
   (forall (p_0:pointer), ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
   (forall (x_6:pointer),
    (((valid alloc x_6) /\ (isreachable alloc l r root x_6)) /\
     (acc m0 x_6) = 0 -> (unmarked_reachable alloc m0 l0 r1 t2 x_6) \/
     (exists y:pointer, (in_list y stack) /\
      (unmarked_reachable alloc m0 l0 r1 (acc r1 y) x_6))))) /\
   (forall (x_5:pointer),
    (~(in_list x_5 stack) -> (acc r1 x_5) = (acc r x_5) /\
     (acc l0 x_5) = (acc l x_5)))) /\
   (forall (p1:pointer),
    (forall (p2:pointer),
     ((pair_in_list p1 p2 (cons t2 stack)) ->
      (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\ (acc r p2) = p1)) /\
      (((acc c0 p2) = 0 -> (acc l p2) = p1 /\ (acc r p2) = (acc r1 p2))))))) /\
   (forall (x_4:pointer),
    (~(isreachable alloc l r root x_4) -> (acc m0 x_4) = (acc m x_4)))) /\
   (forall (x_3:pointer),
    (~(x_3 = null) /\ (isreachable alloc l r root x_3) -> (valid alloc x_3))))) /\
  (Zwf 0 0 0).
Proof.
(* preservation of loop invariant for the first branch of if "pop" *)
intuition.
generalize (H x_7 H3).
subst.
intuition.
left.
unfold isreachable.
inversion H4;subst.
inversion H2;subst.
exists (p1::nil).
apply Path_right;auto.
assert (acc (upd r0 p1 null) p1 = null).
apply acc_upd.
rewrite H5.
apply Path_null.
inversion H5;elim H7;auto.
inversion H5;elim H7;auto.
inversion_clear H4;subst.
unfold isreachable.
generalize (reachable_no_cycle alloc p1 x_7 l0 r0 x H2).
intros.
inversion_clear H4.
inversion_clear H5.
inversion H6;subst.
left.
exists (@nil pointer).
apply Path_null.
left.
exists (p1::lp).
apply Path_left;auto.
case (In_dec eq_pointer_dec p1 lp).
intro.
simpl in H4.
inversion_clear H4.
destruct In_dec.
inversion H8.
elim (n i).
intro.
apply l1;auto.
right.
exists (lp).
case (In_dec eq_pointer_dec p1 lp).
intro.
simpl in H4.
inversion_clear H4.
destruct In_dec.
inversion H8.
elim (n i).
intro.
apply l1;auto.
inversion_clear H0.
exists (tail x).
intuition.
inversion H3;subst.
elim H1.
auto.
simpl.
destruct (Z_eq_dec (p1 # c0) 0).
elim (Test4 e).
unfold clr_list.
unfold llist.
apply l2;auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p1 l3 H3).
intuition.
apply H9 with p_0;auto.
destruct x.
inversion H0.
simpl in H0.
unfold in_list in *|-*.
right;auto.
generalize (H8 x_6).
intuition.
inversion H10.
inversion H13.
inversion H15;subst.
inversion_clear H0;elim H2;auto.
inversion_clear H16;elim H2;auto.
inversion_clear H16;elim H2;auto.
inversion_clear H10.
inversion_clear H13.
unfold in_list in H10.
destruct x;inversion H10;subst.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 x0 x H3).
intuition.
subst.
casetype False.
assert ((x0#r0) <> null).
inversion H14.
inversion_clear H2.
inversion H16.
subst.
inversion H0;auto.
inversion H2;auto.
inversion H2;auto.
assert (In (x0#r0) x).
inversion_clear H3.
destruct (Z_eq_dec (x0 # c0) 0 ).
elim (Test4 e).
inversion H16.
tauto.
left;auto.
apply (H9 (x0#r0)).
unfold in_list.
simpl;auto.
inversion H14.
inversion_clear H16.
apply H17.
generalize (reachable_in_list alloc l0 r0 (x0#r0) x_6 x1 H18).
intros.
inversion H16.
inversion H19;subst.
left;auto.
subst.
inversion H18;subst.
casetype False.
apply (H9 (x0#r0)).
unfold in_list.
right;auto.
auto.
right.
exists (x0).
simpl.
split.
auto.
assert (In x0 x).
auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p0 x H3).
intros (s,h).
subst p1.
assert (p0 <> x0).
intro.
subst.
apply h;auto.
rewrite acc_upd_neq;auto.
inversion H14.
inversion_clear H16.
unfold unmarked_reachable.
exists x1.
split;auto.
apply l1.
intro.
generalize (H17 p0 H16).
intro.
apply H9 with p0.
unfold in_list.
left;auto.
auto.
auto.
(*i6*)
subst.
generalize (eq_pointer_dec x_5 p1).
intro.
destruct x.
inversion H3.
subst.
elim H1;auto.
inversion_clear H2;subst;caduceus.
generalize (H6 null p1).
intros.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
assert (((p # c0 = 0 -> False) -> p # l = p # l0 /\ p # r = null) /\
     (p # c0 = 0 -> p # l = null /\ p # r = p # r0)).
apply H2.
simpl.
intuition.
inversion_clear H10.
generalize (H11 Test4).
intuition.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
assert (~ In x_5 (p::x)).
intro;inversion_clear H2;auto.
generalize (H7 x_5 H2).
intuition.
(*i6b*)
subst.
generalize (eq_pointer_dec x_5 p1).
intro.
destruct x.
inversion H3.
subst.
elim H1;auto.
inversion_clear H2;subst;caduceus.
generalize (H6 null p1).
intros.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
assert (((p # c0 = 0 -> False) -> p # l = p # l0 /\ p # r = null) /\
     (p # c0 = 0 -> p # l = null /\ p # r = p # r0)).
apply H2.
simpl.
intuition.
inversion_clear H10.
generalize (H11 Test4).
intuition.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
assert (~ In x_5 (p::x)).
intro;inversion_clear H2;auto.
generalize (H7 x_5 H2).
intuition.
(*i7a*)
subst.
destruct x.
inversion H3.
subst.
elim H1;auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons null ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H6 p0 p3 H2);intro.
inversion_clear H11.
generalize (H12 H10);intuition.
auto.
subst.
destruct x.
inversion H3.
subst.
elim H1;auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons null ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H6 p0 p3 H2);intro.
inversion_clear H11.
generalize (H12 H10);intuition.
auto.
subst.
destruct x.
inversion H3.
subst.
elim H1;auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons null ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H6 p0 p3 H2);intro.
inversion_clear H11.
generalize (H13 H10);intuition.
auto.
subst.
assert (p3<> p1).
intro;subst.
elim (Test4 H10).
caduceus.
destruct x.
inversion H3.
subst.
elim H1;auto.
unfold clr_list in H3.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H3).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons null ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H6 p0 p3 H11);intro.
inversion_clear H12.
generalize (H14 H10);intuition.
auto.
apply termination_admitted.
(*i1*)
generalize (H x_7 H5).
intuition.
inversion_clear H7.
subst.
unfold isreachable.
generalize (reachable_no_cycle alloc t1 x_7 l0 r0 x H6). 
intro.
inversion_clear H7.
inversion_clear H8.
generalize (In_dec eq_pointer_dec p1 x0).
intro.
inversion_clear H8.
generalize (split_list p1 x0 H10).
intros (lp0,(lp1,H11)).
subst x0.
generalize (split_reachable alloc t1 x_7 l0 r0 (p1::lp1) (lp0) H9).
intros (p3,(H11,H12)) .
inversion H12;subst.
left.
exists (p1::lp1).
constructor 2;auto.
apply l1;auto.
apply sans_rep_p.
apply (sans_rep_sublist (lp0 ++ p1 :: lp1) lp0 (p1::lp1)  H7).
auto.
right.
exists lp1.
apply l1;auto.
apply sans_rep_p.
apply (sans_rep_sublist (lp0 ++ p1 :: lp1) lp0 (p1::lp1)  H7).
auto.
left.
exists (p1::x0).
constructor 3;auto.
rewrite acc_upd_eq;auto.
apply l1;auto.
(*i1b*)
subst.
inversion_clear H7.
generalize (reachable_no_cycle alloc p1 x_7 l0 r0 x H6). 
intros (path', (H7,H8)).
inversion H8;subst.
unfold isreachable.
left.
exists (@nil pointer).
constructor.
left.
exists (p1::lp).
apply Path_left;auto.
apply l1;auto.
apply sans_rep_p;auto.
right.
exists lp.
apply l1;auto.
apply sans_rep_p;auto.
(*recuperation de la list*)
inversion_clear H0.
exists (tail x).
intuition.
(*i2*)
inversion H5;subst.
elim H1.
auto.
simpl.
destruct (Z_eq_dec (p1 # c0) 0).
elim (Test4 e).
unfold clr_list.
unfold llist.
apply l2;auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p1 l3 H5).
intuition.
(*i3*)
apply H11 with p_0;auto.
destruct x.
inversion H0.
simpl in H0.
unfold in_list in *|-*.
right;auto.
(*i4*)
generalize (H10 x_6).
intuition.
inversion H12.
inversion_clear H15.
inversion H17;subst.
elim (H4 H13).
assert (In t1 (t1::lp)).
left;auto.
generalize (H16 t1 H19);intro;elim (H4 H20).
assert (In t1 (t1::lp)).
left;auto.
generalize (H16 t1 H19);intro;elim (H4 H20).
(*i4b*)
inversion_clear H12.
inversion_clear H15.
unfold in_list in H12.
destruct x;inversion H12;subst.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 x0 x H5).
intros (e,lp).
subst.
casetype False.
assert ((x0#r0) <> null).
inversion H16.
inversion_clear H15.
inversion H18.
subst.
inversion H0;auto.
inversion H15;auto.
inversion H15;auto.
assert (In (x0#r0) x).
inversion_clear H5.
destruct (Z_eq_dec (x0 # c0) 0 ).
elim (Test4 e).
inversion H18.
tauto.
left;auto.
apply (H11 (x0#r0)).
unfold in_list.
simpl;auto.
inversion H16.
inversion_clear H18.
apply H19.
generalize (reachable_in_list alloc l0 r0 (x0#r0) x_6 x1 H20).
intros.
inversion H18.
inversion H21;subst.
left;auto.
subst.
inversion H20;subst.
casetype False.
apply (H11 (x0#r0)).
unfold in_list.
right;auto.
auto.
right.
exists (x0).
simpl.
split.
auto.
assert (In x0 x).
auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p0 x H5).
intros (s,h).
subst p1.
assert (p0 <> x0).
intro.
subst.
apply h;auto.
rewrite acc_upd_neq;auto.
inversion H16.
inversion_clear H19.
unfold unmarked_reachable.
exists x1.
split;auto.
apply l1.
intro.
generalize (H20 p0 H19).
intro.
apply H11 with p0.
unfold in_list.
left;auto.
auto.
auto.
(*i6*)
subst.
generalize (eq_pointer_dec x_5 p1).
intro.
destruct x.
inversion H5.
subst.
elim H1;auto.
inversion_clear H12;subst;caduceus.
generalize (H8 t1 p1).
intros.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
assert (((p # c0 = 0 -> False) -> p # l = p # l0 /\ p # r = t1) /\
     (p # c0 = 0 -> p # l = t1 /\ p # r = p # r0)).
apply H12.
simpl.
intuition.
inversion_clear H13.
generalize (H14 Test4).
intuition.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
assert (~ In x_5 (p::x)).
intro;inversion_clear H12;auto.
generalize (H9 x_5 H12).
intuition.
(*i6b*)
subst.
generalize (eq_pointer_dec x_5 p1).
intro.
destruct x.
inversion H5.
subst.
elim H1;auto.
inversion_clear H12;subst;caduceus.
generalize (H8 t1 p1).
intros.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
assert (((p # c0 = 0 -> False) -> p # l = p # l0 /\ p # r = t1) /\
     (p # c0 = 0 -> p # l = t1 /\ p # r = p # r0)).
apply H12.
simpl.
intuition.
inversion_clear H13.
generalize (H14 Test4).
intuition.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
assert (~ In x_5 (p::x)).
intro;inversion_clear H12;auto.
generalize (H9 x_5 H12).
intuition.
(*i7a*)
subst.
destruct x.
inversion H5.
subst.
elim H1;auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons t1 ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H8 p0 p3 H13);intro.
inversion_clear H14.
generalize (H15 H12);intuition.
auto.
subst.
destruct x.
inversion H5.
subst.
elim H1;auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons t1 ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H8 p0 p3 H13);intro.
inversion_clear H14.
generalize (H15 H12);intuition.
auto.
subst.
destruct x.
inversion H5.
subst.
elim H1;auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons t1 ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H8 p0 p3 H13);intro.
inversion_clear H14.
generalize (H16 H12);intuition.
auto.
subst.
assert (p3<> p1).
intro;subst.
elim (Test4 H12).
caduceus.
destruct x.
inversion H5.
subst.
elim H1;auto.
unfold clr_list in H5.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H5).
intros (s,h).
subst.
replace (cons p ( tail (p::x))) with (p::x) in H0.
assert (pair_in_list p0 p3 (cons t1 ( p :: x))).
simpl.
simpl in H0.
auto.
generalize (H8 p0 p3 H14);intro.
inversion_clear H15.
generalize (H17 H12);intuition.
auto.
apply termination_admitted.
Save.


(* Why obligation from file "why/schorr_waite.why", characters 3149-3185 *)
Lemma schorr_waite_impl_po_6 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test5: t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0),
  forall (Pre32: (valid alloc p1)),
  forall (Test3: (acc c0 p1) = 0),
  forall (q_0: pointer),
  forall (Post25: q_0 = t1),
  forall (t2: pointer),
  forall (Post14: t2 = (acc r0 p1)),
  forall (caduceus_6: pointer),
  forall (Post18: caduceus_6 = p1),
  forall (Pre19: (valid alloc p1)),
  forall (aux_1: pointer),
  forall (Post17: aux_1 = (acc l0 p1)),
  (valid alloc caduceus_6).
Proof.
(* validity of p in "p->r = p->l" in second branch of if "swing" *)
intuition; subst;auto.
Qed.

(* Why obligation from file "why/schorr_waite.why", characters 3149-3185 *)
Lemma schorr_waite_impl_po_7 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test5: t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0),
  forall (Pre32: (valid alloc p1)),
  forall (Test3: (acc c0 p1) = 0),
  forall (q_0: pointer),
  forall (Post25: q_0 = t1),
  forall (t2: pointer),
  forall (Post14: t2 = (acc r0 p1)),
  forall (caduceus_6: pointer),
  forall (Post18: caduceus_6 = p1),
  forall (Pre19: (valid alloc p1)),
  forall (aux_1: pointer),
  forall (Post17: aux_1 = (acc l0 p1)),
  forall (Pre17: (valid alloc caduceus_6)),
  forall (r1: ((memory) pointer)),
  forall (Post56: r1 = (upd r0 caduceus_6 aux_1)),
  (forall (result:pointer),
   (result = p1 ->
    (forall (l1:((memory) pointer)),
     (l1 = (upd l0 result q_0) ->
      (forall (result:pointer),
       (result = p1 ->
        (forall (c:((memory) Z)),
         (c = (upd c0 result 1) ->
          ((forall (x_7:pointer),
            ((isreachable alloc l r root x_7) ->
             (isreachable alloc l1 r1 t2 x_7) \/
             (isreachable alloc l1 r1 p1 x_7))) /\
          (exists stack:plist, ((((((clr_list alloc c l1 r1 p1 stack) /\
           (forall (p_0:pointer), ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
           (forall (x_6:pointer),
            (((valid alloc x_6) /\ (isreachable alloc l r root x_6)) /\
             (acc m0 x_6) = 0 ->
             (unmarked_reachable alloc m0 l1 r1 t2 x_6) \/
             (exists y:pointer, (in_list y stack) /\
              (unmarked_reachable alloc m0 l1 r1 (acc r1 y) x_6))))) /\
           (forall (x_5:pointer),
            (~(in_list x_5 stack) -> (acc r1 x_5) = (acc r x_5) /\
             (acc l1 x_5) = (acc l x_5)))) /\
           (forall (p1:pointer),
            (forall (p2:pointer),
             ((pair_in_list p1 p2 (cons t2 stack)) ->
              (((acc c p2) <> 0 -> (acc l p2) = (acc l1 p2) /\
                (acc r p2) = p1)) /\
              (((acc c p2) = 0 -> (acc l p2) = p1 /\ (acc r p2) = (acc r1 p2))))))) /\
           (forall (x_4:pointer),
            (~(isreachable alloc l r root x_4) -> (acc m0 x_4) = (acc m x_4)))) /\
           (forall (x_3:pointer),
            (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
             (valid alloc x_3))))) /\
          (Zwf 0 0 0))) /\
        (valid alloc result))))) /\
    (valid alloc result))).
Proof.
intros.
split;subst;auto with *.
intros.
split;subst;auto with *.
intros;split.
intros;split.
intros.
inversion_clear Pre35.
(*1*)
generalize (H1 x_7 H0);clear H1.
intros [H3|H4].
unfold isreachable.
inversion H3;subst.
generalize (reachable_no_cycle alloc t1 x_7 l0 r0 x H1).
intros (path,(H4,H5)).
generalize ( In_dec eq_pointer_dec p1 path).
intros [H|H].
generalize (split_list p1 path H). 
intros (path',(path'',H6)).
subst.
generalize (split_reachable alloc t1 x_7 l0 r0  (p1::path'') path' H5).
intros (p3,(H6,H7)).
inversion H7;subst.
right.
exists (p1::path'').
constructor 3;auto.
rewrite acc_upd_eq.
assert (path' ++ p1 :: path'' = path' ++ p1 :: path'').
auto.
generalize (sans_rep_sublist (path' ++ p1 :: path'') path' (p1::path'') H4 H8).
intros.
apply l1bis;auto.
apply sans_rep_p;auto.
apply l1;auto.
apply sans_rep_p;auto.
auto.
left.
exists (path'').
assert (path' ++ p1 :: path'' = path' ++ p1 :: path'').
auto.
generalize (sans_rep_sublist (path' ++ p1 :: path'') path' (p1::path'') H4 H8).
intros.
apply l1bis;auto.
apply sans_rep_p;auto.
apply l1;auto.
apply sans_rep_p;auto.
right.
exists (p1::path).
constructor 2;auto.
rewrite acc_upd_eq.
apply l1bis;auto.
apply l1;auto.
auto.
inversion_clear H4.
unfold isreachable.
generalize (reachable_no_cycle alloc p1 x_7 l0 r0 x H1).
intros (path,(sans_rep,reach)).
inversion reach;subst.
right.
exists (@nil pointer).
constructor.
right.
exists (p1::lp).
constructor 3;auto.
rewrite acc_upd_eq.
apply l1;auto.
apply sans_rep_p;auto.
apply l1bis;auto.
apply sans_rep_p;auto.
auto.
left.
exists lp.
apply l1;auto.
apply sans_rep_p;auto.
apply l1bis;auto.
apply sans_rep_p;auto.
(*recuperation de la list*)
inversion_clear Pre35.
inversion_clear H1.
exists x.
inversion_clear H2.
inversion_clear H1.
inversion_clear H2.
inversion_clear H1.
inversion_clear H2.
inversion_clear H1.
split.
split.
split.
split.
split.
split.
(*i2*)
inversion H2;subst.
inversion Pre19.
elim H.
auto.
unfold clr_list.
unfold llist.
destruct (Z_eq_dec (p1 # (upd c0 p1 1)) 0).
rewrite acc_upd_eq in e.
inversion e.
auto.
unfold clr_list in H2.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p1 l3 H2).
intros (p,In).
constructor 2;auto.
caduceus.
simpl.
rewrite Test3 in H9.
simpl in H9.
apply lpath_eq_fun with      (fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0);auto.
intros.
assert (p1<> p0).
intro;subst.
apply In;auto.
rewrite acc_upd_neq;auto.
rewrite acc_upd_neq;auto.
rewrite acc_upd_neq;auto.
auto.
intros.
generalize (H7 x_6 H1);clear H7;intros [H7|H7].
unfold unmarked_reachable in H7.
inversion_clear H7.
inversion_clear H9.
unfold clr_list in H2.
inversion H10;subst.
decompose [and] H1.
elim Test5.
intro;subst.
inversion H11.
elim H;auto.
intros (H13,H14).
elim H14;auto.
elim Test5.
intro;subst.
inversion H9.
elim H;auto.
intros (H13,H14).
elim H14;auto.
generalize (H7 t1).
intro.
apply H.
left;auto.
elim Test5.
intro;subst.
inversion H9.
elim H;auto.
intros (H13,H14).
elim H14;auto.
generalize (H7 t1).
intro.
apply H.
left;auto.
inversion_clear H7.
inversion_clear H9.
inversion_clear H10.
inversion_clear H9.
destruct x.
inversion H7.
unfold clr_list in H2.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H2).
intros (sub,H12).
subst.
inversion H11;subst.
inversion H7.
subst x0.
left.
unfold unmarked_reachable.
exists (@nil pointer).
split;auto.
constructor.
assert (In x0 x).
auto.
clear H.
right.
exists x0.
split.
right;auto.
rewrite acc_upd_neq.
unfold unmarked_reachable.
exists (@nil pointer).
split;auto.
constructor.
intro;subst;apply H12;auto.
inversion H7.
subst.
left.
unfold unmarked_reachable.
exists (x0 # r0 :: lp).
split;auto.
constructor 2;auto.
assert (in_list x0 (x0::x)).
left;auto.
apply l1.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
rewrite acc_upd_neq;auto.
generalize (H8 (x0) H13).
intro.
intro.
assert (In (x0#r0) ((x0#r0)::lp)).
left;auto.
generalize (H10 (x0#r0) H16).
intro.
rewrite H15 in H14.
elim (H14 H17).
assert (In x0 x).
auto.
clear H13.
right.
exists x0.
split;auto.
unfold unmarked_reachable.
exists (x0#r0::lp).
split;auto.
rewrite acc_upd_neq.
constructor 2;auto.
assert (In p (p::x)).
left;auto.
rewrite acc_upd_neq.
apply l1.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
auto.
intro;subst.
generalize (H8 (x0#r0) H13).
intro.
apply H15.
apply H10.
left;auto.
intro;subst.
apply H12;auto.
inversion H7.
subst.
left.
unfold unmarked_reachable.
exists (x0 # r0 :: lp).
split;auto.
constructor 3;auto.
assert (in_list x0 (x0::x)).
left;auto.
apply l1.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
rewrite acc_upd_neq;auto.
generalize (H8 (x0) H13).
intro.
assert (In (x0#r0) ((x0#r0)::lp)).
left;auto.
generalize (H10 (x0#r0) H15).
intro.
intro.
rewrite H17 in H14.
elim (H14 H16).
assert (In x0 x).
auto.
clear H13.
right.
exists x0.
split;auto.
unfold unmarked_reachable.
exists (x0#r0::lp).
split;auto.
rewrite acc_upd_neq.
constructor 3;auto.
assert (In p (p::x)).
left;auto.
rewrite acc_upd_neq.
apply l1.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
auto.
intro;subst.
generalize (H8 (x0#r0) H13).
intro.
apply H15.
apply H10.
left;auto.
intro;subst.
apply H12;auto.
(*i5*)
intros.
generalize (H6 x_5 H1).
assert (x_5 <>p1).
unfold clr_list in H2.
destruct x.
inversion H2.
subst.
inversion Pre17.
elim H;auto.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H2).
intros (sub,H12).
subst.
intro;subst.
apply H1;left;auto.
rewrite acc_upd_neq;auto.
rewrite acc_upd_neq;auto.
(*i6*)
intros.
generalize (eq_pointer_dec p0 (p1#r0)).
intros [H9|H9].
subst.
unfold clr_list in H2.
destruct x.
inversion H2.
subst.
inversion Pre17.
elim H;auto.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H2).
intros (sub,H12).
subst.
inversion_clear H1;subst;caduceus.
inversion_clear H;subst.
caduceus.
split;intro.
assert (pair_in_list t1 p2 (cons t1 (p2 :: x)) ).
simpl;left;auto.
generalize (H5 t1 p2 H9).
intros (H10,H11).
apply H11;auto.
inversion H.
inversion_clear H.
inversion_clear H1.
destruct x.
inversion H9.
subst p0.
intros.
assert (p2<>p).
intro;subst p.
apply H12;left;auto.
caduceus.
apply H5.
right.
rewrite <- H.
left;auto.
destruct x.
tauto.
assert (In p2 x).
apply (pair_in_list_in (p#r0) p2 p0 ).
auto.
assert (p2<> p).
intro;subst.
apply H12;right;auto.
caduceus.
apply H5.
right;right;auto.
inversion_clear H1.
inversion_clear H10.
elim (H9 ).
auto.
destruct x;auto.
inversion H10.
unfold clr_list in H2.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H2).
intros (sub,H12).
subst.
generalize (pair_in_list_in p0 p2 p (x) H10).
intro.
assert (p2<>p).
intro;subst;apply H12;auto.
caduceus.
apply H5.
right;auto.
(*i7*)
auto.
(*i8*)
auto.
(*termination*)
apply termination_admitted.
Save.



(* Why obligation from file "why/schorr_waite.why", characters 3449-3461 *)
Lemma schorr_waite_impl_po_8 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test2: ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (q_1: pointer),
  forall (Post13: q_1 = p1),
  forall (p2: pointer),
  forall (Post2: p2 = t1),
  (valid alloc t1).
Proof.
intuition.
Save.

(* Why obligation from file "why/schorr_waite.why", characters 3511-3537 *)
Lemma schorr_waite_impl_po_9 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test2: ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (q_1: pointer),
  forall (Post13: q_1 = p1),
  forall (p2: pointer),
  forall (Post2: p2 = t1),
  forall (t2: pointer),
  forall (Post3: t2 = (acc l0 t1)),
  forall (caduceus_3: pointer),
  forall (Post6: caduceus_3 = p2),
  (valid alloc caduceus_3).
Proof.
intros;subst;tauto.
Save.

(* Why obligation from file "why/schorr_waite.why", characters 3488-3537 *)
Lemma schorr_waite_impl_po_10 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test6: ~(p1 = null) \/ p1 = null /\ ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (Pre33: (~(t1 = null) -> (valid alloc t1))),
  forall (Test2: ~(t1 = null) /\ (acc m0 t1) = 0),
  forall (q_1: pointer),
  forall (Post13: q_1 = p1),
  forall (p2: pointer),
  forall (Post2: p2 = t1),
  forall (t2: pointer),
  forall (Post3: t2 = (acc l0 t1)),
  forall (caduceus_3: pointer),
  forall (Post6: caduceus_3 = p2),
  forall (Pre7: (valid alloc caduceus_3)),
  forall (l1: ((memory) pointer)),
  forall (Post48: l1 = (upd l0 caduceus_3 q_1)),
  (forall (result:pointer),
   (result = p2 ->
    (forall (m1:((memory) Z)),
     (m1 = (upd m0 result 1) ->
      (forall (result:pointer),
       (result = p2 ->
        (forall (c:((memory) Z)),
         (c = (upd c0 result 0) ->
          ((forall (x_7:pointer),
            ((isreachable alloc l r root x_7) ->
             (isreachable alloc l1 r0 t2 x_7) \/
             (isreachable alloc l1 r0 p2 x_7))) /\
          (exists stack:plist, ((((((clr_list alloc c l1 r0 p2 stack) /\
           (forall (p_0:pointer), ((in_list p_0 stack) -> (acc m1 p_0) <> 0))) /\
           (forall (x_6:pointer),
            (((valid alloc x_6) /\ (isreachable alloc l r root x_6)) /\
             (acc m1 x_6) = 0 ->
             (unmarked_reachable alloc m1 l1 r0 t2 x_6) \/
             (exists y:pointer, (in_list y stack) /\
              (unmarked_reachable alloc m1 l1 r0 (acc r0 y) x_6))))) /\
           (forall (x_5:pointer),
            (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
             (acc l1 x_5) = (acc l x_5)))) /\
           (forall (p1:pointer),
            (forall (p2:pointer),
             ((pair_in_list p1 p2 (cons t2 stack)) ->
              (((acc c p2) <> 0 -> (acc l p2) = (acc l1 p2) /\
                (acc r p2) = p1)) /\
              (((acc c p2) = 0 -> (acc l p2) = p1 /\ (acc r p2) = (acc r0 p2))))))) /\
           (forall (x_4:pointer),
            (~(isreachable alloc l r root x_4) -> (acc m1 x_4) = (acc m x_4)))) /\
           (forall (x_3:pointer),
            (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
             (valid alloc x_3))))) /\
          (Zwf 0 0 0))) /\
        (valid alloc result))))) /\
    (valid alloc result))).
Proof.
(*push*)
intros.
split;subst;auto with *.
intros.
split;subst;auto with *.
intros;split.
intros;split.
intros.
subst.
inversion_clear Pre35.
generalize (H x_7 H0);clear H.
intros [H|H].
inversion_clear H.
generalize (reachable_no_cycle alloc t1 x_7 l0 r0 x H2). 
intros (path,(H,H3)).
unfold isreachable.
inversion H3;subst.
right.
exists (@nil pointer).
apply l1bis;auto.
left.
exists lp.
apply l1bis;auto.
apply sans_rep_p;auto.
right.
exists (t1::lp).
constructor 3;auto.
apply l1bis;auto.
apply sans_rep_p;auto.
unfold isreachable.
inversion_clear H.
generalize  (reachable_no_cycle alloc p1 x_7 l0 r0 x H2).
intros (path,(H,H3)).
generalize (In_dec eq_pointer_dec t1 path).
intros [H4|H4].
generalize (split_list t1 path H4).
intros (path',(path'',H5)).
subst path.
generalize (split_reachable alloc p1 x_7 l0 r0 (t1 :: path'') path'   H3 ).
intros (p3,(H5,H6)).
inversion H6;subst.
left.
exists (path'').
apply l1bis;auto.
generalize (sans_rep_sublist (path' ++ t1 :: path'') path' (t1::path'') H). 
intro.
apply sans_rep_p.
apply H7.
auto.
right.
exists (t1::path'').
constructor 3;auto.
caduceus.
apply l1bis;auto.
generalize (sans_rep_sublist (path' ++ t1 :: path'') path' (t1::path'') H). 
intro.
apply sans_rep_p.
apply H7.
auto.
right.
exists (t1::path).
constructor 2;auto.
caduceus.
apply l1bis;auto.
(*recuperation de la list*)
inversion_clear Pre35.
inversion_clear H1.
exists x.
inversion_clear H2.
inversion_clear H1.
inversion_clear H2.
inversion_clear H1.
inversion_clear H2.
inversion_clear H1.
split.
split.
split.
split.
split.
split.
(*i2*)


inversion H2;subst.
inversion Pre19.
elim H.
auto.
unfold clr_list.
unfold llist.
destruct (Z_eq_dec (p1 # (upd c0 p1 1)) 0).
rewrite acc_upd_eq in e.
inversion e.
auto.
unfold clr_list in H2.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p1 l3 H2).
intros (p,In).
constructor 2;auto.
caduceus.
simpl.
rewrite Test3 in H9.
simpl in H9.
apply lpath_eq_fun with      (fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0);auto.
intros.
assert (p1<> p0).
intro;subst.
apply In;auto.
rewrite acc_upd_neq;auto.
rewrite acc_upd_neq;auto.
rewrite acc_upd_neq;auto.
auto.
intros.
generalize (H7 x_6 H1);clear H7;intros [H7|H7].
unfold unmarked_reachable in H7.
inversion_clear H7.
inversion_clear H9.
unfold clr_list in H2.
inversion H10;subst.
decompose [and] H1.
elim Test5.
intro;subst.
inversion H11.
elim H;auto.
intros (H13,H14).
elim H14;auto.
elim Test5.
intro;subst.
inversion H9.
elim H;auto.
intros (H13,H14).
elim H14;auto.
generalize (H7 t1).
intro.
apply H.
left;auto.
elim Test5.
intro;subst.
inversion H9.
elim H;auto.
intros (H13,H14).
elim H14;auto.
generalize (H7 t1).
intro.
apply H.
left;auto.
inversion_clear H7.
inversion_clear H9.
inversion_clear H10.
inversion_clear H9.
destruct x.
inversion H7.
unfold clr_list in H2.
generalize (llist_no_rep alloc 
(fun t : pointer => if Z_eq_dec (t # c0) 0 then t # l0 else t # r0) p1 p x H2).
intros (sub,H12).
subst.
inversion H11;subst.
inversion H7.
subst x0.
left.
unfold unmarked_reachable.
exists (@nil pointer).
split;auto.
constructor.
assert (In x0 x).
auto.
clear H.
right.
exists x0.
split.
right;auto.
rewrite acc_upd_neq.
unfold unmarked_reachable.
exists (@nil pointer).
split;auto.
constructor.
intro;subst;apply H12;auto.
inversion H7.
subst.
left.
unfold unmarked_reachable.
exists (x0 # r0 :: lp).
split;auto.
constructor 2;auto.
assert (in_list x0 (x0::x)).
left;auto.
apply l1.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
rewrite acc_upd_neq;auto.
generalize (H8 (x0) H13).
intro.
intro.
assert (In (x0#r0) ((x0#r0)::lp)).
left;auto.
generalize (H10 (x0#r0) H16).
intro.
rewrite H15 in H14.
elim (H14 H17).
assert (In x0 x).
auto.
clear H13.
right.
exists x0.
split;auto.
unfold unmarked_reachable.
exists (x0#r0::lp).
split;auto.
rewrite acc_upd_neq.
constructor 2;auto.
assert (In p (p::x)).
left;auto.
rewrite acc_upd_neq.
apply l1.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
auto.
intro;subst.
generalize (H8 (x0#r0) H13).
intro.
apply H15.
apply H10.
left;auto.
intro;subst.
apply H12;auto.
inversion H7.
subst.
left.
unfold unmarked_reachable.
exists (x0 # r0 :: lp).
split;auto.
constructor 3;auto.
assert (in_list x0 (x0::x)).
left;auto.
apply l1.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
intro.
generalize (H8 (x0) H13).
intro.
apply H15.
apply H10.
right;auto.
rewrite acc_upd_neq;auto.
generalize (H8 (x0) H13).
intro.
assert (In (x0#r0) ((x0#r0)::lp)).
left;auto.
generalize (H10 (x0#r0) H15).
intro.
intro.
rewrite H17 in H14.
elim (H14 H16).
assert (In x0 x).
auto.
clear H13.
right.
exists x0.
split;auto.
unfold unmarked_reachable.
exists (x0#r0::lp).
split;auto.
rewrite acc_upd_neq.
constructor 3;auto.
assert (In p (p::x)).
left;auto.
rewrite acc_upd_neq.
apply l1.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
apply l1bis.
generalize (H8 p H13).
intros.
intro.
apply H15.
apply H10.
right;auto.
auto.
intro;subst.
generalize (H8 (x0#r0) H13).
intro.
apply H15.
apply H10.
left;auto.
intro;subst.
apply H12;auto.



Save.

(* Why obligation from file "why/schorr_waite.why", characters 289-3725 *)
Lemma schorr_waite_impl_po_11 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  forall (Variant1: Z),
  forall (c0: ((memory) Z)),
  forall (l0: ((memory) pointer)),
  forall (m0: ((memory) Z)),
  forall (p1: pointer),
  forall (r0: ((memory) pointer)),
  forall (t1: pointer),
  forall (Pre36: Variant1 = 0),
  forall (Pre35: (forall (x_7:pointer),
                  ((isreachable alloc l r root x_7) ->
                   (isreachable alloc l0 r0 t1 x_7) \/
                   (isreachable alloc l0 r0 p1 x_7))) /\
                 (exists stack:plist,
                  ((((((clr_list alloc c0 l0 r0 p1 stack) /\
                  (forall (p_0:pointer),
                   ((in_list p_0 stack) -> (acc m0 p_0) <> 0))) /\
                  (forall (x_6:pointer),
                   (((valid alloc x_6) /\
                    (isreachable alloc l r root x_6)) /\ (acc m0 x_6) = 0 ->
                    (unmarked_reachable alloc m0 l0 r0 t1 x_6) \/
                    (exists y:pointer, (in_list y stack) /\
                     (unmarked_reachable alloc m0 l0 r0 (acc r0 y) x_6))))) /\
                  (forall (x_5:pointer),
                   (~(in_list x_5 stack) -> (acc r0 x_5) = (acc r x_5) /\
                    (acc l0 x_5) = (acc l x_5)))) /\
                  (forall (p1:pointer),
                   (forall (p2:pointer),
                    ((pair_in_list p1 p2 (cons t1 stack)) ->
                     (((acc c0 p2) <> 0 -> (acc l p2) = (acc l0 p2) /\
                       (acc r p2) = p1)) /\
                     (((acc c0 p2) = 0 -> (acc l p2) = p1 /\
                       (acc r p2) = (acc r0 p2))))))) /\
                  (forall (x_4:pointer),
                   (~(isreachable alloc l r root x_4) -> (acc m0 x_4) =
                    (acc m x_4)))) /\
                  (forall (x_3:pointer),
                   (~(x_3 = null) /\ (isreachable alloc l r root x_3) ->
                    (valid alloc x_3))))),
  forall (Pre34: (p1 = null -> (~(t1 = null) -> (valid alloc t1)))),
  forall (Test1: p1 = null /\ (t1 = null \/ ~(t1 = null) /\ (acc m0 t1) <> 0)),
  ((forall (x_2:pointer), (acc l x_2) = (acc l0 x_2) /\
    (acc r x_2) = (acc r0 x_2)) /\
  (forall (x_1:pointer),
   ((valid alloc x_1) /\ (isreachable alloc l0 r0 root x_1) ->
    (acc m0 x_1) <> 0))) /\
  (forall (x_0:pointer),
   (~(isreachable alloc l0 r0 root x_0) -> (acc m0 x_0) = (acc m x_0))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "why/schorr_waite.why", characters 647-2610 *)
Lemma schorr_waite_impl_po_12 : 
  forall (root: pointer),
  forall (alloc: alloc_table),
  forall (c: ((memory) Z)),
  forall (l: ((memory) pointer)),
  forall (m: ((memory) Z)),
  forall (r: ((memory) pointer)),
  forall (Pre37: (forall (x:pointer),
                  (~(x = null) /\ (isreachable alloc l r root x) ->
                   (valid alloc x) /\ (acc m x) = 0))),
  forall (t: pointer),
  forall (Post35: t = root),
  forall (p: pointer),
  forall (Post34: p = null),
  (forall (x_7:pointer),
   ((isreachable alloc l r root x_7) -> (isreachable alloc l r t x_7) \/
    (isreachable alloc l r p x_7))) /\
  (exists stack:plist, ((((((clr_list alloc c l r p stack) /\
   (forall (p_0:pointer), ((in_list p_0 stack) -> (acc m p_0) <> 0))) /\
   (forall (x_6:pointer),
    (((valid alloc x_6) /\ (isreachable alloc l r root x_6)) /\ (acc m x_6) =
     0 -> (unmarked_reachable alloc m l r t x_6) \/
     (exists y:pointer, (in_list y stack) /\
      (unmarked_reachable alloc m l r (acc r y) x_6))))) /\
   (forall (x_5:pointer),
    (~(in_list x_5 stack) -> (acc r x_5) = (acc r x_5) /\
     (acc l x_5) = (acc l x_5)))) /\
   (forall (p1:pointer),
    (forall (p2:pointer),
     ((pair_in_list p1 p2 (cons t stack)) ->
      (((acc c p2) <> 0 -> (acc l p2) = (acc l p2) /\ (acc r p2) = p1)) /\
      (((acc c p2) = 0 -> (acc l p2) = p1 /\ (acc r p2) = (acc r p2))))))) /\
   (forall (x_4:pointer),
    (~(isreachable alloc l r root x_4) -> (acc m x_4) = (acc m x_4)))) /\
   (forall (x_3:pointer),
    (~(x_3 = null) /\ (isreachable alloc l r root x_3) -> (valid alloc x_3)))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

