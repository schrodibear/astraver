


\hfill\begin{minipage}{0.6\textwidth}
\begin{slshape}
The Schorr-Waite algorithm is the first moutain that any formalism for
pointer aliasing should climb.
\end{slshape}

~\hfill --- Richard Bornat (\cite{bornat00mpc}, page 121)
\end{minipage}

\section{Introduction}

Using formal methods for verifying properties of programs at their
source code level has gained more interest with the increased use of
embedded programs, which are short programs where a high-level of
confidence is required. Such embedded programs are no more written in
assembly language but in C (plane command control, cars, etc.) or in
JavaCard~\cite{JavaCard} (mobile phones, smart cards, etc.).  To
perform formal verification of C or Java programs, one faces the
general issue of verification of pointer programs: \emph{aliasing},
that is referencing a memory location by several ways, must be taken
into account. 

The Schorr-Waite algorithm~\cite{schorr67cacm} is a graph-marking
algorithm, intended to be used in garbage collectors. It performs a
depth-first traversal of an arbitrary graph structure (hence a
structure where aliasing may occur), without using additional memory,
but using the pointers in the graph structure itself as a backtracking
stack. A first (non computer-aided) proof of correctness of this
algorithm has been proposed by Topor~\cite{topor79acta} (see
also~\cite{morris82}). %  Reynolds ? 

%automatic proof by Suzuki ? 

In 2000, Bornat~\cite{bornat00mpc} has been able to perform a
computer-aided formal proof of the Schorr-Waite algorithm using the
Jape system. To make the proof tractable, an old idea by
Burstall~\cite{burstall72} for reasoning on pointer programs as been
reused, called the `component-as-array' trick by Bornat: the heap
memory is not modelled by single large array, but by several ones,
separating the memory into parts where it is statically known that no
aliasing can occur between two parts. These parts correspond to
differents fields of records (i.e. structures in C, or instance
variables in Java).

% PARLER aussi de la preuve en B

In 2003, the Schorr-Waite algorithm has been used again as a case
study by Mehta and Nipkow~\cite{mehta03cade}, this time for
verification of pointer programs in the higher-logic system
Isabelle/HOL. 

In 2004, we proposed a new verification method for ANSI
C source code~\cite{filliatre04icfem}.  A prototype tool has been
implemented, called \caduceus{}, freely available for
experimentation~\cite{Caduceus}. This tool is currently under
experimentation at Axalto (smart cards) and Dassault Aviation
(aeronautics). Unlike formerly mentioned systems, \caduceus{} takes as
input real source code in the C programming language, where
specifications are given inside regular C comments, in the spirit of
the Java Modeling Language~\cite{leavens00jml}. 

To provide an evidence that \caduceus{} is a powerful approach (and
tool) to formal verification of C source, according to Bornat's
citation, we decided to perform again the verification of the
Schorr-Waite algorithm, and this article reports
on this experiment.

It has to be noticed that with \caduceus{}, we indeed formally proved
more properties of the Schorr-Waite algorithm than previous studies.
The first additional property we show is the absence of \emph{threats}
(null pointer dereferencing, out-of-bounds array access, or in general
dereferencing a pointer that does not point to a regularly allocated
memory block): if the initial graph structure is regularly allocated
at the beginning, then no invalid pointer deferencing occur during
execution of the algorithm. Even if this is not hard to do on this
example, it is a crucial property to prove on C programs (in
particular buffer overflow is known to be a major source of bugs), and
it is indeed mandatory with the \caduceus{} approach. The second
additional property we show is about the remaining of the memory, that
is the part of the memory that is not accessible from the root node
given as a starting point of the algorithm. We are able to show that
in this remaining part, nothing is changed. The third additional
property is the termination: although informal termination arguments
were known since Topor~\cite{topor79acta}, % ({\Huge A VERIFIER}), 
no formal
verification has been made before. This is now done.

This paper is organized as follows.  Section~\ref{sec:overview} gives
an overview of the \caduceus{} tool.  In Section~\ref{sec:algo}, we
describe the Schorr-Waite algorithm, and provide a functional
specification for it in the \caduceus{} specification language.
We then describe the formal proof of it in Section~\ref{sec:proof},
including the additional annotations needed, mainly the loop
invariant.  We conclude in Section~\ref{sec:conclusion} with a
comparison to related works.





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
