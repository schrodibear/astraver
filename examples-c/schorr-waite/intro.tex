


\hfill\begin{minipage}{0.42\textwidth}
\begin{slshape}
The Schorr-Waite algorithm is the first moutain that any formalism for
pointer aliasing should climb.
\end{slshape}

~\hfill --- Richard Bornat (\cite{bornat00mpc}, page 121)
\end{minipage}

\section{Introduction}

Using formal methods for verifying properties of programs at their
source code level has gained more interest with the increased use of
embedded programs, which are short programs where a high-level of
confidence is required. Such embedded programs are no longer written in
assembly language but rather in C (plane command control, cars, etc.) or in
JavaCard~\cite{JavaCard} (mobile phones, smart cards, etc.).  To
perform formal verification of C or Java programs, one faces the
general issue of verification of pointer programs: \emph{aliasing},
that is referencing a memory location by several pointers, must be taken
into account. 

The Schorr-Waite algorithm~\cite{schorr67cacm} is a graph-marking
algorithm intended to be used in garbage collectors. It performs a
depth-first traversal of an arbitrary graph structure (hence a
structure where aliasing may occur), without using additional memory,
but using the pointers in the graph structure itself as a backtracking
stack. A first (non computer-aided) proof of correctness of this
algorithm was given by Topor~\cite{topor79acta} in 1979, and in 1982
Morris~\cite{morris82} presented a semi-formal proof using a general
mechanism for dealing with inductive data structures.

%automatic proof by Suzuki ? 

In 2000, Bornat~\cite{bornat00mpc} was able to perform a
computer-aided formal proof of the Schorr-Waite algorithm using the
Jape system~\cite{bornat99}. To make the proof tractable, an old idea
by Burstall~\cite{burstall72} for reasoning on pointer programs was
reused, called the `component-as-array' trick: the heap memory is not
modelled by a single large array, but by several ones, separating the
memory into parts where it is statically known that no aliasing can
occur between two parts. These parts correspond to differents fields
of records (i.e. structures in C, or instance variables in Java).  In
2003, the Schorr-Waite algorithm was used again as a case study by
Mehta and Nipkow~\cite{mehta03cade}, this time for verification of
pointer programs in the higher-logic system Isabelle/HOL. In 2003
also, Abrial~\cite{abrial03fme} performed another verification of this
algorithm, this time based on refinement, using the B system.

In 2004, we proposed a new verification method for ANSI C source
code~\cite{filliatre04icfem}.  A prototype tool has been implemented,
called \caduceus{}, freely available for
experimentation~\cite{Caduceus}. Unlike formerly mentioned systems,
\caduceus{} takes as input real source code in the C programming
language, where specifications are given inside regular C comments, in
the spirit of the Java Modeling Language~\cite{leavens00jml}. It is
not the purpose of this paper to describe \caduceus{} internal
technology, which already have been presented in another
conference~\cite{filliatre04icfem}. Roughly 
speaking, \caduceus{} is a verification condition generator, from
programs annotated with pre- and post-conditions. Those conditions are
generated using a weakest precondition calculus and a monadic
translation to functional programs. An original feature of \caduceus{}
is its multi-prover output: the user may choose to establish the
validity of the generated conditions with several different provers,
both automatic and interactive ones. In this paper, we illustrate the
use of the Simplify~\cite{simplify} automatic prover and the
Coq~\cite{CoqProofAssistant} proof assistant.

To provide an evidence that \caduceus{} is a powerful approach (and
tool) to formal verification of C source, according to Bornat's
citation, we decided to perform again the verification of the
Schorr-Waite algorithm, and this article reports on this experiment.
With \caduceus{}, we indeed formally proved more properties of the
Schorr-Waite algorithm than previous studies.  The first additional
property we show is the absence of \emph{threats} (null pointer
dereferencing, out-of-bounds array access, or more generally dereferencing
a pointer that does not point to a regularly allocated memory block):
if the initial graph structure is regularly allocated, then no invalid pointer deferencing occurs during execution
of the algorithm. Even if this is not hard to do on this example, it
is a crucial property to prove on C programs (in particular buffer
overflow is known to be a major source of bugs), and it is indeed
mandatory with the \caduceus{} approach. The second additional
property we show is an extra behavioral property: everything outside
the graph structure remains unchanged. The third additional property is
the termination: informal termination arguments were known
since Topor~\cite{topor79acta}, and Abrial~\cite{abrial03fme} has a
termination proof integrated in the B refinement process, but we are
the first to provide a formal proof of termination on the implementation
itself.

This paper is organized as follows.  Section~\ref{sec:overview} gives
an overview of the \caduceus{} tool.  In Section~\ref{sec:algo}, we
describe the Schorr-Waite algorithm and give it a behavioral
specification in the \caduceus{} specification language.  Then we
describe the formal proof in Section~\ref{sec:proof}, which
amounts to add more annotations in the source code: a loop invariant
and a variant. We conclude in Section~\ref{sec:conclusion} with a
comparison to related works.





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
