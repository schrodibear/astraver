\documentclass[pdf,proval,slideColor,colorBG,total]{prosper}

\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{pstricks}
\usepackage{pst-node}
%\usepackage{color}
\usepackage{url}
\usepackage{verbatim}

\input{./macros}

\pagestyle{empty}

\newrgbcolor{lightred}{1 0.8 0.8}
\newrgbcolor{lightblue}{0.8 0.8 1}
\newrgbcolor{whycolor}{0 0.5 1}
\newrgbcolor{coqcolor}{1 0.5 0}


\begin{document}
%\sffamily
%\parindent=0mm

\title{Certification de l'algorithme de
  Schorr-Waite avec Caduceus}
\author{Thierry Hubert, Claude Marché}
\institution{Projet PROVAL de l'INRIA --- Équipe DEMONS
  du LRI - Orsay}

\slideCaption{Séminaire LogiCal-ProVal --- 11 mars 2005}

\maketitle





\begin{slide}{Plan de cet exposé}

\begin{enumerate}
\item Motivations
\item L'algorithme de Schorr-Waite
\item Sa spécification formelle en Caduceus
\item Annotation du code 
\item Preuve avec le démonstrateur automatique Simplify
\item Preuve avec Coq
\item Terminaison avec Coq
\item Conclusions
\end{enumerate}

\end{slide}


\begin{slide}{Motivations}

\begin{slshape}
The Schorr-Waite algorithm is the first moutain that any formalism for
pointer aliasing should climb.
\end{slshape}

\hspace*{5cm} --- Richard Bornat \begin{small}(Proving pointer programs in {H}oare logic, In {\em
  Mathematics of Program Construction}, 2000, page 121)
\end{small}

\begin{itemize}
\item 2000, Bornat, système Jape
\item 2003, Mehta \& Nipkow, système Isabelle/HOL
\item 2004, Abrial, système Atelier B
\end{itemize}

$\leadsto$ au tour de Caduceus
\end{slide}

\begin{slide}{Originalité de la preuve avec Caduceus}

\begin{itemize}
\item Directement sur du code source en C
\item Preuve de l'absence de ``segmentation fault'' 
\item Partie inaccessible de la mémoire montrée inchangée
\item Preuve formelle de terminaison
\end{itemize}

\end{slide}


\begin{slide}{L'algorithme de Schorr-Waite}

Parcours d'un graphe orienté (binaire) 
\begin{itemize}
\item en profondeur
\item sans utiliser d'allocation memoire
\end{itemize}

N{\oe}uds du graphe codés par structure C :
\fontsize{10}{10pt}
\begin{alltt}
typedef struct struct_node \{
  unsigned int m :1;         /* marquage */
  unsigned int c :1;         /* usage interne */
  struct struct_node *l, *r; /* fils gauche et droit */
\} * node;
\end{alltt}
La fonction
\fontsize{10}{10pt}
\begin{alltt}
void schorr_waite(node root);
\end{alltt}
doit parcourir le graphe, à partir du n{\oe}ud donné \verb|root|, en
suivant les fils gauche et droits.
\end{slide}




\begin{slide}{L'algorithme de Schorr-Waite en C}
\fontsize{10}{10pt}
\begin{alltt}
void schorr_waite(node root) \{
  node t = root; node p = NULL;
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ \begin{slshape}/* \textbf{pop} */\end{slshape}
        node q = t; t = p; p = p->r; t->r = q;
      \} 
      else \{ \begin{slshape}/* \textbf{swing} */\end{slshape}
        node q = t; t = p->r; p->r = p->l; 
        p->l = q; p->c = 1;
      \}
    \} 
    else \{ \begin{slshape}/* \textbf{push} */ \end{slshape}
      node q = p; p = t; t = t->l; p->l = q; 
      p->m = 1; p->c = 0;
\}\}\}
\end{alltt}
\end{slide}

\overlays{6}{
\begin{slide}{Exemple d'exécution}

\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
%\fbox{
\begin{picture}(100,100)
\put(-50,50){\rnode{fig1}}
\put(-20,50){\rnode{fig2}}
\put(110,50){\rnode{fig3}}
\put(140,50){\rnode{fig4}}
\put(50,100){\rnode{null}{\makebox(0,0)[l]{\tiny NULL}}}
\untilSlide*{1}{\put(50,80){\unode{n0}}}
\fromSlide*{2}{\put(50,80){\mnode{n0}}}
\untilSlide*{2}{\put(20,50){\unode{n1}}}
\fromSlide*{3}{\put(20,50){\mnode{n1}}}
\put(80,50){\unode{n2}}
\untilSlide*{2}{\put(25,90){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\untilSlide*{2}{\put(20,70){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\put(0,20){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(40,20){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(60,20){\rnode{n11}}
\put(100,20){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n2}{n11}
\ncline[linestyle=dotted]{-}{n2}{n12}
\untilSlide*{1}{\ncline{n0}{n1}}
\untilSlide*{5}{\ncline{n0}{n2}}
\untilSlide*{2}{\ncline[nodesepB=1mm]{n1}{null2}}
\untilSlide*{3}{\ncline[nodesepB=1mm]{n1}{null3}}
\onlySlide*{1}{\ncline[nodesepA=2mm]{p}{null}}
\onlySlide*{1}{\ncline[nodesepA=2mm]{t}{n0}}
\untilSlide*{2}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{push}}
%\onlySlide*{2}{\put(80,100){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
%\onlySlide*{2}{\put(0,50){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{2}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{2}{\ncline[nodesepA=2mm]{t}{n1}}
\onlySlide*{2}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{2}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{push}}
\onlySlide*{3}{\put(0,70){\rnode{p}{\makebox(0,0)[br]{$p$}}}}
%\onlySlide*{3}{\put(-10,30){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{3}{\put(20,-10){\rnode{t}{\makebox(0,0)[tl]{$t$}}}}
\onlySlide*{3}{\ncline[nodesepA=2mm]{p}{n1}}
\onlySlide*{3}{\ncline[nodesepB=2mm]{t}{null2}}
\onlySlide*{3}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{3}{\ncarc[arcangleA=150,arcangleB=-20,linewidth=1]{n1}{n0}}
\onlySlide*{3}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{push}}
\onlySlide*{3}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{swing}}
\onlySlide*{4}{\put(0,70){\rnode{p}{\makebox(0,0)[br]{$p$}}}}
\onlySlide*{4}{\put(20,-10){\rnode{t}{\makebox(0,0)[tr]{$t$}}}}
\onlySlide*{4}{\ncline[nodesepA=2mm]{p}{n1}}
\onlySlide*{4}{\ncline[nodesepB=2mm]{t}{null3}}
\onlySlide*{4}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{4}{\ncarc[arcangleA=-120,arcangleB=-40,linewidth=1]{n1}{n0}}
\fromSlide*{4}{\ncline[nodesepB=1mm]{n1}{null2}}
\onlySlide*{4}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{swing}}
\onlySlide*{4}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{pop}}
\fromSlide*{5}{\put(-25,90){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\onlySlide*{5}{\put(-60,60){\rnode{t}{\makebox(0,0)[b]{$t$}}}}
\onlySlide*{5}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{5}{\ncline[nodesepA=2mm]{t}{n1}}
\onlySlide*{5}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\fromSlide*{5}{\ncline[nodesepB=1mm]{n1}{null3}}
\onlySlide*{5}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{pop}}
\onlySlide*{5}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{swing}}
%\onlySlide*{6}{\put(-50,70){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\onlySlide*{6}{\put(30,60){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{6}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{6}{\ncline[nodesepA=2mm]{t}{n2}}
\onlySlide*{6}{\ncarc[nodesepB=1mm,arcangleA=-120,arcangleB=-20,linewidth=1]{n0}{null}}
\fromSlide*{6}{\ncline[nodesepB=1mm]{n0}{n1}}
\onlySlide*{6}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{swing}}
\onlySlide*{6}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{push}}
\end{picture}
%}

\end{center}

\end{slide}}


\begin{slide}{Spécification informelle}

\begin{alltt}
void schorr_waite(node root);
\end{alltt}

\begin{itemize}
\item Les noeuds accessibles à partir de \verb|root| sont initialement
  non-marqués (\verb|n->m == 0|) et marqués à la fin (\verb|n->m == 1|)

\item La structure du graphe est restaurée (pointeurs des fils gauche et
droit restaurés à leurs valeurs initiales)
\end{itemize}
\end{slide}

\begin{slide}{Spécification formelle en Caduceus}

Il faut exprimer l'accessibilité. On introduit
\fontsize{10}{10pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ predicate reachable (node p1, node p2) 
  @   reads p1->l,p1->r */
\end{blue}\end{slshape}\end{alltt}
\begin{itemize}
\item déclaré en Caduceus
\item supposé défini (ou du moins axiomatisé) dans le prouveur.
\item déclaration
  \begin{slshape}\begin{blue}reads\end{blue}\end{slshape} : permet de
  faire dépendre ce prédicat
  de $\verb|p1| (\verb|->l| \cup \verb|->r|)^*$
\end{itemize}

\end{slide}

\begin{slide}{Annotation de la fonction}

\fontsize{10}{10pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ \textbf{requires}
  @  \bs{}forall node x; 
  @     x != \bs{}null && reachable(root,x) => 
  @                           \valid(x) && ! x->m  
  @ \textbf{ensures}
  @  (\bs{}forall node x; \old(x->l) == x->l && 
  @                       \old(x->r) == x->r) 
  @ &&
  @  (\bs{}forall node x; x != \bs{}null && 
  @                       reachable(root,x) => x->m) 
  @ &&
  @  (\bs{}forall node x; ! reachable(root,x) => 
  @                      x->m == \old(x->m))
  @*/\end{blue}\end{slshape}
void schorr_waite(node root);
\end{alltt}
\end{slide}

\newsavebox{\pile}
\savebox{\pile}{\unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(80,83){\rnode{root}{\makebox(0,0)[lb]{root}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {$c=0$}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {$c=1$}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {$c=0$}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\put(40,0){\unode{n1211}}
\put(20,0){\unode{n1212}}
\put(70,43){\rnode{p}{\makebox(0,0)[lb]{$p$}}}
\put(0,30){\rnode{t}{\makebox(0,0)[rb]{$t$}}}

\ncline[linestyle=dotted]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dotted]{n1}{n12}
\ncline[linestyle=dotted]{n12}{n121}
\ncarc[arcangleA=120,arcangleB=30,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\ncline[nodesepA=1mm]{root}{n0}
\ncline{n121}{n1211}
\ncline{n121}{n1212}
\ncline[nodesepA=1mm]{p}{n12}
\ncline[nodesepA=1mm]{t}{n121}
\end{picture}}

\begin{slide}{Annotation du code}

$\leadsto$ trouver le bon invariant de boucle.

\begin{minipage}[b]{0.4\textwidth}
Idée essentielle : codage d'une pile de backtracking dans le graphe
\end{minipage}\hfill
\usebox{\pile}

\end{slide}





\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}
/*@ invariant
  @  (I1 :: \bs{}forall node x; \old(reachable(root,x)) => 
  @    reachable(t,x) || reachable(p,x))
  @ &&
\end{alltt}
N{\oe}ud initialement accessible $\Ra$ accessible par $p$ ou $t$

\begin{comment}
Ce premier invariant indique que tous les noeuds dans le graphe au
debut de la fonction sont atteignable par t ou p.
\end{comment}

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}
@ (I2 :: \bs{}forall node x; x != \bs{}null => 
@         (reachable(t,x) || reachable(p,x)) => 
@         \old(reachable(root,x)))
@ &&
\end{alltt}
N{\oe}ud non null accessible par $p$ ou $t$ $\Ra$ initialement accessible

\begin{comment}
Ce deuxième invariant indique que tous les noeuds non null atteignable
par t ou p etaient dans le graphe avant la fonction.
\end{comment}

\end{slide}


\begin{slide}{Invariant de la boucle}

\fontsize{10pt}{9pt}
\begin{alltt}
@ (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => 
@         x->m == \old(x->m)) 
@ &&
\end{alltt}
N{\oe}ud inaccessible $\Ra$ marquage inchangé

\begin{comment}
Cet invariant indique que tous les noeuds qui n'etait pas dans le
graphe avant la fonction, ont leur marquage inchanger.
\end{comment}
\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}
@ \bs{}exists plist stack;
@  (I4a :: clr_list (p,stack))
@    &&
\end{alltt}

Définition de la pile de backtrack \verb|stack|

\begin{comment}
Cet invariant permet de definir la pile de backtrack.
La declaration de 
\end{comment}
\begin{minipage}[b]{0.4\textwidth}
\verb|clr_list| déclaré dans Caduceus par :
\fontsize{10pt}{9pt}
\begin{alltt}
/*@ predicate 
  @   clr_list(node p, 
  @            plist stack)
  @   reads p->c,p->l,p->r
  @*/
\end{alltt}
\end{minipage}\hfill
\usebox{\pile}
\end{slide}


\begin{slide}{Invariant de la boucle}

\fontsize{10pt}{9pt}
\begin{alltt}
@ (I4b :: \bs{}forall node p; in_list (p,stack) => p->m)  
@ &&
\end{alltt}
\begin{comment}
Cet invariant precise que tous les noeuds dans la pile sont marqués.
La declaration de \verb|in_list| dans caduceus est :
\end{comment}

\begin{minipage}[b]{0.4\textwidth}
Tout n{\oe}ud de la pile est marqué

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}
/*@ predicate 
  @   in_list(node p,
  @           plist stack) */
\end{alltt}
\end{minipage}\hfill
\usebox{\pile}
\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}
@ (I4c :: \bs{}forall node x; 
@   \valid(x) && \old(reachable(root,x)) && !x->m =>
@     unmarked_reachable(t,x) || 
@     (\bs{}exists node y; 
@       in_list(y,stack) && unmarked_reachable(y->r,x))) 
@  &&
\end{alltt}
\begin{comment}
Cet invariant precise que tous les noeuds non marqués qui etaient
valid et dans le graphe au debut de la fonction, sont atteignable par
un chemin non marqués par t ou atteignable par un chemin non marqués
par un des fils droit des noeuds de la pile de backtrack.
La declaration de \verb|unmarked_reachable| dans caduceus est :
\end{comment}

\bigskip

Tout n{\oe}ud accessible non marqué est accessible depuis $t$ ou bien
par un fils droit d'un élément de la pile

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}
/*@ predicate unmarked_reachable(node p1, node p2)
  @   reads p1->r,p1->l,p1->m
  @*/
\end{alltt}

\end{slide}
\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}
@ (I4d ::\bs{}forall node x; !in_list(x,stack) =>  
@        (x->r == \old(x->r) && x->l == \old(x->l))) 
@  &&
\end{alltt}

\begin{minipage}[b]{0.4\textwidth}
N{\oe}ud hors de la pile $\Ra$ les fils sont inchangés par rapport à
leur valeurs initiales
\end{minipage}\hfill
\usebox{\pile}

\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}
@ (I4e :: \bs{}forall node p1; \bs{}forall node p2;
@    pair_in_list(p1,p2,cons(t,stack)) => 
@        (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
@     && (!p2->c => \old(p2->l) == p1 && \old(p2->r) == p2->r)) */
\end{alltt}
\begin{comment}
Enfin cet invariant precise que pour tous les elements de la pile de
backtrack, suivant la valeur de c soit son fils gauche soit son fils
droit est inchangé et leur fils changer est maintenant la pointeur
qui les precède dans la pile ou bien t si ce pointer est en tête de la pile.
La declaration de \verb|pair_in_list| dans caduceus est :
\fontsize{10pt}{9pt}
\begin{alltt}
/*@ predicate pair_in_list(node p1, node p2, plist stack) */
\end{alltt}
\end{comment}
\begin{minipage}[b]{0.4\textwidth}
Précise les fils gauche et droit des éléments de la pile
\end{minipage}\hfill
\usebox{\pile}


\end{slide}
\begin{slide}{La preuve avec Simplify}
\begin{comment}
. invariant vrai init
. poste condition
. 3 fois invariant preserve resp. pop swing push
. validite des acces
. po1 = WF order
. po2 = validite de l'acces a t->m dans la boucle while 
. po3 = validite de l'acces a t->m dans la premiere condition du if 
. po4 = validite de l'acces a  p->c dans la seconde condition du if 
. po5 = validite de t dans 't->r = q' dans la premiere branche du if 
. po6 = preservation de l'invariant de boucle pour le ``pop'' 
. po7 = validite de p dans ``p->r = p->l'' dans la seconde branche du
  if (swing) 
. po8 = preservation de l'invariant de boucle pour le ``swing'' 
. po9 = validite de l'acces a  t dans la branche ``push'' 
. po10 = validite de l'acces a p dans la branche ``push'' 
. po11 = preservation de l'invariant de boucle pour le ``push'' 
. po12 = po du a la terminaison
. po13 = post-condition de la fonction
. po14 = l'invariant vrai au debut de la boucle 

avec Simplify: 

.***.*.*..*.** (6/8/0)

-> 4/12 (po5,7,9 et 10)

ajout axiome reachable(p,p) : 

.....*.*..*.** (9/5/0)   

-> 7/12 (po2,3,4 en plus)

\end{comment}

12 obligations de preuve
\begin{itemize}
\item invariant initialement
\item post-condition de la fonction
\item 3 fois : invariant préservé,  resp. par \textbf{pop},
  \textbf{swing} et \textbf{push}
\item 7 fois : validité d'accès $n\rightarrow f$
\end{itemize}

Simplify prouve 4 accès valides.

Ajout de 
\fontsize{10pt}{9pt}
\begin{alltt}\begin{slshape}
//@ axiom reachable_refl : \bs{}forall node p ; reachable(p,p) 
\end{slshape}\end{alltt}

$\leadsto$ tous les accès sont valides
\end{slide}

\begin{slide}{La preuve Coq}
Nous devons d''abord definir les predicates utilisés par caduceus.
\fontsize{10pt}{9pt}
\begin{alltt}
  Definition llist (a: alloc_table) (next : pointer -> pointer)
  (p:pointer) (l:plist) :=
  lpath a next p l null.

  Definition clr_list (a: alloc_table)  (c:memory Z) 
  (l: memory pointer)(r: memory pointer) : 
  pointer ->list pointer-> Prop :=
  let next t := if Z_eq_dec (acc c t) 0 then (acc l t) 
  else (acc r t) in
  llist a next .
\end{alltt}
Voici donc la d	finition Coq de la pile de backtrack.
\end{slide}
\begin{slide}{La preuve Coq}
\fontsize{10pt}{9pt}
\begin{alltt}
  Inductive path (a: alloc_table) (l: memory pointer)
  (r: memory pointer) : 
  pointer ->  pointer -> list pointer -> Prop :=
    | Path_null : forall p:pointer, path a l r p  p nil
    | Path_left :
      forall p1 p2:pointer,
        forall lp : list pointer,
          valid a p1 ->
            path a l r (acc l p1) p2 lp-> 
               path a l r p1  p2 (p1::lp)
    | Path_right :
      	forall p1 p2:pointer,
          forall lp : list pointer ,
        	valid a p1 ->
        	  path a l r (acc r p1)  p2 lp -> 
                     path a l r p1 p2 (p1::lp). 
\end{alltt}
Ce predicat represente le chemin entre 2 noeuds du graphe.
\end{slide}
\begin{slide}{La preuve Coq}
\fontsize{10pt}{9pt}
\begin{alltt}     
  Definition reachable (a: alloc_table) 
    (l: memory pointer)(r: memory pointer) 
    (p1 :pointer) (p2:pointer) : Prop :=
    exists lp : list pointer, path a l r p1 p2 lp.
\end{alltt}
Ce predicat represente l'accesibilite d'un noeuds a un autre dans le graphe.
\end{slide}
\begin{slide}{La preuve Coq}
\fontsize{10pt}{9pt}
\begin{alltt}
Definition unmarked_reachable (a: alloc_table) 
  (m:memory Z) (l r: memory pointer) (p1 p2:pointer) 
  : Prop :=
  exists lp : list pointer, 
    (forall x : pointer, In x lp -> (acc m x) = 0 ) 
    /\ path a l r p1 p2 lp.
\end{alltt}
Ce predicat represente l'accesibilite par des noeuds non marquer d'un noeuds a un autre dans le graphe.
\end{slide}
\begin{slide}{La preuve Coq}
\fontsize{10pt}{9pt}
\begin{alltt}
Lemma path_no_cycle : forall (a : alloc_table) 
  (p1 p2 : pointer) (l r : memory pointer) 
  (pa : list pointer), path a l r p1 p2 pa -> 
  exists pa' :list pointer, 
  incl pa' pa /\ no_rep pa' /\ path a l r p1 p2 pa'.   
\end{alltt}
Ce lemme affirme que s'y il existe un chemin de p1 a p2, alors il
existe un chemin de p1 a p2 sans repetition.
\end{slide}
\begin{slide}{La preuve Coq}
\fontsize{10pt}{9pt}
\begin{alltt}
Lemma path_upd_left : forall (alloc : alloc_table) 
  (l r : memory pointer) (p:pointer)
  (lp : list pointer) (p1 p0 p2 : pointer), 
  ~ In p lp -> path alloc l r p1 p0 lp -> 
  path alloc (upd l p p2) r p1 p0 lp.
\end{alltt}
Les quatres lemmes \texttt{path\_upd\_left}, \texttt{path\_upd\_right},
\texttt{path\_inv\_upd\_left} et \texttt{path\_inv\_upd\_right}
affirme que si il y a un chemin entre p1 et p2 et que l'ont modifie le
graphe en dehors de ce chemin alors ce chemin existe toujours. 
\end{slide}
\begin{slide}{La preuve de terminaison}
Pour prouver la terminaison il faut monter la terminaison de la boucle
while. Pour cela en caduceus on annote la boucle avec \emph{variant}:
une expression qui decroit a chaque tour de la boucle.
La mesure qui decroit strictement pour cette boucle est 
la mesure lexicographique des 3 mesures suivant :
\begin{enumerate}
\item le nombre de noeud non marquer.
\item le nombre de noeuds qui ont $c=0$
\item la taille de la pile
\end{enumerate}
\end{slide}
\begin{slide}{La preuve de terminaison: généralités}

On définit:
\begin{itemize}
\item La notion d'ordre lexicographique \emph{non-dépendant}
\begin{comment}
\fontsize{10pt}{9pt}
\begin{alltt}
Section lexico.

Variables A B : Set.

Variable Ra : A -> A -> Prop.
Variable Rb : B -> B -> Prop.

Definition lex := lexprod A (fun _:A => B) Ra (fun _:A => Rb).

Lemma lex_well_founded :
 well_founded Ra -> well_founded Rb -> well_founded lex.

End lexico.
\end{alltt} 
Cette section est utilise afin d'avoir une version non dependante de
l'ordre lexicographique.
\end{comment}
\item Une généralisation de \verb|Wf_nat.inv_lt_rel| de Coq pour
\begin{comment}
\fontsize{10pt}{9pt}
\begin{alltt}
Section LT_WF_REL.
Variable A : Set.

Variable X : Set.
Variable lt : X -> X -> Prop.
Variable F : A -> X -> Prop.
Definition inv_lt_rel x y :=
   exists2 n : _, F x n & (forall m, F y m -> lt n m).

Hypothesis lt_wf : well_founded lt.

Remark acc_lt_rel : forall x:A, (exists n : _, F x n) -> Acc
inv_lt_rel x.

Theorem well_founded_inv_rel_compat : well_founded inv_lt_rel.

End LT_WF_REL.

\end{alltt}
Cette section est une copie de la section de meme nom tiree de
WF_nat, mais qui generalise a 
\end{comment}
n'importe quelle relation bien fondée à la place de \verb|<| sur les
nat. 

$\mapsto$ Permet de prouver la terminaison avec des mesures qui 
\begin{enumerate}
\item ne sont pas totales (c.-à.-d. pas définies partout)
\item à valeur dans autre chose que \verb|nat| (ici \verb|nat * nat * nat|)
\end{enumerate}
\end{itemize}

$\mapsto$ ajouts dans la librairie standard de Coq ?
\end{slide}

\begin{slide}{La preuve de terminaison}

% Pour la preuve de terminaison on doit rajouter les elements suivant
% a l'annotation du code.

On doit compléter la spécification
\fontsize{10pt}{9pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ logic Length weight(node p, node t) 
            reads p->m,p->c,p->l,p->r  */
/*@ predicate reachable_elements(node root, plist s) 
            reads root->l,root->r */ 
/*@ requires 
       \bs{}exists plist s; reachable_elements(root,s) && 
     ... */\end{blue}\end{slshape}
void schorr_waite(node root) \{
  node t = root; node p = NULL;\begin{slshape}\begin{blue}
  /*@ invariant ...
    @ variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/\end{blue}\end{slshape}
  while (p != NULL || (t != NULL && ! t->m)) \{
   ...
\end{alltt}
ou en Coq on définit :
\[
\begin{array}{l}
\verb|reachable_elements|(a,l,r, root, s) = %\\\qquad\qquad\qquad 
\forall p, p \in s \leftrightarrow \verb|reachable|(a,l,r,root,p) 
\end{array}
\]
Les fonctions \verb|weight| et \verb|order_mark_m_and_c_and_stack|
définissent la mesure précédente.
\end{slide}
\begin{slide}{Quelques chiffres}
Avec Simplify nous avons prouve 8 obligations de preuves sur 13.

Avec Coq nous avons prouve toutes les obligations de preuves avec :
\begin{enumerate}
\item 317 lignes de definition et 589 lignes de tatics sur les listes
et accesibilite.
\item 985 lignes de obligation de preuve generees automatiquement et
  2411 lignes de tactiques ont ete insere automatiquement pour les
  prouvees.
\item environ 40% du travail a ete fait pour la terminaison
\item 3 semaines ont ete neccessaire pour faire la preuve et 2
  semaines de plus pour la terminaison.  
\end{enumerate}

\end{slide}
\begin{slide}{Conclusion}
On a prouver different aspect de l'algorithme de schorrWaite : 
\begin{enumerate}
\item cette algorithme est bien un aprcours de graphe
\item il ne peu y avoir de ``segmentation fault''
\item que les parties hors du graphes ne sont pas changees
\item la terminaison
\end{enumerate}

De plus contrairement aux autres travaus, cette preuve a ete fait sur un vrai programme C.


\end{slide}
\end{document}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: