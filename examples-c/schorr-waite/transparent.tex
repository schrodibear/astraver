\documentclass[pdf,proval,slideColor,colorBG,total]{prosper}

\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{pstricks}
\usepackage{pst-node}
%\usepackage{color}
\usepackage{url}
\usepackage{verbatim}

\input{./macros}

\pagestyle{empty}

\newrgbcolor{lightred}{1 0.8 0.8}
\newrgbcolor{lightblue}{0.8 0.8 1}
\newrgbcolor{whycolor}{0 0.5 1}
\newrgbcolor{coqcolor}{1 0.5 0}


\begin{document}
%\sffamily
%\parindent=0mm

\title{Certification de l'algorithme de
  Schorr-Waite avec Caduceus}
\author{Thierry Hubert, Claude Marché}
\institution{Projet PROVAL de l'INRIA --- Équipe DEMONS
  du LRI - Orsay}

\slideCaption{Séminaire LogiCal-ProVal --- 11 mars 2005}

\maketitle





\begin{slide}{Plan de cet exposé}

\begin{enumerate}
\item Motivations
\item L'algorithme de Schorr-Waite
\item Sa spécification formelle en Caduceus
\item Sa preuve
\begin{itemize}
\item Annotation du code 
\item Preuve avec le démonstrateur automatique Simplify
\item Preuve avec Coq
\item Terminaison avec Coq
\end{itemize}
\item Conclusions
\end{enumerate}

\end{slide}


\begin{slide}{Motivations}

\begin{slshape}
The Schorr-Waite algorithm is the first moutain that any formalism for
pointer aliasing should climb.
\end{slshape}

\hspace*{5cm} --- Richard Bornat \begin{small}(Proving pointer programs in {H}oare logic, In {\em
  Mathematics of Program Construction}, 2000, page 121)
\end{small}

\begin{itemize}
\item 2000, Bornat, système Jape
\item 2003, Mehta \& Nipkow, système Isabelle/HOL
\item 2004, Abrial, système Atelier B
\end{itemize}

$\leadsto$ au tour de Caduceus
\end{slide}

\begin{slide}{Originalité de la preuve avec Caduceus}

\begin{itemize}
\item Directement sur du code source en C
\item Preuve de l'absence de ``segmentation fault'' 
\item Partie inaccessible de la mémoire montrée inchangée
\item Preuve formelle de terminaison
\end{itemize}

\end{slide}


\begin{slide}{L'algorithme de Schorr-Waite}

Parcours d'un graphe orienté (binaire) 
\begin{itemize}
\item en profondeur
\item sans utiliser d'allocation mémoire
\end{itemize}

N{\oe}uds du graphe codés par structure C :
\fontsize{10}{10pt}
\begin{alltt}\blue
typedef struct struct_node \{
  unsigned int m :1;         \textsl{/* marquage */}
  unsigned int c :1;         \textsl{/* usage interne */}
  struct struct_node *l, *r; \textsl{/* fils gauche et droit */}
\} * node;
\end{alltt}
La fonction
\fontsize{10}{10pt}
\begin{alltt}\blue
void schorr_waite(node root);
\end{alltt}
doit parcourir le graphe, à partir du n{\oe}ud donné \texttt{\blue root}, en
suivant les fils gauches et droits.
\end{slide}




\begin{slide}{L'algorithme de Schorr-Waite en C}
\fontsize{10}{10pt}
\begin{alltt}
void schorr_waite(node root) \{
  node t = root; node p = NULL;
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ \begin{slshape}/* \textbf{pop} */\end{slshape}
        node q = t; t = p; p = p->r; t->r = q;
      \} 
      else \{ \begin{slshape}/* \textbf{swing} */\end{slshape}
        node q = t; t = p->r; p->r = p->l; 
        p->l = q; p->c = 1;
      \}
    \} 
    else \{ \begin{slshape}/* \textbf{push} */ \end{slshape}
      node q = p; p = t; t = t->l; p->l = q; 
      p->m = 1; p->c = 0;
\}\}\}
\end{alltt}
\end{slide}

\overlays{6}{
\begin{slide}{Exemple d'exécution}

\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
%\fbox{
\begin{picture}(100,100)
\put(-50,50){\rnode{fig1}}
\put(-20,50){\rnode{fig2}}
\put(110,50){\rnode{fig3}}
\put(140,50){\rnode{fig4}}
\put(50,100){\rnode{null}{\makebox(0,0)[l]{\tiny NULL}}}
\untilSlide*{1}{\put(50,80){\unode{n0}}}
\fromSlide*{2}{\put(50,80){\mnode{n0}}}
\untilSlide*{2}{\put(20,50){\unode{n1}}}
\fromSlide*{3}{\put(20,50){\mnode{n1}}}
\put(80,50){\unode{n2}}
\untilSlide*{2}{\put(25,90){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\untilSlide*{2}{\put(20,70){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\put(0,20){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(40,20){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(60,20){\rnode{n11}}
\put(100,20){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n2}{n11}
\ncline[linestyle=dotted]{-}{n2}{n12}
\untilSlide*{1}{\ncline{n0}{n1}}
\untilSlide*{5}{\ncline{n0}{n2}}
\untilSlide*{2}{\ncline[nodesepB=1mm]{n1}{null2}}
\untilSlide*{3}{\ncline[nodesepB=1mm]{n1}{null3}}
\onlySlide*{1}{\ncline[nodesepA=2mm]{p}{null}}
\onlySlide*{1}{\ncline[nodesepA=2mm]{t}{n0}}
\untilSlide*{2}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{push}}
%\onlySlide*{2}{\put(80,100){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
%\onlySlide*{2}{\put(0,50){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{2}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{2}{\ncline[nodesepA=2mm]{t}{n1}}
\onlySlide*{2}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{2}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{push}}
\onlySlide*{3}{\put(0,70){\rnode{p}{\makebox(0,0)[br]{$p$}}}}
%\onlySlide*{3}{\put(-10,30){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{3}{\put(20,-10){\rnode{t}{\makebox(0,0)[tl]{$t$}}}}
\onlySlide*{3}{\ncline[nodesepA=2mm]{p}{n1}}
\onlySlide*{3}{\ncline[nodesepB=2mm]{t}{null2}}
\onlySlide*{3}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{3}{\ncarc[arcangleA=150,arcangleB=-20,linewidth=1]{n1}{n0}}
\onlySlide*{3}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{push}}
\onlySlide*{3}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{swing}}
\onlySlide*{4}{\put(0,70){\rnode{p}{\makebox(0,0)[br]{$p$}}}}
\onlySlide*{4}{\put(20,-10){\rnode{t}{\makebox(0,0)[tr]{$t$}}}}
\onlySlide*{4}{\ncline[nodesepA=2mm]{p}{n1}}
\onlySlide*{4}{\ncline[nodesepB=2mm]{t}{null3}}
\onlySlide*{4}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\onlySlide*{4}{\ncarc[arcangleA=-120,arcangleB=-40,linewidth=1]{n1}{n0}}
\fromSlide*{4}{\ncline[nodesepB=1mm]{n1}{null2}}
\onlySlide*{4}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{swing}}
\onlySlide*{4}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{pop}}
\fromSlide*{5}{\put(-25,90){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\onlySlide*{5}{\put(-60,60){\rnode{t}{\makebox(0,0)[b]{$t$}}}}
\onlySlide*{5}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{5}{\ncline[nodesepA=2mm]{t}{n1}}
\onlySlide*{5}{\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}}
\fromSlide*{5}{\ncline[nodesepB=1mm]{n1}{null3}}
\onlySlide*{5}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{pop}}
\onlySlide*{5}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{swing}}
%\onlySlide*{6}{\put(-50,70){\rnode{p}{\makebox(0,0)[r]{$p$}}}}
\onlySlide*{6}{\put(30,60){\rnode{t}{\makebox(0,0)[r]{$t$}}}}
\onlySlide*{6}{\ncline[nodesepA=2mm]{p}{n0}}
\onlySlide*{6}{\ncline[nodesepA=2mm]{t}{n2}}
\onlySlide*{6}{\ncarc[nodesepB=1mm,arcangleA=-120,arcangleB=-20,linewidth=1]{n0}{null}}
\fromSlide*{6}{\ncline[nodesepB=1mm]{n0}{n1}}
\onlySlide*{6}{\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{swing}}
\onlySlide*{6}{\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{push}}
\end{picture}
%}

\end{center}

\end{slide}}


\begin{slide}{Spécification informelle}

\begin{alltt}\blue
void schorr_waite(node root);
\end{alltt}

\begin{itemize}
\item Les n{\oe}uds accessibles à partir de \verb|root| sont supposés initialement
  non-marqués : \texttt{\blue n->m == 0}

\item ils doivent être marqués à la fin : \texttt{\blue n->m == 1}

\item La structure du graphe doit être préservée : pointeurs des fils
  gauches et droits doivent reprendre leurs valeurs initiales
\end{itemize}
\end{slide}

\begin{slide}{Spécification formelle en Caduceus}

Il faut exprimer l'accessibilité. On introduit
\fontsize{10}{10pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ predicate reachable (node p1, node p2) 
  @   reads p1->l,p1->r */
\end{blue}\end{slshape}\end{alltt}
\begin{itemize}
\item déclaré en Caduceus
\item supposé défini (ou du moins axiomatisé) dans le prouveur utilisé.
\item déclaration
  \texttt{\textsl{\blue reads}} : permet de
  faire dépendre ce prédicat
  de \begin{slshape}\texttt{\blue p1} (\texttt{\blue ->l} $\cup$
    \texttt{\blue ->r})$^*$\end{slshape}
\end{itemize}

\end{slide}

\begin{slide}{Spécification formelle en Caduceus}

\fontsize{10}{10pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ \textbf{requires}
  @  \bs{}forall node x; 
  @     x != \bs{}null && reachable(root,x) => 
  @                           \valid(x) && ! x->m  
  @ \textbf{ensures}
  @  (\bs{}forall node x; \old(x->l) == x->l && 
  @                       \old(x->r) == x->r) 
  @ &&
  @  (\bs{}forall node x; x != \bs{}null && 
  @                       reachable(root,x) => x->m) 
  @ &&
  @  (\bs{}forall node x; ! reachable(root,x) => 
  @                      x->m == \old(x->m))
  @*/\end{blue}\end{slshape}
void schorr_waite(node root);
\end{alltt}
\end{slide}

\newsavebox{\pile}
\savebox{\pile}{\unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(80,83){\rnode{root}{\makebox(0,0)[lb]{root}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {$c=0$}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {$c=1$}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {$c=0$}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\put(40,0){\unode{n1211}}
\put(20,0){\unode{n1212}}
\put(70,43){\rnode{p}{\makebox(0,0)[lb]{$p$}}}
\put(0,30){\rnode{t}{\makebox(0,0)[rb]{$t$}}}

\ncline[linestyle=dotted]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dotted]{n1}{n12}
\ncline[linestyle=dotted]{n12}{n121}
\ncarc[arcangleA=120,arcangleB=30,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\ncline[nodesepA=1mm]{root}{n0}
\ncline{n121}{n1211}
\ncline{n121}{n1212}
\ncline[nodesepA=1mm]{p}{n12}
\ncline[nodesepA=1mm]{t}{n121}
\end{picture}}

\begin{slide}{Annotation du code}

$\leadsto$ trouver le bon invariant de boucle.

\begin{minipage}[b]{0.4\textwidth}
Idée essentielle : codage d'une pile de \emph{backtracking} dans le graphe
\end{minipage}\hfill
\usebox{\pile}

\end{slide}





\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}\blue
/*@ invariant
  @  (I1 :: \bs{}forall node x; \old(reachable(root,x)) => 
  @    reachable(t,x) || reachable(p,x))
  @ &&
\end{alltt}

\bigskip

N{\oe}ud initialement accessible $\Ra$ accessible par \texttt{\blue p}
ou \texttt{\blue t}

\begin{comment}
Ce premier invariant indique que tous les n\oe{}uds dans le graphe au
début de la fonction sont atteignable par t ou p.
\end{comment}

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I2 :: \bs{}forall node x; x != \bs{}null => 
@         (reachable(t,x) || reachable(p,x)) => 
@         \old(reachable(root,x)))
@ &&
\end{alltt}

\bigskip

N{\oe}ud non null accessible par \texttt{\blue p} ou \texttt{\blue t}
$\Ra$ initialement accessible 

\begin{comment}
Ce deuxième invariant indique que tous les n\oe{}uds non null atteignable
par t ou p étaient dans le graphe avant la fonction.
\end{comment}

\end{slide}


\begin{slide}{Invariant de la boucle}

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => 
@         x->m == \old(x->m)) 
@ &&
\end{alltt}

\bigskip

N{\oe}ud inaccessible $\Ra$ marquage inchangé

\begin{comment}
Cet invariant indique que tous les n\oe{}uds qui n'était pas dans le
graphe avant la fonction, ont leur marquage inchangé.
\end{comment}
\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ \bs{}exists plist stack;
@  (I4a :: clr_list (p,stack))
@    &&
\end{alltt}

\bigskip

\begin{comment}
Cet invariant permet de définir la pile de \emph{backtrack}.
La déclaration de 
\end{comment}
\begin{minipage}[b]{0.4\textwidth}
Définition de la pile de backtrack \texttt{\blue stack}

\bigskip

\texttt{\blue clr\_list} déclaré dans Caduceus par :
\fontsize{10pt}{9pt}
\begin{alltt}\blue
/*@ predicate 
  @   clr_list(node p, 
  @            plist stack)
  @   reads p->c,p->l,p->r
  @*/
\end{alltt}
\end{minipage}\hfill
\usebox{\pile}
\end{slide}


\begin{slide}{Invariant de la boucle}

\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I4b :: \bs{}forall node p; in_list (p,stack) => p->m)  
@ &&
\end{alltt}
\begin{comment}
Cet invariant précise que tous les n\oe{}uds dans la pile sont marqués.
La déclaration de \verb|in_list| dans Caduceus est :
\end{comment}

\begin{minipage}[b]{0.4\textwidth}
Tout n{\oe}ud de la pile est marqué

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
/*@ predicate 
  @   in_list(node p,
  @           plist stack) */


\end{alltt}
\end{minipage}\hfill
\usebox{\pile}
\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I4c :: \bs{}forall node x; 
@  \valid(x) && \old(reachable(root,x)) && !x->m =>
@    unmarked_reachable(t,x) || 
@    (\bs{}exists node y; 
@     in_list(y,stack) && unmarked_reachable(y->r,x))) 
@  &&
\end{alltt}
\begin{comment}
Cet invariant précise que tous les n\oe{}uds non marqués qui étaient
valides et dans le graphe au début de la fonction, sont atteignable par
un chemin non marqués par t ou atteignable par un chemin non marqués
par un des fils droit des n\oe{}uds de la pile de \emph{backtrack}.
La déclaration de \verb|unmarked_reachable| dans Caduceus est :
\end{comment}

\bigskip

Tout n{\oe}ud accessible non marqué est accessible depuis $t$ ou bien
par un fils droit d'un élément de la pile

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
/*@ predicate unmarked_reachable(node p1, node p2)
  @   reads p1->r,p1->l,p1->m
  @*/
\end{alltt}
(accessibilité par un chemin formé de n{\oe}uds non marqués)

\end{slide}
\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I4d ::\bs{}forall node x; !in_list(x,stack) =>  
@        (x->r == \old(x->r) && x->l == \old(x->l))) 
@  &&
\end{alltt}

\begin{minipage}[b]{0.4\textwidth}
N{\oe}ud hors de la pile $\Ra$ les fils sont inchangés par rapport à
leur valeurs initiales

\bigskip
\end{minipage}\hfill
\usebox{\pile}

\end{slide}

\begin{slide}{Invariant de la boucle}
\fontsize{10pt}{9pt}
\begin{alltt}\blue
@ (I4e :: \bs{}forall node p1; \bs{}forall node p2;
@   pair_in_list(p1,p2,cons(t,stack)) => 
@     (p2->c => 
@         \old(p2->l) == p2->l && \old(p2->r) == p1)
@  && (!p2->c => 
@         \old(p2->l) == p1 && \old(p2->r) == p2->r)) 
@*/
\end{alltt}
\begin{comment}
Enfin cet invariant précise que pour tous les éléments de la pile de
backtrack, suivant la valeur de c soit son fils gauche soit son fils
droit est inchangé et leur fils changer est maintenant la pointeur
qui les precède dans la pile ou bien t si ce pointer est en tête de la pile.
La déclaration de \verb|pair_in_list| dans Caduceus est :
\fontsize{10pt}{9pt}
\begin{alltt}
/*@ predicate pair_in_list(node p1, node p2, plist stack) */
\end{alltt}
\end{comment}
\begin{minipage}[b]{0.4\textwidth}
Précise les fils gauche et droit des éléments de la pile
\bigskip
\bigskip
\bigskip
\end{minipage}\hfill
\usebox{\pile}


\end{slide}
\begin{slide}{La preuve avec Simplify}
\begin{comment}
. invariant vrai init
. poste condition
. 3 fois invariant préserve resp. pop swing push
. validité des accès
. po1 = WF order
. po2 = validité de l'accès a t->m dans la boucle while 
. po3 = validité de l'accès a t->m dans la première condition du if 
. po4 = validité de l'accès a  p->c dans la seconde condition du if 
. po5 = validité de t dans 't->r = q' dans la première branche du if 
. po6 = préservation de l'invariant de boucle pour le ``pop'' 
. po7 = validité de p dans ``p->r = p->l'' dans la seconde branche du
  if (swing) 
. po8 = préservation de l'invariant de boucle pour le ``swing'' 
. po9 = validité de l'accès a  t dans la branche ``push'' 
. po10 = validité de l'accès a p dans la branche ``push'' 
. po11 = préservation de l'invariant de boucle pour le ``push'' 
. po12 = po du a la terminaison
. po13 = post-condition de la fonction
. po14 = l'invariant vrai au début de la boucle 

avec Simplify: 

.***.*.*..*.** (6/8/0)

-> 4/12 (po5,7,9 et 10)

ajout axiome reachable(p,p) : 

.....*.*..*.** (9/5/0)   

-> 7/12 (po2,3,4 en plus)

\end{comment}

12 obligations de preuve
\begin{itemize}
\item invariant initialement vrai
\item post-condition de la fonction
\item invariant préservé,  resp. par \textbf{pop},
  \textbf{swing} et \textbf{push} (3 obligations)
\item validité d'accès $n\rightarrow f$ (7 obligations)
\end{itemize}

Simplify prouve 4 accès valides.

\bigskip
Si ajout de 
\fontsize{10pt}{9pt}
\begin{alltt}\begin{slshape}\blue
/*@ axiom reachable_refl : 
  @    \bs{}forall node p ; reachable(p,p) 
\end{slshape}\end{alltt}

$\leadsto$ tous les accès sont prouvés valides
\end{slide}

\begin{slide}{La preuve en Coq}

Nous devons d'abord \emph{définir} les prédicats déclarés en Caduceus.

\bigskip

On commence par les listes de n{\oe}uds:

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Require Export List.

Definition plist := list pointer.

Definition in_list := (@In pointer).
\end{alltt}
\end{slide}

\begin{slide}{Listes obtenues en suivant des pointeurs}

\texttt{\blue (lpath a next p1 l p2)} :
  il y a un chemin de \texttt{\blue p1} à \texttt{\blue p2} suivant les
  liens \texttt{\blue next}, et \texttt{\blue l} est la liste des
  pointeurs rencontrés sur ce chemin

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Inductive lpath 
   (a: alloc_table) (next: pointer -> pointer) : 
    pointer -> plist -> pointer -> Prop :=
  | Path_null : forall p:pointer, lpath a next p nil p
  | Path_cons : forall p1 p2:pointer, valid a p1 ->
        forall l:list pointer,
          lpath a next (next p1) l p2 -> 
            lpath a next  p1 (cons p1 l) p2.
\end{alltt}  
\bigskip
Listes terminées par \texttt{\blue null} :
\fontsize{10pt}{9pt}
\begin{alltt}\blue
Definition llist 
  (a: alloc_table) (next : pointer -> pointer)
  (p:pointer) (l:plist) := lpath a next p l null.
\end{alltt}
\end{slide}

\begin{slide}{La pile de backtracking}

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Definition clr_list (a: alloc_table)  (c:memory Z) 
  (l: memory pointer)(r: memory pointer) : 
  pointer ->list pointer-> Prop :=

    let next t := if Z_eq_dec (acc c t) 0 then (acc l t) 
                  else (acc r t) 
    in
    llist a next .
\end{alltt}

\bigskip

\texttt{\blue (acc f t)} est l'écriture Coq de \texttt{\blue t->f} :
modèle mémoire de Burstall-Bornat, un tableau par champ de structure.
\fontsize{10pt}{9pt}
\begin{alltt}\blue
acc : forall A:Set, (memory A) -> pointer -> A
\end{alltt}
\end{slide}


\begin{slide}{Chemins dans les graphes}

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Inductive path (a: alloc_table) (l: memory pointer)
  (r: memory pointer) : 
  pointer ->  pointer -> list pointer -> Prop :=
    | Path_null : forall p:pointer, 
            path a l r p  p nil
    | Path_left : forall p1 p2:pointer,
        forall lp : list pointer, valid a p1 ->
            path a l r (acc l p1) p2 lp-> 
               path a l r p1  p2 (p1::lp)
    | Path_right : forall p1 p2:pointer,
        forall lp : list pointer, valid a p1 ->
            path a l r (acc r p1)  p2 lp -> 
               path a l r p1 p2 (p1::lp). 
\end{alltt}
 
\end{slide}



\begin{slide}{Définition de l'accessibilité}

Accessible = existence d'un chemin

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Definition reachable (a: alloc_table) 
    (l: memory pointer)(r: memory pointer) 
    (p1 :pointer) (p2:pointer) : Prop :=

    exists lp : list pointer, 
       path a l r p1 p2 lp.
\end{alltt}
\begin{comment}
Ce prédicat représente l'accessibilité d'un n\oe{}uds a un autre dans le graphe.
\end{comment}
\end{slide}


\begin{slide}{Accessibilité}

Accessibilité suivant des n{\oe}uds non marqués 

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Definition unmarked_reachable (a: alloc_table) 
  (m:memory Z) (l r: memory pointer) (p1 p2:pointer) 
  : Prop :=
  exists lp : list pointer, 
    (forall x : pointer, In x lp -> (acc m x) = 0 ) 
    /\bs{} path a l r p1 p2 lp.
\end{alltt}
\begin{comment}
Ce prédicat représente l'accessibilité par des n\oe{}uds non marqués d'un noeuds à un autre dans le graphe.
\end{comment}
\end{slide}



\begin{slide}{Quelques lemmes essentiels}

Chemins sans cycle :

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Fixpoint no_rep (l:list pointer) : Prop :=
match l with
| nil => True
| (a::l) => 
    (if In_dec eq_pointer_dec a l then False else True)  
    /\bs{} no_rep l
end.


Lemma path_no_cycle : forall (a : alloc_table) 
  (p1 p2 : pointer) (l r : memory pointer) 
  (pa : list pointer), path a l r p1 p2 pa -> 
  exists pa' :list pointer, 
  incl pa' pa /\bs{} no_rep pa' /\bs{} path a l r p1 p2 pa'.   

\end{alltt}
\begin{comment}
Ce lemme affirme que s'y il existe un chemin de p1 a p2, alors il
existe un chemin de p1 a p2 sans répétition.
\end{comment}
\end{slide}



\begin{slide}{Accessibilité et mise à jour}

Besoin de montrer que l'accessibilité est préservée en modifiant un
pointeur non concerné :

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\blue
Lemma path_upd_left : forall (alloc : alloc_table) 
  (l r : memory pointer) (p:pointer)
  (lp : list pointer) (p1 p0 p2 : pointer), 
  ~ In p lp -> path alloc l r p1 p0 lp -> 
  path alloc (upd l p p2) r p1 p0 lp.
\end{alltt}

\bigskip

Lemmes analogues \texttt{\blue path\_upd\_right},
\texttt{\blue path\_inv\_upd\_left} et \texttt{\blue path\_inv\_upd\_right}
\begin{comment}
Les quatre lemmes \texttt{path\_upd\_left}, \texttt{path\_upd\_right},
\texttt{path\_inv\_upd\_left} et \texttt{path\_inv\_upd\_right}
affirme que si il y a un chemin entre p1 et p2 et que l'ont modifie le
graphe en dehors de ce chemin alors ce chemin existe toujours. 
\end{comment}
\end{slide}




\begin{slide}{La preuve de terminaison}

\begin{comment}
Pour prouver la terminaison il faut monter la terminaison de la boucle
while. Pour cela en Caduceus on annote la boucle avec \emph{variant}:
une expression qui décroît a chaque tour de la boucle.
\end{comment}

\begin{itemize}
\item Terminaison du while : clause \texttt{\blue variant} de Caduceus

\item Mesure qui décroît strictement : ordre lexicographique 
\begin{enumerate}
\item nombre de n{\oe}uds non marqués.
\item nombre de n{\oe}uds qui ont $c=0$
\item taille de la pile
\end{enumerate}

\item Léger détail: besoin d'une hypothèse de finitude du graphe !
  (c.-à-d. ensemble fini de n{\oe}uds accessibles)
\end{itemize}

\end{slide}


\begin{slide}{La preuve de terminaison: généralités}

En Coq on définit:
\begin{itemize}
\item La notion d'ordre lexicographique \emph{non-dépendant}
\begin{comment}
\fontsize{10pt}{9pt}
\begin{alltt}
Section lexico.

Variables A B : Set.

Variable Ra : A -> A -> Prop.
Variable Rb : B -> B -> Prop.

Definition lex := lexprod A (fun _:A => B) Ra (fun _:A => Rb).

Lemma lex_well_founded :
 well_founded Ra -> well_founded Rb -> well_founded lex.

End lexico.
\end{alltt} 
Cette section est utilise afin d'avoir une version non dépendante de
l'ordre lexicographique.
\end{comment}
\item Une généralisation de \verb|Wf_nat.inv_lt_rel| de Coq pour
\begin{comment}
\fontsize{10pt}{9pt}
\begin{alltt}
Section LT_WF_REL.
Variable A : Set.

Variable X : Set.
Variable lt : X -> X -> Prop.
Variable F : A -> X -> Prop.
Definition inv_lt_rel x y :=
   exists2 n : _, F x n & (forall m, F y m -> lt n m).

Hypothesis lt_wf : well_founded lt.

Remark acc_lt_rel : forall x:A, (exists n : _, F x n) -> Acc
inv_lt_rel x.

Theorem well_founded_inv_rel_compat : well_founded inv_lt_rel.

End LT_WF_REL.

\end{alltt}
Cette section est une copie de la section de même nom tirée de
WF_nat, mais qui généralise a 
\end{comment}
n'importe quelle relation bien fondée à la place de \verb|<| sur les
nat. 

$\leadsto$ Permet de prouver la terminaison avec des mesures qui 
\begin{enumerate}
\item ne sont pas totales (c.-à.-d. pas définies partout)
\item à valeur dans autre chose que \verb|nat| (ici \verb|nat * nat * nat|)
\end{enumerate}
\end{itemize}

$\leadsto$ ajouts dans la librairie standard de Coq ?
\end{slide}

\begin{slide}{Terminaison : annotations supplémentaires}

% Pour la preuve de terminaison on doit rajouter les elements suivant
% a l'annotation du code.

On doit compléter la spécification
\fontsize{10pt}{9pt}
\begin{alltt}\begin{slshape}\begin{blue}
/*@ logic weight_type weight(node p, node t) 
            reads p->m,p->c,p->l,p->r  */
/*@ predicate reachable_elements(node root, plist s) 
            reads root->l,root->r */ 
/*@ requires 
       \bs{}exists plist s; reachable_elements(root,s) && 
     ... */\end{blue}\end{slshape}
void schorr_waite(node root) \{
  node t = root; node p = NULL;\begin{slshape}\begin{blue}
  /*@ invariant ...
    @ variant weight(p,t) 
    @     for order_mark_m_and_c_and_stack 
    @*/\end{blue}\end{slshape}
  while (...) \{
\end{alltt}
\end{slide}
\begin{slide}{Terminaison en Coq}

en Coq on définit :

\bigskip

\fontsize{10pt}{9pt}
\begin{alltt}\begin{slshape}\begin{blue}
Definition reachable_elements a l r root s := 
   forall p, In p s <-> reachable a l r root p 
\end{blue}\end{slshape}\end{alltt}

\bigskip

\texttt{\blue weight} : un simple Record

\bigskip

\texttt{\blue order\_mark\_m\_and\_c\_and\_stack} : définition de la mesure
lexicographique précédente.

\end{slide}


\begin{slide}{Quelques chiffres}

% Simplify nous avons prouve 8 obligations de preuves sur 13.

Avec Coq nous avons prouvé toutes les obligations de preuves avec :
\begin{enumerate}
\item 317 lignes de définitions et 589 lignes de tactiques sur les
  listes, les graphes, les lemmes d'accessibilité.
\item 985 lignes d'obligation de preuve sont générées automatiquement
  par Caduceus+Why
\item 2411 lignes de tactiques ont été insérées manuellement pour les
  prouver.
\item environ 5 semaines de travail ont été nécessaires.
\item environ 40\% du temps et des lignes de Coq ont été consacrés à
  la terminaison. 
\end{enumerate}

\end{slide}
\begin{slide}{Conclusion}

La montagne Schorr-Waite a pu être conquise par Caduceus 
\begin{enumerate}
\item le langage de spécification est suffisamment puissant
\item on peut traiter du vrai code C, et montrer l'absence de
  ``segmentation fault'' 
\item la terminaison peut être traitée aussi
\end{enumerate}

\bigskip

Quelle serait la montagne suivante ?

\end{slide}
\end{document}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End:
% LocalWords:  pt list stack
