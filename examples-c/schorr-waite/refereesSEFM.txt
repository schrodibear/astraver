------------- Review from Reviewer 1 -------------
Evaluation of work impact and contribution 
(1=not at all important, 3=limited importance, 5=somewhat important, 7=important, 10=highly important)  : 7
Significance to theory and practice
(1=no significance, 3=limited significance, 5=somewhat significant, 7=significant, 10=highly significant) : 7
Originality and novelty
(1=not original, 3=little originality, 5=somewhat original, 7=original, 10=highly original)  : 5
Relevance to SEFM 2005
(1=not relevant, 3=little relevance, 5=some relevance, 7=relevant, 10=very relevant) : 9
Readability and organization
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 8
Technical quality and soundness
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 7
Overall recommendation
(1=strong reject, 3= weak reject, 5=borderline, 7=weak accept, 10=strong accept) : 8
Reviewer familiarity
(1=no confidence, 3=little confidence, 5=some confidence, 7=confident, 10=very confident)  : 8

-- Comments to the author(s):
WORK IMPACT AND CONTRIBUTION

The paper presents an approach to verify C programs with pointers.  This is clearly a challenging task and the authors have made a contribution to this field.







RELEVANCE





This is definitely of interest to SEFM.





ORIGINALITY



While there have been many attempts to verify the Schorr-Waite algorithm, verifying at the C source code level is novel.









SIGNIFICANCE TO THEORY AND PRACTICE



This approach could be applied to a variety of programs.











TECHNICAL QUALITY



The technical details are, in general,  of high quality.









QUALITY OF PRESENTATION



The paper is also easy to read.











OTHER COMMENTS FOR THE AUTHOR(S):



DONE The authors should comment on the cost of switching verification tools
(e.g., from Simplify to Coq). I suspect it is not as straightfoward as
the paper seems to indicate.



TODO On page 8, they claim that their approach is different from that reported in [13]. A few details on the difference and why this is important should be added.





The paper has a number of minor errors which can be fixed easily.



DONE In section 4, the first sentence: The function is now formally specified. It is not clear which function is bein specified.

DONE In section 4.4 second paragraph. "It may be surprised"  should read "It may be surprising" 


-- Summary:
In summary, this paper presents an interesting case study and shows how verification of real pograms (with pointers) can be attempted.  
---------- End of Review from Reviewer 1 ----------

------------- Review from Reviewer 2 -------------
Evaluation of work impact and contribution 
(1=not at all important, 3=limited importance, 5=somewhat important, 7=important, 10=highly important)  : 7
Significance to theory and practice
(1=no significance, 3=limited significance, 5=somewhat significant, 7=significant, 10=highly significant) : 8
Originality and novelty
(1=not original, 3=little originality, 5=somewhat original, 7=original, 10=highly original)  : 7
Relevance to SEFM 2005
(1=not relevant, 3=little relevance, 5=some relevance, 7=relevant, 10=very relevant) : 10
Readability and organization
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 6
Technical quality and soundness
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 7
Overall recommendation
(1=strong reject, 3= weak reject, 5=borderline, 7=weak accept, 10=strong accept) : 8
Reviewer familiarity
(1=no confidence, 3=little confidence, 5=some confidence, 7=confident, 10=very confident)  : 8

-- Comments to the author(s):
WORK IMPACT AND CONTRIBUTION

- Does the work constitute a significant contribution to its field?



The work indeed constitutes a significant contribution to its

field, since the approach presented appears to have quite some

application potential in realistic settings and is still rather

flexible, e.g. wrt. the proof engines used.





RELEVANCE

- Is the work relevant for SEFM 2005?



Undoubtedly.







ORIGINALITY

- Is the work described in the paper novel?



The problem tackled in the paper, namely verification of the

Schorr-Waite algorithm, and some of the main proof ideas, are not

orginal, since this has been done by various authors before. However,

what is very likely to be original is the development of this

specification and verification experiment within the Caduceus language

and system (which in turn is not described in the paper

itself). Moreover, some parts of the verification properties

(probably) have not been verified before. 









SIGNIFICANCE TO THEORY AND PRACTICE

- Is the work important?



The combination of being able to handle arbitrary ANSI C source code

and to generate verification conditions (from annotated programs) via

Caduceus on one hand, and to prove corresponding properties with

existing theorem provers is a very important and promising, yet also

notoriously difficult area. My impression is that, even though the

tool itself is not really described (which is a drawback of the

paper), this approach is quite promising and likely to work not only

in toy examples. Hence, I think the work has substantial

significance. 











TECHNICAL QUALITY

- Is the work technically sound?

- Are the paper's arguments compelling?

- Is there a compelling empirical evaluation?



Technical soundness cannot really be judged from the presentation,

since only fragments of specifications and proofs are given. The

quantitative evaluation of the experiments(s) indicate that an

enormous amount of manual work remains to be done on the verification

side, even with a powerful prover like Coq (and, moreover, requires

high expertise with the respective systems). Perhaps this is not

really surprising as this phenoemenon is well known from other case

studies, too. Somehow a weakness of the approach is the hybrid

character of the specification and prover languages which requires

non-trivial translations and impedes credibility of the original

verification claims. 









QUALITY OF PRESENTATION

- Is the paper clearly written?

- Does the paper motivate the research?

- Is the paper well organized?



The paper is quite well written and structured, with some imprecisions

and many typos (see below). The technical parts are not easy to

digest, but this is at least partially due to the inherent complexity

of the Schorr-Waite algorithm.









OTHER COMMENTS FOR THE AUTHOR(S):

- Please provide comprehensive feedback to the authors.



TODO page2 2-4: give at least an informal description of the Schorr-Waite

  algorithm (for the sake of readability)! 

TODO page 3, left col., 3.1: discuss briefly this restriction (what would

  be different without it?!

DONE page 4, left col.: to explore -> to be explored;

DONE is explored -> has been explored;

DONE   this is not -> it is not;

DONE   latter -> later

DONE page 4, right col.: indeed mean -> indeed means

DONE page 5, left col. line 3 (and later): make clear what you mean by 'an

     expression ... is valid'! do you mean something like 'admissible' or

     'defined'?

DONE page 5, left col., line 15: 'of the function': which function do you

     mean?

DONE page 5, left col., bottom: 'The design ... proof itself.': this claim

     seems to be a self-contradiction (at least if the design of the

     invariant is considered to be part of the proof)! 

DONE page 5, right col., 4.1: 'on Figure ...' -> 'in Figure ...' (here and

     later)

TODO page 5, right col., 4.1: 'The normal arrows correspond to unmodified

     links': I don't really understand this, because the link from p or t

     is modified but is still 'normal'!?

DONE   children -> child (twice)

DONE page 6, right col., bottom: may not be -> may be not (because of

     different semantics)

TODO page 7, right col., lines 13-14: why did your attempts (using

     Simplify) fail? this is important because one could argue that you

     just haven't tried hard enough; or are there any principal/essential

     problems that cannot be overcome with Simplify?

TODO   also at the beginning of 4.4: it would be useful to roughly describe

     the functionality, strengths and weaknesses of Simplify;

DONE page 7, right col.: surprised -> surprising

TODO page 8, left col.: 'the most important one is ...': why is this the

     most important one?

TODO page 8, left col.: 'With those definitions and lemmas, we are able

     ... in Coq.: what you do not tell is how many fruitless efforts

    (inappropriate definitions, false lemmas, inappropriate lemmas etc.)

    you have started until the final proof went through; some comments

    in this direction would also be instructive! 

DONE page 8, right col.: decrease -> decreases;

DONE   given Figure 6 -> given in Figure 6;

TODO   artifact of the Cadeus ...? what do you mean here?

DONE page 9, left col.: in term of -> in terms of

TODO   '2411 lines of tactics were inserted manually': this sounds quite a

    lot, and probably only takes into account the final successful run!?

DONE page 9, left col.: well-founded relation -> well-founded relations

TODO page 9, left col. second half: the claim 'But as far as we know ...'

     seems to be (too) strong (since you don't know what can still be

    done in the future with other approaches, even if it has  not been

    done previously); perhaps you should weaken that a bit; 

DONE page 9, left col.: does not any -> does not do any

TODO page 9, right col., line 3: 'the Caduceus approach': in this paper

      this is undefined!

DONE   defined -> defining

DONE   this are -> these are

TODO page 9, right col, first paragr.: 'This would require to define

     predicates ... only in higher-order logical frameworks': this is

     quite unclear! why?

DONE   major goal -> major goals

DONE   than automatic provers -> than those of automatic provers

DONE   the develop -> to develop

DONE   fail -> fails

DONE   ask -> asked

DONE   to embedded -> on embedded

TODO page 9, right col, line 3 from bottom: 'solutions': for what?

DONE page 10, left col.: its fruitful -> his fruitful

DONE   [3]: page numbers are missing


-- Summary:
Summary



The paper describes (more precisely, sketches) an experiment of formal

verification of a C source code program for the Schorr-Waite

algorithm, using the Caduceus annotation language and tool as well as

some (automatic and interactive) theorem provers as backends for the

verification tasks. 



Even though the application example treated here is not original, the

approach presented appears to have quite some application potential in

realistic settings and is still rather flexible. Despite a few

weaknesses, the paper is certainly an interesting contribution that,

in my opinion, should definitely be accepted for SEFM 2005.


---------- End of Review from Reviewer 2 ----------

------------- Review from Reviewer 3 -------------
Evaluation of work impact and contribution 
(1=not at all important, 3=limited importance, 5=somewhat important, 7=important, 10=highly important)  : 6
Significance to theory and practice
(1=no significance, 3=limited significance, 5=somewhat significant, 7=significant, 10=highly significant) : 6
Originality and novelty
(1=not original, 3=little originality, 5=somewhat original, 7=original, 10=highly original)  : 4
Relevance to SEFM 2005
(1=not relevant, 3=little relevance, 5=some relevance, 7=relevant, 10=very relevant) : 8
Readability and organization
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 6
Technical quality and soundness
(1=poor, 3=somewhat weak, 5=acceptable, 7=good, 10=excellent) : 4
Overall recommendation
(1=strong reject, 3= weak reject, 5=borderline, 7=weak accept, 10=strong accept) : 3
Reviewer familiarity
(1=no confidence, 3=little confidence, 5=some confidence, 7=confident, 10=very confident)  : 7

-- Comments to the author(s):
WORK IMPACT AND CONTRIBUTION

- Does the work constitute a significant contribution to its field?



I was excited to see this paper and read its results.  Verification of

C programs, especially for non-trivial functional properties is

something I've been waiting years for.  I think that the underlying

techniques here, especially as applied at the source code level, and

through the reutilisation of the Why tool for another domain, is

great.  Additionally, supporting multiple provers really gives the

ability to leverage different decision procedures and logical

frameworks as appropriate for the problem domain.  That's potentially

a winning design choice as well.



RELEVANCE

- Is the work relevant for SEFM 2005?



This work is of direct relevance to SEFM.



ORIGINALITY

- Is the work described in the paper novel?



The work here is somewhat novel, as it is very much inspired by

similar approaches in verification of programs at the source code

level, in tandem with standard approaches to reasoning about programs

with pointers.  It is really an incremental advance to reasoning about

C programs, but a welcome one at that.



SIGNIFICANCE TO THEORY AND PRACTICE

- Is the work important?



This work is a logical, important next step in the development of

real-world verification tools for C programs.



TECHNICAL QUALITY

- Is the work technically sound?

- Are the paper's arguments compelling?

- Is there a compelling empirical evaluation?



The work looks technically sound, but that presumes a lot of user

assumptions and trust of the authors.  There are unfortunately (too)

many issues glossed over in the paper as it currently stands.  The

focus on verifiying the Schorr-Waite algorithm is a wise target, as it

is a small-but-non-trivial algorithm that has been investigated by

others using several different techniques.  This gives a reasonable

relativistic standpoint for the techniques and tools presented here.



QUALITY OF PRESENTATION

- Is the paper clearly written?

- Does the paper motivate the research?

- Is the paper well organized?



The paper is relatively well-organised and a fairly easy read.  The

motivation is clear.



There are a few small problems with the presentation which are

stylistic:

DONE  o never use citations as nouns (e.g., "we refer to [8,9] for more

   information").

DONE  o the font and size of several words (e.g., Caduceus, cons) is a bit

   off and needs to be revisited.

DONE  o lisp => Lisp

DONE  o explain what "m:1" means in C for old C hackers that have forgotten

   about such.

DONE  o first order => first-order

DONE  o "With respect to the most recent formal..." most recent wrt what?

DONE   In the same paragraph, why are the mentioned preconditions not 

   actually presented in the paper?

DONE  o "is the most difficult part of the verification process" =>

   "is the most difficult part of this verification process" (this is

   an overly strong claim)

DONE  o "...which is limited to first-order..." (rewrite/reword for clairity)

DONE  o "...obligation is indeed not..." (cut "indeed")\

DONE  o "So finally Simplify solves..." (rewrite/reword for clarity)

DONE  o "We have not only...." (rewrite/reword for clarity)

DONE  o "Note that with Caduceus, as shown..." (a few spelling and grammar

   errors are in this and adjacent sentences)

DONE  o ESC/Java does not generate annotations; Daikon and Houdini do.



The medium-level problems I have with the paper are:

DONE  o if you support PVS and were worried about the size and complexity

   of the resulting manual verification, why in the world use the Coq

   backend?

DONE  o if you support Harvey and CVC-lite, why use Simplify, given the

   latter's well-known problems with soundness and stability?

DONE  o you mention that the loop variant can be an arbitrary well-founded

   relation



The big problems with the paper are:

TODO  o a crucial lack of details about some important aspects of the

   problem and solution which are fobbed off on the reader.  E.g., I

   had to download the tool and read the source to understand some of

   the claims in the paper.  In particular, many predicates are

   mentioned in the paper but are undefined (wrt their semantics,

   which is critical for comprehending the verification and the

   paper's many claims).  There are still some predicates that I do

   not understand even after looking at the code for an hour (e.g.,

   reachable).  This is a serious problem.

TODO  o while there is a verification involving loop invariants, you

   do not define the semantics of such anywhere.

TODO  o you have defined a number of datatypes that related to specification

   constructs (e.g., loop invariants) but they are not presented in the

   paper.  what's more, how are we to know if the datatypes and related

   definitions that you have introduced are sound or not?  how do we

   know if they have equivalent semantics across all >=4 provers you

   support?  some discussion about these issues is warranted.

DONE  o a very bad misrepresentation of the main related work on JML and

   verification tools supporting such.  In particular, there seems to

   be a complete ignorance about model variables and model methods,

   notions of reachability, the semantics of JML expressions with

   undefined subexpressions, etc.  the main goal of JML has nothing to

   do with runtime checking as well; it is just one application, and

   not even a very interesting one at that.  also, reasoning about

   model methods is supported in several tools (e.g., Loop and

   ESC/Java2), invalidating the claims at the end of the lengthy

   paragraph in the conclusion about JML.

   CLAUDE : parler du \reach de JML ?



OTHER COMMENTS FOR THE AUTHOR(S):

- Please provide comprehensive feedback to the authors.


-- Summary:
While the work is relevant and interesting and looks to be technically

valid, there are serious presentation problems. If the authors were to

fix their serious misrepresentation of JML and related tools as well

as improve the exposition and actually explain what the semantics of

the many mentioned predicates actually is then I would reconsider this

paper for SEFM.  As it stands it is simply not acceptable.




---------- End of Review from Reviewer 3 ----------



-- 
SEFM 2005 - http://sefm2005.uni-koblenz.de
3rd IEEE International Conference on Software Engineering and Formal Methods
September 7-9, 2005, Koblenz, Germany
