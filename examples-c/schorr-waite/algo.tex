
\section{The Schorr-Waite algorithm and its formal specification}
\label{sec:algo}

The Schorr-Waite algorithm performs a depth-first traversal of a
directed graph, starting from a specific node of the graph called the
root. Its main characteristic is that it directly uses the pointers of
the graph to implement backtracking. This is why its soundness is
quite difficult to establish. 

\subsection{The C source code}

\begin{figure*}[t]
\begin{alltt}
void schorr_waite(node root) \{
  node t = root; node p = NULL;
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ \begin{slshape}/* \textbf{pop} */\end{slshape}
        node q = t; t = p; p = p->r; t->r = q;
      \} 
      else \{ \begin{slshape}/* \textbf{swing} */\end{slshape}
        node q = t; t = p->r; p->r = p->l; p->l = q; p->c = 1;
      \}
    \} 
    else \{ \begin{slshape}/* \textbf{push} */ \end{slshape}
      node q = p; p = t; t = t->l; p->l = q; p->m = 1; p->c = 0;
    \}
  \}
\}
\end{alltt}
\caption{C version of the Schorr-Waite algorithm}
\label{fig:code}
\end{figure*}

\begin{figure*}
\vspace*{2mm}
\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
%\fbox{
\begin{picture}(180,65)(-80,115)
\put(-80,180){\rnode{null}{\makebox(0,0)[l]{\tiny NULL}}}
\put(-80,160){\unode{n0}}
\put(-70,140){\unode{n1}}
\put(-90,140){\unode{n2}}
\put(-100,180){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(-100,160){\rnode{t}{\makebox(0,0)[r]{$t$}}}
\put(-100,120){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(-80,120){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(-60,160){\rnode{fig1}}
\put(-75,130){\rnode{n11}}
\put(-65,130){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\ncline{n0}{n1}
\ncline{n0}{n2}
\ncline[nodesepB=1mm]{n2}{null2}
\ncline[nodesepB=1mm]{n2}{null3}
\ncline[nodesep=1mm]{p}{null}
\ncline[nodesepA=1mm]{t}{n0}
\put(-30,160){\rnode{fig2}}
\put(0,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(0,160){\mnode{n0}}
\put(10,140){\unode{n1}}
\put(-10,140){\unode{n2}}
\put(-20,155){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(-30,140){\rnode{t}{\makebox(0,0)[r]{$t$}}}
\put(-20,120){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(0,120){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(5,130){\rnode{n11}}
\put(15,130){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}
\ncline{n0}{n1}
\ncline[nodesepB=1mm]{n2}{null2}
\ncline[nodesepB=1mm]{n2}{null3}
\ncarc[nodesepA=1mm,arcangleA=-10,arcangleB=-50]{p}{n0}
\ncline[nodesepA=1mm]{t}{n2}
\ncline[linewidth=2mm,linecolor=gray]{fig1}{fig2}\Aput{push}
\put(20,160){\rnode{fig2}}
\put(50,160){\rnode{fig3}}
\put(80,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(80,160){\mnode{n0}}
\put(90,140){\unode{n1}}
\put(70,140){\mnode{n2}}
\put(50,135){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(40,120){\rnode{t}{\makebox(0,0)[r]{$t$}}}
\put(60,120){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(80,120){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(95,130){\rnode{n11}}
\put(85,130){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\ncarc[nodesepB=1mm,arcangleA=130,linewidth=1]{n0}{null}
\ncarc[arcangleA=140,linewidth=1]{n2}{n0}
\ncline{n0}{n1}
\ncline[nodesepB=1mm]{n2}{null3}
\ncarc[nodesepA=1mm,arcangleA=-10,arcangleB=-40]{p}{n2}
\ncline[nodesepA=1mm,nodesepB=3mm]{t}{null2}
\ncline[linewidth=2mm,linecolor=gray]{fig2}{fig3}\Aput{push}
\put(100,160){\rnode{fig3}}
\put(130,160){\rnode{fig4}}
\ncline[linewidth=2mm,linecolor=gray]{fig3}{fig4}\Aput{swing}
\end{picture}
%}
%\\\hrulefill
%\vspace*{5mm}
%\fbox{
\begin{picture}(180,65)(-80,30)
\put(-80,80){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(-80,60){\mnode{n0}}
\put(-70,40){\unode{n1}}
\put(-90,40){\mnode{n2}}
\put(-110,50){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(-60,20){\rnode{t}{\makebox(0,0)[l]{$t$}}}
\put(-100,20){\rnode{null2}{\makebox(0,0)[c]{\tiny NULL}}}
\put(-80,20){\rnode{null3}{\makebox(0,0)[c]{\tiny NULL}}}
\put(-75,30){\rnode{n11}}
\put(-65,30){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\ncarc[nodesepB=1mm,arcangleA=120,linewidth=1]{n0}{null}
\ncarc[arcangleA=-120,linewidth=1]{n2}{n0}
\ncline{n0}{n1}
\ncline[nodesepA=1mm]{p}{n2}
\ncline[nodesepA=1mm,nodesepB=3mm]{t}{null3}
\ncline[nodesepB=1mm]{n2}{null2}
\put(-60,60){\rnode{fig4}}
\put(-30,60){\rnode{fig5}}
\put(0,80){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(0,60){\mnode{n0}}
\put(10,40){\unode{n1}}
\put(-10,40){\mnode{n2}}
\put(-20,50){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(20,20){\rnode{t}{\makebox(0,0)[l]{$t$}}}
\put(-20,20){\rnode{null2}{\makebox(0,0)[t]{\tiny NULL}}}
\put(0,20){\rnode{null3}{\makebox(0,0)[t]{\tiny NULL}}}
\put(5,30){\rnode{n11}}
\put(15,30){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\ncline{n0}{n1}
\ncline[nodesepB=1mm]{n2}{null2}
\ncline[nodesepB=1mm]{n2}{null3}
\ncarc[nodesepA=1mm,arcangleA=-10,arcangleB=-40]{p}{n0}
\ncarc[nodesepA=1mm]{t}{n2}
\ncarc[nodesepB=1mm,arcangleA=120,linewidth=1]{n0}{null}
\ncline[linewidth=2mm,linecolor=gray]{fig4}{fig5}\Aput{pop}
\put(20,60){\rnode{fig5}}
\put(50,60){\rnode{fig6}}
\put(80,80){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(80,60){\mnode{n0}}
\put(90,40){\unode{n1}}
\put(70,40){\mnode{n2}}
\put(60,50){\rnode{p}{\makebox(0,0)[r]{$p$}}}
\put(110,30){\rnode{t}{\makebox(0,0)[l]{$t$}}}
\put(60,20){\rnode{null2}{\makebox(0,0)[t]{\tiny NULL}}}
\put(80,20){\rnode{null3}{\makebox(0,0)[t]{\tiny NULL}}}
\put(95,30){\rnode{n11}}
\put(85,30){\rnode{n12}}
\ncline[linestyle=dotted]{-}{n1}{n11}
\ncline[linestyle=dotted]{-}{n1}{n12}
\put(90,60){\rnode{fig1}}
\ncline{n0}{n2}
\ncline[nodesepB=1mm]{n2}{null2}
\ncline[nodesepB=1mm]{n2}{null3}
\ncline[nodesepA=1mm]{p}{n0}
\ncline[nodesepA=1mm]{t}{n1}
\ncarc[nodesepB=1mm,arcangleA=-120,linewidth=1]{n0}{null}
\ncline[linewidth=2mm,linecolor=gray]{fig5}{fig6}\Aput{swing}
\put(110,60){\rnode{fig6}}
\put(140,60){\rnode{fig7}}
\ncline[linewidth=2mm,linecolor=gray]{fig6}{fig7}\Aput{...}
\end{picture}
%}
\end{center}
\vspace*{5mm}
\caption{Schorr-Waite algorithm: sample execution}
\label{fig:algo}
\end{figure*}

In the version we consider here, we assume that the nodes have
at most two child, which is the situation for example in a garbage
collector of a pure Lisp interpreter, where the only memory allocated
value is the \textsf{cons} of lists. In C, these \textsf{cons}
structures can be defined as
\begin{alltt}
typedef struct struct_node \{
  unsigned int m:1, c:1;
  struct struct_node *l, *r;
\} * node;
\end{alltt}
where $l$ and $r$ are respectively pointers to the left and to the
right child (they may be set to NULL). The boolean field $m$ is a
mark: initially, all nodes of the graph will be assumed unmarked, and
at the end of the traversal, they will have to be all marked. The
boolean field $c$ is used internally by the algorithm, to denote which
of the child is currently been explored.
 
\begin{figure*}
\begin{alltt}\begin{slshape}
/*@ \textbf{requires}
  @  \bs{}forall node x; 
  @     x != \bs{}null && reachable(root,x) => \valid(x) && ! x->m  
  @ \textbf{ensures}
  @  (\bs{}forall node x; \old(x->l) == x->l && \old(x->r) == x->r) 
  @ &&
  @  (\bs{}forall node x; x != \bs{}null && reachable(root,x) => x->m) 
  @ &&
  @  (\bs{}forall node x; !reachable(root,x) => x->m == \old(x->m))
  @*/\end{slshape}
void schorr_waite(node root) \{
  ...
\}
\end{alltt}
\caption{Specification of Schorr-Waite algorithm in the \caduceus{}
  syntax}
\label{fig:spec}
\end{figure*}

The Schorr-Waite graph-marking algorithm, written directly in true C
source code, is given in Figure~\ref{fig:code}. 
%This algorithm is a non-recursive graph marking. 
The beginning of a sample execution is illustrated in
Figure~\ref{fig:algo}, with each possible move `push', `swing' and
`pop'. The black nodes represent marked nodes, whereas white nodes are
unmarked. The sample graph shown is a tree for readibility, but of
course any graph could be given. $t$ is the next node to 
be explored and $p$ is the head of the backtracking stack. `push' marks a
new node and then explores the left child. `swing' occurs when the left
child has been explored: the search continues to the right child. `pop' is used
when the right child is been explored: the search goes back up.        


\subsection{Formal specification of the algorithm}
\label{sec:spec}

The first step in the formal verification process is to give a formal
specification to the \verb|schorr_waite| function. The informal
specification says that every node in the graph, reachable from the
root node, must be marked. Moreover the graph structure must be
restored to its initial state.

So it appears immediately that to formally specify the algorithm, one
needs to talk about reachability of some node from another in the
graph. Indeed reasoning about reachability is the main part of all the
verification, as already noticed by previous studies of the
Schorr-Waite algorithm.

At this point, the \caduceus{} methodology is quite different from the
JML one: in JML, one would need to provide a so-called \emph{pure}
(i.e. side-effect free) method defining reachability and using it in
annotations. This is convenient for runtime assertion checking, but
for formal verification it is not, because we need to reason (e.g.
by induction) about reachability, not only compute with it. In the
\caduceus{} methodology, such a logical notion must be declared, by a
\verb|predicate| annotation, and supposed to be defined or axiomatized
in the back-end prover. This is very similar to a forward declaration
of a C function, whose implementation will be given later: such
predicates have to be `implemented' later, either by giving
additional \caduceus{} annotations (such as \verb|axioms|) or in the
back-end prover. For the reachability predicate, we write
\pagebreak
\begin{alltt}\begin{slshape}
/*@ predicate 
  @   reachable(node p1, node p2) 
  @   reads p1->l,p1->r */
\end{slshape}\end{alltt}
This declares a binary predicate on nodes, but nothing yet is
said about its semantics. The \texttt{reads} clause that follows the predicate
declaration above gives information on which data the predicate
depends on: in this case, it does depend on \verb|p1| and
\verb|p2| but also on the child of \verb|p1|. This may be confusing
at first, because in fact this predicate depends not only on the
child of \verb|p1|, but also the grand child and so on. To
really understand the meaning of the \texttt{reads} clause, one needs
to remember that we use the component-as-array modeling: this
declaration indeed means that this predicate will have, on the prover
side, additional `array' arguments \verb|l| and \verb|r| respectively
representing the left and right child of all nodes. We will come back
to this in Section~\ref{sec:coq}.


Once this \texttt{reachable} predicate is declared, it is possible to
give a formal specification to the algorithm, even if we did not give
the semantics of \texttt{reachable} yet. The specification, in the
\caduceus{} syntax, is given in Figure~\ref{fig:spec}. It is made of
two clauses: the \texttt{requires} clause specifies the pre-condition
whereas the \texttt{ensures} clause specifies the post-condition. Both
are followed by a logical formula, where logical connectives follow a
C-like syntax: C operator \verb|&&| denotes conjunction, \verb|!|
denotes negation, etc. Additional syntax is introduced to denote
implication by \verb|=>|, and universal quantification by
$\bs{}\verb|forall|~\textsl{type}~x ; \textsl{formula}$. C expressions 
can be used in logical formulas as long as they are side-effect free. On this example we use equality and inequality (\verb|==| and
\verb|!=|) and field accesses like \verb|x->l|. Additional predicates
exist, all prefixed by a backslash, such as \verb|\null| which 
denotes the null pointer. Notice that our annotation language
inherits from C the fact that booleans are not clearly distinguished
from the integers: when an integer expression $e$ is used as a logical
atom, then it should be understood as the boolean $e\neq 0$, so that
one can equivalently write \verb|! x->m| or \verb|x->m == 0|. 
Notice that we use a standard first-order logic: every function is
total (like in JML, i.e. no 3-valued logic) so that an expression
\verb|p->f| is valid even if \verb|p| is \verb|null|, but no
property of it is known (very similarly to division by zero for
example). 

In the pre-condition, the built-in predicate $\valid(p)$ means that
the pointer $p$ points to a correctly allocated memory block, i.e. that
dereferencing $p$ is safe. So the pre-condition specifies that for any
node $x$ that is not null and reachable from the root, it should be
regularly allocated and its $m$ field must be false (that is $x$ is
unmarked).

The post-condition is a conjunct of three assertions. The built-in
construct $\old(e)$ in \caduceus{}, inspired from the JML one, denotes
the value of expression $e$ before the execution of the function. So
the first assertion means that for all nodes (even the non-reachable
ones), the child are the same after the run of the algorithm, as
they were before. This is of course very important to specify, because
during the execution the child are modified, so one wants to prove
that the initial graph structure is restored. The second
assertion specifies that any non-null node $x$ reachable from the
root is now marked. So this specifies that the whole 
graph has been traversed. The third assertion says that for the nodes
which were not reachable, their mark is not changed by the algorithm,
that is the unreachable nodes are not traversed by the algorithm.

With respect to the most recent formal specification given in
Isabelle/HOL~\cite{mehta03cade}, we added two things: first the
pre-condition that all pointers of the graph are regularly
allocated at the beginning, so that we are now able to prove that no
wrong pointer dereferencing can occur. Second, we also talk about the
non-reachable nodes of the graph: we are also able to show that they
are not traversed and not modified. In Section~\ref{sec:termination},
we will add more annotations in order to establish the termination of the
function.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
