
\section{The Schorr-Waite algorithm and its formal specification}
\label{sec:algo}

The Schorr-Waite algorithm performs a depth-first traversal of a
directed graph, starting from a specific node of the graph called the
root. Its main characteristic is that it directly uses the pointers of
the graph to implement backtracking. This is why its soundness is
quite difficult to establish. 

\subsection{The C source code}

In the version we consider here, we assume that the nodes have
at most two children, which is the situation for example for a garbage
collector for a pure lisp interpreter, where the only memory allocated
value is the \textsf{cons} of lists. In C, these \textsf{cons}
structures can be defined as
\begin{alltt}
typedef struct struct_node \{
  unsigned int m :1;
  unsigned int c :1;
  struct struct_node *l, *r;
\} * node;
\end{alltt}
where $l$ and $r$ are respectively pointers to the left and to the
right child (they may be assigned to NULL). The boolean field $m$ is a
mark: initially, all nodes of the graph will be assumed unmarked, and
at the end of the traversal, they will have to be all marked. The
boolean field $c$ is used internally by the algorithm, to denote which
of the children is currently explored.
 
\begin{figure}[t]
\begin{alltt}
void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ \begin{slshape}/* pop */\end{slshape}
        node q = t; t = p; p = p->r; t->r = q;
      \} 
      else \{ \begin{slshape}/* swing */\end{slshape}
        node q = t; t = p->r; p->r = p->l; p->l = q; p->c = 1;
      \}
    \} 
    else \{ \begin{slshape}/* push */ \end{slshape}
      node q = p; p = t; t = t->l; p->l = q; p->m = 1; p->c = 0;
    \}
  \}
\}
\end{alltt}
\vspace*{-5mm}
\caption{C version of the Schorr-Waite algorithm}
\label{fig:code}
\end{figure}

The Schorr-Waite graph-marking algorithm, written directly in true C
source code, is then given in Figure~\ref{fig:code}. 
\begin{figure}[t]
\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,150)
\put(-80,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(-100,170){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(-80,160){\unode{n0}}
\put(-70,140){\unode{n1}}
\put(-90,140){\unode{n2}}
\put(-90,190){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(-100,160){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(-110,120){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(-80,120){\rnode{null3}{\makebox(0,0)[c]{null}}}
\put(-70,160){\rnode{fig1}}
\ncline{n0}{n1}
\ncline{n0}{n2}
\ncline{n2}{null2}
\ncline{n2}{null3}
\ncline{root}{n0}
\ncline{p}{null}
\ncline{t}{n0}
\put(-40,160){\rnode{fig2}}
\put(0,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(-20,170){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(0,160){\mnode{n0}}
\put(10,140){\unode{n1}}
\put(-10,140){\unode{n2}}
\put(20,170){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(-20,140){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(-20,120){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(0,120){\rnode{null3}{\makebox(0,0)[c]{null}}}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n1}
\ncline{root}{n0}
\ncline{n2}{null2}
\ncline{n2}{null3}
\ncline{p}{n0}
\ncline{t}{n2}
\ncline{fig1}{fig2}
\put(10,160){\rnode{fig2}}
\put(40,160){\rnode{fig3}}
\put(80,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(60,170){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(80,160){\mnode{n0}}
\put(90,140){\unode{n1}}
\put(70,140){\mnode{n2}}
\put(60,140){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(50,130){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(50,120){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(80,120){\rnode{null3}{\makebox(0,0)[c]{null}}}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncarc[arcangleA=120,linewidth=1]{n2}{n0}
\ncline{n0}{n1}
\ncline{root}{n0}
\ncline{n2}{null3}
\ncline{p}{n2}
\ncline{t}{null2}
\ncline{fig2}{fig3}
\put(90,160){\rnode{fig3}}
\put(120,160){\rnode{fig4}}
\put(160,180){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(140,170){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(160,160){\mnode{n0}}
\put(170,140){\unode{n1}}
\put(150,140){\mnode{n2}}
\put(140,140){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(150,130){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(130,120){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(160,120){\rnode{null3}{\makebox(0,0)[c]{null}}}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncarc[arcangleA=120,linewidth=1]{n2}{n0}
\ncline{n0}{n1}
\ncline{root}{n0}
\ncline{p}{n2}
\ncline{t}{null3}
\ncline{n2}{null2}
\ncline{fig3}{fig4}
\put(-70,60){\rnode{fig4}}
\put(-30,60){\rnode{fig5}}
\put(0,80){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(-20,70){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(0,60){\mnode{n0}}
\put(10,40){\unode{n1}}
\put(-10,40){\mnode{n2}}
\put(10,70){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(-20,60){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(-30,20){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(0,20){\rnode{null3}{\makebox(0,0)[c]{null}}}
\put(10,60){\rnode{fig1}}
\ncline{n0}{n1}
\ncline{n2}{null2}
\ncline{n2}{null3}
\ncline{root}{n0}
\ncline{p}{n0}
\ncline{t}{n2}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{fig4}{fig5}
\put(10,60){\rnode{fig5}}
\put(50,60){\rnode{fig6}}
\put(80,80){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(60,70){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(80,60){\mnode{n0}}
\put(90,40){\unode{n1}}
\put(70,40){\mnode{n2}}
\put(60,60){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(100,60){\rnode{t}{\makebox(0,0)[c]{t}}}
\put(50,20){\rnode{null2}{\makebox(0,0)[c]{null}}}
\put(80,20){\rnode{null3}{\makebox(0,0)[c]{null}}}
\put(90,60){\rnode{fig1}}
\ncline{n0}{n2}
\ncline{n2}{null2}
\ncline{n2}{null3}
\ncline{root}{n0}
\ncline{p}{n0}
\ncline{t}{n1}
\ncarc[arcangleA=-120,linewidth=1]{n0}{null}
\ncline{fig5}{fig6}
\put(90,60){\rnode{fig6}}

\end{picture}\label{figure}
\end{center}
\caption{The algorithm of Schorr Waite}
\label{fig:algo}
\end{figure}

{\Huge decrire l'algo informellement, avec des dessins pour illustrer
  les operations pop, push et swing}

\subsection{Formal specification of the algorithm}

The first step in the formal verification process is to give a formal
specification to the \verb|schorr_waite| function. The informal
specification says that every node in the graph, reachable from the
root node, must be marked. Also the graph structure has to be the same
after the execution of the function, as it was before.

So it appears immediately that to formally specify the algorithm, one
needs to talk about reachability of some node from another in the
graph. Indeed reasoning about reachability is the main part of all the
verification, as already noticed by previous studies of the
Schorr-Waite algorithm.

In the \caduceus{} methodology, such an ``external'' notion must be
declared, by a \verb|predicate| annotation. For the reachability
predicate, this is written as
\begin{alltt}\begin{slshape}
/*@ predicate reachable (node p1, node p2) 
  @   reads p1->l,p1->r */
\end{slshape}\end{alltt}
This declares a binary predicate on nodes, but nothing yet is
said about its semantics. This is very similar to a forward
declaration of a C function, whose implementation will be given
latter. Such predicates will have to be `implemented' latter, either
by giving additional \caduceus{} annotations (such as \verb|axioms|)
or in the back-end prover. 

The \texttt{reads} clause that follows the predicate
declaration above is for giving information on which data the predicate
depends on: in this case, it does depend only on \verb|p1| and
\verb|p2| but also on the graph structure itself. The syntax
\verb|p1->l,p1->r| is a \caduceus{} idiom, that should be understood
in fact as $\verb|p1| (\verb|->l| \cup \verb|->r|)^*$ that is all the
node expressions from \verb|p1| using the left and right children.

\begin{figure}[t]
\begin{alltt}\begin{slshape}
/*@ requires 
  @   \bs{}forall node x; 
  @      x != \bs{}null && reachable(root,x) => \valid(x) && ! x->m  
  @ ensures 
  @   (\bs{}forall node x; 
  @       \old(x->l) == x->l && \old(x->r) == x->r) 
  @   &&
  @   (\bs{}forall node x; 
  @       x != \bs{}null && reachable(root,x) => x->m) 
  @   &&
  @   (\bs{}forall node x; 
  @       ! reachable(root,x) => x->m == \old(x->m))
  @*/\end{slshape}
void schorr_waite(node root);
\end{alltt}
\vspace*{-5mm}
\caption{Specification of Schorr-Waite algorithm in the \caduceus{}
  syntax}
\label{fig:spec}
\end{figure}

Once this \texttt{reachable} predicate is declared, it is possible to
give a formal specification to the algorithm, even if we did not give
the semantics of \texttt{reachable} yet. The specification, in the
\caduceus{} syntax, is given on Figure~\ref{fig:spec}. It is made of
two clauses: the \texttt{requires} clause specifies the pre-condition
whereas the \texttt{ensures} clause specifies the post-condition. Both
are followed by a logical formula, where logical connectives follows a
C-like syntax: C operator \verb|&&| denotes conjunction, \verb|!|
denotes negation ; and additional syntax is introduced to denoted
implication by \verb|=>|, and universal quantification under the form
$\bs{}\verb|forall|~\textsl{type}~x ; \textsl{formula}$. C expressions
can be used in logical formulas as soon as they are side-effect free,
on this example we use equality and disequality (\verb|==| and
\verb|!=|) and field accesses like \verb|x->l|. Additional predicates
exist, all prefixed by a backslash, such as \verb|\null| which 
denotes the null pointer. Notice that our annotation language
inherits from C the fact that booleans are not clearly distinguished
from the integers: when an integer expression $e$ is used as a logical
atom, then it should be understood as the boolean $e\neq 0$, so that
one can write \verb|! x->m| to indeed mean \verb|x->m == 0|. 

In the pre-condition, the built-in predicate $\valid(p)$ means that
the pointer $p$ points to a correctly allocated memory block, so that
dereferencing $p$ is safe. So the pre-condition specifies that for any
node $x$ that is not null and reachable from the root, it should be
regularly allocated, and its $m$ field must be false, that is $x$ is
unmarked.

The post-condition is a conjunct of three assertions. The built-in
construct $\old(e)$ in \caduceus{}, inspired from the JML one, denotes
the value of expression $e$ before the execution of the function. So
the first assertion means that for all nodes (even the non-reachable
ones), the children are the same after the run of the algorithm, as
they were before. This is of course very important to specify, because
during the execution the children are modified, so one wants to prove
that the initial structure of the graph is restored. The second
assertion specifies that any non-null node $x$ reachable from the
root, is now marked. So this specifies that all the 
graph has been traversed. The third assertion says that for the nodes
which were not reachable, their mark is not changed by the algorithm,
that is the unreachable node are not traversed by the algorithm.

{\Huge dire quelque chose a propos de la logique, en particulier les
  "erreurs" : pas de logique 3 valuee, dereference x->r autorisée meme
  si x est nul, etc.}


With respect to the most recent formal specification given in
Isabelle/HOL~\cite{mehta03cade}, we added two things: first the
pre-condition that of all pointers of the graph are regularly
allocated at the beginning, so that we are now able to prove that no
wrong pointer dereferencing can occur. Second, we also talk about the
non-reachable nodes of the graph: we are also able to show that they
are not affected. In Section~\ref{sec:termination}, we will add
more annotations in order to establish the termination of the
function.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
