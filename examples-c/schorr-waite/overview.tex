\section{Overview of the \caduceus{} approach}
\label{sec:overview}

In the following, we assume the reader fairly familiar with ANSI
C~\cite{KR88}.  In the \caduceus{} setting, the properties that may be
checked are of two kinds. First, the program may be checked to be free
of \emph{threats}, that are operations which may lead to abnormal
program termination: division by zero and such, including the crucial
case of dereferencing a pointer that does not point to a valid memory
block (i.e. on the current stack or allocated on the heap by a
\texttt{malloc}-like call). In our approach, out-of-bounds array
access is a particular case of pointer dereferencing threat, because
we support full pointer arithmetic.  The second kind of properties
which can be proved are user-defined behavioral properties given as
functions's \emph{postconditions}.

These kinds of properties are not independent since they both usually
need insertion of appropriate annotations (functions's
\emph{preconditions}, \emph{global invariants}, \emph{loop
  invariants}, etc.) as usual in a Hoare logic framework.  In
practice, these annotations are inserted in the source code as
comments of a specific shape \verb!/*@...*/!. The specification
language we use in those comments is largely inspired by the Java
Modeling Language (JML)~\cite{leavens00jml}. 
%It has however
%significant differences, mainly due to the fact that unlike JML we do
%not seek runtime assertion checking. 
Description of this annotation
language is not the purpose of this article~\cite{Caduceus,filliatre04icfem}, we simply
introduce here what we need for the case study.  One feature of this
annotation language, shared with JML, is that annotations follow
a syntax similar to C, so that a C programmer may learn it
quite easily.
 
Once a C program is annotated, verification is done by running
\caduceus{} on its source code in a way similar to a classical
compiler, but resulting in the generation of so-called
\emph{verification conditions}: first-order predicate logic formulas
whose validity implies the soundness of the program with respect to
the absence of threat and to the behavioral properties given as
annotations. At this point, a general purpose theorem prover must be
used to establish those verification conditions.  An original
\caduceus{} feature is its independence with respect to the prover. It
currently supports Coq~\cite{CoqProofAssistant} and PVS~\cite{PVS}
interactive proof assistants, and Simplify~\cite{simplify},
haRVey~\cite{ranise03harvey} and CVC-lite~\cite{barrett04cav}
automatic provers. Coherence between all prover outputs is obtained
because each verification condition is first produced in a common logical
setting: first-order logic with equality and arithmetic on integers
and reals, which can be syntactically embedded into the logic of each
of the former provers. Switching from a prover to another is trivial,
but on the other hand there is no way to make several provers cooperate
on solving the same goal (we come back to this issue in
Section~\ref{sec:conclusion}).  This means also that a new prover may
easily be added via a suitable pretty-printer, as soon as it supports
first-order quantication, built-in equality, and arithmetic.

To perform proof of the verification conditions with an
interactive prover, the user needs to understand the
modeling of the memory heap provided by \caduceus{}. The
`component-as-array' trick of Burstall and Bornat is re-used, extended
to arrays and pointer arithmetic in
general~\cite{filliatre04icfem}. For this case study, no pointer
arithmetic occurs in the considered source code, and fortunately the
generated verification conditions are exactly what they could be
expected with the original `component-as-array' modeling. That is, the
extension of this trick to pointer arithmetic does not add any
overhead when the source code makes no use of pointer arithmetic.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
