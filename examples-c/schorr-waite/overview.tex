\section{Overview of the \caduceus{} approach}
\label{sec:overview}

In the following, we assume the reader fairly familiar with ANSI
C~\cite{KR88}.  In the \caduceus{} setting, the properties that may be
checked are of two kinds. First, the program may be checked to be free
of \emph{threats}, that is operations which may lead to abnormal
program termination: division by zero and such, including the crucial
case of dereferencing a pointer that does not point to a valid memory
block (i.e. on the current stack or allocated on the heap by a
\texttt{malloc}-like call). In our approach, out-of-bounds array
access is a particular case of pointer dereferencing threat, because
we fully support pointer arithmetic.  The second kind of properties
which can be proved are user-defined functional properties given as
functions's \emph{postconditions}.

These kinds of properties are not independent since they both usually
need insertion of appropriate annotations (functions's
\emph{preconditions}, \emph{global invariants}, \emph{loop
  invariants}, etc.) as usual in a Hoare logic framework.  In
practice, these annotations are inserted in the source code as
comments of a specific shape \verb!/*@...*/!. The specification
language we use in those comments is largely inspired by the Java
Modeling Language (JML)~\cite{leavens00jml}. It has however
significant differences, mainly due to the fact that unlike JML we do
not seek runtime assertion checking. Description of this annotation
language is not the purpose of this article, we refer
to~\cite{Caduceus,filliatre04icfem} for more information, we will
simply introduce here what we need for the case study.
One feature of this annotation language, shared with JML, is that
annotations must follow a similar syntax as C syntax, so that a C
programmer may learn it quite easily.
 
Once a C program is annotated, verification is done by running
\caduceus{} on its source code in a way similar to a classical
compiler, but resulting in the generation of so-called
\emph{verification conditions}: first-order predicate logic formulas
whose validity implies the soundness of the program with respect to
the absence of threat and to the functional properties given as
annotations. At this point, a general purpose theorem prover must be
used to establish those verification conditions.  An original
\caduceus{} feature is its independence with respect to the prover. It
currently supports the Coq interactive proof
assistant~\cite{CoqProofAssistant} and Simplify~\cite{simplify} and
CVC-lite~\cite{cvclite} automatic provers. New provers may easily be
added provided a suitable pretty-printer; support for PVS~\cite{PVS}
and haRVey~\cite{ranise03harvey} are planned in a near future.

For performing proof of the verification conditions with an
interactive prover, the user needs to understand the
modeling of the memory heap providing by \caduceus{}. The
`component-as-array' trick of Burstall and Bornat is re-used, extended
to arrays and pointer arithmetic in
general~\cite{filliatre04icfem}. For this case study, no pointer
arithmetic occur in the considered source code, and fortunately the
generated verification conditions are exactly what they could be
expected with the original `component-as-array' modeling. That is, the
extension of this trick to pointer arithmetic does not add any
overhead when the source code does not use pointer arithmetic.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
