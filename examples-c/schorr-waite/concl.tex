\section{Conclusion}
\label{sec:conclusion}

We presented a machine-checked full verification of the Schorr-Waite
algorithm, directly on a real C source version of it. We 
proved the behavioral properties of it, like previous
works~\cite{bornat00mpc,mehta03cade,abrial03fme}, but we have also
proved that no invalid pointer dereferencing may occur, and the
termination.

The termination does not use any unique feature of \caduceus{}:
termination is indeed established in~\cite{abrial03fme} as a condition
for refinement, and we believe that it could probably also proved by
others as well. The important point is that termination is smoothly
integrated in our methodology, thanks to the powerful clause
\texttt{variant} we have, allowing to use arbitrary well-founded
relations.

Regarding the absence of invalid pointer dereferencing, it has to be
said that advanced static analysis techniques are able to establish it
also. The Schorr-Waite algorithm is one of the examples automatically
handled by the TVLA approach~\cite{sagiv02toplas,reps03esop}, where a powerful
analysis of reachability in pointer structures is done. But as far as
we know, only our approach is able to handle both the pointer
dereferencing checks and the validity of behavioral properties given
by the user. Notice that with \caduceus, as shown in
Section~\ref{sec:simplify}, absence of invalid pointer dereferencing
is established automatically, even if \caduceus{} does not do any kind of
reachability analysis by itself.

Finally, we emphasize again that we use a generic tool for arbitrary C
programs, without anything specialized for this case study, which
additionally gives the choice of the back-end prover. At the
beginning, it was not clear whether the \caduceus{} specification
language would be enough, in particular because it is first-order, but
we finally succeeded.  We claim this is a very successful case study,
which provides a clear evidence that the \caduceus{} approach is
powerful. 

Since we proposed a specification language inspired from JML, and
since we also develop a similar
tool~\cite{marche04jlap,marche05tphols} for Java programs annotated in
JML, it would be natural to perform the same case study on an Java/JML
version of the Schorr-Waite algorithm. We already made attempts into
this direction, indeed we tried first the in-place list
reversal algorithm of
Bornat~\cite{bornat00mpc,filliatre04icfem}. However we met some 
problems due to small differences between JML and our specification
language. First, where we use predicates in annotations which are only
defined on the prover side, one should use model methods in JML, but
those have to be specified in JML itself, which is not obvious for
inductively defined predicates like \verb|reachable| or \verb|clr_list|.
Second, JML has some limitations, such as forbidding the use of
\verb|\old| in loop invariants (this limitation has notified to the JML 
mailing list, and is expected to be relaxed in a near future). So
making the similar case study in JAVA/JML remains a non-trivial
challenge. 

There are still many potential improvements in our approach. One
improvement clearly emphasized by this case study is the ability to
perform proofs with \emph{cooperation} between automatic provers and
interactive ones. Interactive provers are nice because they are very
expressive and allow to prove manually difficult goals, but their
automatic tactics are less powerful than those of automatic provers. This is
especially true for Coq, because any decision procedure in it needs to
provide a checkable proof trace, making its integration very
difficult. So one of the major goals of our research is now to develop
a platform for verification where automatic theorem proving will be
used as far as possible, and only when this fails the user would be asked
for manual interaction. Since \caduceus{} also supports the interactive
prover PVS, making the proofs with PVS, which is known to have more
efficient automatic reasoning than Coq, could be a good alternative
(but unfortunately we are not experienced PVS users ourselves).

This case study was motivated by Bornat's assertion given at the
beginning. But the Schorr-Waite program is not representative of the
kind of C program we are really interested in. We focus in particular
on embedded industrial C programs, where a high level of confidence is
required: \caduceus{} is currently under experimentation at Axalto
(smart cards) and Dassault Aviation (aeronautics). For this goal,
several improvements to the \caduceus{} tool are in progress. There
are scaling up issues for dealing with code of large size. Automatic
annotation of programs is an important need. Properties of separation
of data appear to be crucial for large programs. We are currently
investigating solutions, in particular by integration of advanced
static analysis techniques, and ideas from separation
logic~\cite{reynolds02lics}. Generally speaking adding static analysis
techniques to our setting is a major goal.

Among more academic future work, we wonder what would be the next
``mountain to climb'' for pointer program verification? We think that
memory allocation and multi-procedure programs (where specification of
separation is crucial) are important issues. Significant challenges
include advanced graph algorithms (such as planarity test) and
Ukkonen's algorithm~\cite{ukkonen95}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
