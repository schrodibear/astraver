
\section{Verification}
\label{sec:proof}

\subsection{Modeling lists of pointers}

\begin{alltt}
\begin{slshape}
/*@ logic plist cons(node p, plist l) */

/*@ predicate in_list(node p,plist stack) */

/*@ predicate pair_in_list(node p1,node p2, plist stack) */
\end{slshape}
\end{alltt}


\subsection{Loop invariant}

\begin{alltt}
\begin{slshape}
/*@ predicate unmarked_reachable (node p1, node p2) 
  @   reads p1->r,p1->l,p1->m 
  @*/

/*@ predicate clr_list (node p, plist stack) 
  @   reads p->c,p->l,p->r 
  @*/
\end{slshape}

void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@ invariant
    @   (I1 :: \bs{}forall node x; 
    @     \old(reachable(root,x)) => 
    @        reachable(t,x) || reachable(p,x))
    @ &&
    @   (I2 :: \bs{}forall node x; x != \null => 
    @     ((reachable(t,x) || reachable(p,x)) => 
    @        \old(reachable(root,x)))) 
    @ &&
    @ \bs{}exists plist stack;
    @   (I3 :: clr_list (p,stack)) 
    @   &&
    @   (I4 :: \bs{}forall node p; in_list (p,stack) => p->m) 
    @   &&
    @   (I5 :: \bs{}forall node x; \valid(x) && \old(reachable(root,x)) && !x->m =>
    @      unmarked_reachable(t,x) || 
    @      (\bs{}exists node y; in_list(y,stack) && unmarked_reachable(y->r,x))) 
    @   &&
    @   (I6 :: \bs{}forall node x; !in_list(x,stack) =>  
    @      (x->r == \old(x->r) && x->l == \old(x->l))) 
    @   &&
    @   (I7 :: \bs{}forall node p1; \bs{}forall node p2;
              pair_in_list(p1,p2,cons(t,stack)) => 
	          (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
                  &&
    @	          (!p2->c => \old(p2->l) == p1 && \old(p2->r) ==
    @              p2->r))
    @ &&
    @  (I8 :: \bs{}forall node x; ! \old(reachable(root,x)) => x->m == \old(x->m)) &&
    @  (I9 :: \bs{}forall node x; x != \null && \old(reachable(root,x)) => \valid(x)) 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ /* pop */
	node q = t; t = p; p = p->r; t->r = q; 
      \} 
      else \{ /* swing */
	node q = t; t = p->r; p->r = p->l; p->l = q; p->c = 1;
      \}
    \} 
    else \{ /* push */
      node q = p; p = t; t = t->l; p->l = q; p->m = 1; p->c = 0;
    \}
  \}
\}
\end{alltt}
The clause \texttt{invariant} specifies the invariant of the while.
It's have 9 assertion :
\begin {enumerate}
\item {I1} : This assertion means that for all nodes reachable by root
  before this function, there are reachable by t or p in the while.
\item {I2} : This assertion means that for all nodes reachable by t or
  p in the while there are reachable by root before this function.
\item {I3} : This assertion clr\_list define the stack \texttt{stack}.
\item {I4} : This assertion means all nodes in the
  \texttt{stack} are mark.
\item {I5} : This assertion means that for all nodes valid, reachable by root
  before the function and not mark there are reachable with a way
  totaly not mark by t or a right way of a nodes in the \texttt{stack} .
\item {I6} : This assertion means all nodes out of \texttt{stack} are
  same children then before the function. 
\item {I7} : This assertion means that for all two nodes t1 t2 successive in
  the \texttt{stack} with t on the head if the second mark c of t2 is
  true then the left children of t2 is the same then before the
  function and the right children of t2 is t1 else the left children
  of t2 is t1 and the right children  is the same then before the
  function.
\item {I8} : This assertion means all nodes not reachable by root before the
  function her mark are the same.
\item {I9} :  This assertion means all nodes different of null and
  reachable by root before the function are valid
\end{enumerate}
\subsection{Intermediate lemmas}

\subsection{Termination}

\begin{lstlisting}[language=C]{}

/*@ logic Length weight (node p , node t) reads p->m,p->c,p->l,p->r*/

/*@ \bs{}exists plist l; reachable_elements(root,root,l) */
void schorr_waite(node root) {
  node t = root;
  node p = NULL;
  /*@variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) {
   ...
  }
}

To proof the termination of the while we need an addition in the
precondition. This addition specifies there are a list of all the
graph's elements.

The clause variant specifies the order who decrease for all step of
while. This order is the function order_mark_m_and_c_stack, this
function is an order lexicographic of the number of graph's elements
not mark with m, the number of graph's elements not mark with c and the number
of element in the \texttt{stack}. 


\end{lstlisting}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
