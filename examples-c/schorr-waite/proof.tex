
\section{Verification}
\label{sec:proof}

\subsection{Loop invariant}

\newcommand{\unode}[1]{\makebox(0,0){\circlenode{#1}{\hspace*{0.01\unitlength}}}}
\newcommand{\mnode}[1]{\makebox(0,0){\circlenode[fillstyle=solid,fillcolor=black]{#1}{\hspace*{0.01\unitlength}}}}


\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {c=false}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {c=true}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {c=false}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\ncline[linestyle=dashed]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dashed]{n1}{n12}
\ncline[linestyle=dashed]{n12}{n121}
\ncarc[arcangleA=120,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\end{picture}\label{figure}
\end{center}

\begin{alltt}
\begin{slshape}
/*@ logic plist cons(node p, plist l) */

/*@ predicate in_list(node p,plist stack) */

/*@ predicate pair_in_list(node p1,node p2, plist stack) */
\end{slshape}
\end{alltt}


\begin{alltt}
\begin{slshape}
/*@ predicate unmarked_reachable (node p1, node p2) 
  @   reads p1->r,p1->l,p1->m 
  @*/

/*@ predicate clr_list (node p, plist stack) 
  @   reads p->c,p->l,p->r 
  @*/
\end{slshape}

void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@ invariant
    @   (I1 :: \bs{}forall node x; 
    @     \old(reachable(root,x)) => 
    @        reachable(t,x) || reachable(p,x))
    @ &&
    @   (I2 :: \bs{}forall node x; x != \null => 
    @     ((reachable(t,x) || reachable(p,x)) => 
    @        \old(reachable(root,x))))
    @ &&
    @  (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => x->m == \old(x->m)) &&
    @  (I4 :: \bs{}forall node x; x != \bs{}null && \old(reachable(root,x)) => \valid(x)) 
    @ &&
    @ \bs{}exists plist stack;
    @   (I5a :: clr_list (p,stack)) 
    @   &&
    @   (I5b :: \bs{}forall node p; in_list (p,stack) => p->m) 
    @   &&
    @   (I5c :: \bs{}forall node x; \valid(x) && \old(reachable(root,x)) && !x->m =>
    @      unmarked_reachable(t,x) || 
    @      (\bs{}exists node y; in_list(y,stack) && unmarked_reachable(y->r,x))) 
    @   &&
    @   (I5d :: \bs{}forall node x; !in_list(x,stack) =>  
    @      (x->r == \old(x->r) && x->l == \old(x->l))) 
    @   &&
    @   (I5e :: \bs{}forall node p1; \bs{}forall node p2;
              pair_in_list(p1,p2,cons(t,stack)) => 
	          (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
                  &&
    @	          (!p2->c => \old(p2->l) == p1 && \old(p2->r) ==
    @              p2->r)) 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ /* pop */
	node q = t; t = p; p = p->r; t->r = q; 
      \} 
      else \{ /* swing */
	node q = t; t = p->r; p->r = p->l; p->l = q; p->c = 1;
      \}
    \} 
    else \{ /* push */
      node q = p; p = t; t = t->l; p->l = q; p->m = 1; p->c = 0;
    \}
  \}
\}
\end{alltt}
The clause \texttt{invariant} specifies the invariant of the while.
It's have 9 assertion :
\begin {enumerate}
\item {I1} : This assertion means that for all nodes reachable by root
  before this function, there are reachable by t or p in the while.
\item {I2} : This assertion means that for all nodes reachable by t or
  p in the while there are reachable by root before this function.
\item {I3} : This assertion means all nodes not reachable by root before the
  function her mark are the same.
\item {I4} :  This assertion means all nodes different of null and
  reachable by root before the function are valid
\item {I5a} : This assertion clr\_list define the stack
  \texttt{stack}. As one can see on the figure \ref{figure} the
  \texttt{stack} begin with \texttt{p} and according to the mark \texttt{c} it
  continues until \texttt{null} by the left children if \texttt{c} are true, by the right children otherwise. 
\item {I5b} : This assertion means all nodes in the
  \texttt{stack} are mark by \texttt{m}.
\item {I5c} : This assertion means that for all nodes valid, reachable by root
  before the function and not mark by \texttt{m} there are reachable with a way
  totaly not mark by t or a right way of a nodes in the \texttt{stack} .
\item {I5d} : This assertion means all nodes out of \texttt{stack} are
  same children then before the function. 
\item {I5e} : This assertion means that for all two nodes t1 t2 successive in
  the \texttt{stack} with t on the head if the second mark c of t2 is
  true then the left children of t2 is the same then before the
  function and the right children of t2 is t1 else the left children
  of t2 is t1 and the right children  is the same then before the
  function.

\end{enumerate}
\subsection{Intermediate lemmas}
For define in coq the reachability two definitions:
Firstly a inductive definition  \texttt{path} which define a path between two pointers.
\begin{alltt}
\begin{slshape}
Inductive path (a: alloc_table) (l: memory pointer)(r: memory pointer) : 
pointer ->  pointer -> list pointer -> Prop :=
  | Path_null : forall p:pointer, path a l r p  p nil
  | Path_left :
      forall p1 p2:pointer,
      forall lp : list pointer,
        valid a p1 ->
          path a l r (acc l p1) p2 lp-> path a l r p1  p2 (p1::lp)
  | Path_right :
      	forall p1 p2:pointer,
      forall lp : list pointer ,
        	valid a p1 ->
        	  path a l r (acc r p1)  p2 lp -> path a l r p1 p2 (p1::lp). 
\end{slshape}
\end{alltt}
Secondly a definition  \texttt{reachable} which define if two pointers are
reachable i.e. there exist a path between this two pointers.
\begin{alltt}
\begin{slshape}
Definition reachable (a: alloc_table) 
  (l: memory pointer)(r: memory pointer) 
  (p1 :pointer) (p2:pointer) : Prop :=
  exists lp : list pointer, path a l r p1 p2 lp
\end{slshape}
\end{alltt}

We supplement this definition with the lemma
\texttt{path\_no\_cycle} which affirm if
there exist a path between this two pointers then there exist a path
between this two pointers without cycle.
\begin{alltt}
\begin{slshape}
Lemma path_no_cycle : forall (a : alloc_table) 
  (p1 p2 : pointer) (l r : memory pointer) 
  (pa : list pointer), path a l r p1 p2 pa -> 
  exists pa' :list pointer, 
  incl pa' pa /\ no_rep pa' /\ path a l r p1 p2 pa'. 
\end{slshape}
\end{alltt}

And we supplement this definition with four lemmas
\texttt{path\_upd\_left}, \texttt{path\_upd\_right},
\texttt{path\_inv\_upd\_left} and \texttt{path\_inv\_upd\_right} which
affirm if we have un path between the two pointers p1 p2 and if we
modify the graphe without touch the pointers in this path then this
path exists always. 
\begin{alltt}
\begin{slshape}
Lemma path_upd_left : forall (alloc : alloc_table) 
  (l r : memory pointer) (p:pointer)
  (lp : list pointer) (p1 p0 p2 : pointer), 
  ~ In p lp -> path alloc l r p1 p0 lp -> 
  path alloc (upd l p p2) r p1 p0 lp.
\end{slshape}
\end{alltt}



An other definition on reachability is neccessary, the definition
 \texttt{unmarked\_reachable} which define if there exist a path
 between this two pointers with all the pointers in this path are not marked.
\begin{alltt}
\begin{slshape}
Definition unmarked_reachable (a: alloc_table) 
  (m:memory Z) (l r: memory pointer) (p1 p2:pointer) 
  : Prop :=
  exists lp : list pointer, 
    (forall x : pointer, In x lp -> (acc m x) = 0 ) 
    /\ path a l r p1 p2 lp.
\end{slshape}
\end{alltt}


An other important definition for this proof is \texttt{clr\_list}
which define the pile. For this it use a inductive definition llist
which define a list form a initial pointer and un function
\texttt{next} which give us a follower of a pointer.  
\begin{alltt}
\begin{slshape}
Definition clr_list (a: alloc_table)  (c:memory Z) (l: memory pointer)
(r: memory pointer) : pointer ->list pointer-> Prop :=
let next t := if Z_eq_dec (acc c t) 0 then (acc l t) else (acc r t) in
llist a next .
\end{slshape}
\end{alltt}

\subsection{Termination}

\begin{alltt}
/*@ logic Length weight(node p , node t) reads p->m,p->c,p->l,p->r*/

/*@ requires \bs{}exists plist l; reachable_elements(root,root,l) */
void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
   ...
  \}
\}
\end{alltt}

To proof the termination of the while we need an addition in the
precondition. This addition specifies there are a list of all the
graph's elements.

The clause variant specifies the order who decrease for all step of
while. This order is the function \verb|order_mark_m_and_c_stack|, this
function is an order lexicographic of the number of graph's elements
not mark with m, the number of graph's elements not mark with c and the number
of element in the \texttt{stack}. 





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
