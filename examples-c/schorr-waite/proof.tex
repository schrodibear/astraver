
\section{Verification}
\label{sec:proof}

\subsection{Modeling lists of pointers}

\begin{alltt}

\begin{slshape}
/*@ logic plist cons(node p, plist l) */

/*@ predicate in_list(node p,plist stack) */

/*@ predicate pair_in_list(node p1,node p2, plist stack) */
\end{slshape}
\end{alltt}


\subsection{Loop invariant}

\begin{lstlisting}[language=C]{}

/*@ predicate unmarked_reachable (node p1, node p2) reads p1->r,p1->l,p1->m */

/*@ predicate clr_list (node p, plist stack) reads p->c,p->l,p->r*/

void schorr_waite(node root) {
  node t = root;
  node p = NULL;
  /*@invariant
    @ (\forall node x; 
    @   (\old(isreachable(root,x)) => (isreachable(t,x) || isreachable(p,x))))
    @ &&
    @ (\forall node x; x!=\null => 
    @   ((isreachable(t,x) || isreachable(p,x)) => \old(isreachable(root,x)))) 
    @ &&
    @ \exists plist stack;
    @   clr_list (p,stack) &&
    @   (\forall node p; in_list (p,stack) => p->m) &&
    @   (\forall node x; \valid(x) && \old(isreachable(root,x)) && !x->m =>
    @      unmarked_reachable(t,x) || 
    @      (\exists node y; in_list(y,stack) && unmarked_reachable(y->r,x))) &&
    @  (\forall node x; !in_list(x,stack) =>  
            (x->r == \old(x->r) && x->l == \old(x->l))) &&
    @  (\forall node p1; (\forall node p2;
              pair_in_list(p1,p2,cons(t,stack)) => 
	          (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
                  &&
	          (!p2->c => \old(p2->l) == p1 && \old(p2->r) == p2->r)))&&
    @  (\forall node x; ! \old(isreachable(root,x)) => x->m == \old(x->m)) &&
    @  (\forall node x; x != \null && \old(isreachable(root,x)) => \valid(x)) 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) {
    if (t == NULL || t->m) {
      if (p->c) {
	/* pop */
	node q = t;
	t = p;
	p = p->r;
	t->r = q;
      } else {
	/* swing */
	node q = t;
	t = p->r;
	p->r = p->l;
	p->l = q;
	p->c = 1;
      }
    } else {
      /* push */
      node q = p;
      p = t;
      t = t->l;
      p->l = q;
      p->m = 1;
      p->c = 0;
    }
  }
}
\end{lstlisting}

\subsection{Intermediate lemmas}

\subsection{Termination}

\begin{lstlisting}[language=C]{}

/*@ logic Length mesure (node p , node t) reads p->m,p->c,p->l,p->r*/

/*@ NE PAS OUBLIER le nouveau requires */
void schorr_waite(node root) {
  node t = root;
  node p = NULL;
  /*@variant A AJOUTER
    @*/
  while (p != NULL || (t != NULL && ! t->m)) {
   ...
  }
}
\end{lstlisting}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
