
\section{Verification}
\label{sec:proof}

\subsection{Loop invariant}

\newcommand{\unode}[1]{\makebox(0,0){\circlenode{#1}{\hspace*{0.01\unitlength}}}}
\newcommand{\mnode}[1]{\makebox(0,0){\circlenode[fillstyle=solid,fillcolor=black]{#1}{\hspace*{0.01\unitlength}}}}


\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {c=false}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {c=true}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {c=false}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\ncline[linestyle=dashed]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dashed]{n1}{n12}
\ncline[linestyle=dashed]{n12}{n121}
\ncarc[arcangleA=120,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\end{picture}\label{figure}
\end{center}

\begin{alltt}
\begin{slshape}
/*@ logic plist cons(node p, plist l) */

/*@ predicate in_list(node p,plist stack) */

/*@ predicate pair_in_list(node p1,node p2, plist stack) */
\end{slshape}
\end{alltt}


\begin{alltt}
\begin{slshape}
/*@ predicate unmarked_reachable (node p1, node p2) 
  @   reads p1->r,p1->l,p1->m 
  @*/

/*@ predicate clr_list (node p, plist stack) 
  @   reads p->c,p->l,p->r 
  @*/
\end{slshape}

void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@ invariant
    @   (I1 :: \bs{}forall node x; 
    @     \old(reachable(root,x)) => 
    @        reachable(t,x) || reachable(p,x))
    @ &&
    @   (I2 :: \bs{}forall node x; x != \null => 
    @     ((reachable(t,x) || reachable(p,x)) => 
    @        \old(reachable(root,x))))
    @ &&
    @  (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => x->m == \old(x->m)) &&
    @  (I4 :: \bs{}forall node x; x != \bs{}null && \old(reachable(root,x)) => \valid(x)) 
    @ &&
    @ \bs{}exists plist stack;
    @   (I5a :: clr_list (p,stack)) 
    @   &&
    @   (I5b :: \bs{}forall node p; in_list (p,stack) => p->m) 
    @   &&
    @   (I5c :: \bs{}forall node x; \valid(x) && \old(reachable(root,x)) && !x->m =>
    @      unmarked_reachable(t,x) || 
    @      (\bs{}exists node y; in_list(y,stack) && unmarked_reachable(y->r,x))) 
    @   &&
    @   (I5d :: \bs{}forall node x; !in_list(x,stack) =>  
    @      (x->r == \old(x->r) && x->l == \old(x->l))) 
    @   &&
    @   (I5e :: \bs{}forall node p1; \bs{}forall node p2;
              pair_in_list(p1,p2,cons(t,stack)) => 
	          (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
                  &&
    @	          (!p2->c => \old(p2->l) == p1 && \old(p2->r) ==
    @              p2->r)) 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
    if (t == NULL || t->m) \{
      if (p->c) \{ /* pop */
	node q = t; t = p; p = p->r; t->r = q; 
      \} 
      else \{ /* swing */
	node q = t; t = p->r; p->r = p->l; p->l = q; p->c = 1;
      \}
    \} 
    else \{ /* push */
      node q = p; p = t; t = t->l; p->l = q; p->m = 1; p->c = 0;
    \}
  \}
\}
\end{alltt}
The clause \texttt{invariant} specifies the invariant of the while.
It's have 9 assertion :
\begin {enumerate}
\item {I1} : This assertion means that for all nodes reachable by root
  before this function, there are reachable by t or p in the while.
\item {I2} : This assertion means that for all nodes reachable by t or
  p in the while there are reachable by root before this function.
\item {I3} : This assertion means all nodes not reachable by root before the
  function her mark are the same.
\item {I4} :  This assertion means all nodes different of null and
  reachable by root before the function are valid
\item {I5a} : This assertion clr\_list define the stack
  \texttt{stack}. As one can see on the figure \ref{figure} the
  \texttt{stack} begin with p and according to the mark \texttt{c} it
  continues with the left children if \texttt{c} are true, with the
  right children otherwise. 
\item {I5b} : This assertion means all nodes in the
  \texttt{stack} are mark by \texttt{m}.
\item {I5c} : This assertion means that for all nodes valid, reachable by root
  before the function and not mark by \texttt{m} there are reachable with a way
  totaly not mark by t or a right way of a nodes in the \texttt{stack} .
\item {I5d} : This assertion means all nodes out of \texttt{stack} are
  same children then before the function. 
\item {I5e} : This assertion means that for all two nodes t1 t2 successive in
  the \texttt{stack} with t on the head if the second mark c of t2 is
  true then the left children of t2 is the same then before the
  function and the right children of t2 is t1 else the left children
  of t2 is t1 and the right children  is the same then before the
  function.

\end{enumerate}
\subsection{Intermediate lemmas}

\subsection{Termination}

\begin{alltt}
/*@ logic Length weight(node p , node t) reads p->m,p->c,p->l,p->r*/

/*@ requires \bs{}exists plist l; reachable_elements(root,root,l) */
void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
   ...
  \}
\}
\end{alltt}

To proof the termination of the while we need an addition in the
precondition. This addition specifies there are a list of all the
graph's elements.

The clause variant specifies the order who decrease for all step of
while. This order is the function \verb|order_mark_m_and_c_stack|, this
function is an order lexicographic of the number of graph's elements
not mark with m, the number of graph's elements not mark with c and the number
of element in the \texttt{stack}. 





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
