
\section{Verification}
\label{sec:proof}

The function is formally specified, now the hard work begins, we need
to prove that the implementation of Figure~\ref{fig:code} indeed
satisfies this specification. If one runs the \caduceus{} tool on that
annotated code now, it will generate verification conditions that
are indeed not provable: as usual with a Hoare-like system, when there
are loops like the \verb|while| of Schorr-Waite, it is mandatory
(except in simple cases) to manually add a loop invariant. The design
of a suitable loop invariant is the most difficult part of
the verification process, more difficult than performing the proof
themselves. Fortunately for us, suitable loop invariants were proposed
by previous works on Schorr-Waite algorithm. However, some
difficulties remain. The main one is that we need to express this loop
invariant in the \caduceus{} syntax, which is quite poor, for example
in~\cite{mehta03cade} they use a higher-order syntax that is simply
not allowed by \caduceus. Also, since we proved a little bit more than
previous works, namely the absence of invalid pointer dereferencing,
we needed to add new assertions in the loop invariant.

\subsection{Designing the loop invariant}

\begin{figure}[t]
\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(20,90){\rnode{root}{\makebox(0,0)[c]{root}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {c=0}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {c=1}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {c=0}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\put(40,0){\unode{n1211}}
\put(20,0){\unode{n1212}}
\put(0,50){\rnode{p}{\makebox(0,0)[c]{p}}}
\put(0,30){\rnode{t}{\makebox(0,0)[c]{t}}}

\ncline[linestyle=dashed]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dashed]{n1}{n12}
\ncline[linestyle=dashed]{n12}{n121}
\ncarc[arcangleA=120,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\ncline{root}{n0}
\ncline{n121}{n1211}
\ncline{n121}{n1212}
\ncline{p}{n12}
\ncline{t}{n121}
\end{picture}\label{figure}
\end{center}
\caption{The backtracking stack inside the graph structure}
\label{fig:stack}
\end{figure}

The key idea for the loop invariant is that even if the graph
structure is temporarily modified, the reachability of nodes is
preserved. More precisely, each node that is initially reachable from
the root will be always reachable either from p or from t. We also
need to describe as a loop invariant how the backtracking stack is
implemented using the pointers of the graph. On
Figure~\ref{fig:stack}, we display some state of the graph as it may
occur at an arbitrary iteration of the loop. The dashed arrows
corresponds to the children pointers as they were at the beginning,
whereas the thick arrows shows their current values. the normal arrows
corresponds to unmodified links. The backtracking stack is indeed the
list of pointers, starting from p ({\huge t ?}), following either the left
children when c is 0, or the right children when c is 1.


\subsection{Writing the loop invariant}

\begin{figure}[t]
\begin{alltt}
void schorr_waite(node root) \{
  node t = root;
  node p = NULL;\begin{slshape}
  /*@ invariant
    @  (I1 :: \bs{}forall node x; 
    @     \old(reachable(root,x)) => 
    @        reachable(t,x) || reachable(p,x))
    @ &&
    @  (I2 :: \bs{}forall node x; x != \null => 
    @     ((reachable(t,x) || reachable(p,x)) => 
    @        \old(reachable(root,x))))
    @ &&
    @  (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => 
    @     x->m == \old(x->m)) 
    @ &&
    @  \bs{}exists plist stack;
    @   (I4a :: clr_list (p,stack)) 
    @   &&
    @   (I4b :: \bs{}forall node p; in_list (p,stack) => p->m) 
    @   &&
    @   (I4c :: \bs{}forall node x; \valid(x) && \old(reachable(root,x)) && !x->m =>
    @      unmarked_reachable(t,x) || 
    @      (\bs{}exists node y; in_list(y,stack) && unmarked_reachable(y->r,x))) 
    @   &&
    @   (I4d :: \bs{}forall node x; !in_list(x,stack) =>  
    @      (x->r == \old(x->r) && x->l == \old(x->l))) 
    @   &&
    @   (I4e :: \bs{}forall node p1; \bs{}forall node p2;
    @          pair_in_list(p1,p2,cons(t,stack)) => 
    @         (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
    @         &&
    @        (!p2->c => \old(p2->l) == p1 && \old(p2->r) ==
    @              p2->r)) 
    @*/\end{slshape}
  while (p != NULL || (t != NULL && ! t->m)) \{
    ...
\end{alltt}
\caption{The loop invariant}
\label{fig:loopinv}
\end{figure}

The loop invariant as it is writing in the \caduceus{} annotation
language is displayed on Figure~\ref{fig:loopinv}.  For specifying this
loop invariant, in particular the stack, we need to talk about lists
of pointers, in annotations. With \caduceus{}, such a datatype from
the logical side can be imported, implicitly. Then new predicates and
logical function symbols can be declared, as the \verb|reachable|
predicate already introduced, which can take as argument either C
types or logical types. Here we declare
\begin{alltt}
\begin{slshape}
/*@ logic plist cons(node p, plist l) */
/*@ predicate in_list(node p,plist l) */
/*@ predicate pair_in_list(node p1,node p2, plist l) */
\end{slshape}
\end{alltt}
which first introduce the logical type \verb|plist| for finite lists
of pointers, then a logical function symbol \verb|cons| which adds an
element to a list, a predicate \verb|in_list| which tests of a
pointer belongs to a list, and finally a predicate \verb|pair_in_list|,
saying that p1 and p2 are two consecutive nodes of a list.

The loop invariant finally requires the declaration of two predicates:
\begin{alltt}
\begin{slshape}
/*@ predicate unmarked_reachable (node p1, node p2) 
  @   reads p1->r,p1->l,p1->m 
  @*/
\end{slshape}
\end{alltt}
specifies that p2 is reachable from p1, by traversing only unmarked
nodes; and
\begin{alltt}
\begin{slshape}
/*@ predicate clr_list (node p, plist stack) 
  @   reads p->c,p->l,p->r 
  @*/
\end{slshape}
\end{alltt}
specifies that \verb|stack| is the list of pointers obtained from p as
described on Figure~\ref{fig:stack}.

On Figure~\ref{fig:loopinv}, we used the \caduceus{} notation to name
formulas, of the form \textsl{name}\verb|::|\textsl{formula}. The loop
invariant has 9 assertions:
\begin {enumerate}
\item {I1} : means that all nodes which were initially reachable from
  root, are reachable from t or p
\item {I2} : means that conversely, all (non-null) nodes reachable by t or
  p were initially reachable from root. This is true only for non-null
  node, because null may not be reachable from root is the graph is cyclic.
\item {I3} : means that for nodes initially unreachable, the mark
  remains unchanged.
\item {I4a} : defines the backtracking stack as on Figure~\ref{fig:stack}.
\item {I4b} : means that all nodes in the \texttt{stack} are marked.
\item {I4c} : the trickest annotation, due to {\Huge ?}, means that
  any valid {\Huge non null ?} node, initially reachable from root, 
  and not yet marked, is reachable by traversing only
  unmarked nodes, either from t or from the right children of a node
  in the stack.
\item {I4d} : means all nodes out of \texttt{stack} have
  the same children as before the function. 
\item {I4e} : a trick one also, that is essential for being able to
  `recover' the correct children of nodes of the stack, as it can be
  seen again on Figure~\ref{fig:stack}: if p1 is in
  the stack, followed by p2 (or if p1 is t and p2 is the head of the
  stack), then : if p2->c is
  1 then its left child is the same as its was initially
     and its right child is p1 ; and if p2->c is 0 then its left child
   is p1 and its right child is the same as it was initially.
\end{enumerate}


\subsection{Verification using automatic provers}

\begin{comment}

. invariant vrai init
. post cond
. 3 fois invariant preserve resp. pop swing push
. validité des accès
. po1 = WF order
. po2 = validity of access to t->m in the condition of while 
. po3 = validity of access to t->m in the condition of the first if 
. po4 = validity of access to p->c in the condition of the second if 
. po5 = validity of t in 't->r = q' in the first branch of if 
. po6 = preservation of loop invariant for "pop" 
. po7 = validity of p in "p->r = p->l" in second branch of if (swing) 
. po8 = preservation of loop invariant for "swing" 
. po9 = validity of acces to t in the "push" branch
. po10 = validity of acces to p in the "push" branch
. po11 = preservation of loop invariant for "push" 
. po12 = dummy po due to variant
. po13 = post-condition of the function
. po14 = loop invariant true at the beginning 

with Simplify: 

.***.*.*..*.** (6/8/0)

-> 4/12 (po5,7,9 et 10)

ajout axiome reachable(p,p) : 

.....*.*..*.** (9/5/0)   

-> 7/12 (po2,3,4 en plus)

\end{comment}

Running \caduceus{} on the annotated source code leads to twelve
verification conditions. Five of them relate to the functional
specification of the algorithm: loop invariant true when entering the
loop, preservation of the loop invariant for each of the branches
`pop', `swing' and `push', and validity of the post-condition. The
seven others are requested to establish the absence of invalid pointer
dereferencing: the first one asks for validity of \verb|t| for the
field access \verb|t->m| in the condition of the \verb|while|, and the
six others similarly ask for validity of dereferencing \verb|t->m| in
the first \verb|if|, \verb|p->c| in the second \verb|if|, \verb|t->r|
in the `pop' branch, \verb|p->l| in the `swing' branch, \verb|t->l|
and \verb|p->l| in the `push' branch. Notice that some accesses do not
require validity check, because they are trivial enough to be
automatically discharged, for example \verb|p->r| in the `pop` branch
because it was preceeded by \verb|p->c| and \verb|p| did not change.

A first attempt can be made to solve these obligations by an
automatic prover. Here we present the result with Simplify, which appears
to be the best in that case. Four of the twelve obligations are
solved automatically, which are the validity of the dereferencings
occuring in the `pop', `swing' and `push' branches. Indeed, a quick
look at those obligations shows that they can be solved by equality
reasoning: for example the \verb|t->r| access in the `pop' branch is
valid because \verb|t| is equal to the old value of \verb|p| in the
condition of the if, which is already assumed valid. It is not
surprising at all that Simplify do not solve the other obligations,
because until now we did not give any definition or axiomatization of
the introduce predicates, in particular reachability. Indeed, to
establish for example validity of \verb|t->m| in the condition of the
\verb|while|, one needs to use the function's pre-condition saying
that any non-null, initially reachable node is valid. To establish
that \verb|t| is initially reachable, one can use the \verb|I1|
assertion of the loop invariant, as soon as one knows the simple fact
that \verb|t| is reachable from itself! So one thing that can be done
is to add in the source an axiom for \verb|reachable|:
\begin{alltt}\begin{slshape}
//@ axiom reachable_refl : \bs{}forall node p ; reachable(p,p) 
\end{slshape}\end{alltt}
Indeed with that new axiom, Simplify automatically solves the three
remaining obligations for validity of pointer dereferencing: we have
certified the absence of threat. 

At this point, any of our attempts to add axioms for solving the
remaining obligations failed. These obligations are apparently too
difficult, so we switch to an interactive prover: the Coq proof
assistant. 

\subsection{Verification with the Coq interactive prover}

Unlike with Simplify, we have now all the power of the Coq
specification language, in particular we do not need to axiomatize
predicates in the C source file, but we can \emph{define} them, and in
particular for reachability, it is natural to use an inductive
definition.

Due to lack of space, we do not present any Coq code here, the whole
development can be found from the \caduceus{} web
page~\cite{Caduceus}. The first step is to deal with the type
\verb|plist| used to modelize the stack: we simply use the finite list
datatype of the Coq standard library. The \verb|clr_list|
predicate can be defined inductively with the clauses:
\verb|clr_list|, we need to specify what is the list of pointers

passage a Coq:

def de plist avec list de la lib standard de Coq

def de llist (le modele component-as-array exposed to the user)

def clr\_list

def des path a la prolog: 3 clauses

def de reachable, unmarked\_reachable
 
lemme intermediaires

Coq: 12/12

chiffres avec coqwc

\begin{comment}
\subsubsection{Intermediate lemmas}

For define in coq the reachability two definitions:
Firstly a inductive definition  \texttt{path} which define a path between two pointers.
\begin{alltt}
\begin{slshape}
Inductive path (a: alloc_table) (l: memory pointer)(r: memory pointer) : 
pointer ->  pointer -> list pointer -> Prop :=
  | Path_null : forall p:pointer, path a l r p  p nil
  | Path_left :
      forall p1 p2:pointer,
      forall lp : list pointer,
        valid a p1 ->
          path a l r (acc l p1) p2 lp-> path a l r p1  p2 (p1::lp)
  | Path_right :
      	forall p1 p2:pointer,
      forall lp : list pointer ,
        	valid a p1 ->
        	  path a l r (acc r p1)  p2 lp -> path a l r p1 p2 (p1::lp). 
\end{slshape}
\end{alltt}
Secondly a definition  \texttt{reachable} which define if two pointers are
reachable i.e. there exist a path between this two pointers.
\begin{alltt}
\begin{slshape}
Definition reachable (a: alloc_table) 
  (l: memory pointer)(r: memory pointer) 
  (p1 :pointer) (p2:pointer) : Prop :=
  exists lp : list pointer, path a l r p1 p2 lp
\end{slshape}
\end{alltt}

We supplement this definition with the lemma
\texttt{path\_no\_cycle} which affirm if
there exist a path between this two pointers then there exist a path
between this two pointers without cycle.
\begin{alltt}
\begin{slshape}
Lemma path_no_cycle : forall (a : alloc_table) 
  (p1 p2 : pointer) (l r : memory pointer) 
  (pa : list pointer), path a l r p1 p2 pa -> 
  exists pa' :list pointer, 
  incl pa' pa /\ no_rep pa' /\ path a l r p1 p2 pa'. 
\end{slshape}
\end{alltt}

And we supplement this definition with four lemmas
\texttt{path\_upd\_left}, \texttt{path\_upd\_right},
\texttt{path\_inv\_upd\_left} and \texttt{path\_inv\_upd\_right} which
affirm if we have un path between the two pointers p1 p2 and if we
modify the graphe without touch the pointers in this path then this
path exists always. 
\begin{alltt}
\begin{slshape}
Lemma path_upd_left : forall (alloc : alloc_table) 
  (l r : memory pointer) (p:pointer)
  (lp : list pointer) (p1 p0 p2 : pointer), 
  ~ In p lp -> path alloc l r p1 p0 lp -> 
  path alloc (upd l p p2) r p1 p0 lp.
\end{slshape}
\end{alltt}



An other definition on reachability is neccessary, the definition
 \texttt{unmarked\_reachable} which define if there exist a path
 between this two pointers with all the pointers in this path are not marked.
\begin{alltt}
\begin{slshape}
Definition unmarked_reachable (a: alloc_table) 
  (m:memory Z) (l r: memory pointer) (p1 p2:pointer) 
  : Prop :=
  exists lp : list pointer, 
    (forall x : pointer, In x lp -> (acc m x) = 0 ) 
    /\ path a l r p1 p2 lp.
\end{slshape}
\end{alltt}


An other important definition for this proof is \texttt{clr\_list}
which define the pile. For this it use a inductive definition llist
which define a list form a initial pointer and un function
\texttt{next} which give us a follower of a pointer.  
\begin{alltt}
\begin{slshape}
Definition clr_list (a: alloc_table)  (c:memory Z) (l: memory pointer)
(r: memory pointer) : pointer ->list pointer-> Prop :=
let next t := if Z_eq_dec (acc c t) 0 then (acc l t) else (acc r t) in
llist a next .
\end{slshape}
\end{alltt}
\end{comment}

\subsection{Termination}
\label{sec:termination}

\begin{alltt}
/*@ logic Length weight(node p , node t) reads p->m,p->c,p->l,p->r*/

/*@ requires \bs{}exists plist l; reachable_elements(root,root,l) */
void schorr_waite(node root) \{
  node t = root;
  node p = NULL;
  /*@variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/
  while (p != NULL || (t != NULL && ! t->m)) \{
   ...
  \}
\}
\end{alltt}

To proof the termination of the while we need an addition in the
precondition. This addition specifies there are a list of all the
graph's elements.

The clause variant specifies the order who decrease for all step of
while. This order is the function \verb|order_mark_m_and_c_stack|, this
function is an order lexicographic of the number of graph's elements
not mark with m, the number of graph's elements not mark with c and the number
of element in the \texttt{stack}. 



2 VCG en plus: 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
