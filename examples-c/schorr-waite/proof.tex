
\section{Verification}
\label{sec:proof}

The function is now formally specified. The hard work begins: we need
to prove that the implementation of Figure~\ref{fig:code} indeed
satisfies this specification. If one runs the \caduceus{} tool on that
annotated code, it generates verification conditions that
are actually not provable: as usual with a Hoare-like system, when there
are loops like the \verb|while| of Schorr-Waite, it is mandatory
(except in simple cases) to manually add a loop invariant. The design
of a suitable loop invariant is the most difficult part of
the verification process, more difficult than performing the proof
themselves. Fortunately for us, suitable loop invariants were proposed
by previous works on Schorr-Waite algorithm. However, some
difficulties remain. The main one is that we need to express this loop
invariant in the \caduceus{} syntax, which is limited to
first-order. Hence, the higher-order specifications of~\cite{mehta03cade}
are not allowed by \caduceus. 
% Also, since we proved a little bit more than
% previous works, namely the absence of invalid pointer dereferencing,
% we needed to add new assertions in the loop invariant.

\subsection{Designing the loop invariant}

\begin{figure}[t]
\begin{center}
  \unitlength=0.5mm
  \psset{unit=\unitlength,arrows=->}
\begin{picture}(100,100)
\put(50,100){\rnode{null}{\makebox(0,0)[b]{\tiny NULL}}}
\put(80,83){\rnode{root}{\makebox(0,0)[lb]{root}}}
\put(50,80){\mnode{n0}}\put(58,83){\makebox(0,0)[b] {$c=0$}}
\put(30,60){\mnode{n1}}\put(23,63){\makebox(0,0)[b] {$c=1$}}
\put(60,60){\unode{n2}}

\put(20,40){\mnode{n11}}
\put(40,40){\mnode{n12}}\put(50,43){\makebox(0,0)[b] {$c=0$}}
\put(50,20){\unode{n122}}
\put(30,20){\unode{n121}}
\put(40,0){\unode{n1211}}
\put(20,0){\unode{n1212}}
\put(70,43){\rnode{p}{\makebox(0,0)[lb]{$p$}}}
\put(0,30){\rnode{t}{\makebox(0,0)[rb]{$t$}}}

\ncline[linestyle=dotted]{n0}{n1}
\ncarc[arcangleA=120,linewidth=1]{n0}{null}
\ncline{n0}{n2}
\ncline{n1}{n11}
\ncline{n12}{n122}
\ncline[linestyle=dotted]{n1}{n12}
\ncline[linestyle=dotted]{n12}{n121}
\ncarc[arcangleA=120,arcangleB=30,linewidth=1]{n12}{n1}
\ncarc[arcangleA=-100,arcangleB=-30,linewidth=1]{n1}{n0}
\ncline[nodesepA=1mm]{root}{n0}
\ncline{n121}{n1211}
\ncline{n121}{n1212}
\ncline[nodesepA=1mm]{p}{n12}
\ncline[nodesepA=1mm]{t}{n121}
\end{picture}\label{figure}
\end{center}
\vspace*{-5mm}
\caption{The backtracking stack inside the graph structure}
\label{fig:stack}
\end{figure}

The key idea for the loop invariant is that even if the graph
structure is temporarily modified, the reachability of nodes is
preserved. More precisely, each node that is initially reachable from
the root will be always reachable either from $p$ or from $t$. We also
need to describe as a loop invariant how the backtracking stack is
implemented using the pointers of the graph. On
Figure~\ref{fig:stack}, we display some state of the graph as it may
occur at an arbitrary iteration of the loop. The dotted arrows
correspond to the children pointers as they were at the beginning,
whereas the thick arrows show their current values. The normal arrows
correspond to unmodified links. The backtracking stack is indeed the
list of pointers, starting from $p$, following either the left
children when $c$ is 0, or the right children when $c$ is 1.


\subsection{Writing the loop invariant}

\begin{figure}[b]
\vspace*{-5mm}
\hrulefill
\begin{alltt}
void schorr_waite(node root) \{
  node t = root; node p = NULL;\begin{slshape}
  /*@ invariant
    @  (I1 :: \bs{}forall node x; \old(reachable(root,x)) => 
    @    reachable(t,x) || reachable(p,x))
    @ &&
    @  (I2 :: \bs{}forall node x; x != \bs{}null => 
    @         (reachable(t,x) || reachable(p,x)) => 
    @         \old(reachable(root,x)))
    @ &&
    @  (I3 :: \bs{}forall node x; ! \old(reachable(root,x)) => 
    @         x->m == \old(x->m)) 
    @ &&
    @  \bs{}exists plist stack;
    @  (I4a :: clr_list (p,stack)) 
    @  &&
    @  (I4b :: \bs{}forall node p; in_list (p,stack) => p->m) 
    @  &&
    @  (I4c :: \bs{}forall node x; 
    @          \valid(x) && \old(reachable(root,x)) && !x->m =>
    @          unmarked_reachable(t,x) || (\bs{}exists node y; 
    @            in_list(y,stack) && unmarked_reachable(y->r,x))) 
    @  &&
    @  (I4d :: \bs{}forall node x; !in_list(x,stack) =>  
    @          (x->r == \old(x->r) && x->l == \old(x->l))) 
    @  &&
    @  (I4e :: \bs{}forall node p1; \bs{}forall node p2;
    @          pair_in_list(p1,p2,cons(t,stack)) => 
    @          (p2->c => \old(p2->l) == p2->l && \old(p2->r) == p1)
    @          &&
    @          (!p2->c => \old(p2->l) == p1 && \old(p2->r) == p2->r)) 
    @*/\end{slshape}
  while (p != NULL || (t != NULL && ! t->m)) \{
    ...
\end{alltt}
\vspace*{-5mm}
\caption{The loop invariant}
\label{fig:loopinv}
\end{figure}

The loop invariant as it is written in the \caduceus{} annotation
language is displayed on Figure~\ref{fig:loopinv}.  For specifying this
loop invariant, in particular the stack, we need to talk about lists
of pointers in annotations. With \caduceus{}, such a datatype from
the logical side can be imported, implicitly. Then new predicates and
logical function symbols can be declared, as the \verb|reachable|
predicate already introduced, which can take as arguments either C
types or logical types. Here we declare
\begin{alltt}\begin{slshape}
/*@ logic plist cons(node p, plist l) */
/*@ predicate in_list(node p,plist l) */
/*@ predicate pair_in_list(node p1,node p2, plist l) */\end{slshape}
\end{alltt}
which first introduces the logical type \verb|plist| for finite lists
of pointers, then a logical function symbol \verb|cons| which adds an
element to a list, a predicate \verb|in_list| which tests whether a pointer
belongs to a list, and finally a predicate
$\verb|pair_in_list|(p_1,p_2,l)$, saying that $p_1$ and $p_2$ are two
consecutive elements in a list $l$.

The loop invariant finally requires the declaration of two predicates:
\begin{alltt}\begin{slshape}
/*@ predicate unmarked_reachable (node p1, node p2) 
  @   reads p1->r,p1->l,p1->m */\end{slshape}
\end{alltt}
specifies that $p_2$ is reachable from $p_1$ by traversing only
unmarked nodes; and
\begin{alltt}\begin{slshape}
/*@ predicate clr_list (node p, plist stack) 
  @   reads p->c,p->l,p->r */\end{slshape}
\end{alltt}
specifies that \verb|stack| is the list of pointers obtained from $p$ as
described on Figure~\ref{fig:stack}.

On Figure~\ref{fig:loopinv}, we use the \caduceus{} notation to name
formulas with double-colons. The loop
invariant is made of eight assertions:
\begin {enumerate}
\item[I1] means that each node which was initially reachable from
  root, is reachable from $t$ or $p$
\item[I2] means that conversely, each (non-null) nodes reachable from $t$
  or $p$ was initially reachable from \verb|root|. This is true only
  for non-null nodes, because \verb|null| may not be reachable from
  \verb|root| if the graph is cyclic.
\item[I3] means that for initially unreachable nodes, the mark
  remain unchanged.
\item[I4a] defines the backtracking stack as on Figure~\ref{fig:stack}.
\item[I4b] means that all nodes in the \texttt{stack} are marked.
\item[I4c] is the trickiest annotation: it means that
  any valid node, initially reachable from root, 
  and not yet marked, is reachable by traversing only
  unmarked nodes, either from $t$ or from the right child of a node
  in the stack.
\item[I4d] means that all nodes out of \texttt{stack} have
  the same children as initially. 
\item[I4e] is essential for being able to
  `recover' the correct children of nodes of the stack, as it can be
  seen again on Figure~\ref{fig:stack}: if $p_1$ is in
  the stack, followed by $p_2$ (or if $p_1$ is $t$ and $p_2$ is the head of the
  stack), then: if $p_2\verb|->c|$ is
  1 then its left child is the same as its was initially
     and its right child is $p_1$; and if $p_2\verb|->c|$ is 0 then
     its left child is $p_1$ and its right child is the same as it was
     initially. 
\end{enumerate}


\subsection{Verification using automatic provers}

\begin{comment}

. invariant vrai init
. post cond
. 3 fois invariant preserve resp. pop swing push
. validité des accès
. po1 = WF order
. po2 = validity of access to t->m in the condition of while 
. po3 = validity of access to t->m in the condition of the first if 
. po4 = validity of access to p->c in the condition of the second if 
. po5 = validity of t in 't->r = q' in the first branch of if 
. po6 = preservation of loop invariant for "pop" 
. po7 = validity of p in "p->r = p->l" in second branch of if (swing) 
. po8 = preservation of loop invariant for "swing" 
. po9 = validity of acces to t in the "push" branch
. po10 = validity of acces to p in the "push" branch
. po11 = preservation of loop invariant for "push" 
. po12 = dummy po due to variant
. po13 = post-condition of the function
. po14 = loop invariant true at the beginning 

with Simplify: 

.***.*.*..*.** (6/8/0)

-> 4/12 (po5,7,9 et 10)

ajout axiome reachable(p,p) : 

.....*.*..*.** (9/5/0)   

-> 7/12 (po2,3,4 en plus)

\end{comment}

Running \caduceus{} on the annotated source code leads to twelve
verification conditions. Five of them relate to the behavioral
specification of the algorithm: loop invariant true when entering the
loop, preservation of the loop invariant for each of the branches
`pop', `swing' and `push', and validity of the post-condition. The
seven others are requested to establish the absence of invalid pointer
dereferencing: the first one asks for validity of \verb|t| for the
field access \verb|t->m| in the condition of the \verb|while|, and the
six others similarly ask for validity of dereferencing \verb|t->m| in
the first \verb|if|, \verb|p->c| in the second \verb|if|, \verb|t->r|
in the `pop' branch, \verb|p->l| in the `swing' branch, \verb|t->l|
and \verb|p->l| in the `push' branch. Notice that some accesses do not
require validity check, because they are trivial enough to be
automatically discharged, for example \verb|p->r| in the `pop` branch
because it was preceeded by \verb|p->c| and \verb|p| did not change.

A first attempt can be made to solve these obligations with an
automatic prover. Here we present the results with Simplify, which appears
to be the best in that case. Four of the twelve obligations are
solved automatically, which are the validity of the dereferencings
occuring in the `pop', `swing' and `push' branches. Indeed, a quick
look at those obligations shows that they can be solved by equality
reasoning: for example the \verb|t->r| access in the `pop' branch is
valid because \verb|t| is equal to the old value of \verb|p| in the
condition of the if, which is already assumed valid. It is not
surprising at all that Simplify does not solve the other obligations,
because until now we did not give any definition or axiomatization for
the introduced predicates, in particular reachability. Indeed, to
establish for example validity of \verb|t->m| in the condition of the
\verb|while|, one needs to use the function's pre-condition saying
that any non-null initially reachable node is valid. To establish
that \verb|t| is initially reachable, one can use the \verb|I1|
assertion of the loop invariant, as soon as one knows the simple fact
that \verb|t| is reachable from itself! So one thing that can be done
is to add in the source an axiom for \verb|reachable|:
\begin{alltt}\begin{slshape}
//@ axiom reachable_refl : \bs{}forall node p ; reachable(p,p) 
\end{slshape}\end{alltt}
Indeed with that new axiom, Simplify automatically solves the three
remaining obligations for validity of pointer dereferencing: we have
certified the absence of threat. 

At this point, any of our attempts to add axioms for solving the
remaining obligations failed. These obligations are apparently too
difficult, so we switch to an interactive prover: the Coq proof
assistant. 

\subsection{Verification with the Coq interactive prover}

Unlike with Simplify, we have now all the power of the Coq
specification language; in particular we do not need to axiomatize
predicates in the C source file, but we can \emph{define} them, and in
particular for reachability, it is natural to use an inductive
definition in the spirit of~\cite{mehta03cade}.

Due to lack of space, we do not present any Coq code here, but only
approximations to ease reading. The whole
development can be found from the \caduceus{} web
page~\cite{Caduceus}. The first step is to deal with the type
\verb|plist| used to modelize the stack: we simply use the finite list
datatype of the Coq standard library. The \verb|clr_list| predicate
can be defined inductively with the Prolog-like clauses:
\[
\begin{array}{l}
\verb|clr_list|(a,c,l,r, p, nil).  \\
\verb|clr_list|(a,c,l,r,p,cons(p,s)) \verb|:-| \verb|valid|(a,p), \verb|clr_list|(a,next(c,l,r,p),s).
\end{array}
\]
where $next(c,l,r,p) = \verb|if|~select(c,p) =
0~\verb|then|~select(l,p)~\verb|else|~select(r,p)$. Here we see that
the component-as-array modeling is exposed to the user: the
\verb|clr_list| predicate has two arguments in C, but in the modeling
it is given extras arguments $a$, $c$, $l$, $r$ which are arrays
indexed by pointers (with $select$ as their access function). $a$
corresponds to an allocation table which tells for each pointer
whether it is allocated or not, and $c$, $l$, $r$ correspond to
fields of the \verb|node| structure. It is clear that to perform the
verification of a C program with \caduceus{} and an interactive prover
as back-end, one needs to learn more on this
modeling~\cite{Caduceus,filliatre04icfem}.

The next step is to define the reachability predicate in Coq. We
proceeded in a slightly different way than Mehta and
Nipkow~\cite{mehta03cade}: we introduce a more general predicate
\verb|path| which also makes precise the path between nodes. It is
defined by three clauses:
\[
\begin{array}{l}
\verb|path|(a,l,r, p, p, nil)  \\
\verb|path|(a,l,r,p_1,p_2,cons(p_1,s)) \verb|:-| 
  \verb|valid|(a,p_1), \verb|path|(a,select(l,p_1),p_2,s) \\
\verb|path|(a,l,r,p_1,p_2,cons(p_1,s)) \verb|:-| 
  \verb|valid|(a,p_1), \verb|path|(a,select(r,p_1),p_2,s)
\end{array}
\]
and then
\[
\begin{array}{l}
\verb|reachable|(a,l,r, p_1, p_2) = \exists s,~\verb|path|(a,l,r, p_1,
p_2, s) \\
\verb|unmarked_reachable|(a,m,l,r, p_1, p_2) = \\
\qquad\qquad\qquad \exists s,~\verb|path|(a,l,r, p_1,
p_2, s) \land \forall p, p \in s \rightarrow select(m,p) = 0 \\
\end{array} 
\]
Notice that it is now easy to establish the validity of the axiom
\verb|reachable_refl|.

A few lemmas are proved before proving the obligations, the most
important one is to show that when $p_2$ is reachable from $p_1$,
there is a path which has no cycle:
\[
\begin{array}{l}
\forall a, p_1, p_2, l, r, s,~path(a,l,r,p_1,p_2,s) \rightarrow
 \\\qquad\qquad\qquad
  \exists s', s' \subseteq s \land \verb|no_rep|(s') \land
  path(a,l,r,p_1, p_2, s')
\end{array}
\] 
where \verb|no_rep| is a simple predicate on a list which says that no
element occurs twice. 

With those definitions and lemmas, we are able to manually
complete all the proof obligations in Coq. We give a few figures
at the end of the next section.
% after talking about the last point: termination.


\begin{comment}
\subsubsection{Intermediate lemmas}

For define in coq the reachability two definitions:
Firstly a inductive definition  \texttt{path} which define a path between two pointers.
\begin{alltt}
\begin{slshape}
Inductive path (a: alloc_table) (l: memory pointer)(r: memory pointer) : 
pointer ->  pointer -> list pointer -> Prop :=
  | Path_null : forall p:pointer, path a l r p  p nil
  | Path_left :
      forall p1 p2:pointer,
      forall lp : list pointer,
        valid a p1 ->
          path a l r (acc l p1) p2 lp-> path a l r p1  p2 (p1::lp)
  | Path_right :
      	forall p1 p2:pointer,
      forall lp : list pointer ,
        	valid a p1 ->
        	  path a l r (acc r p1)  p2 lp -> path a l r p1 p2 (p1::lp). 
\end{slshape}
\end{alltt}
Secondly a definition  \texttt{reachable} which define if two pointers are
reachable i.e. there exist a path between this two pointers.
\begin{alltt}
\begin{slshape}
Definition reachable (a: alloc_table) 
  (l: memory pointer)(r: memory pointer) 
  (p1 :pointer) (p2:pointer) : Prop :=
  exists lp : list pointer, path a l r p1 p2 lp
\end{slshape}
\end{alltt}

We supplement this definition with the lemma
\texttt{path\_no\_cycle} which affirm if
there exist a path between this two pointers then there exist a path
between this two pointers without cycle.
\begin{alltt}
\begin{slshape}
Lemma path_no_cycle : forall (a : alloc_table) 
  (p1 p2 : pointer) (l r : memory pointer) 
  (pa : list pointer), path a l r p1 p2 pa -> 
  exists pa' :list pointer, 
  incl pa' pa /\ no_rep pa' /\ path a l r p1 p2 pa'. 
\end{slshape}
\end{alltt}

And we supplement this definition with four lemmas
\texttt{path\_upd\_left}, \texttt{path\_upd\_right},
\texttt{path\_inv\_upd\_left} and \texttt{path\_inv\_upd\_right} which
affirm if we have un path between the two pointers p1 p2 and if we
modify the graphe without touch the pointers in this path then this
path exists always. 
\begin{alltt}
\begin{slshape}
Lemma path_upd_left : forall (alloc : alloc_table) 
  (l r : memory pointer) (p:pointer)
  (lp : list pointer) (p1 p0 p2 : pointer), 
  ~ In p lp -> path alloc l r p1 p0 lp -> 
  path alloc (upd l p p2) r p1 p0 lp.
\end{slshape}
\end{alltt}



An other definition on reachability is neccessary, the definition
 \texttt{unmarked\_reachable} which define if there exist a path
 between this two pointers with all the pointers in this path are not marked.
\begin{alltt}
\begin{slshape}
Definition unmarked_reachable (a: alloc_table) 
  (m:memory Z) (l r: memory pointer) (p1 p2:pointer) 
  : Prop :=
  exists lp : list pointer, 
    (forall x : pointer, In x lp -> (acc m x) = 0 ) 
    /\ path a l r p1 p2 lp.
\end{slshape}
\end{alltt}


An other important definition for this proof is \texttt{clr\_list}
which define the pile. For this it use a inductive definition llist
which define a list form a initial pointer and un function
\texttt{next} which give us a follower of a pointer.  
\begin{alltt}
\begin{slshape}
Definition clr_list (a: alloc_table)  (c:memory Z) (l: memory pointer)
(r: memory pointer) : pointer ->list pointer-> Prop :=
let next t := if Z_eq_dec (acc c t) 0 then (acc l t) else (acc r t) in
llist a next .
\end{slshape}
\end{alltt}
\end{comment}

\subsection{Termination}
\label{sec:termination}

Proving termination of the algorithm is proving
termination of the while loop. In \caduceus{}, one can annotate a
loop by a \emph{variant}: an expression which decreases with respect
to some well-founded ordering. It is not hard to find such a
measure for the Schorr-Waite algorithm. There is a triple of natural
numbers which decrease lexicographically at each iteration:
\begin{enumerate}
\item The number of unmarked reachable nodes;
\item The number of reachable nodes which have $c=0$;
\item The length of the stack
\end{enumerate}
There is a minor issue: in our modeling, there is no assumption on
the finiteness of the memory, so indeed nothing tells that the set of
reachable nodes is finite. So this is an extra assumption we have
to insert in the pre-condition. The additional annotations for
termination are given Figure~\ref{fig:term}, where in Coq we define
\[
\begin{array}{l}
\verb|reachable_elements|(a,l,r, root, s) = %\\\qquad\qquad\qquad 
\forall p, p \in s \leftrightarrow reachable(a,l,r,root,p) 
\end{array}
\]
The \verb|weight| function and the \verb|order_mark_m_and_c_and_stack|
relation are also defined in Coq according the informal definition of
the measure above. 

\begin{figure}[b]
\vspace*{-5mm}
\hrulefill 
\begin{alltt}\begin{slshape}
/*@ logic Length weight(node p, node t) 
            reads p->m,p->c,p->l,p->r  */
/*@ predicate reachable_elements(node root, plist s) 
            reads root->l,root->r */ 
/*@ requires 
       \bs{}exists plist s; reachable_elements(root,s) && 
     ... */\end{slshape}
void schorr_waite(node root) \{
  node t = root; node p = NULL;\begin{slshape}
  /*@ invariant ...
    @ variant weight(p,t) for order_mark_m_and_c_and_stack 
    @*/\end{slshape}
  while (p != NULL || (t != NULL && ! t->m)) \{
   ...
  \}
\}
\end{alltt}
\vspace*{-5mm}
\caption{Additional annotations for termination}
\label{fig:term}
\end{figure}

With the completed annotated code, \caduceus{} generates two
additional verification conditions. The first is to show that the ordering is
well-founded, whereas the second is indeed an artifact of the
\caduceus{} verification condition generator, trivially solved by
equality reasoning. The verification that the measure decreases at
each iteration is added to the obligations corresponding to
preservation of the loop invariant. 

The well-foundedness obligation is indeed not passed to
automatic provers like Simplify because it is a second-order
formula. So finally Simplify solves 8 of the 13 obligations, which is
a quite good score but of course the 5 remaining obligations are by
far the most difficult.

With Coq, we completed all the obligations including the
well-foundedness. Here are a few figures about the whole Coq proof: 
definition of predicates on lists, reachability and such, and
corresponding lemmas amount to 317 lines of definitions and 589 lines
of proof tactics. The generated verification conditions amount to 985
lines, and 2411 lines of tactics were inserted manually to prove
them. Approximately 40\% of the work was devoted to the termination proof,
both in term of lines of Coq text and of time spent: proving the
obligations without termination required around 3 weeks, and the
termination proof required 2 more weeks.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rapport"
%%% End: 
