(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export caduceus_tactics.
Require Export caduceus_why.
Require Export LinkedLists.

(* Why obligation from file "why/has_cycle.why", characters 165-220 *)
Lemma cyclic_impl_po_1 : 
  forall (l: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre16: (finite alloc tl l)),
  forall (l1: pointer),
  forall (Post5: l1 = l),
  forall (l2: pointer),
  forall (Post4: l2 = (any_pointer tt)),
  forall (caduceus_4: pointer),
  forall (Post1: caduceus_4 = l1),
  forall (result: bool),
  forall (Post20: (if result then ~(caduceus_4 = null) else caduceus_4 = null)),
  (if result
   then (forall (l2:pointer),
         (l2 = (acc tl l1) ->
          (((exists pl1:plist, (lpath alloc tl l pl1 l1)) /\
          (exists pl2:plist, (lpath alloc tl l pl2 l2))) /\
          (exists pl12:plist, (lpath alloc tl l1 pl12 l2))) /\
          (forall (l1:pointer),
           (forall (l2:pointer),
            (((exists pl1:plist, (lpath alloc tl l pl1 l1)) /\
             (exists pl2:plist, (lpath alloc tl l pl2 l2))) /\
             (exists pl12:plist, (lpath alloc tl l1 pl12 l2)) ->
             ((~(l1 = l2) ->
               (forall (result:pointer),
                (result = l1 ->
                 ((~(result = null) ->
                   (forall (result:pointer),
                    (result = l2 ->
                     ((~(result = null) ->
                       (forall (result:pointer),
                        (result = (acc tl l2) ->
                         ((~(result = null) ->
                           (forall (l1_0:pointer),
                            (l1_0 = (acc tl l1) ->
                             (forall (result:pointer),
                              (result = (acc tl l2) ->
                               (forall (result0:pointer),
                                (result0 = (acc tl result) ->
                                 (((exists pl1:plist,
                                    (lpath alloc tl l pl1 l1_0)) /\
                                 (exists pl2:plist,
                                  (lpath alloc tl l pl2 result0))) /\
                                 (exists pl12:plist,
                                  (lpath alloc tl l1_0 pl12 result0))) /\
                                 (Zwf 0 0 0))) /\
                               (valid alloc result))) /\
                             (valid alloc l2))) /\
                           (valid alloc l1))) /\
                         ((result = null -> (0 <> 0 <-> (cyclic alloc tl l)))))) /\
                       (valid alloc l2))) /\
                     ((result = null -> (0 <> 0 <-> (cyclic alloc tl l)))))))) /\
                 ((result = null -> (0 <> 0 <-> (cyclic alloc tl l)))))))) /\
             ((l1 = l2 -> (1 <> 0 <-> (cyclic alloc tl l))))))))) /\
   (valid alloc l1) else (0 <> 0 <-> (cyclic alloc tl l))).
Proof.
intros; destruct result; intuition idtac.
subst; exists (@nil pointer); auto.
subst; exists (cons l nil); apply Path_cons; auto.
apply finite_is_valid with tl; auto.
subst; exists (cons l nil); apply Path_cons; auto.
apply finite_is_valid with tl; auto.
subst.
Save.

(* Why obligation from file "why/has_cycle.why", characters 599-654 *)
Lemma cyclic_impl_po_2 : 
  forall (l: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre16: (finite alloc tl l)),
  forall (l1: pointer),
  forall (Post5: l1 = l),
  forall (l2: pointer),
  forall (Post4: l2 = (any_pointer tt)),
  forall (Pre15: (valid alloc l1)),
  forall (l2_1: pointer),
  forall (Post23: l2_1 = (acc tl l1)),
  forall (Variant1: Z),
  forall (l1_1: pointer),
  forall (l2_2: pointer),
  forall (Pre14: Variant1 = 0),
  forall (Pre13: ((exists pl1:plist, (lpath alloc tl l pl1 l1_1)) /\
                 (exists pl2:plist, (lpath alloc tl l pl2 l2_2))) /\
                 (exists pl12:plist, (lpath alloc tl l1_1 pl12 l2_2))),
  forall (Test2: ~(l1_1 = l2_2)),
  forall (caduceus_3: pointer),
  forall (Post2: caduceus_3 = l1_1),
  forall (result2: bool),
  forall (Post34: (if result2 then ~(caduceus_3 = null)
                   else caduceus_3 = null)),
  (if result2
   then (forall (result:pointer),
         (result = l2_2 ->
          ((~(result = null) ->
            (forall (result:pointer),
             (result = (acc tl l2_2) ->
              ((~(result = null) ->
                (forall (l1:pointer),
                 (l1 = (acc tl l1_1) ->
                  (forall (result:pointer),
                   (result = (acc tl l2_2) ->
                    (forall (result0:pointer),
                     (result0 = (acc tl result) ->
                      (((exists pl1:plist, (lpath alloc tl l pl1 l1)) /\
                      (exists pl2:plist, (lpath alloc tl l pl2 result0))) /\
                      (exists pl12:plist, (lpath alloc tl l1 pl12 result0))) /\
                      (Zwf 0 0 0))) /\
                    (valid alloc result))) /\
                  (valid alloc l2_2))) /\
                (valid alloc l1_1))) /\
              ((result = null -> (0 <> 0 <-> (cyclic alloc tl l)))))) /\
            (valid alloc l2_2))) /\
          ((result = null -> (0 <> 0 <-> (cyclic alloc tl l))))))
   else (0 <> 0 <-> (cyclic alloc tl l))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "why/has_cycle.why", characters 676-731 *)
Lemma cyclic_impl_po_3 : 
  forall (l: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre16: (finite alloc tl l)),
  forall (l1: pointer),
  forall (Post5: l1 = l),
  forall (l2: pointer),
  forall (Post4: l2 = (any_pointer tt)),
  forall (Pre15: (valid alloc l1)),
  forall (l2_1: pointer),
  forall (Post23: l2_1 = (acc tl l1)),
  forall (Variant1: Z),
  forall (l1_1: pointer),
  forall (l2_2: pointer),
  forall (Pre14: Variant1 = 0),
  forall (Pre13: ((exists pl1:plist, (lpath alloc tl l pl1 l1_1)) /\
                 (exists pl2:plist, (lpath alloc tl l pl2 l2_2))) /\
                 (exists pl12:plist, (lpath alloc tl l1_1 pl12 l2_2))),
  forall (Test2: ~(l1_1 = l2_2)),
  forall (caduceus_2: pointer),
  forall (Post3: caduceus_2 = l2_2),
  forall (result3: bool),
  forall (Post36: (if result3 then ~(caduceus_2 = null)
                   else caduceus_2 = null)),
  (if result3
   then (forall (result:pointer),
         (result = (acc tl l2_2) ->
          ((~(result = null) ->
            (forall (l1:pointer),
             (l1 = (acc tl l1_1) ->
              (forall (result:pointer),
               (result = (acc tl l2_2) ->
                (forall (result0:pointer),
                 (result0 = (acc tl result) ->
                  (((exists pl1:plist, (lpath alloc tl l pl1 l1)) /\
                  (exists pl2:plist, (lpath alloc tl l pl2 result0))) /\
                  (exists pl12:plist, (lpath alloc tl l1 pl12 result0))) /\
                  (Zwf 0 0 0))) /\
                (valid alloc result))) /\
              (valid alloc l2_2))) /\
            (valid alloc l1_1))) /\
          ((result = null -> (0 <> 0 <-> (cyclic alloc tl l)))))) /\
   (valid alloc l2_2) else (0 <> 0 <-> (cyclic alloc tl l))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "why/has_cycle.why", characters 753-835 *)
Lemma cyclic_impl_po_4 : 
  forall (l: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre16: (finite alloc tl l)),
  forall (l1: pointer),
  forall (Post5: l1 = l),
  forall (l2: pointer),
  forall (Post4: l2 = (any_pointer tt)),
  forall (Pre15: (valid alloc l1)),
  forall (l2_1: pointer),
  forall (Post23: l2_1 = (acc tl l1)),
  forall (Variant1: Z),
  forall (l1_1: pointer),
  forall (l2_2: pointer),
  forall (Pre14: Variant1 = 0),
  forall (Pre13: ((exists pl1:plist, (lpath alloc tl l pl1 l1_1)) /\
                 (exists pl2:plist, (lpath alloc tl l pl2 l2_2))) /\
                 (exists pl12:plist, (lpath alloc tl l1_1 pl12 l2_2))),
  forall (Test2: ~(l1_1 = l2_2)),
  forall (Pre5: (valid alloc l2_2)),
  forall (caduceus_1: pointer),
  forall (Post38: caduceus_1 = (acc tl l2_2)),
  forall (result3: bool),
  forall (Post40: (if result3 then ~(caduceus_1 = null)
                   else caduceus_1 = null)),
  (if result3
   then (forall (l1:pointer),
         (l1 = (acc tl l1_1) ->
          (forall (result:pointer),
           (result = (acc tl l2_2) ->
            (forall (result0:pointer),
             (result0 = (acc tl result) ->
              (((exists pl1:plist, (lpath alloc tl l pl1 l1)) /\
              (exists pl2:plist, (lpath alloc tl l pl2 result0))) /\
              (exists pl12:plist, (lpath alloc tl l1 pl12 result0))) /\
              (Zwf 0 0 0))) /\
            (valid alloc result))) /\
          (valid alloc l2_2))) /\
   (valid alloc l1_1) else (0 <> 0 <-> (cyclic alloc tl l))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "why/has_cycle.why", characters 318-970 *)
Lemma cyclic_impl_po_5 : 
  forall (l: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre16: (finite alloc tl l)),
  forall (l1: pointer),
  forall (Post5: l1 = l),
  forall (l2: pointer),
  forall (Post4: l2 = (any_pointer tt)),
  forall (Pre15: (valid alloc l1)),
  forall (l2_1: pointer),
  forall (Post23: l2_1 = (acc tl l1)),
  forall (Variant1: Z),
  forall (l1_1: pointer),
  forall (l2_2: pointer),
  forall (Pre14: Variant1 = 0),
  forall (Pre13: ((exists pl1:plist, (lpath alloc tl l pl1 l1_1)) /\
                 (exists pl2:plist, (lpath alloc tl l pl2 l2_2))) /\
                 (exists pl12:plist, (lpath alloc tl l1_1 pl12 l2_2))),
  forall (Test1: l1_1 = l2_2),
  (1 <> 0 <-> (cyclic alloc tl l)).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

