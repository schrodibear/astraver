(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export List.

(* should go in List *)
Lemma app_rev_cons :
 forall (A:Set) (l1 l2:list A) (x:A),
   app (rev l1) (cons x l2) = app (rev (cons x l1)) l2.
Proof.
intros; simpl.
rewrite app_ass; auto.
Qed.

Require Export reverse_spec_why.

Definition length_order := length_order Z23.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_1 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  (well_founded length_order).
Proof.
unfold length_order; intuition.
apply length_order_wf.
Qed.




(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_2 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  (* File "reverse.c", line 14, characters 9-194 *)
  (exists lp:plist,
   (exists lr:plist, (((llist tl_Z23 alloc null lp) /\
    (llist tl_Z23 alloc p0 lr)) /\ (disjoint lp lr)) /\
    (forall (l:plist),
     ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l))))).
Proof.
exists nil.
inversion_clear HW_1.
exists x.
unfold is_list, app,nil; intuition.
constructor.
apply disjoint_nil2.
rewrite <- app_nil_end; auto.
rewrite (llist_function  H H0); auto.
Qed.



(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_3 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  forall (HW_2: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23 alloc null lp) /\
                  (llist tl_Z23 alloc p0 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (p: ((pointer) Z23)),
  forall (r: ((pointer) Z23)),
  forall (tl_Z23_0: ((memory) ((pointer) Z23) Z23)),
  forall (HW_3: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23_0 alloc p lp) /\
                  (llist tl_Z23_0 alloc r lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (HW_4: ~(r = null)),
  (valid alloc r).
Proof.
intuition.
inversion_clear HW_3.
inversion_clear H.
intuition.
inversion H3; intuition.
Qed.



(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_4 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  forall (HW_2: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23 alloc null lp) /\
                  (llist tl_Z23 alloc p0 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (p: ((pointer) Z23)),
  forall (r: ((pointer) Z23)),
  forall (tl_Z23_0: ((memory) ((pointer) Z23) Z23)),
  forall (HW_3: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23_0 alloc p lp) /\
                  (llist tl_Z23_0 alloc r lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (HW_4: ~(r = null)),
  forall (HW_5: (valid alloc r)),
  forall (result: ((pointer) Z23)),
  forall (HW_6: result = (acc tl_Z23_0 r)),
  forall (r0: ((pointer) Z23)),
  forall (HW_7: r0 = result),
  (valid alloc r).
Proof.
intros; subst; intuition.
Qed.


(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_5 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  forall (HW_2: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23 alloc null lp) /\
                  (llist tl_Z23 alloc p0 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (p: ((pointer) Z23)),
  forall (r: ((pointer) Z23)),
  forall (tl_Z23_0: ((memory) ((pointer) Z23) Z23)),
  forall (HW_3: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23_0 alloc p lp) /\
                  (llist tl_Z23_0 alloc r lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (HW_4: ~(r = null)),
  forall (HW_5: (valid alloc r)),
  forall (result: ((pointer) Z23)),
  forall (HW_6: result = (acc tl_Z23_0 r)),
  forall (r0: ((pointer) Z23)),
  forall (HW_7: r0 = result),
  forall (HW_8: (valid alloc r)),
  forall (tl_Z23_1: ((memory) ((pointer) Z23) Z23)),
  forall (HW_9: tl_Z23_1 = (upd tl_Z23_0 r p)),
  forall (p1: ((pointer) Z23)),
  forall (HW_10: p1 = r),
  (* File "reverse.c", line 14, characters 9-194 *)
  (exists lp:plist,
   (exists lr:plist, (((llist tl_Z23_1 alloc p1 lp) /\
    (llist tl_Z23_1 alloc r0 lr)) /\ (disjoint lp lr)) /\
    (forall (l:plist),
     ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l))))) /\
  (length_order (length tl_Z23_1 alloc r0) (length tl_Z23_0 alloc r)).
Proof.
(*
elim Pre8; clear Pre8; intuition.
elim H1; clear H1; intuition.
elim (is_list_llist alloc tl p0 Pre10); intros l1 Hl1.
subst.
assert (x0 = nil).
inversion_clear H5; intuition.
inversion_clear H. elim H5; auto.
subst x0.
generalize (H3 l0 H0); simpl; intro.
rewrite <- H; auto.
Save.

Proof.
*)
intros; subst; intuition.
exists nil.
elim (is_list_llist alloc tl p0 Pre10); intros l Hl; exists l.
intuition.
rewrite <- app_nil_end; auto.
rewrite (llist_function _ _ _ _ _ _ Hl H); auto.
Save.
(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma rev_impl_po_6 : 
  forall (p0: ((pointer) Z23)),
  forall (alloc: alloc_table),
  forall (tl_Z23: ((memory) ((pointer) Z23) Z23)),
  forall (HW_1: (* File "reverse.c", line 7, characters 14-25 *)
                (is_list tl_Z23 alloc p0)),
  forall (HW_2: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23 alloc null lp) /\
                  (llist tl_Z23 alloc p0 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (p: ((pointer) Z23)),
  forall (r: ((pointer) Z23)),
  forall (tl_Z23_0: ((memory) ((pointer) Z23) Z23)),
  forall (HW_3: (* File "reverse.c", line 14, characters 9-194 *)
                (exists lp:plist,
                 (exists lr:plist, (((llist tl_Z23_0 alloc p lp) /\
                  (llist tl_Z23_0 alloc r lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist tl_Z23 alloc p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (HW_11: r = null),
  (* File "reverse.c", line 8, characters 13-77 *)
  (forall (l0:plist),
   ((llist tl_Z23 alloc p0 l0) -> (llist tl_Z23_0 alloc p (rev l0)))).
Proof.
intuition.
(* FILL PROOF HERE *)
Save.

(*
intuition.
elim Pre8; clear Pre8; intuition.
elim H; clear H; intuition.
inversion H3; intuition.
Save.
*)
(*
elim Pre8; clear Pre8; intuition.
elim H; clear H; intuition.
inversion H3; intuition.
*)
(*
elim Pre8;intros;elim H;intros;elim H0;intuition.
inversion H7;auto.
elim Test2;auto.
*)
Save.

intuition.
elim Pre8; clear Pre8; intuition.
elim H; clear H; intuition.
inversion H3.
absurd (r1 = null); intuition.
exists (cons r1 x); exists l; subst; intuition.
unfold llist; apply Path_cons; intuition.
 rewrite acc_upd_eq; auto.
apply llist_pset_same; auto.
unfold disjoint in H2; intuition.
apply (H7 r1); auto.
auto with *.
apply llist_pset_same; auto.
apply llist_not_starting with alloc tl0; auto.
apply disjoint_cons.
auto.
apply llist_not_starting with alloc tl0; auto.
rewrite app_rev_cons.
apply H1; auto.
unfold length_order, length.
exists alloc.
elim Pre8; clear Pre8; intuition.
elim H; clear H; intuition.
subst.
inversion H3; intuition.
exists l; exists x0; intuition.
apply llist_pset_same; auto.
apply llist_not_starting with alloc tl0; auto.
rewrite <- H6; simpl; omega.
Save.

