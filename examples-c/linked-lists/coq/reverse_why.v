(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export caduceus_why.
Require Export LinkedLists.

(* Definition eq_list := (@eq (list pointer)). *)

(* Why obligation from file "why/reverse.why", characters 161-641 *)
Lemma rev_impl_po_1 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  (well_founded length_order).
Proof.
intuition.
Save.

(* should go in PolyList *)
Lemma app_rev_cons :
 forall (A:Set) (l1 l2:list A) (x:A),
   app (rev l1) (cons x l2) = app (rev (cons x l1)) l2.
Proof.
intros; simpl.
rewrite app_ass; auto.
Qed.


(* Why obligation from file "why/reverse.why", characters 575-589 *)
Lemma rev_impl_po_2 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  forall (Variant1: Length),
  forall (p2: pointer),
  forall (r1: pointer),
  forall (tl0: ((memory) pointer)),
  forall (Pre8: Variant1 = (length alloc tl0 r1)),
  forall (Pre7: (exists lp:plist,
                 (exists lr:plist, (((llist alloc tl0 p2 lp) /\
                  (llist alloc tl0 r1 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (Test2: ~(r1 = null)),
  forall (q: pointer),
  forall (Post2: q = r1),
  (valid alloc r1).
Proof.
intuition.
elim Pre7; clear Pre7; intuition.
elim H; clear H; intuition.
inversion H3; intuition.
Qed.

(* Why obligation from file "why/reverse.why", characters 599-617 *)
Lemma rev_impl_po_3 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  forall (Variant1: Length),
  forall (p2: pointer),
  forall (r1: pointer),
  forall (tl0: ((memory) pointer)),
  forall (Pre8: Variant1 = (length alloc tl0 r1)),
  forall (Pre7: (exists lp:plist,
                 (exists lr:plist, (((llist alloc tl0 p2 lp) /\
                  (llist alloc tl0 r1 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (Test2: ~(r1 = null)),
  forall (q: pointer),
  forall (Post2: q = r1),
  forall (Pre6: (valid alloc r1)),
  forall (r2: pointer),
  forall (Post12: r2 = (acc tl0 r1)),
  (valid alloc q).
Proof.
intros; subst; intuition.
Save.

(* Why obligation from file "why/reverse.why", characters 591-629 *)
Lemma rev_impl_po_4 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  forall (Variant1: Length),
  forall (p2: pointer),
  forall (r1: pointer),
  forall (tl0: ((memory) pointer)),
  forall (Pre8: Variant1 = (length alloc tl0 r1)),
  forall (Pre7: (exists lp:plist,
                 (exists lr:plist, (((llist alloc tl0 p2 lp) /\
                  (llist alloc tl0 r1 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (Test2: ~(r1 = null)),
  forall (q: pointer),
  forall (Post2: q = r1),
  forall (Pre6: (valid alloc r1)),
  forall (r2: pointer),
  forall (Post12: r2 = (acc tl0 r1)),
  forall (Pre5: (valid alloc q)),
  forall (tl1: ((memory) pointer)),
  forall (Post15: tl1 = (upd tl0 q p2)),
  forall (p3: pointer),
  forall (Post1: p3 = q),
  (exists lp:plist,
   (exists lr:plist, (((llist alloc tl1 p3 lp) /\ (llist alloc tl1 r2 lr)) /\
    (disjoint lp lr)) /\
    (forall (l:plist), ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l))))) /\
  (length_order (length alloc tl1 r2) (length alloc tl0 r1)).
Proof.
intuition.
elim Pre7; clear Pre7; intuition.
elim H; clear H; intuition.
inversion H3.
absurd (r1 = null); intuition.
exists (cons r1 x); exists l; subst; intuition.
unfold llist; apply Path_cons; intuition.
 rewrite acc_upd_eq; auto.
apply llist_pset_same; auto.
unfold disjoint in H2; intuition.
apply (H7 r1); auto.
auto with *.
apply llist_pset_same; auto.
apply llist_not_starting with alloc tl0; auto.
apply disjoint_cons.
auto.
apply llist_not_starting with alloc tl0; auto.
rewrite app_rev_cons.
apply H1; auto.
unfold length_order, length.
exists alloc.
elim Pre7; clear Pre7; intuition.
elim H; clear H; intuition.
subst.
inversion H3; intuition.
exists l; exists x0; intuition.
apply llist_pset_same; auto.
apply llist_not_starting with alloc tl0; auto.
rewrite <- H6; simpl; omega.
Save.

(* Why obligation from file "why/reverse.why", characters 161-641 *)
Lemma rev_impl_po_5 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  forall (Variant1: Length),
  forall (p2: pointer),
  forall (r1: pointer),
  forall (tl0: ((memory) pointer)),
  forall (Pre8: Variant1 = (length alloc tl0 r1)),
  forall (Pre7: (exists lp:plist,
                 (exists lr:plist, (((llist alloc tl0 p2 lp) /\
                  (llist alloc tl0 r1 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (Test2: ~(r1 = null)),
  forall (p3: pointer),
  forall (r2: pointer),
  forall (tl1: ((memory) pointer)),
  forall (Post5: (exists lp:plist,
                  (exists lr:plist, (((llist alloc tl1 p3 lp) /\
                   (llist alloc tl1 r2 lr)) /\ (disjoint lp lr)) /\
                   (forall (l:plist),
                    ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l))))) /\
                 (length_order (length alloc tl1 r2) (length alloc tl0 r1))),
  (length_order (length alloc tl1 r2) Variant1).
Proof.
intros; subst; intuition.
Save.

(* Why obligation from file "why/reverse.why", characters 161-641 *)
Lemma rev_impl_po_6 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  forall (Variant1: Length),
  forall (p2: pointer),
  forall (r1: pointer),
  forall (tl0: ((memory) pointer)),
  forall (Pre8: Variant1 = (length alloc tl0 r1)),
  forall (Pre7: (exists lp:plist,
                 (exists lr:plist, (((llist alloc tl0 p2 lp) /\
                  (llist alloc tl0 r1 lr)) /\ (disjoint lp lr)) /\
                  (forall (l:plist),
                   ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l)))))),
  forall (Test1: r1 = null),
  (forall (l0:plist),
   ((llist alloc tl p0 l0) -> (llist alloc tl0 p2 (rev l0)))).
Proof.
intuition.
elim Pre7; clear Pre7; intuition.
elim H0; clear H0; intuition.
elim (is_list_llist alloc tl p0 Pre9); intros l1 Hl1.
subst.
assert (x0 = nil).
inversion_clear H4; intuition.
inversion_clear H0. elim H4; auto.
subst x0.
generalize (H2 l0 H); simpl; intro.
rewrite <- H0; auto.
Save.

(* Why obligation from file "why/reverse.why", characters 216-486 *)
Lemma rev_impl_po_7 : 
  forall (p0: pointer),
  forall (alloc: alloc_table),
  forall (tl: ((memory) pointer)),
  forall (Pre9: (is_list alloc tl p0)),
  forall (r: pointer),
  forall (Post4: r = p0),
  forall (p: pointer),
  forall (Post3: p = null),
  (exists lp:plist,
   (exists lr:plist, (((llist alloc tl p lp) /\ (llist alloc tl r lr)) /\
    (disjoint lp lr)) /\
    (forall (l:plist), ((llist alloc tl p0 l) -> (app (rev lr) lp) = (rev l))))).
Proof.
intros; subst.
exists (nil (A:=pointer)).
elim (is_list_llist alloc tl p0 Pre9); intros l Hl; exists l.
intuition.
rewrite <- app_nil_end; auto.
rewrite (llist_function _ _ _ _ _ _ Hl H); auto.
Save.
