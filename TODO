
CADUCEUS
========

  - variable locale de type union :

      typedef union {long x; float y;} state;
      void f(){  state s; }

 - structures passed to functions (by value): validity should be added
   automatically

 - C features
   - &x for local variable x
   - switch 
	Done, except for 'nested' case like switch (e) { if () { case ...
   - union
   - memory allocation
   - sizeof / sizeof_expr DONE

 - implementation:

   - evaluation order: add an interference test to exclude expressions where
     evaluation order changes the result

   - heap variables: rename to avoid clashes
     possible clash between a local variable and a heap var, e.g. in struct.c
       DONE

 - logic: & in logic term syntax

 - struct forward reference: breaks Cenv.eq_type (e.g. line 27)

 - allowing invariants for local static variables

WHY FEATURES
============

 - polymorphic let-in

 - mutually recursive functions 
   (many variants over the same type, one relation)

COQ
===

PVS
===

Mizar
=====

 - option --mizar-preamble-from <file> to extract environ from <file>

Simplify
========

haRVey
======

DOCUMENTATION
=============

 - whydoc (to LaTeX)

GWHY
====

BUGS
====

 - higher order needs intensive testing; known bugs:

   ======================================================================
   let f (g:int->int) = (g 0)
   let g (x:int) = x
   let h = (f g)
   ======================================================================
   parameter x : int ref
   let g (t:void) =
     let a = ref 0 in
     a := let v1 = (sub_int !x) in let v2 = (v1 2) in v2
   ======================================================================

WHY
===

 - do not overwrite .bak if no change

 - references mentioned in specs are added to read references; e.g.
       t:array 10 of int -> {} unit { access(t,1) = 2 }
    => t:array 10 of int -> {} unit reads t { access(t,1) = 2 }

 - floats: post-condition annotating an assignement (x := E { x = E })
   uses generic equality (t_eq); should be t_eq_float on floats

 - auto discharge of  v = phi, P(phi) |- P(v)  (converse of rewrite_var)
