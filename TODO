
FEATURES
========

 - arguments which are types

 - option to suppress termination obligations (i.e. partial correctness)
   (=> no validation)

 - mutually recursive functions 
   (many variants over the same type, one relation)

 - C: assert statement

COQ
===

PVS
===

Mizar
=====

 - option --mizar-preamble-from <file> to extract environ from <file>

 - 80 characters limit

 - split conjunctions in lemma conclusion

Simplify
========

 - types: predicates for abstract types (ISxxx a) are (probably) needed
   (see for instance flag_why.sx); that is 
	
	(FORALL (x) ...)

   is replaced by

	(FORALL (x) (IMPLIES (ISxxx x) ...

   needs to be extended to arrays too (otherwise one looses the fact that
   elements of an array are of a given type); may someting like

        (FORALL (t) (IMPLIES (FORALL (i) (ISxxx (select t i)))) ...

haRVey
======

 - types as for Simplify?

DOCUMENTATION
=============

 - whydoc (to LaTeX / HTML)

WHY VIEWER
==========

 - nice pretty-print for internal types

BUGS
====

 - higher order needs intensive testing; known bugs:

   ======================================================================
   let f (g:int->int) = (g 0)
   let g (x:int) = x
   let h = (f g)
   ======================================================================
   parameter x : int ref
   let g (t:void) =
     let a = ref 0 in
     a := let v1 = (sub_int !x) in let v2 = (v1 2) in v2
   ======================================================================

IMPLEMENTATION
==============

 - do not overwrite .bak if no change

 - references mentioned in specs are added to read references; e.g.
       t:array 10 of int -> {} unit { access(t,1) = 2 }
    => t:array 10 of int -> {} unit reads t { access(t,1) = 2 }

 - floats: post-condition annotating an assignement (x := E { x = E })
   uses generic equality (t_eq); should be t_eq_float on floats
