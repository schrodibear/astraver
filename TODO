
INPUT
=====

FEATURES
========

 - Java input
   see http://home.inreach.com/bronikov/grammars/java.html

 - pure code output (with annotations as comments)

 - functional code output (mainly to check the interpretation; auto-check?)

 - arguments which are types

 - option to suppress termination obligations (i.e. partial correctness)

 - mutually recursive functions 
   (many variants over the same type, one relation)

COQ
===

 - validation

 - libraries

DOCUMENTATION
=============

 - bibliography

 - examples

 - Coq library (in ref man)

BUGS
====

IMPLEMENTATION
==============

 - array bounds checking: only when index is pure for the moment

 - wp(t[e1] := e2) does not propagate wp inside e2
   inconsistent evaluation order between Wp and Mlize
   => transform intro "let v2 = e2 in let v1 = e1 in t[v1] := v2"

 - suppress Coerce node?

 - simplify predicates (e.g. if true then ...)

 - wf recursion only on type int (built-in in Monad.wfrec)

 - proof obligations related to if-then-else:
   replace "b:bool,h:Q(b),h':Q(true)" with "Q(true)" directly

 - type predicates
   => declare predicates in input files with a syntax like
	predicate P(type,...,type)
   only pure types?
