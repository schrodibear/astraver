
(* finite sets *)

type 'a set
logic set_empty : 'a set
logic set_add : 'a, 'a set -> 'a set
logic set_rmv : 'a, 'a set -> 'a set

logic In : 'a, 'a set -> prop
predicate Is_empty(s : 'a set) = forall x:'a. not In(x, s)
predicate Incl(s1 : 'a set, s2 : 'a set) = forall x:'a. In(x, s1) -> In(x, s2)

axiom set_empty_def : Is_empty(set_empty)
axiom set_add_def : 
  forall x:'a. forall y:'a. forall s:'a set. 
  In(x, set_add(y,s)) <-> (x = y or In(x, s))
axiom set_rmv_def :
  forall x:'a. forall y:'a. forall s:'a set. 
  In(x, set_rmv(y,s)) <-> (x <> y and In(x, s))

logic set_card : 'a set -> int

axiom card_nonneg : 
  forall s:'a set. set_card(s) >= 0

axiom card_set_add : 
  forall x:'a. forall s:'a set. 
  not In(x,s) -> set_card(set_add(x,s)) = 1 + set_card(s)

axiom card_set_rmv : 
  forall x:'a. forall s:'a set. 
  In(x,s) -> set_card(s) = 1 + set_card(set_rmv(x, s))

parameter set_is_empty : 
  s:'a set -> {} bool { if result then Is_empty(s) else not Is_empty(s) }

parameter set_choose :
  s:'a set -> { not Is_empty(s) } 'a { In(result, s) }

(* pairs *)

type ('a,'b) prod
logic pair : 'a, 'b -> ('a, 'b) prod
logic fst : ('a, 'b) prod -> 'a
logic snd : ('a, 'b) prod -> 'b

axiom pair_1 : forall x:'a. forall y:'b. fst(pair(x,y)) = x
axiom pair_2 : forall x:'a. forall y:'b. snd(pair(x,y)) = y
axiom pair_e : forall p:('a,'b) prod. p = pair(fst(p), snd(p))

(* maps *)

type ('a, 'b) map

logic map_get : ('a,'b) map, 'a -> 'b
logic map_set : ('a,'b) map, 'a, 'b -> ('a, 'b) map

axiom map_get_set_eq :
  forall m : ('a,'b) map . forall i : 'a. forall v : 'b.
  map_get(map_set(m,i,v), i) = v

axiom map_get_set_neq : 
  forall m : ('a, 'b) map. forall i : 'a. forall j : 'a. forall v : 'b.
  i <> j -> map_get(map_set(m,i,v), j) = map_get(m,j)

(* graph *)

type vertex

logic g_vertices : vertex set

logic g_succ : vertex -> vertex set

axiom g_succ_sound : 
  forall x:vertex. Incl(g_succ(x), g_vertices)

logic weight : vertex, vertex -> int (* edge weight, if there is an edge *)

axiom weight_nonneg : forall x,y:vertex. weight(x,y) >= 0

parameter eq_vertex : 
  x:vertex -> y:vertex -> {} bool { if result then x=y else x<>y }

(* visited vertices *)

parameter visited : vertex set ref

parameter visited_add : 
  x:vertex -> {} unit writes visited { visited = set_add(x, visited@) }

(* current distances *)

parameter dist : (vertex, int) map ref

(* priority queue *)

parameter pq : vertex set ref

parameter pq_is_empty : 
  unit -> 
    {} bool reads pq { if result then Is_empty(pq) else not Is_empty(pq) }

parameter relax :
  u:vertex -> v:vertex -> 
    {} 
    unit reads visited writes dist,pq 
    { (In(v,visited) and pq = pq@ and dist = dist@) 
      or
      (In(v,pq) and map_get(dist,u) + weight(u,v) >= map_get(dist,v) and 		pq = pq@ and dist = dist@)
      or	
      (In(v,pq) and map_get(dist,u) + weight(u,v) < map_get(dist,v) and 		pq = pq@ and dist = map_set(dist@, v, map_get(dist,u) + weight(u,v)))
      or
      (not In(v,visited) and not In(v,pq) and pq = set_add(v,pq@) and
       dist = map_set(dist@, v, map_get(dist,u) + weight(u,v))) }	

predicate Min(m:vertex, pq:vertex set, visited:vertex set) =
  In(m, pq) and forall x:vertex. In(x, pq) -> snd(e) <= snd(x)

parameter pq_extract_min :
  unit ->
    { not Is_empty(pq) } 
    vertex writes pq 
    { Min(result, pq@) and pq = set_rmv(result, pq@) }

(* paths and shortest paths 
   path(x,y,d) = 
	there is a path from x to y of length d
   shortest_path(x,y,d) = 
	there is a path from x to y of length d, and to shorter path *)

logic path : vertex, vertex, int -> prop 

axiom path_nil : 
  forall x:vertex. path(x,x,0)
axiom path_cons : 
  forall x,y,z:vertex. forall d:int. 
    path(x,y,d) -> In(z,g_succ(y)) -> path(x,z,d+weight(y,z))

axiom length_nonneg : forall x,y:vertex. forall d:int. path(x,y,d) -> d >= 0

predicate shortest_path(x:vertex, y:vertex, d:int) =
  path(x,y,d) and forall d':int. path(x,y,d') -> d <= d'

axiom path_inversion :
  forall src,v:vertex. forall d:int. path(src,v,d) ->
    (v = src and d = 0) or
    (exists v':vertex. path(src,v',d - weight(v',v)) and In(v,g_succ(v')))

axiom path_shortest_path :
  forall src,v:vertex. forall d:int. path(src,v,d) ->
    exists d':int. shortest_path(src,v,d') and d' <= d

(* lemmas *)

axiom main_lemma :
  forall src,v:vertex. forall d:int. 
  path(src,v,d) -> not shortest_path(src,v,d) ->
    exists v':vertex. exists d':int. 
      shortest_path(src,v',d') and In(v,g_succ(v')) and d' + weight(v',v) < d

axiom completeness_lemma :
  forall s:vertex set. forall src:vertex. forall dst:vertex. forall d:int. 
    (* if s is closed under g_succ *)
    (forall v:vertex. In(v,s) -> forall w:vertex. In(w,g_succ(v)) -> In(w,s))
    ->
    (* and if s contains src *)
    In(src, s) -> 
    (* then any vertex reachable from s is also in s *)
    path(src, dst, d) -> In(dst, s)

(* termination uses a lexicographic order *)

predicate lex2(x:(int, int) prod, y:(int, int) prod) =
  fst(x) < fst(y) or (fst(x) = fst(y) and snd(x) < snd(y))

(* definitions used in loop invariants *)

predicate MinNotVisited
  (e:(vertex,int) prod, pq:(vertex, int) prod set, visited:vertex set) =
  In(e, pq) and not In(fst(e), visited) and
  forall x:(vertex, int) prod. 
    (In(x, pq) and not In(fst(x), visited)) -> snd(e) <= snd(x)

predicate Inv_src(src:vertex, visited:vertex set, pq: (vertex, int) prod set) =
  In(src,visited) or In(pair(src,0),pq)

predicate Inv(src:vertex, visited:vertex set, pq: (vertex, int) prod set) =
  Inv_src(src, visited, pq)
  (* there are paths for the vertices in pq *)
  and
  (forall e:(vertex, int) prod. In(e,pq) -> path(src,fst(e),snd(e))) 
  (* we already visited all vertices at distance < min(pq) *)
  and
  (forall m:(vertex, int) prod. MinNotVisited(m,pq,visited) -> 
     forall x:vertex. forall d:int. shortest_path(src,x,d) -> d < snd(m) -> 
       In(x,visited)) 

predicate InvSucc(src:vertex, visited:vertex set, pq: (vertex, int) prod set) =
  (* successors of visited vertices are either visited or in pq *)
  (forall x:vertex. In(x, visited) -> 
     exists d:int. shortest_path(src, x, d) and
       forall y:vertex. In(y,g_succ(x)) ->
         In(y, visited) or In(pair(y, d+weight(x,y)), pq))

predicate InvSucc2
  (src:vertex, visited:vertex set, pq: (vertex, int) prod set) =
  (* successors of visited vertices are either visited or in pq *)
  (forall x:vertex. In(x, visited) -> 
     exists d:int. path(src, x, d) and
       forall y:vertex. In(y,g_succ(x)) ->
         In(y, visited) or In(pair(y, d+weight(x,y)), pq))

(* code *)

exception Found of int

let shortest_path (src:vertex) (dst:vertex) =
  { In(src,g_vertices) and In(dst,g_vertices) and 
    Is_empty(visited) and Is_empty(pq) }
  pq_add (pair src 0);
  while not (pq_is_empty void) do
    { invariant 
	Inv(src, visited, pq) and not In(dst,visited) and
	InvSucc(src, visited, pq)
      variant 
	pair(set_card(g_vertices) - set_card(visited), set_card(pq)) 
	for lex2 }
    let m = pq_extract_min void in
    let v = fst m in
    let d = snd m in
    if not (visited_mem v) then begin
      assert { shortest_path(src, v, d) };
      visited_add v;
      if eq_vertex v dst then raise (Found d);
      let vs = ref (g_succ v) in
      while not (set_is_empty !vs) do 
        { invariant Inv(src, visited, pq)
          variant set_card(vs) }
	let w = set_choose !vs in
	if not (visited_mem w) then
	  pq_add (pair w (d + weight v w));
        vs := set_rmv w !vs
      done
    end
  done;
  assert { forall v:vertex. In(v,visited) -> 
           forall w:vertex. In(w,g_succ(v)) -> In(w,visited) };
  void
  { forall d:int. not path(src,dst,d) 
  | Found => shortest_path(src,dst,result) }
    
(*
Local Variables: 
compile-command: "gwhy dijkstra.why"
End: 
*)
