(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require find_spec.
Require find_lemmas.
Require find_proofs.

Require Why.
Require Omega.


(* Why obligation from file "find.mlw", characters 1604-1608 *)
Lemma find_po_1 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  `0 <= f` /\ `f < (array_length A0)`.
Proof.
Intros; Generalize le_f_N; Generalize le_1_f.
Intuition; SameLength A0 A; Omega.
Save.

(* Why obligation from file "find.mlw", characters 1977-1982 *)
Lemma find_po_2 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (Variant5: Z)
  (i1: Z)
  (Pre5: Variant5 = `N + 1 - i1`)
  (Inv_i: (i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1))
  `0 <= i1` /\ `i1 < (array_length A1)`.
Proof.
Intuition SameLength A1 A.
Unfold i_invariant in H13; Omega.
Omega.
Save.

(* Why obligation from file "find.mlw", characters 1971-2191 *)
Lemma find_po_3 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (Variant5: Z)
  (i1: Z)
  (Pre5: Variant5 = `N + 1 - i1`)
  (Inv_i: (i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1))
  (Test4: `(access A1 i1) < r`)
  (i2: Z)
  (Post1: i2 = `i1 + 1`)
  ((i_invariant m0 n0 i2 r A1) /\ `i0 <= i2` /\ `i2 <= n0` /\
  (termination i2 j0 m0 n0 r A1)) /\ (Zwf `0` `N + 1 - i2` `N + 1 - i1`).
Proof.
Intros. 
Subst r.
Subst i2.
Generalize (subgoal_1 m0 n0 i0 j0 i1 A A0 A1 
              Inv_mn Test14 zero_f_SN Inv_ij Test9 Inv_i Test4).
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2012-2129 *)
Lemma find_po_4 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i_invariant m0 n0 i0 r A1) /\ `i0 <= i0` /\ `i0 <= n0` /\
  (termination i0 j0 m0 n0 r A1).
Proof.
Intuition.
Unfold j_invariant in H8; Unfold termination in H12; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2219-2224 *)
Lemma find_po_5 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (Variant7: Z)
  (j1: Z)
  (Pre8: Variant7 = j1)
  (Inv_j: (j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1))
  `0 <= j1` /\ `j1 < (array_length A1)`.
Proof.
Intuition SameLength A1 A.
Unfold j_invariant in H8; Unfold termination in H12; Omega.
Unfold j_invariant in H8; Unfold termination in H12; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2209-2426 *)
Lemma find_po_6 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (Variant7: Z)
  (j1: Z)
  (Pre8: Variant7 = j1)
  (Inv_j: (j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1))
  (Test6: `r < (access A1 j1)`)
  (j2: Z)
  (Post2: j2 = `j1 - 1`)
  ((j_invariant m0 n0 j2 r A1) /\ `j2 <= j0` /\ `m0 <= j2` /\
  (termination i1 j2 m0 n0 r A1)) /\ (Zwf `0` j2 j1).
Proof.
Intros. 
Subst r.
Subst j2.
Generalize (subgoal_2 m0 n0 i0 j0 i1 j1 A A0 A1
                  Inv_mn Test14 zero_f_SN Inv_ij Test9 Inv_i 
                  Inv_j Test6).
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2250-2367 *)
Lemma find_po_7 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j_invariant m0 n0 j0 r A1) /\ `j0 <= j0` /\ `m0 <= j0` /\
  (termination i1 j0 m0 n0 r A1).
Proof.
Intuition.
Unfold m_invariant in H7.
Unfold termination in H12.
Omega.
Save.

(* Why obligation from file "find.mlw", characters 2446-2469 *)
Lemma find_po_8 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  `(access A1 j1) <= r` /\ `r <= (access A1 i1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "find.mlw", characters 2523-2528 *)
Lemma find_po_9 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  (Pre16: `(access A1 j1) <= r` /\ `r <= (access A1 i1)`)
  (Test8: `i1 <= j1`)
  `0 <= i1` /\ `i1 < (array_length A1)`.
Proof.
Intuition SameLength A1 A.
Unfold i_invariant in H16; Omega.
Unfold i_invariant in H16; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2547-2552 *)
Lemma find_po_10 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  (Pre16: `(access A1 j1) <= r` /\ `r <= (access A1 i1)`)
  (Test8: `i1 <= j1`)
  (Pre12: `0 <= i1` /\ `i1 < (array_length A1)`)
  (w: Z)
  (Post5: w = (access A1 i1))
  (Pre10: `0 <= i1` /\ `i1 < (array_length A1)`)
  `0 <= j1` /\ `j1 < (array_length A1)`.
Proof.
Intuition SameLength A1 A.
Unfold termination in H28; Unfold j_invariant in H25; Omega.
Unfold termination in H28; Unfold j_invariant in H25; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2554-2564 *)
Lemma find_po_11 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  (Pre16: `(access A1 j1) <= r` /\ `r <= (access A1 i1)`)
  (Test8: `i1 <= j1`)
  (Pre12: `0 <= i1` /\ `i1 < (array_length A1)`)
  (w: Z)
  (Post5: w = (access A1 i1))
  (Pre10: `0 <= i1` /\ `i1 < (array_length A1)`)
  (Pre11: `0 <= j1` /\ `j1 < (array_length A1)`)
  (A2: (array Z))
  (Post3: A2 = (store A1 i1 (access A1 j1)))
  `0 <= j1` /\ `j1 < (array_length A2)`.
Proof.
Intuition WhyArrays.
ArraySubst A2; Omega.
Save.

(* Why obligation from file "find.mlw", characters 2532-2568 *)
Lemma find_po_12 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  (Pre16: `(access A1 j1) <= r` /\ `r <= (access A1 i1)`)
  (Test8: `i1 <= j1`)
  (Pre12: `0 <= i1` /\ `i1 < (array_length A1)`)
  (w: Z)
  (Post5: w = (access A1 i1))
  (Pre10: `0 <= i1` /\ `i1 < (array_length A1)`)
  (Pre11: `0 <= j1` /\ `j1 < (array_length A1)`)
  (A2: (array Z))
  (Post3: A2 = (store A1 i1 (access A1 j1)))
  (Pre9: `0 <= j1` /\ `j1 < (array_length A2)`)
  (A3: (array Z))
  (Post4: A3 = (store A2 j1 w))
  (exchange A3 A1 i1 j1) /\ `(access A3 i1) <= r` /\ `r <= (access A3 j1)` /\
  ((i:Z)
   (i = `i1 + 1` ->
    ((j:Z)
     (j = `j1 - 1` -> ((i_invariant m0 n0 i r A3) /\
      (j_invariant m0 n0 j r A3) /\ (m_invariant m0 A3) /\
      (n_invariant n0 A3) /\ `0 <= j` /\ `i <= N + 1` /\
      (termination i j m0 n0 r A3) /\ (permut A3 A)) /\
      (Zwf `0` `N + 2 + j - i` `N + 2 + j0 - i0`))))).
Proof.
Intros.
Subst r.
Assert H:(exchange A3 A1 i1 j1).
Subst A3. Subst A2. Subst w.
Auto with datatypes.
Split. Assumption.
Assert H0:`(access A3 i1) <= (access A0 f)`.
Elim H; Intros; Rewrite H3; Omega.
Split. Assumption.
Assert H1:`(access A0 f) <= (access A3 j1)`.
Elim H; Intros; Rewrite H5; Omega.
Split. Assumption.
Intros.
Subst i.
Subst j.
Generalize (subgoal_3 m0 n0 i0 j0 i1 j1 A A0 A1 A3 Pre21 Inv_mn Test14 
  zero_f_SN Inv_ij 
  Test9 Inv_i Inv_j Pre16 Test8 H H0 H1).
Intuition.
Save.

(* Why obligation from file "find.mlw", characters 2482-2697 *)
Lemma find_po_13 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (Variant3: Z)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Pre17: Variant3 = `N + 2 + j0 - i0`)
  (Inv_ij: (i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\ (permut A1 A))
  (Test9: `i0 <= j0`)
  (i1: Z)
  (Inv_i: ((i_invariant m0 n0 i1 r A1) /\ `i0 <= i1` /\ `i1 <= n0` /\
          (termination i1 j0 m0 n0 r A1)) /\ `(access A1 i1) >= r`)
  (j1: Z)
  (Inv_j: ((j_invariant m0 n0 j1 r A1) /\ `j1 <= j0` /\ `m0 <= j1` /\
          (termination i1 j1 m0 n0 r A1)) /\ `r >= (access A1 j1)`)
  (Pre16: `(access A1 j1) <= r` /\ `r <= (access A1 i1)`)
  (Test7: `i1 > j1`)
  ((i_invariant m0 n0 i1 r A1) /\ (j_invariant m0 n0 j1 r A1) /\
  (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j1` /\ `i1 <= N + 1` /\
  (termination i1 j1 m0 n0 r A1) /\ (permut A1 A)) /\
  (Zwf `0` `N + 2 + j1 - i1` `N + 2 + j0 - i0`).
Proof.
Intuition. 
Unfold Zwf; Omega.
Save.

(* Why obligation from file "find.mlw", characters 1703-1916 *)
Lemma find_po_14 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (i_invariant m0 n0 result2 r A0) /\ (j_invariant m0 n0 result3 r A0) /\
  (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ `0 <= result3` /\
  `result2 <= N + 1` /\ (termination result2 result3 m0 n0 r A0) /\
  (permut A0 A).
Proof.
Intros; Subst r; Subst result2; Subst result3; Intuition.
Apply Lemma_4_14; Auto.
Elim H; Elim H3; Omega.
Apply Lemma_5_14'; Auto.
Elim H; Elim H3; Omega.
Unfold termination; Right; Elim H; Elim H3; Intros; Split.
Omega.
Auto.
Save.

(* Why obligation from file "find.mlw", characters 2726-2741 *)
Lemma find_po_15 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Inv_ij: ((i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\
           (permut A1 A)) /\ `i0 > j0`)
  `m0 < i0` /\ `j0 < n0`.
Proof.
Intuition (Elim H13; Omega).
Save.

(* Why obligation from file "find.mlw", characters 2776-2783 *)
Lemma find_po_16 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Inv_ij: ((i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\
           (permut A1 A)) /\ `i0 > j0`)
  (Pre18: `m0 < i0` /\ `j0 < n0`)
  (Test13: `f <= j0`)
  (n1: Z)
  (Post8: n1 = j0)
  ((m_invariant m0 A1) /\ (n_invariant n1 A1) /\ (permut A1 A) /\
  `1 <= m0` /\ `n1 <= N`) /\ (Zwf `0` `n1 - m0` `n0 - m0`).
Proof.
Intros; Subst n1; Subst r.
Assert (array_length A0)=(array_length A).
Intuition; ProveSameLength A0 A.
Rewrite H in Pre19; Rewrite Pre21 in Pre19.
Generalize (subgoal_5 m0 n0 i0 j0 A A0 A1 
                 Inv_mn Test14 Pre19 Inv_ij Pre18 Test13).
Intuition.
Save.

(* Why obligation from file "find.mlw", characters 2819-2826 *)
Lemma find_po_17 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Inv_ij: ((i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\
           (permut A1 A)) /\ `i0 > j0`)
  (Pre18: `m0 < i0` /\ `j0 < n0`)
  (Test12: `f > j0`)
  (Test11: `i0 <= f`)
  (m1: Z)
  (Post9: m1 = i0)
  ((m_invariant m1 A1) /\ (n_invariant n0 A1) /\ (permut A1 A) /\
  `1 <= m1` /\ `n0 <= N`) /\ (Zwf `0` `n0 - m1` `n0 - m0`).
Proof.
Intros; Subst m1; Subst r.
Assert (array_length A0)=(array_length A).
Intuition; ProveSameLength A0 A.
Rewrite H in Pre19; Rewrite Pre21 in Pre19.
Generalize (subgoal_6 m0 n0 i0 j0 A A0 A1
                 Inv_mn Test14 Pre19 Inv_ij Pre18 Test12 Test11).
Intuition.
Save.

(* Why obligation from file "find.mlw", characters 2846-2870 *)
Lemma find_po_18 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (Variant1: Z)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Pre20: Variant1 = `n0 - m0`)
  (Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`)
  (Test14: `m0 < n0`)
  (Pre19: `0 <= f` /\ `f < (array_length A0)`)
  (r: Z)
  (Post14: r = (access A0 f))
  (result2: Z)
  (Post13: result2 = m0)
  (result3: Z)
  (Post12: result3 = n0)
  (A1: (array Z))
  (i0: Z)
  (j0: Z)
  (Inv_ij: ((i_invariant m0 n0 i0 r A1) /\ (j_invariant m0 n0 j0 r A1) /\
           (m_invariant m0 A1) /\ (n_invariant n0 A1) /\ `0 <= j0` /\
           `i0 <= N + 1` /\ (termination i0 j0 m0 n0 r A1) /\
           (permut A1 A)) /\ `i0 > j0`)
  (Pre18: `m0 < i0` /\ `j0 < n0`)
  (Test12: `f > j0`)
  (Test10: `i0 > f`)
  (n1: Z)
  (Post10: n1 = f)
  (m1: Z)
  (Post11: m1 = f)
  ((m_invariant m1 A1) /\ (n_invariant n1 A1) /\ (permut A1 A) /\
  `1 <= m1` /\ `n1 <= N`) /\ (Zwf `0` `n1 - m1` `n0 - m0`).
Proof.
Intros; Subst n1; Subst m1; Subst r.
Assert (array_length A0)=(array_length A).
Intuition; ProveSameLength A0 A.
Rewrite H in Pre19; Rewrite Pre21 in Pre19.
Generalize (subgoal_7 m0 n0 i0 j0 A A0 A1
                 Inv_mn Test14 Pre19 Inv_ij Pre18 Test12 Test10).
Intuition.
Save.

(* Why obligation from file "find.mlw", characters 1467-1571 *)
Lemma find_po_19 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (m_invariant result A) /\ (n_invariant result0 A) /\ (permut A A) /\
  `1 <= result` /\ `result0 <= N`.
Proof.
Intuition.
Subst result; Exact (Lemma_1 A).
Subst result0; Exact (Lemma_2 A).
Save.

(* Why obligation from file "find.mlw", characters 1415-2885 *)
Lemma find_po_20 : 
  (A: (array Z))
  (Pre21: `(array_length A) = N + 1`)
  (result: Z)
  (Post16: result = `1`)
  (result0: Z)
  (Post15: result0 = N)
  (A0: (array Z))
  (m0: Z)
  (n0: Z)
  (Inv_mn: ((m_invariant m0 A0) /\ (n_invariant n0 A0) /\ (permut A0 A) /\
           `1 <= m0` /\ `n0 <= N`) /\ `m0 >= n0`)
  (found A0) /\ (permut A0 A).
Proof.
Intuition.
Apply Lemma_3 with m:=m0 n:=n0; Auto.
Save.

Definition find (* validation *)
  : (A: (array Z))(_: `(array_length A) = N + 1`)
    (sig_2 (array Z) unit [A0: (array Z)][result: unit]((found A0) /\
     (permut A0 A)))
  := [A: (array Z); Pre21: `(array_length A) = N + 1`]
       let (result, Post16) = (exist_1 [result: Z]result = `1` `1`
         (refl_equal ? `1`)) in
       let (A0, m0, result0, Post20) =
         let (result0, Post15) = (exist_1 [result0: Z]result0 = N N
           (refl_equal ? N)) in
         let (A0, m0, n0, result1, Inv_mn) =
           (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
             [Variant1: Z](A0: (array Z))(m0: Z)(n0: Z)
             (_: Variant1 = `n0 - m0`)(Inv_mn: (m_invariant m0 A0) /\
             (n_invariant n0 A0) /\ (permut A0 A) /\ `1 <= m0` /\ `n0 <= N`)
             (sig_4 (array Z) Z Z unit [A1: (array Z)][m1: Z][n1: Z]
              [result1: unit](((m_invariant m1 A1) /\ (n_invariant n1 A1) /\
              (permut A1 A) /\ `1 <= m1` /\ `n1 <= N`) /\ `m1 >= n1`))
             [Variant1: Z; wf1: (Variant2: Z)
              (Pre1: (Zwf `0` Variant2 Variant1))(A0: (array Z))(m0: Z)
              (n0: Z)(_: Variant2 = `n0 - m0`)(Inv_mn: (m_invariant m0 A0) /\
              (n_invariant n0 A0) /\ (permut A0 A) /\ `1 <= m0` /\ `n0 <= N`)
              (sig_4 (array Z) Z Z unit [A1: (array Z)][m1: Z][n1: Z]
               [result1: unit](((m_invariant m1 A1) /\ (n_invariant n1 A1) /\
               (permut A1 A) /\ `1 <= m1` /\ `n1 <= N`) /\ `m1 >= n1`));
              A0: (array Z); m0: Z; n0: Z; Pre20: Variant1 = `n0 - m0`;
              Inv_mn: (m_invariant m0 A0) /\ (n_invariant n0 A0) /\
              (permut A0 A) /\ `1 <= m0` /\ `n0 <= N`]
               let (result1, Bool7) =
                 let (result3, Post21) = (Z_lt_ge_bool m0 n0) in
                 (exist_1 [result4: bool]
                 (if result4 then `m0 < n0` else `m0 >= n0`) result3 Post21) in
               (Cases (btest
                       [result1:bool](if result1 then `m0 < n0`
                                      else `m0 >= n0`)
                       result1 Bool7) of
               | (left Test14) =>
                   let (A1, m1, n1, result2, Inv_mn0) =
                     let (A1, m1, n1, result2, Inv_mn0) =
                       let (A1, m1, n1, result2, Inv_mn0) =
                         let Pre19 =
                           (find_po_1 A Pre21 result Post16 result0 Post15
                           Variant1 A0 m0 n0 Pre20 Inv_mn Test14) in
                         let (r, Post14) = (exist_1 [result2: Z]
                           result2 = (access A0 f) (access A0 f)
                           (refl_equal ? (access A0 f))) in
                         let (A1, m1, n1, result2, Inv_mn0) =
                           let (result2, Post13) = (exist_1 [result2: Z]
                             result2 = m0 m0 (refl_equal ? m0)) in
                           let (A1, i0, m1, n1, result3, Inv_mn0) =
                             let (result3, Post12) = (exist_1 [result3: Z]
                               result3 = n0 n0 (refl_equal ? n0)) in
                             let (A1, i0, j0, m1, n1, result4, Inv_mn0) =
                               let (A1, i0, j0, result4, Inv_ij) =
                                 (well_founded_induction Z (Zwf ZERO)
                                   (Zwf_well_founded `0`) [Variant3: Z]
                                   (A1: (array Z))(i0: Z)(j0: Z)
                                   (_: Variant3 = `N + 2 + j0 - i0`)
                                   (Inv_ij: (i_invariant m0 n0 i0 r A1) /\
                                   (j_invariant m0 n0 j0 r A1) /\
                                   (m_invariant m0 A1) /\
                                   (n_invariant n0 A1) /\ `0 <= j0` /\
                                   `i0 <= N + 1` /\
                                   (termination i0 j0 m0 n0 r A1) /\
                                   (permut A1 A))
                                   (sig_4 (array Z) Z Z unit [A2: (array Z)]
                                    [i1: Z][j1: Z][result4: unit]
                                    (((i_invariant m0 n0 i1 r A2) /\
                                    (j_invariant m0 n0 j1 r A2) /\
                                    (m_invariant m0 A2) /\
                                    (n_invariant n0 A2) /\ `0 <= j1` /\
                                    `i1 <= N + 1` /\
                                    (termination i1 j1 m0 n0 r A2) /\
                                    (permut A2 A)) /\ `i1 > j1`))
                                   [Variant3: Z; wf2: (Variant4: Z)
                                    (Pre2: (Zwf `0` Variant4 Variant3))
                                    (A1: (array Z))(i0: Z)(j0: Z)
                                    (_: Variant4 = `N + 2 + j0 - i0`)
                                    (Inv_ij: (i_invariant m0 n0 i0 r A1) /\
                                    (j_invariant m0 n0 j0 r A1) /\
                                    (m_invariant m0 A1) /\
                                    (n_invariant n0 A1) /\ `0 <= j0` /\
                                    `i0 <= N + 1` /\
                                    (termination i0 j0 m0 n0 r A1) /\
                                    (permut A1 A))
                                    (sig_4 (array Z) Z Z unit [A2: (array Z)]
                                     [i1: Z][j1: Z][result4: unit]
                                     (((i_invariant m0 n0 i1 r A2) /\
                                     (j_invariant m0 n0 j1 r A2) /\
                                     (m_invariant m0 A2) /\
                                     (n_invariant n0 A2) /\ `0 <= j1` /\
                                     `i1 <= N + 1` /\
                                     (termination i1 j1 m0 n0 r A2) /\
                                     (permut A2 A)) /\ `i1 > j1`));
                                    A1: (array Z); i0: Z; j0: Z;
                                    Pre17: Variant3 = `N + 2 + j0 - i0`;
                                    Inv_ij: (i_invariant m0 n0 i0 r A1) /\
                                    (j_invariant m0 n0 j0 r A1) /\
                                    (m_invariant m0 A1) /\
                                    (n_invariant n0 A1) /\ `0 <= j0` /\
                                    `i0 <= N + 1` /\
                                    (termination i0 j0 m0 n0 r A1) /\
                                    (permut A1 A)]
                                     let (result4, Bool4) =
                                       let (result6, Post22) =
                                         (Z_le_gt_bool i0 j0) in
                                       (exist_1 [result7: bool]
                                       (if result7 then `i0 <= j0`
                                        else `i0 > j0`) result6
                                       Post22) in
                                     (Cases (btest
                                             [result4:bool](if result4
                                                            then `i0 <= j0`
                                                            else `i0 > j0`)
                                             result4 Bool4) of
                                     | (left Test9) =>
                                         let (A2, i1, j1, result5, Inv_ij0) =
                                           let (A2, i1, j1, result5,
                                             Inv_ij0) =
                                             let (i1, result5, Inv_i) =
                                               (well_founded_induction Z
                                                 (Zwf ZERO)
                                                 (Zwf_well_founded `0`)
                                                 [Variant5: Z](i1: Z)
                                                 (_: Variant5 = `N + 1 - i1`)
                                                 (Inv_i: (i_invariant m0 n0
                                                          i1 r A1) /\
                                                 `i0 <= i1` /\ `i1 <= n0` /\
                                                 (termination i1 j0 m0 n0 r
                                                  A1))
                                                 (sig_2 Z unit [i2: Z]
                                                  [result5: unit]
                                                  (((i_invariant m0 n0 i2 r
                                                     A1) /\
                                                  `i0 <= i2` /\ `i2 <= n0` /\
                                                  (termination i2 j0 m0 n0 r
                                                   A1)) /\
                                                  `(access A1 i2) >= r`))
                                                 [Variant5: Z;
                                                  wf3: (Variant6: Z)
                                                  (Pre3: (Zwf `0` Variant6 Variant5))
                                                  (i1: Z)
                                                  (_: Variant6 = `N + 1 - i1`)
                                                  (Inv_i: (i_invariant m0 n0
                                                           i1 r A1) /\
                                                  `i0 <= i1` /\ `i1 <= n0` /\
                                                  (termination i1 j0 m0 n0 r
                                                   A1))
                                                  (sig_2 Z unit [i2: Z]
                                                   [result5: unit]
                                                   (((i_invariant m0 n0 i2 r
                                                      A1) /\
                                                   `i0 <= i2` /\
                                                   `i2 <= n0` /\
                                                   (termination i2 j0 m0 n0 r
                                                    A1)) /\
                                                   `(access A1 i2) >= r`));
                                                  i1: Z;
                                                  Pre5: Variant5 = `N + 1 -
                                                                    i1`;
                                                  Inv_i: (i_invariant m0 n0
                                                          i1 r A1) /\
                                                  `i0 <= i1` /\ `i1 <= n0` /\
                                                  (termination i1 j0 m0 n0 r
                                                   A1)]
                                                   let (result5, Bool1) =
                                                     let result6 =
                                                       let Pre4 =
                                                         (find_po_2 A Pre21
                                                         result Post16
                                                         result0 Post15
                                                         Variant1 A0 m0 n0
                                                         Pre20 Inv_mn Test14
                                                         Pre19 r Post14
                                                         result2 Post13
                                                         result3 Post12
                                                         Variant3 A1 i0 j0
                                                         Pre17 Inv_ij Test9
                                                         Variant5 i1 Pre5
                                                         Inv_i) in
                                                       (Z_lt_ge_bool (
                                                        access A1 i1)) in
                                                     let (result7, Post23) =
                                                       (result6 r) in
                                                     (exist_1 [result8: bool]
                                                     (if result8
                                                      then `(access A1 i1) <
                                                            r`
                                                      else `(access A1 i1) >=
                                                            r`) result7
                                                     Post23) in
                                                   (Cases (btest
                                                           [result5:bool](
                                                           if result5
                                                           then `(access A1
                                                                  i1) <
                                                                 r`
                                                           else `(access A1
                                                                  i1) >=
                                                                 r`)
                                                           result5 Bool1) of
                                                   | (left Test4) =>
                                                       let (i2, result6,
                                                         Inv_i0) =
                                                         let (i2, result6,
                                                           Inv_i0) =
                                                           let (i2, result6,
                                                             Post1) =
                                                             let (result6,
                                                               Post1) =
                                                               (exist_1 [result6: Z]
                                                               result6 = `
                                                               i1 + 1` 
                                                               `i1 + 1`
                                                               (refl_equal ? `
                                                               i1 + 1`)) in
                                                             (exist_2 [i3: Z]
                                                             [result7: unit]
                                                             i3 = `i1 + 1` 
                                                             result6 
                                                             tt Post1) in
                                                           (exist_2 [i3: Z]
                                                           [result7: unit]
                                                           ((i_invariant m0
                                                             n0 i3 r A1) /\
                                                           `i0 <= i3` /\
                                                           `i3 <= n0` /\
                                                           (termination i3 j0
                                                            m0 n0 r A1)) /\
                                                           (Zwf `0` `
                                                           N + 1 - i3` `
                                                           N + 1 - i1`) 
                                                           i2 result6
                                                           (find_po_3 A Pre21
                                                           result Post16
                                                           result0 Post15
                                                           Variant1 A0 m0 n0
                                                           Pre20 Inv_mn
                                                           Test14 Pre19 r
                                                           Post14 result2
                                                           Post13 result3
                                                           Post12 Variant3 A1
                                                           i0 j0 Pre17 Inv_ij
                                                           Test9 Variant5 i1
                                                           Pre5 Inv_i Test4
                                                           i2 Post1)) in
                                                         ((wf3 `N + 1 - i2`)
                                                           (loop_variant_1 Pre5 Inv_i0)
                                                           i2
                                                           (refl_equal ? `
                                                           N + 1 - i2`)
                                                           (proj1 ? ? Inv_i0)) in
                                                       (exist_2 [i3: Z]
                                                       [result7: unit]
                                                       ((i_invariant m0 n0 i3
                                                         r A1) /\
                                                       `i0 <= i3` /\
                                                       `i3 <= n0` /\
                                                       (termination i3 j0 m0
                                                        n0 r A1)) /\
                                                       `(access A1 i3) >= r` 
                                                       i2 result6 Inv_i0)
                                                   | (right Test3) =>
                                                       let (i2, result6,
                                                         Inv_i0) =
                                                         (exist_2 [i2: Z]
                                                         [result6: unit]
                                                         ((i_invariant m0 n0
                                                           i2 r A1) /\
                                                         `i0 <= i2` /\
                                                         `i2 <= n0` /\
                                                         (termination i2 j0
                                                          m0 n0 r A1)) /\
                                                         `(access A1 i2) >= r` 
                                                         i1 tt
                                                         (conj ? ? Inv_i Test3)) in
                                                       (exist_2 [i3: Z]
                                                       [result7: unit]
                                                       ((i_invariant m0 n0 i3
                                                         r A1) /\
                                                       `i0 <= i3` /\
                                                       `i3 <= n0` /\
                                                       (termination i3 j0 m0
                                                        n0 r A1)) /\
                                                       `(access A1 i3) >= r` 
                                                       i2 result6 Inv_i0) end)
                                                 `N + 1 - i0` i0
                                                 (refl_equal ? `N + 1 - i0`)
                                                 (find_po_4 A Pre21 result
                                                 Post16 result0 Post15
                                                 Variant1 A0 m0 n0 Pre20
                                                 Inv_mn Test14 Pre19 r Post14
                                                 result2 Post13 result3
                                                 Post12 Variant3 A1 i0 j0
                                                 Pre17 Inv_ij Test9)) in
                                             let (j1, result6, Inv_j) =
                                               (well_founded_induction Z
                                                 (Zwf ZERO)
                                                 (Zwf_well_founded `0`)
                                                 [Variant7: Z](j1: Z)
                                                 (_: Variant7 = j1)
                                                 (Inv_j: (j_invariant m0 n0
                                                          j1 r A1) /\
                                                 `j1 <= j0` /\ `m0 <= j1` /\
                                                 (termination i1 j1 m0 n0 r
                                                  A1))
                                                 (sig_2 Z unit [j2: Z]
                                                  [result6: unit]
                                                  (((j_invariant m0 n0 j2 r
                                                     A1) /\
                                                  `j2 <= j0` /\ `m0 <= j2` /\
                                                  (termination i1 j2 m0 n0 r
                                                   A1)) /\
                                                  `r >= (access A1 j2)`))
                                                 [Variant7: Z;
                                                  wf4: (Variant8: Z)
                                                  (Pre6: (Zwf `0` Variant8 Variant7))
                                                  (j1: Z)(_: Variant8 = j1)
                                                  (Inv_j: (j_invariant m0 n0
                                                           j1 r A1) /\
                                                  `j1 <= j0` /\ `m0 <= j1` /\
                                                  (termination i1 j1 m0 n0 r
                                                   A1))
                                                  (sig_2 Z unit [j2: Z]
                                                   [result6: unit]
                                                   (((j_invariant m0 n0 j2 r
                                                      A1) /\
                                                   `j2 <= j0` /\
                                                   `m0 <= j2` /\
                                                   (termination i1 j2 m0 n0 r
                                                    A1)) /\
                                                   `r >= (access A1 j2)`));
                                                  j1: Z; Pre8: Variant7 = j1;
                                                  Inv_j: (j_invariant m0 n0
                                                          j1 r A1) /\
                                                  `j1 <= j0` /\ `m0 <= j1` /\
                                                  (termination i1 j1 m0 n0 r
                                                   A1)]
                                                   let (result6, Bool2) =
                                                     let Pre7 =
                                                       (find_po_5 A Pre21
                                                       result Post16 result0
                                                       Post15 Variant1 A0 m0
                                                       n0 Pre20 Inv_mn Test14
                                                       Pre19 r Post14 result2
                                                       Post13 result3 Post12
                                                       Variant3 A1 i0 j0
                                                       Pre17 Inv_ij Test9 i1
                                                       Inv_i Variant7 j1 Pre8
                                                       Inv_j) in
                                                     let (result8, Post24) =
                                                       (Z_lt_ge_bool r
                                                          (access A1 j1)) in
                                                     (exist_1 [result9: bool]
                                                     (if result9
                                                      then `r <
                                                            (access A1 j1)`
                                                      else `r >=
                                                            (access A1 j1)`) 
                                                     result8 Post24) in
                                                   (Cases (btest
                                                           [result6:bool](
                                                           if result6
                                                           then `r <
                                                                 (access A1
                                                                  j1)`
                                                           else `r >=
                                                                 (access A1
                                                                  j1)`)
                                                           result6 Bool2) of
                                                   | (left Test6) =>
                                                       let (j2, result7,
                                                         Inv_j0) =
                                                         let (j2, result7,
                                                           Inv_j0) =
                                                           let (j2, result7,
                                                             Post2) =
                                                             let (result7,
                                                               Post2) =
                                                               (exist_1 [result7: Z]
                                                               result7 = `
                                                               j1 - 1` 
                                                               `j1 - 1`
                                                               (refl_equal ? `
                                                               j1 - 1`)) in
                                                             (exist_2 [j3: Z]
                                                             [result8: unit]
                                                             j3 = `j1 - 1` 
                                                             result7 
                                                             tt Post2) in
                                                           (exist_2 [j3: Z]
                                                           [result8: unit]
                                                           ((j_invariant m0
                                                             n0 j3 r A1) /\
                                                           `j3 <= j0` /\
                                                           `m0 <= j3` /\
                                                           (termination i1 j3
                                                            m0 n0 r A1)) /\
                                                           (Zwf `0` j3 j1) 
                                                           j2 result7
                                                           (find_po_6 A Pre21
                                                           result Post16
                                                           result0 Post15
                                                           Variant1 A0 m0 n0
                                                           Pre20 Inv_mn
                                                           Test14 Pre19 r
                                                           Post14 result2
                                                           Post13 result3
                                                           Post12 Variant3 A1
                                                           i0 j0 Pre17 Inv_ij
                                                           Test9 i1 Inv_i
                                                           Variant7 j1 Pre8
                                                           Inv_j Test6 j2
                                                           Post2)) in
                                                         ((wf4 j2)
                                                           (loop_variant_1 Pre8 Inv_j0)
                                                           j2
                                                           (refl_equal ? j2)
                                                           (proj1 ? ? Inv_j0)) in
                                                       (exist_2 [j3: Z]
                                                       [result8: unit]
                                                       ((j_invariant m0 n0 j3
                                                         r A1) /\
                                                       `j3 <= j0` /\
                                                       `m0 <= j3` /\
                                                       (termination i1 j3 m0
                                                        n0 r A1)) /\
                                                       `r >= (access A1 j3)` 
                                                       j2 result7 Inv_j0)
                                                   | (right Test5) =>
                                                       let (j2, result7,
                                                         Inv_j0) =
                                                         (exist_2 [j2: Z]
                                                         [result7: unit]
                                                         ((j_invariant m0 n0
                                                           j2 r A1) /\
                                                         `j2 <= j0` /\
                                                         `m0 <= j2` /\
                                                         (termination i1 j2
                                                          m0 n0 r A1)) /\
                                                         `r >= (access A1 j2)` 
                                                         j1 tt
                                                         (conj ? ? Inv_j Test5)) in
                                                       (exist_2 [j3: Z]
                                                       [result8: unit]
                                                       ((j_invariant m0 n0 j3
                                                         r A1) /\
                                                       `j3 <= j0` /\
                                                       `m0 <= j3` /\
                                                       (termination i1 j3 m0
                                                        n0 r A1)) /\
                                                       `r >= (access A1 j3)` 
                                                       j2 result7 Inv_j0) end)
                                                 j0 j0 (refl_equal ? j0)
                                                 (find_po_7 A Pre21 result
                                                 Post16 result0 Post15
                                                 Variant1 A0 m0 n0 Pre20
                                                 Inv_mn Test14 Pre19 r Post14
                                                 result2 Post13 result3
                                                 Post12 Variant3 A1 i0 j0
                                                 Pre17 Inv_ij Test9 i1 Inv_i)) in
                                             let Pre16 =
                                               (find_po_8 A Pre21 result
                                               Post16 result0 Post15 Variant1
                                               A0 m0 n0 Pre20 Inv_mn Test14
                                               Pre19 r Post14 result2 Post13
                                               result3 Post12 Variant3 A1 i0
                                               j0 Pre17 Inv_ij Test9 i1 Inv_i
                                               j1 Inv_j) in
                                             let (A2, i2, j2, result7,
                                               Inv_ij0) =
                                               let (result7, Bool3) =
                                                 let (result9, Post25) =
                                                   (Z_le_gt_bool i1 j1) in
                                                 (exist_1 [result10: bool]
                                                 (if result10 then `i1 <= j1`
                                                  else `i1 > j1`) result9
                                                 Post25) in
                                               (Cases (btest
                                                       [result7:bool](
                                                       if result7
                                                       then `i1 <= j1`
                                                       else `i1 > j1`)
                                                       result7 Bool3) of
                                               | (left Test8) =>
                                                   let (A2, i2, j2, result8,
                                                     Inv_ij0) =
                                                     let (A2, result8,
                                                       Post26) =
                                                       let Pre12 =
                                                         (find_po_9 A Pre21
                                                         result Post16
                                                         result0 Post15
                                                         Variant1 A0 m0 n0
                                                         Pre20 Inv_mn Test14
                                                         Pre19 r Post14
                                                         result2 Post13
                                                         result3 Post12
                                                         Variant3 A1 i0 j0
                                                         Pre17 Inv_ij Test9
                                                         i1 Inv_i j1 Inv_j
                                                         Pre16 Test8) in
                                                       let (w, Post5) =
                                                         (exist_1 [result8: Z]
                                                         result8 = (access A1
                                                                    i1) 
                                                         (access A1 i1)
                                                         (refl_equal ? (
                                                         access A1 i1))) in
                                                       let (A2, result8,
                                                         Post27) =
                                                         let Pre10 = Pre12 in
                                                         let Pre11 =
                                                           (find_po_10 A
                                                           Pre21 result
                                                           Post16 result0
                                                           Post15 Variant1 A0
                                                           m0 n0 Pre20 Inv_mn
                                                           Test14 Pre19 r
                                                           Post14 result2
                                                           Post13 result3
                                                           Post12 Variant3 A1
                                                           i0 j0 Pre17 Inv_ij
                                                           Test9 i1 Inv_i j1
                                                           Inv_j Pre16 Test8
                                                           Pre12 w Post5
                                                           Pre10) in
                                                         let (A2, result8,
                                                           Post3) =
                                                           (exist_2 [A3: (
                                                           array Z)]
                                                           [result10: unit]
                                                           A3 = (store A1 i1
                                                                 (access A1
                                                                  j1)) 
                                                           (store A1 i1
                                                            (access A1 j1))
                                                           tt
                                                           (refl_equal ? (
                                                           store A1 i1
                                                           (access A1 j1)))) in
                                                         let Pre9 =
                                                           (find_po_11 A
                                                           Pre21 result
                                                           Post16 result0
                                                           Post15 Variant1 A0
                                                           m0 n0 Pre20 Inv_mn
                                                           Test14 Pre19 r
                                                           Post14 result2
                                                           Post13 result3
                                                           Post12 Variant3 A1
                                                           i0 j0 Pre17 Inv_ij
                                                           Test9 i1 Inv_i j1
                                                           Inv_j Pre16 Test8
                                                           Pre12 w Post5
                                                           Pre10 Pre11 A2
                                                           Post3) in
                                                         let (A3, result9,
                                                           Post4) =
                                                           (exist_2 [A4: (
                                                           array Z)]
                                                           [result11: unit]
                                                           A4 = (store A2 j1
                                                                 w) (
                                                                    store A2
                                                                    j1 w) 
                                                           tt
                                                           (refl_equal ? (
                                                           store A2 j1 w))) in
                                                         (exist_2 [A4: (
                                                         array Z)]
                                                         [result10: unit]
                                                         (exchange A4 A1 i1
                                                          j1) /\
                                                         `(access A4 i1) <= r` /\
                                                         `r <= (access A4 j1)` /\
                                                         ((i:Z)
                                                          (i = `i1 + 1` ->
                                                           ((j:Z)
                                                            (j = `j1 - 1` ->
                                                             ((i_invariant m0
                                                               n0 i r A4) /\
                                                             (j_invariant m0
                                                              n0 j r A4) /\
                                                             (m_invariant m0
                                                              A4) /\
                                                             (n_invariant n0
                                                              A4) /\
                                                             `0 <= j` /\
                                                             `i <= N + 1` /\
                                                             (termination i j
                                                              m0 n0 r A4) /\
                                                             (permut A4 A)) /\
                                                             (Zwf `0` `
                                                             N + 2 + j - i` `
                                                             N + 2 + j0 - i0`))))) 
                                                         A3 result9
                                                         (find_po_12 A Pre21
                                                         result Post16
                                                         result0 Post15
                                                         Variant1 A0 m0 n0
                                                         Pre20 Inv_mn Test14
                                                         Pre19 r Post14
                                                         result2 Post13
                                                         result3 Post12
                                                         Variant3 A1 i0 j0
                                                         Pre17 Inv_ij Test9
                                                         i1 Inv_i j1 Inv_j
                                                         Pre16 Test8 Pre12 w
                                                         Post5 Pre10 Pre11 A2
                                                         Post3 Pre9 A3 Post4)) in
                                                       (exist_2 [A3: (
                                                       array Z)]
                                                       [result9: unit]
                                                       (exchange A3 A1 i1 j1) /\
                                                       `(access A3 i1) <= r` /\
                                                       `r <= (access A3 j1)` /\
                                                       ((i:Z)
                                                        (i = `i1 + 1` ->
                                                         ((j:Z)
                                                          (j = `j1 - 1` ->
                                                           ((i_invariant m0
                                                             n0 i r A3) /\
                                                           (j_invariant m0 n0
                                                            j r A3) /\
                                                           (m_invariant m0 A3) /\
                                                           (n_invariant n0 A3) /\
                                                           `0 <= j` /\
                                                           `i <= N + 1` /\
                                                           (termination i j
                                                            m0 n0 r A3) /\
                                                           (permut A3 A)) /\
                                                           (Zwf `0` `
                                                           N + 2 + j - i` `
                                                           N + 2 + j0 - i0`))))) 
                                                       A2 result8 Post27) in
                                                     let Pre15 =
                                                       (proj1 ? ? Post26) in
                                                     let Pre14 =
                                                       let (HW_427, HW_428) =
                                                         Inv_mn in
                                                       let (HW_429, HW_430) =
                                                         HW_428 in
                                                       let (HW_431, HW_432) =
                                                         HW_430 in
                                                       let (HW_433, HW_434) =
                                                         HW_432 in
                                                       let (HW_435, HW_436) =
                                                         Pre19 in
                                                       let (HW_437, HW_438) =
                                                         Inv_ij in
                                                       let (HW_439, HW_440) =
                                                         HW_438 in
                                                       let (HW_441, HW_442) =
                                                         HW_440 in
                                                       let (HW_443, HW_444) =
                                                         HW_442 in
                                                       let (HW_445, HW_446) =
                                                         HW_444 in
                                                       let (HW_447, HW_448) =
                                                         HW_446 in
                                                       let (HW_449, HW_450) =
                                                         HW_448 in
                                                       let (HW_451, HW_452) =
                                                         Inv_i in
                                                       let (HW_453, HW_454) =
                                                         HW_451 in
                                                       let (HW_455, HW_456) =
                                                         HW_454 in
                                                       let (HW_457, HW_458) =
                                                         HW_456 in
                                                       let (HW_459, HW_460) =
                                                         Inv_j in
                                                       let (HW_461, HW_462) =
                                                         HW_459 in
                                                       let (HW_463, HW_464) =
                                                         HW_462 in
                                                       let (HW_465, HW_466) =
                                                         HW_464 in
                                                       let (HW_467, HW_468) =
                                                         Pre16 in
                                                       let (HW_469, HW_470) =
                                                         Post26 in
                                                       let (HW_471, HW_472) =
                                                         HW_470 in
                                                       HW_471 in
                                                     let Pre13 =
                                                       let (HW_473, HW_474) =
                                                         Inv_mn in
                                                       let (HW_475, HW_476) =
                                                         HW_474 in
                                                       let (HW_477, HW_478) =
                                                         HW_476 in
                                                       let (HW_479, HW_480) =
                                                         HW_478 in
                                                       let (HW_481, HW_482) =
                                                         Pre19 in
                                                       let (HW_483, HW_484) =
                                                         Inv_ij in
                                                       let (HW_485, HW_486) =
                                                         HW_484 in
                                                       let (HW_487, HW_488) =
                                                         HW_486 in
                                                       let (HW_489, HW_490) =
                                                         HW_488 in
                                                       let (HW_491, HW_492) =
                                                         HW_490 in
                                                       let (HW_493, HW_494) =
                                                         HW_492 in
                                                       let (HW_495, HW_496) =
                                                         HW_494 in
                                                       let (HW_497, HW_498) =
                                                         Inv_i in
                                                       let (HW_499, HW_500) =
                                                         HW_497 in
                                                       let (HW_501, HW_502) =
                                                         HW_500 in
                                                       let (HW_503, HW_504) =
                                                         HW_502 in
                                                       let (HW_505, HW_506) =
                                                         Inv_j in
                                                       let (HW_507, HW_508) =
                                                         HW_505 in
                                                       let (HW_509, HW_510) =
                                                         HW_508 in
                                                       let (HW_511, HW_512) =
                                                         HW_510 in
                                                       let (HW_513, HW_514) =
                                                         Pre16 in
                                                       let (HW_515, HW_516) =
                                                         Post26 in
                                                       let (HW_517, HW_518) =
                                                         HW_516 in
                                                       let (HW_519, HW_520) =
                                                         HW_518 in
                                                       HW_519 in
                                                     let (i2, result9,
                                                       Post6) =
                                                       let (result9, Post6) =
                                                         (exist_1 [result9: Z]
                                                         result9 = `i1 + 1` 
                                                         `i1 + 1`
                                                         (refl_equal ? `
                                                         i1 + 1`)) in
                                                       (exist_2 [i3: Z]
                                                       [result10: unit]
                                                       i3 = `i1 + 1` 
                                                       result9 tt Post6) in
                                                     let (j2, result10,
                                                       Post7) =
                                                       let (result10,
                                                         Post7) =
                                                         (exist_1 [result10: Z]
                                                         result10 = `j1 - 1` 
                                                         `j1 - 1`
                                                         (refl_equal ? `
                                                         j1 - 1`)) in
                                                       (exist_2 [j3: Z]
                                                       [result11: unit]
                                                       j3 = `j1 - 1` 
                                                       result10 tt Post7) in
                                                     (exist_4 [A3: (array Z)]
                                                     [i3: Z][j3: Z]
                                                     [result11: unit]
                                                     ((i_invariant m0 n0 i3 r
                                                       A3) /\
                                                     (j_invariant m0 n0 j3 r
                                                      A3) /\
                                                     (m_invariant m0 A3) /\
                                                     (n_invariant n0 A3) /\
                                                     `0 <= j3` /\
                                                     `i3 <= N + 1` /\
                                                     (termination i3 j3 m0 n0
                                                      r A3) /\
                                                     (permut A3 A)) /\
                                                     (Zwf `0` `N + 2 + j3 -
                                                               i3` `N + 2 +
                                                                    j0 - i0`) 
                                                     A2 i2 j2 result10
                                                     let (HW_521, HW_522) =
                                                       Inv_mn in
                                                     let (HW_523, HW_524) =
                                                       HW_522 in
                                                     let (HW_525, HW_526) =
                                                       HW_524 in
                                                     let (HW_527, HW_528) =
                                                       HW_526 in
                                                     let (HW_529, HW_530) =
                                                       Pre19 in
                                                     let (HW_531, HW_532) =
                                                       Inv_ij in
                                                     let (HW_533, HW_534) =
                                                       HW_532 in
                                                     let (HW_535, HW_536) =
                                                       HW_534 in
                                                     let (HW_537, HW_538) =
                                                       HW_536 in
                                                     let (HW_539, HW_540) =
                                                       HW_538 in
                                                     let (HW_541, HW_542) =
                                                       HW_540 in
                                                     let (HW_543, HW_544) =
                                                       HW_542 in
                                                     let (HW_545, HW_546) =
                                                       Inv_i in
                                                     let (HW_547, HW_548) =
                                                       HW_545 in
                                                     let (HW_549, HW_550) =
                                                       HW_548 in
                                                     let (HW_551, HW_552) =
                                                       HW_550 in
                                                     let (HW_553, HW_554) =
                                                       Inv_j in
                                                     let (HW_555, HW_556) =
                                                       HW_553 in
                                                     let (HW_557, HW_558) =
                                                       HW_556 in
                                                     let (HW_559, HW_560) =
                                                       HW_558 in
                                                     let (HW_561, HW_562) =
                                                       Pre16 in
                                                     let (HW_563, HW_564) =
                                                       Post26 in
                                                     let (HW_565, HW_566) =
                                                       HW_564 in
                                                     let (HW_567, HW_568) =
                                                       HW_566 in
                                                     let HW_569 =
                                                       (HW_568 i2 Post6) in
                                                     let HW_570 =
                                                       (HW_569 j2 Post7) in
                                                     HW_570) in
                                                   (exist_4 [A3: (array Z)]
                                                   [i3: Z][j3: Z]
                                                   [result9: unit]
                                                   ((i_invariant m0 n0 i3 r
                                                     A3) /\
                                                   (j_invariant m0 n0 j3 r A3) /\
                                                   (m_invariant m0 A3) /\
                                                   (n_invariant n0 A3) /\
                                                   `0 <= j3` /\
                                                   `i3 <= N + 1` /\
                                                   (termination i3 j3 m0 n0 r
                                                    A3) /\
                                                   (permut A3 A)) /\
                                                   (Zwf `0` `N + 2 + j3 - i3` `
                                                   N + 2 + j0 - i0`) 
                                                   A2 i2 j2 result8 Inv_ij0)
                                               | (right Test7) =>
                                                   let (result8, Inv_ij0) =
                                                     (exist_1 [result8: unit]
                                                     ((i_invariant m0 n0 i1 r
                                                       A1) /\
                                                     (j_invariant m0 n0 j1 r
                                                      A1) /\
                                                     (m_invariant m0 A1) /\
                                                     (n_invariant n0 A1) /\
                                                     `0 <= j1` /\
                                                     `i1 <= N + 1` /\
                                                     (termination i1 j1 m0 n0
                                                      r A1) /\
                                                     (permut A1 A)) /\
                                                     (Zwf `0` `N + 2 + j1 -
                                                               i1` `N + 2 +
                                                                    j0 - i0`) 
                                                     tt
                                                     (find_po_13 A Pre21
                                                     result Post16 result0
                                                     Post15 Variant1 A0 m0 n0
                                                     Pre20 Inv_mn Test14
                                                     Pre19 r Post14 result2
                                                     Post13 result3 Post12
                                                     Variant3 A1 i0 j0 Pre17
                                                     Inv_ij Test9 i1 Inv_i j1
                                                     Inv_j Pre16 Test7)) in
                                                   (exist_4 [A2: (array Z)]
                                                   [i2: Z][j2: Z]
                                                   [result9: unit]
                                                   ((i_invariant m0 n0 i2 r
                                                     A2) /\
                                                   (j_invariant m0 n0 j2 r A2) /\
                                                   (m_invariant m0 A2) /\
                                                   (n_invariant n0 A2) /\
                                                   `0 <= j2` /\
                                                   `i2 <= N + 1` /\
                                                   (termination i2 j2 m0 n0 r
                                                    A2) /\
                                                   (permut A2 A)) /\
                                                   (Zwf `0` `N + 2 + j2 - i2` `
                                                   N + 2 + j0 - i0`) 
                                                   A1 i1 j1 result8 Inv_ij0) end) in
                                             (exist_4 [A3: (array Z)][i3: Z]
                                             [j3: Z][result8: unit]
                                             ((i_invariant m0 n0 i3 r A3) /\
                                             (j_invariant m0 n0 j3 r A3) /\
                                             (m_invariant m0 A3) /\
                                             (n_invariant n0 A3) /\
                                             `0 <= j3` /\ `i3 <= N + 1` /\
                                             (termination i3 j3 m0 n0 r A3) /\
                                             (permut A3 A)) /\
                                             (Zwf `0` `N + 2 + j3 - i3` `
                                             N + 2 + j0 - i0`) A2 i2 
                                             j2 result7 Inv_ij0) in
                                           ((wf2 `N + 2 + j1 - i1`)
                                             (loop_variant_1 Pre17 Inv_ij0)
                                             A2 i1 j1
                                             (refl_equal ? `N + 2 + j1 - i1`)
                                             (proj1 ? ? Inv_ij0)) in
                                         (exist_4 [A3: (array Z)][i2: Z]
                                         [j2: Z][result6: unit]
                                         ((i_invariant m0 n0 i2 r A3) /\
                                         (j_invariant m0 n0 j2 r A3) /\
                                         (m_invariant m0 A3) /\
                                         (n_invariant n0 A3) /\ `0 <= j2` /\
                                         `i2 <= N + 1` /\
                                         (termination i2 j2 m0 n0 r A3) /\
                                         (permut A3 A)) /\ `i2 > j2` 
                                         A2 i1 j1 result5 Inv_ij0)
                                     | (right Test2) =>
                                         let (A2, i1, j1, result5, Inv_ij0) =
                                           (exist_4 [A2: (array Z)][i1: Z]
                                           [j1: Z][result5: unit]
                                           ((i_invariant m0 n0 i1 r A2) /\
                                           (j_invariant m0 n0 j1 r A2) /\
                                           (m_invariant m0 A2) /\
                                           (n_invariant n0 A2) /\
                                           `0 <= j1` /\ `i1 <= N + 1` /\
                                           (termination i1 j1 m0 n0 r A2) /\
                                           (permut A2 A)) /\ `i1 > j1` 
                                           A1 i0 j0 tt
                                           (conj ? ? Inv_ij Test2)) in
                                         (exist_4 [A3: (array Z)][i2: Z]
                                         [j2: Z][result6: unit]
                                         ((i_invariant m0 n0 i2 r A3) /\
                                         (j_invariant m0 n0 j2 r A3) /\
                                         (m_invariant m0 A3) /\
                                         (n_invariant n0 A3) /\ `0 <= j2` /\
                                         `i2 <= N + 1` /\
                                         (termination i2 j2 m0 n0 r A3) /\
                                         (permut A3 A)) /\ `i2 > j2` 
                                         A2 i1 j1 result5 Inv_ij0) end)
                                   `N + 2 + result3 - result2` A0 result2
                                   result3
                                   (refl_equal ? `N + 2 + result3 - result2`)
                                   (find_po_14 A Pre21 result Post16 result0
                                   Post15 Variant1 A0 m0 n0 Pre20 Inv_mn
                                   Test14 Pre19 r Post14 result2 Post13
                                   result3 Post12)) in
                               let Pre18 =
                                 (find_po_15 A Pre21 result Post16 result0
                                 Post15 Variant1 A0 m0 n0 Pre20 Inv_mn Test14
                                 Pre19 r Post14 result2 Post13 result3 Post12
                                 A1 i0 j0 Inv_ij) in
                               let (m1, n1, result5, Inv_mn0) =
                                 let (result5, Bool6) =
                                   let (result7, Post28) =
                                     (Z_le_gt_bool f j0) in
                                   (exist_1 [result8: bool]
                                   (if result8 then `f <= j0` else `f > j0`) 
                                   result7 Post28) in
                                 (Cases (btest
                                         [result5:bool](if result5
                                                        then `f <= j0`
                                                        else `f > j0`)
                                         result5 Bool6) of
                                 | (left Test13) =>
                                     let (n1, result6, Post8) =
                                       let (result6, Post8) =
                                         (exist_1 [result6: Z]result6 = j0 
                                         j0 (refl_equal ? j0)) in
                                       (exist_2 [n2: Z][result7: unit]
                                       n2 = j0 result6 tt Post8) in
                                     (exist_3 [m1: Z][n2: Z][result7: unit]
                                     ((m_invariant m1 A1) /\
                                     (n_invariant n2 A1) /\ (permut A1 A) /\
                                     `1 <= m1` /\ `n2 <= N`) /\
                                     (Zwf `0` `n2 - m1` `n0 - m0`) m0 
                                     n1 result6
                                     (find_po_16 A Pre21 result Post16
                                     result0 Post15 Variant1 A0 m0 n0 Pre20
                                     Inv_mn Test14 Pre19 r Post14 result2
                                     Post13 result3 Post12 A1 i0 j0 Inv_ij
                                     Pre18 Test13 n1 Post8))
                                 | (right Test12) =>
                                     let (m1, n1, result6, Inv_mn0) =
                                       let (result6, Bool5) =
                                         let (result8, Post29) =
                                           (Z_le_gt_bool i0 f) in
                                         (exist_1 [result9: bool]
                                         (if result9 then `i0 <= f`
                                          else `i0 > f`) result8
                                         Post29) in
                                       (Cases (btest
                                               [result6:bool](if result6
                                                              then `i0 <= f`
                                                              else `i0 > f`)
                                               result6 Bool5) of
                                       | (left Test11) =>
                                           let (m1, result7, Post9) =
                                             let (result7, Post9) =
                                               (exist_1 [result7: Z]
                                               result7 = i0 i0
                                               (refl_equal ? i0)) in
                                             (exist_2 [m2: Z][result8: unit]
                                             m2 = i0 result7 tt Post9) in
                                           (exist_3 [m2: Z][n1: Z]
                                           [result8: unit]
                                           ((m_invariant m2 A1) /\
                                           (n_invariant n1 A1) /\
                                           (permut A1 A) /\ `1 <= m2` /\
                                           `n1 <= N`) /\
                                           (Zwf `0` `n1 - m2` `n0 - m0`) 
                                           m1 n0 result7
                                           (find_po_17 A Pre21 result Post16
                                           result0 Post15 Variant1 A0 m0 n0
                                           Pre20 Inv_mn Test14 Pre19 r Post14
                                           result2 Post13 result3 Post12 A1
                                           i0 j0 Inv_ij Pre18 Test12 Test11
                                           m1 Post9))
                                       | (right Test10) =>
                                           let (m1, n1, result7, Inv_mn0) =
                                             let (n1, result7, Post10) =
                                               let (result7, Post10) =
                                                 (exist_1 [result7: Z]
                                                 result7 = f f
                                                 (refl_equal ? f)) in
                                               (exist_2 [n2: Z]
                                               [result8: unit]n2 = f 
                                               result7 tt Post10) in
                                             let (m1, result8, Post11) =
                                               let (result8, Post11) =
                                                 (exist_1 [result8: Z]
                                                 result8 = f f
                                                 (refl_equal ? f)) in
                                               (exist_2 [m2: Z]
                                               [result9: unit]m2 = f 
                                               result8 tt Post11) in
                                             (exist_3 [m2: Z][n2: Z]
                                             [result9: unit]
                                             ((m_invariant m2 A1) /\
                                             (n_invariant n2 A1) /\
                                             (permut A1 A) /\ `1 <= m2` /\
                                             `n2 <= N`) /\
                                             (Zwf `0` `n2 - m2` `n0 - m0`) 
                                             m1 n1 result8
                                             (find_po_18 A Pre21 result
                                             Post16 result0 Post15 Variant1
                                             A0 m0 n0 Pre20 Inv_mn Test14
                                             Pre19 r Post14 result2 Post13
                                             result3 Post12 A1 i0 j0 Inv_ij
                                             Pre18 Test12 Test10 n1 Post10 m1
                                             Post11)) in
                                           (exist_3 [m2: Z][n2: Z]
                                           [result8: unit]
                                           ((m_invariant m2 A1) /\
                                           (n_invariant n2 A1) /\
                                           (permut A1 A) /\ `1 <= m2` /\
                                           `n2 <= N`) /\
                                           (Zwf `0` `n2 - m2` `n0 - m0`) 
                                           m1 n1 result7 Inv_mn0) end) in
                                     (exist_3 [m2: Z][n2: Z][result7: unit]
                                     ((m_invariant m2 A1) /\
                                     (n_invariant n2 A1) /\ (permut A1 A) /\
                                     `1 <= m2` /\ `n2 <= N`) /\
                                     (Zwf `0` `n2 - m2` `n0 - m0`) m1 
                                     n1 result6 Inv_mn0) end) in
                               (exist_6 [A2: (array Z)][i1: Z][j1: Z][m2: Z]
                               [n2: Z][result6: unit]((m_invariant m2 A2) /\
                               (n_invariant n2 A2) /\ (permut A2 A) /\
                               `1 <= m2` /\ `n2 <= N`) /\
                               (Zwf `0` `n2 - m2` `n0 - m0`) A1 i0 j0 
                               m1 n1 result5 Inv_mn0) in
                             (exist_5 [A2: (array Z)][i1: Z][m2: Z][n2: Z]
                             [result5: unit]((m_invariant m2 A2) /\
                             (n_invariant n2 A2) /\ (permut A2 A) /\
                             `1 <= m2` /\ `n2 <= N`) /\
                             (Zwf `0` `n2 - m2` `n0 - m0`) A1 i0 m1 n1
                             result4 Inv_mn0) in
                           (exist_4 [A2: (array Z)][m2: Z][n2: Z]
                           [result4: unit]((m_invariant m2 A2) /\
                           (n_invariant n2 A2) /\ (permut A2 A) /\
                           `1 <= m2` /\ `n2 <= N`) /\
                           (Zwf `0` `n2 - m2` `n0 - m0`) A1 m1 n1 result3
                           Inv_mn0) in
                         (exist_4 [A2: (array Z)][m2: Z][n2: Z]
                         [result3: unit]((m_invariant m2 A2) /\
                         (n_invariant n2 A2) /\ (permut A2 A) /\ `1 <= m2` /\
                         `n2 <= N`) /\ (Zwf `0` `n2 - m2` `n0 - m0`) 
                         A1 m1 n1 result2 Inv_mn0) in
                       (exist_4 [A2: (array Z)][m2: Z][n2: Z][result3: unit]
                       ((m_invariant m2 A2) /\ (n_invariant n2 A2) /\
                       (permut A2 A) /\ `1 <= m2` /\ `n2 <= N`) /\
                       (Zwf `0` `n2 - m2` `n0 - m0`) A1 m1 n1 result2
                       Inv_mn0) in
                     ((wf1 `n1 - m1`) (loop_variant_1 Pre20 Inv_mn0) 
                       A1 m1 n1 (refl_equal ? `n1 - m1`) (proj1 ? ? Inv_mn0)) in
                   (exist_4 [A2: (array Z)][m2: Z][n2: Z][result3: unit]
                   ((m_invariant m2 A2) /\ (n_invariant n2 A2) /\
                   (permut A2 A) /\ `1 <= m2` /\ `n2 <= N`) /\ `m2 >= n2` 
                   A1 m1 n1 result2 Inv_mn0)
               | (right Test1) =>
                   let (A1, m1, n1, result2, Inv_mn0) =
                     (exist_4 [A1: (array Z)][m1: Z][n1: Z][result2: unit]
                     ((m_invariant m1 A1) /\ (n_invariant n1 A1) /\
                     (permut A1 A) /\ `1 <= m1` /\ `n1 <= N`) /\
                     `m1 >= n1` A0 m0 n0 tt (conj ? ? Inv_mn Test1)) in
                   (exist_4 [A2: (array Z)][m2: Z][n2: Z][result3: unit]
                   ((m_invariant m2 A2) /\ (n_invariant n2 A2) /\
                   (permut A2 A) /\ `1 <= m2` /\ `n2 <= N`) /\ `m2 >= n2` 
                   A1 m1 n1 result2 Inv_mn0) end) `result0 - result` 
             A result result0 (refl_equal ? `result0 - result`)
             (find_po_19 A Pre21 result Post16 result0 Post15)) in
         (exist_3 [A1: (array Z)][m1: Z][result2: unit](found A1) /\
         (permut A1 A) A0 m0 result1
         (find_po_20 A Pre21 result Post16 result0 Post15 A0 m0 n0 Inv_mn)) in
       (exist_2 [A1: (array Z)][result1: unit](found A1) /\ (permut A1 A) 
       A0 result0 Post20).

