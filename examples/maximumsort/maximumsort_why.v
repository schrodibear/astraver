(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.


(* ----------- PRELIMINAIRES ------------- *)
(* dÃ©finition et propriÃ©tÃ©s de    *)
Require Import Omega.
Require Import ZArithRing.

Ltac Omega' := abstract omega.

Set Implicit Arguments.
Unset Strict Implicit.

(* Induction pour vÃ©rifier qu'on est le maximum *)
Inductive Maximize (t:array Z) (n m:Z) : Z -> Prop :=
    Maxim_cons :
      forall k:Z,
        ((k <= n)%Z -> (access t k <= m)%Z) ->
        ((k < n)%Z -> Maximize t n m (k + 1)%Z) -> Maximize t n m k.

(* Signification  de ce prÃ©dicat: *)
Lemma Maximize_ext1 :
 forall (t:array Z) (n m k i:Z),
   Maximize t n m k -> (k <= i <= n)%Z -> (access t i <= m)%Z.
  Proof.
  intros t n m k i H1; elim H1; auto.
  intros k0 H2 H3 HR H4; case (Z_eq_dec k0 i).
   intros H; rewrite <- H; apply H2; Omega'.
   intros; apply HR; Omega'.
Qed.

Lemma Maximize_ext2 :
 forall (t:array Z) (n m k:Z),
   (forall i:Z, (k <= i <= n)%Z -> (access t i <= m)%Z) ->
   Maximize t n m k.
  Proof.
  intros t n m k.
     refine
      (well_founded_ind (Zwf_up_well_founded n)
         (fun k:Z =>
            (forall i:Z, (k <= i <= n)%Z -> (access t i <= m)%Z) ->
            Maximize t n m k) _ _).
     clear k; intros k HR H.
     constructor 1.
       intros; apply H; Omega'.
       intros; apply HR.
         unfold Zwf_up; Omega'.
         intros; apply H; Omega'.
Qed.

(* compatibilitÃ© de  avec  *)
Lemma Maximize_Zle :
 forall (t:array Z) (n m1 m2 k:Z),
   Maximize t n m1 k -> (k <= n)%Z -> (m1 <= m2)%Z -> Maximize t n m2 k.
  Proof.
  intros t n m1 m2 k H0; elim H0.
  intros k0 H1 H2 H3 H4 H5; constructor 1.
  Omega'.
 intros; apply H3; Omega'.
Qed.

Set Strict Implicit.
Unset Implicit Arguments.
(* ----------- FIN PRELIMINAIRES ----------- *)


(* DÃ©but: preuve de  *)
(* Why obligation from file "maximumsort.mlw", characters 206-210 *)
Lemma swap_po_1 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (Pre5: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (Pre4: 0 <= i /\ i < (array_length t)),
  forall (v: Z),
  forall (Post3: v = (access t i)),
  forall (Pre2: 0 <= i /\ i < (array_length t)),
  0 <= j /\ j < (array_length t).
Proof.
intuition ArraySubst t0.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 217-226 *)
Lemma swap_po_2 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (Pre5: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (Pre4: 0 <= i /\ i < (array_length t)),
  forall (v: Z),
  forall (Post3: v = (access t i)),
  forall (Pre2: 0 <= i /\ i < (array_length t)),
  forall (Pre3: 0 <= j /\ j < (array_length t)),
  forall (t0: (array Z)),
  forall (Post1: t0 = (store t i (access t j))),
  0 <= j /\ j < (array_length t0).
Proof.
intros; ArraySubst t0; intuition.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 187-233 *)
Lemma swap_po_3 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (Pre5: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (Pre4: 0 <= i /\ i < (array_length t)),
  forall (v: Z),
  forall (Post3: v = (access t i)),
  forall (Pre2: 0 <= i /\ i < (array_length t)),
  forall (Pre3: 0 <= j /\ j < (array_length t)),
  forall (t0: (array Z)),
  forall (Post1: t0 = (store t i (access t j))),
  forall (Pre1: 0 <= j /\ j < (array_length t0)),
  forall (t1: (array Z)),
  forall (Post2: t1 = (store t0 j v)),
  (exchange t1 t i j).
 Proof.
 intros; subst t1 t0 v; auto with datatypes.
Qed.

(* Fin: preuve de  *)


(* DÃ©but: preuve de  *)

(* Why obligation from file "maximumsort.mlw", characters 611-612 *)
Lemma maximum_po_1 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test4: k0 = 0),
  (0 <= i0 /\ i0 <= n0) /\ (Maximize t n0 (access t i0) 0).
  Proof.
  intros; split.
  Omega'.
  rewrite Test4 in Pre18; tauto.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 646-651 *)
Lemma maximum_po_2 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  0 <= nk /\ nk < (array_length t).
   Proof.
   intros; Omega'.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 652-656 *)
Lemma maximum_po_3 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  forall (Pre16: 0 <= nk /\ nk < (array_length t)),
  0 <= i0 /\ i0 < (array_length t).
  Proof.
  intros; Omega'.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 665-684 *)
Lemma maximum_po_4 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  forall (Pre16: 0 <= nk /\ nk < (array_length t)),
  forall (Pre17: 0 <= i0 /\ i0 < (array_length t)),
  forall (Test2: (access t nk) > (access t i0)),
  (0 <= nk /\ nk <= nk) /\ nk <= n0 /\ n0 < (array_length t) /\
  (Maximize t n0 (access t nk) nk).
Proof.
repeat (split; [ Omega' | auto ]).
subst nk.
ring (k0 - 1 + 1)%Z; intros;
 apply Maximize_Zle with (m1 := access t i0); Omega' || tauto.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 512-765 *)
Lemma maximum_po_5 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  forall (Pre16: 0 <= nk /\ nk < (array_length t)),
  forall (Pre17: 0 <= i0 /\ i0 < (array_length t)),
  forall (Test2: (access t nk) > (access t i0)),
  forall (Pre15: (0 <= nk /\ nk <= nk) /\ nk <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t nk) nk)),
  forall (Pre13: (0 <= nk /\ nk <= nk) /\ nk <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t nk) nk)),
  forall (Pre14: (0 <= nk /\ nk <= nk) /\ nk <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t nk) nk)),
  (Zwf 0 nk Variant1).
  Proof.
  intros; subst nk; unfold Zwf; Omega'.
  Qed.

(* Why obligation from file "maximumsort.mlw", characters 693-711 *)
Lemma maximum_po_6 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  forall (Pre16: 0 <= nk /\ nk < (array_length t)),
  forall (Pre17: 0 <= i0 /\ i0 < (array_length t)),
  forall (Test1: (access t nk) <= (access t i0)),
  (0 <= nk /\ nk <= i0) /\ i0 <= n0 /\ n0 < (array_length t) /\
  (Maximize t n0 (access t i0) nk).
  Proof.
  intros; subst nk.
  repeat (split; [ Omega' | auto ]); ring (k0 - 1 + 1)%Z; tauto.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 512-765 *)
Lemma maximum_po_7 : 
  forall (n: Z),
  forall (k: Z),
  forall (i: Z),
  forall (t: (array Z)),
  forall (Pre20: (0 <= k /\ k <= i) /\ i <= n /\ n < (array_length t) /\
                 (Maximize t n (access t i) k)),
  forall (Variant1: Z),
  forall (n0: Z),
  forall (k0: Z),
  forall (i0: Z),
  forall (Pre19: Variant1 = k0),
  forall (Pre18: (0 <= k0 /\ k0 <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) k0)),
  forall (Test3: k0 <> 0),
  forall (nk: Z),
  forall (Post3: nk = (k0 - 1)),
  forall (Pre16: 0 <= nk /\ nk < (array_length t)),
  forall (Pre17: 0 <= i0 /\ i0 < (array_length t)),
  forall (Test1: (access t nk) <= (access t i0)),
  forall (Pre11: (0 <= nk /\ nk <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) nk)),
  forall (Pre9: (0 <= nk /\ nk <= i0) /\ i0 <= n0 /\ n0 < (array_length t) /\
                (Maximize t n0 (access t i0) nk)),
  forall (Pre10: (0 <= nk /\ nk <= i0) /\ i0 <= n0 /\ n0 <
                 (array_length t) /\ (Maximize t n0 (access t i0) nk)),
  (Zwf 0 nk Variant1).
  Proof.
  intros; subst nk.
  unfold Zwf; Omega'.
  Qed.


(* fin preuve de maximum *)

(* Why obligation from file "maximumsort.mlw", characters 1140-1160 *)
Lemma maxisort_po_1 : 
  forall (t: (array Z)),
  forall (Pre10: 0 <= (array_length t)),
  forall (i: Z),
  forall (Post3: i = ((array_length t) - 1)),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre9: Variant1 = (i1 + 1)),
  forall (Pre8: (0 <= (i1 + 1) /\ (i1 + 1) <= (array_length t0)) /\
                (sorted_array t0 (i1 + 1) ((array_length t0) - 1)) /\
                (permut t0 t) /\
                (((i1 + 1) < (array_length t0) ->
                  (Maximize t0 i1 (access t0 (i1 + 1)) 0)))),
  forall (Test2: i1 >= 0),
  (0 <= i1 /\ i1 <= i1) /\ i1 <= i1 /\ i1 < (array_length t0) /\
  (Maximize t0 i1 (access t0 i1) i1).
  Proof.
  intros; split.
 Omega'.
 split.
 Omega'.
 split.
 Omega'.
  constructor 1.
 Omega'.
  intros H; absurd (i1 < i1)%Z; Omega'.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 1172-1185 *)
Lemma maxisort_po_2 : 
  forall (t: (array Z)),
  forall (Pre10: 0 <= (array_length t)),
  forall (i: Z),
  forall (Post3: i = ((array_length t) - 1)),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre9: Variant1 = (i1 + 1)),
  forall (Pre8: (0 <= (i1 + 1) /\ (i1 + 1) <= (array_length t0)) /\
                (sorted_array t0 (i1 + 1) ((array_length t0) - 1)) /\
                (permut t0 t) /\
                (((i1 + 1) < (array_length t0) ->
                  (Maximize t0 i1 (access t0 (i1 + 1)) 0)))),
  forall (Test2: i1 >= 0),
  forall (Pre7: (0 <= i1 /\ i1 <= i1) /\ i1 <= i1 /\ i1 <
                (array_length t0) /\ (Maximize t0 i1 (access t0 i1) i1)),
  forall (r: Z),
  forall (Post7: (0 <= r /\ r <= i1) /\ (Maximize t0 i1 (access t0 r) 0)),
  (0 <= i1 /\ i1 < (array_length t0)) /\ 0 <= r /\ r < (array_length t0).
  Proof.
  intros; Omega'.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 1132-1185 *)
Lemma maxisort_po_3 : 
  forall (t: (array Z)),
  forall (Pre10: 0 <= (array_length t)),
  forall (i: Z),
  forall (Post3: i = ((array_length t) - 1)),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre9: Variant1 = (i1 + 1)),
  forall (Pre8: (0 <= (i1 + 1) /\ (i1 + 1) <= (array_length t0)) /\
                (sorted_array t0 (i1 + 1) ((array_length t0) - 1)) /\
                (permut t0 t) /\
                (((i1 + 1) < (array_length t0) ->
                  (Maximize t0 i1 (access t0 (i1 + 1)) 0)))),
  forall (Test2: i1 >= 0),
  forall (Pre7: (0 <= i1 /\ i1 <= i1) /\ i1 <= i1 /\ i1 <
                (array_length t0) /\ (Maximize t0 i1 (access t0 i1) i1)),
  forall (r: Z),
  forall (Post7: (0 <= r /\ r <= i1) /\ (Maximize t0 i1 (access t0 r) 0)),
  forall (Pre6: (0 <= i1 /\ i1 < (array_length t0)) /\ 0 <= r /\ r <
                (array_length t0)),
  forall (t1: (array Z)),
  forall (Post9: (exchange t1 t0 i1 r)),
  (forall (i:Z),
   (i = (i1 - 1) -> ((0 <= (i + 1) /\ (i + 1) <= (array_length t1)) /\
    (sorted_array t1 (i + 1) ((array_length t1) - 1)) /\ (permut t1 t) /\
    (((i + 1) < (array_length t1) -> (Maximize t1 i (access t1 (i + 1)) 0)))) /\
    (Zwf 0 (i + 1) (i1 + 1)))).
 Proof.
 intros; decompose [and] Pre8; clear Pre8; split.
   ArrayLength.
   split.
   omega.
   split.
   (* post-condition 1 *)
   unfold sorted_array in H0; unfold sorted_array.
   intros C1 k C2 C3; case Post9.
    intros Clength C4 C5 C6 C7 C8.
     case (Z_eq_dec k i1).
       intros C9; rewrite C9; rewrite C6; rewrite C8; try Omega'.
       apply Maximize_ext1 with (n := i1) (k := 0%Z); try Omega'.
         apply H5; Omega'.
       intros C9; rewrite C8; try Omega'.
 rewrite C8; try Omega'.
       apply H0; try Omega'.
   (* post-condition 2 *)
   split.
 apply permut_trans with (t' := t0); auto.
   eapply exchange_is_permut; eauto.
   (* post-condition 3 *)
   decompose [and] Post7; clear Post7.
 case Post9; clear Post9.
   intros Clength C1 C2 C3 C4 C5 C5a; replace (i0 + 1)%Z with i1.
 rewrite C3.
     apply Maximize_ext2; intros i' C6.
     case (Z_eq_dec i' r).
       intros C7; rewrite C7; rewrite C4.
         apply Maximize_ext1 with (n := i1) (k := 0%Z); try Omega';
          auto.
       intros; rewrite C5; try Omega'.
         apply Maximize_ext1 with (n := i1) (k := 0%Z); try Omega';
          auto.
   omega.
   unfold Zwf; omega.
Qed.

(* Why obligation from file "maximumsort.mlw", characters 927-1102 *)
Lemma maxisort_po_4 : 
  forall (t: (array Z)),
  forall (Pre10: 0 <= (array_length t)),
  forall (i: Z),
  forall (Post3: i = ((array_length t) - 1)),
  (0 <= (i + 1) /\ (i + 1) <= (array_length t)) /\
  (sorted_array t (i + 1) ((array_length t) - 1)) /\ (permut t t) /\
  (((i + 1) < (array_length t) -> (Maximize t i (access t (i + 1)) 0))).
  Proof.
  intros; subst i; ring (array_length t - 1 + 1)%Z; split.
   Omega'.
  split.
 unfold sorted_array; intros H;
  absurd (array_length t <= array_length t - 1)%Z; [ Omega' | auto ].
  split.
 apply permut_refl.
  intros H; absurd (array_length t < array_length t)%Z;
   [ Omega' | auto ].
Qed.

(* Why obligation from file "maximumsort.mlw", characters 853-1210 *)
Lemma maxisort_po_5 : 
  forall (t: (array Z)),
  forall (Pre10: 0 <= (array_length t)),
  forall (i: Z),
  forall (Post3: i = ((array_length t) - 1)),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Post2: ((0 <= (i1 + 1) /\ (i1 + 1) <= (array_length t0)) /\
                 (sorted_array t0 (i1 + 1) ((array_length t0) - 1)) /\
                 (permut t0 t) /\
                 (((i1 + 1) < (array_length t0) ->
                   (Maximize t0 i1 (access t0 (i1 + 1)) 0)))) /\
                 i1 < 0),
  (sorted_array t0 0 ((array_length t0) - 1)) /\ (permut t0 t).
  Proof.
  intros; cut ((i1 + 1)%Z = 0%Z);
   [ intros H; rewrite H in Post2; split; tauto | Omega' ].
Qed.


