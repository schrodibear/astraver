(* This file is generated by Why; do not edit *)

Require Why.
Require Export partition_why.

Definition swap (* validation *)
  : (i: Z)(j: Z)(t: (array Z))(_: (`0 <= i` /\ `i < (array_length t)`) /\
    `0 <= j` /\ `j < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]((exchange t0 t i j)))
  := [i: Z; j: Z; t: (array Z); Pre5: (`0 <= i` /\ `i < (array_length t)`) /\
      `0 <= j` /\ `j < (array_length t)`]
       let Pre4 = (proj1 ? ? Pre5) in
       let (v, Post3) = (exist_1 [result: Z]
         result = (access t i) (access t i) (refl_equal ? (access t i))) in
       let (t0, result, Post4) =
         let Pre2 = Pre4 in
         let Pre3 = (swap_po_1 i j t Pre5 Pre4 v Post3 Pre2) in
         let (t0, result, Post1) = (exist_2 [t1: (array Z)][result1: unit]
           t1 = (store t i (access t j)) (store t i (access t j)) tt
           (refl_equal ? (store t i (access t j)))) in
         let Pre1 = (swap_po_2 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1) in
         let (t1, result0, Post2) = (exist_2 [t2: (array Z)][result2: unit]
           t2 = (store t0 j v) (store t0 j v) tt
           (refl_equal ? (store t0 j v))) in
         (exist_2 [t2: (array Z)][result1: unit](exchange t2 t i j) t1
         result0
         (swap_po_3 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1 Pre1 t1 Post2)) in
       (exist_2 [t1: (array Z)][result0: unit](exchange t1 t i j) t0 
       result Post4).

Definition partition (* validation *)
  : (l: Z)(r: Z)(t: (array Z))(_: (`0 <= l` /\ `l < r`) /\
    `r < (array_length t)`)
    (sig_2 (array Z) Z [t0: (array Z)][result: Z]((`l <= result` /\
     `result <= r`) /\ (partition_p t0 l r result) /\ (sub_permut l r t0 t)))
  := [l: Z; r: Z; t: (array Z); Pre32: (`0 <= l` /\ `l < r`) /\
      `r < (array_length t)`]
       let Pre31 = (partition_po_1 l r t Pre32) in
       let (pv, Post11) = (exist_1 [result: Z]
         result = (access t l) (access t l) (refl_equal ? (access t l))) in
       let (t0, result, Post16) =
         let (i, Post10) = (exist_1 [result: Z]result = `l + 1` `l + 1`
           (refl_equal ? `l + 1`)) in
         let (i1, t0, result, Post17) =
           let (j, Post9) = (exist_1 [result: Z]result = r r
             (refl_equal ? r)) in
           let (i1, j1, t0, result, Post18) =
             let (i1, j1, t0, result, Inv) =
               (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `
                 0`) [Variant1: Z](i1: Z)(j1: Z)(t0: (array Z))
                 (_: Variant1 = `(array_length t0) + 2 + j1 - i1`)
                 (Inv: (`l + 1 <= i1` /\ `i1 <= r`) /\ `j1 <= r` /\
                 (array_le t0 `l + 1` `i1 - 1` pv) /\
                 (array_ge t0 `j1 + 1` r pv) /\ (sub_permut l r t0 t) /\
                 `(access t0 l) = (access t l)`)
                 (sig_4 Z Z (array Z) unit [i2: Z][j2: Z][t1: (array Z)]
                  [result: unit](((`l + 1 <= i2` /\ `i2 <= r`) /\
                  `j2 <= r` /\ (array_le t1 `l + 1` `i2 - 1` pv) /\
                  (array_ge t1 `j2 + 1` r pv) /\ (sub_permut l r t1 t) /\
                  `(access t1 l) = (access t l)`) /\ `i2 >= j2`))
                 [Variant1: Z; wf1: (Variant2: Z)
                  (Pre1: (Zwf `0` Variant2 Variant1))(i1: Z)(j1: Z)
                  (t0: (array Z))
                  (_: Variant2 = `(array_length t0) + 2 + j1 - i1`)
                  (Inv: (`l + 1 <= i1` /\ `i1 <= r`) /\ `j1 <= r` /\
                  (array_le t0 `l + 1` `i1 - 1` pv) /\
                  (array_ge t0 `j1 + 1` r pv) /\ (sub_permut l r t0 t) /\
                  `(access t0 l) = (access t l)`)
                  (sig_4 Z Z (array Z) unit [i2: Z][j2: Z][t1: (array Z)]
                   [result: unit](((`l + 1 <= i2` /\ `i2 <= r`) /\
                   `j2 <= r` /\ (array_le t1 `l + 1` `i2 - 1` pv) /\
                   (array_ge t1 `j2 + 1` r pv) /\ (sub_permut l r t1 t) /\
                   `(access t1 l) = (access t l)`) /\ `i2 >= j2`));
                  i1: Z; j1: Z; t0: (array Z);
                  Pre19: Variant1 = `(array_length t0) + 2 + j1 - i1`;
                  Inv: (`l + 1 <= i1` /\ `i1 <= r`) /\ `j1 <= r` /\
                  (array_le t0 `l + 1` `i1 - 1` pv) /\
                  (array_ge t0 `j1 + 1` r pv) /\ (sub_permut l r t0 t) /\
                  `(access t0 l) = (access t l)`]
                   let (result, Bool6) =
                     let (result1, Post19) = (Z_lt_ge_bool i1 j1) in
                     (exist_1 [result2: bool]
                     (if result2 then `i1 < j1` else `i1 >= j1`) result1
                     Post19) in
                   Cases
                     (btest
                      [result:bool](if result then `i1 < j1` else `i1 >= j1`) result
                      Bool6) of
                   | (left Test12) =>
                       let (i2, j2, t1, result0, Inv0) =
                         let (i2, j2, t1, result0, Inv0) =
                           let (i2, result0, Invi) =
                             (well_founded_induction Z (Zwf ZERO)
                               (Zwf_well_founded `0`) [Variant3: Z](i2: Z)
                               (_: Variant3 = `r - i2`)(Invi: (`i1 <= i2` /\
                               `i2 <= r`) /\
                               (array_le t0 `l + 1` `i2 - 1` pv))
                               (sig_2 Z unit [i3: Z][result0: unit]
                                (((`i1 <= i3` /\ `i3 <= r`) /\
                                (array_le t0 `l + 1` `i3 - 1` pv)) /\
                                (`(access t0 i3) > pv` \/
                                `(access t0 i3) <= pv` /\ `i3 >= j1`)))
                               [Variant3: Z; wf2: (Variant4: Z)
                                (Pre2: (Zwf `0` Variant4 Variant3))(i2: Z)
                                (_: Variant4 = `r - i2`)(Invi: (`i1 <= i2` /\
                                `i2 <= r`) /\
                                (array_le t0 `l + 1` `i2 - 1` pv))
                                (sig_2 Z unit [i3: Z][result0: unit]
                                 (((`i1 <= i3` /\ `i3 <= r`) /\
                                 (array_le t0 `l + 1` `i3 - 1` pv)) /\
                                 (`(access t0 i3) > pv` \/
                                 `(access t0 i3) <= pv` /\ `i3 >= j1`)));
                                i2: Z; Pre8: Variant3 = `r - i2`;
                                Invi: (`i1 <= i2` /\ `i2 <= r`) /\
                                (array_le t0 `l + 1` `i2 - 1` pv)]
                                 let (result0, Post3) =
                                   let Pre7 =
                                     (partition_po_2 l r t Pre32 Pre31 pv
                                     Post11 i Post10 j Post9 Variant1 i1 j1
                                     t0 Pre19 Inv Test12 Variant3 i2 Pre8
                                     Invi) in
                                   let (result0, Bool1) =
                                     let Pre6 = Pre7 in
                                     let result1 =
                                       let Pre4 = Pre6 in
                                       let Pre3 = Pre4 in
                                       (Z_le_gt_bool (access t0 i2)) in
                                     let Pre5 = Pre6 in
                                     let (result2, Post20) = (result1 pv) in
                                     (exist_1 [result3: bool]
                                     (if result3 then `(access t0 i2) <= pv`
                                      else `(access t0 i2) > pv`) result2
                                     Post20) in
                                   Cases
                                     (btest
                                      [result0:bool]
                                      (if result0 then `(access t0 i2) <= pv`
                                       else `(access t0 i2) > pv`) result0
                                      Bool1) of
                                   | (left Test3) =>
                                       let (result1, Bool2) =
                                         let (result3, Post21) =
                                           (Z_lt_ge_bool i2 j1) in
                                         (exist_1 [result4: bool]
                                         (if result4 then `i2 < j1`
                                          else `i2 >= j1`) result3
                                         Post21) in
                                       (exist_1 [result2: bool]
                                       (if result2
                                        then `(access t0 i2) <= pv` /\
                                        `i2 < j1`
                                        else `(access t0 i2) > pv` \/
                                        `(access t0 i2) <= pv` /\ `i2 >= j1`) 
                                       result1
                                       (partition_po_3 l r t Pre32 Pre31 pv
                                       Post11 i Post10 j Post9 Variant1 i1 j1
                                       t0 Pre19 Inv Test12 Variant3 i2 Pre8
                                       Invi Pre7 Test3 result1 Bool2))
                                   | (right Test2) =>
                                       let (result1, Post2) =
                                         (exist_1 [result1: bool]
                                         result1 = false false
                                         (refl_equal ? false)) in
                                       (exist_1 [result2: bool]
                                       (if result2
                                        then `(access t0 i2) <= pv` /\
                                        `i2 < j1`
                                        else `(access t0 i2) > pv` \/
                                        `(access t0 i2) <= pv` /\ `i2 >= j1`) 
                                       result1
                                       (partition_po_4 l r t Pre32 Pre31 pv
                                       Post11 i Post10 j Post9 Variant1 i1 j1
                                       t0 Pre19 Inv Test12 Variant3 i2 Pre8
                                       Invi Pre7 Test2 result1 Post2)) end in
                                 Cases
                                   (btest
                                    [result0:bool]
                                    (if result0
                                     then `(access t0 i2) <= pv` /\ `
                                     i2 < j1` else `(access t0 i2) > pv` \/
                                     `(access t0 i2) <= pv` /\ `i2 >= j1`) result0
                                    Post3) of
                                 | (left Test5) =>
                                     let (i3, result1, Invi0) =
                                       let (i3, result1, Invi0) =
                                         let (i3, result1, Post1) =
                                           let (result1, Post1) =
                                             (exist_1 [result1: Z]
                                             result1 = `i2 + 1` `i2 + 1`
                                             (refl_equal ? `i2 + 1`)) in
                                           (exist_2 [i4: Z][result2: unit]
                                           i4 = `i2 + 1` result1 tt Post1) in
                                         (exist_2 [i4: Z][result2: unit]
                                         ((`i1 <= i4` /\ `i4 <= r`) /\
                                         (array_le t0 `l + 1` `i4 - 1` pv)) /\
                                         (Zwf `0` `r - i4` `r - i2`) 
                                         i3 result1
                                         (partition_po_5 l r t Pre32 Pre31 pv
                                         Post11 i Post10 j Post9 Variant1 i1
                                         j1 t0 Pre19 Inv Test12 Variant3 i2
                                         Pre8 Invi Test5 i3 Post1)) in
                                       ((wf2 `r - i3`)
                                         (loop_variant_1 Pre8 Invi0) 
                                         i3 (refl_equal ? `r - i3`)
                                         (proj1 ? ? Invi0)) in
                                     (exist_2 [i4: Z][result2: unit]
                                     ((`i1 <= i4` /\ `i4 <= r`) /\
                                     (array_le t0 `l + 1` `i4 - 1` pv)) /\
                                     (`(access t0 i4) > pv` \/
                                     `(access t0 i4) <= pv` /\ `i4 >= j1`) 
                                     i3 result1 Invi0)
                                 | (right Test4) =>
                                     let (i3, result1, Invi0) =
                                       (exist_2 [i3: Z][result1: unit]
                                       ((`i1 <= i3` /\ `i3 <= r`) /\
                                       (array_le t0 `l + 1` `i3 - 1` pv)) /\
                                       (`(access t0 i3) > pv` \/
                                       `(access t0 i3) <= pv` /\
                                       `i3 >= j1`) i2 tt
                                       (conj ? ? Invi Test4)) in
                                     (exist_2 [i4: Z][result2: unit]
                                     ((`i1 <= i4` /\ `i4 <= r`) /\
                                     (array_le t0 `l + 1` `i4 - 1` pv)) /\
                                     (`(access t0 i4) > pv` \/
                                     `(access t0 i4) <= pv` /\ `i4 >= j1`) 
                                     i3 result1 Invi0) end `r - i1` i1
                               (refl_equal ? `r - i1`)
                               (partition_po_6 l r t Pre32 Pre31 pv Post11 i
                               Post10 j Post9 Variant1 i1 j1 t0 Pre19 Inv
                               Test12)) in
                           let (j2, result1, Invj) =
                             (well_founded_induction Z (Zwf ZERO)
                               (Zwf_well_founded `0`) [Variant5: Z](j2: Z)
                               (_: Variant5 = j2)(Invj: (`l <= j2` /\
                               `j2 <= j1`) /\ (array_ge t0 `j2 + 1` r pv))
                               (sig_2 Z unit [j3: Z][result1: unit]
                                (((`l <= j3` /\ `j3 <= j1`) /\
                                (array_ge t0 `j3 + 1` r pv)) /\
                                (`(access t0 j3) < pv` \/
                                `(access t0 j3) >= pv` /\ `i2 >= j3`)))
                               [Variant5: Z; wf3: (Variant6: Z)
                                (Pre9: (Zwf `0` Variant6 Variant5))(j2: Z)
                                (_: Variant6 = j2)(Invj: (`l <= j2` /\
                                `j2 <= j1`) /\ (array_ge t0 `j2 + 1` r pv))
                                (sig_2 Z unit [j3: Z][result1: unit]
                                 (((`l <= j3` /\ `j3 <= j1`) /\
                                 (array_ge t0 `j3 + 1` r pv)) /\
                                 (`(access t0 j3) < pv` \/
                                 `(access t0 j3) >= pv` /\ `i2 >= j3`)));
                                j2: Z; Pre15: Variant5 = j2;
                                Invj: (`l <= j2` /\ `j2 <= j1`) /\
                                (array_ge t0 `j2 + 1` r pv)]
                                 let (result1, Post6) =
                                   let Pre14 =
                                     (partition_po_7 l r t Pre32 Pre31 pv
                                     Post11 i Post10 j Post9 Variant1 i1 j1
                                     t0 Pre19 Inv Test12 i2 Invi Variant5 j2
                                     Pre15 Invj) in
                                   let (result1, Bool3) =
                                     let Pre13 = Pre14 in
                                     let result2 =
                                       let Pre11 = Pre13 in
                                       let Pre10 = Pre11 in
                                       (Z_ge_lt_bool (access t0 j2)) in
                                     let Pre12 = Pre13 in
                                     let (result3, Post22) = (result2 pv) in
                                     (exist_1 [result4: bool]
                                     (if result4 then `(access t0 j2) >= pv`
                                      else `(access t0 j2) < pv`) result3
                                     Post22) in
                                   Cases
                                     (btest
                                      [result1:bool]
                                      (if result1 then `(access t0 j2) >= pv`
                                       else `(access t0 j2) < pv`) result1
                                      Bool3) of
                                   | (left Test7) =>
                                       let (result2, Bool4) =
                                         let (result4, Post23) =
                                           (Z_lt_ge_bool i2 j2) in
                                         (exist_1 [result5: bool]
                                         (if result5 then `i2 < j2`
                                          else `i2 >= j2`) result4
                                         Post23) in
                                       (exist_1 [result3: bool]
                                       (if result3
                                        then `(access t0 j2) >= pv` /\
                                        `i2 < j2`
                                        else `(access t0 j2) < pv` \/
                                        `(access t0 j2) >= pv` /\ `i2 >= j2`) 
                                       result2
                                       (partition_po_8 l r t Pre32 Pre31 pv
                                       Post11 i Post10 j Post9 Variant1 i1 j1
                                       t0 Pre19 Inv Test12 i2 Invi Variant5
                                       j2 Pre15 Invj Pre14 Test7 result2
                                       Bool4))
                                   | (right Test6) =>
                                       let (result2, Post5) =
                                         (exist_1 [result2: bool]
                                         result2 = false false
                                         (refl_equal ? false)) in
                                       (exist_1 [result3: bool]
                                       (if result3
                                        then `(access t0 j2) >= pv` /\
                                        `i2 < j2`
                                        else `(access t0 j2) < pv` \/
                                        `(access t0 j2) >= pv` /\ `i2 >= j2`) 
                                       result2
                                       (partition_po_9 l r t Pre32 Pre31 pv
                                       Post11 i Post10 j Post9 Variant1 i1 j1
                                       t0 Pre19 Inv Test12 i2 Invi Variant5
                                       j2 Pre15 Invj Pre14 Test6 result2
                                       Post5)) end in
                                 Cases
                                   (btest
                                    [result1:bool]
                                    (if result1
                                     then `(access t0 j2) >= pv` /\ `
                                     i2 < j2` else `(access t0 j2) < pv` \/
                                     `(access t0 j2) >= pv` /\ `i2 >= j2`) result1
                                    Post6) of
                                 | (left Test9) =>
                                     let (j3, result2, Invj0) =
                                       let (j3, result2, Invj0) =
                                         let (j3, result2, Post4) =
                                           let (result2, Post4) =
                                             (exist_1 [result2: Z]
                                             result2 = `j2 - 1` `j2 - 1`
                                             (refl_equal ? `j2 - 1`)) in
                                           (exist_2 [j4: Z][result3: unit]
                                           j4 = `j2 - 1` result2 tt Post4) in
                                         (exist_2 [j4: Z][result3: unit]
                                         ((`l <= j4` /\ `j4 <= j1`) /\
                                         (array_ge t0 `j4 + 1` r pv)) /\
                                         (Zwf `0` j4 j2) j3 result2
                                         (partition_po_10 l r t Pre32 Pre31
                                         pv Post11 i Post10 j Post9 Variant1
                                         i1 j1 t0 Pre19 Inv Test12 i2 Invi
                                         Variant5 j2 Pre15 Invj Test9 j3
                                         Post4)) in
                                       ((wf3 j3) (loop_variant_1 Pre15 Invj0)
                                         j3 (refl_equal ? j3)
                                         (proj1 ? ? Invj0)) in
                                     (exist_2 [j4: Z][result3: unit]
                                     ((`l <= j4` /\ `j4 <= j1`) /\
                                     (array_ge t0 `j4 + 1` r pv)) /\
                                     (`(access t0 j4) < pv` \/
                                     `(access t0 j4) >= pv` /\ `i2 >= j4`) 
                                     j3 result2 Invj0)
                                 | (right Test8) =>
                                     let (j3, result2, Invj0) =
                                       (exist_2 [j3: Z][result2: unit]
                                       ((`l <= j3` /\ `j3 <= j1`) /\
                                       (array_ge t0 `j3 + 1` r pv)) /\
                                       (`(access t0 j3) < pv` \/
                                       `(access t0 j3) >= pv` /\
                                       `i2 >= j3`) j2 tt
                                       (conj ? ? Invj Test8)) in
                                     (exist_2 [j4: Z][result3: unit]
                                     ((`l <= j4` /\ `j4 <= j1`) /\
                                     (array_ge t0 `j4 + 1` r pv)) /\
                                     (`(access t0 j4) < pv` \/
                                     `(access t0 j4) >= pv` /\ `i2 >= j4`) 
                                     j3 result2 Invj0) end j1 j1
                               (refl_equal ? j1)
                               (partition_po_11 l r t Pre32 Pre31 pv Post11 i
                               Post10 j Post9 Variant1 i1 j1 t0 Pre19 Inv
                               Test12 i2 Invi)) in
                           let (i3, j3, t1, result2, Inv0) =
                             let (result2, Bool5) =
                               let (result4, Post24) =
                                 (Z_lt_ge_bool i2 j2) in
                               (exist_1 [result5: bool]
                               (if result5 then `i2 < j2` else `i2 >= j2`) 
                               result4 Post24) in
                             Cases
                               (btest
                                [result2:bool]
                                (if result2 then `i2 < j2` else `i2 >= j2`) result2
                                Bool5) of
                             | (left Test11) =>
                                 let (i3, j3, t1, result3, Inv0) =
                                   let Pre18 =
                                     (partition_po_12 l r t Pre32 Pre31 pv
                                     Post11 i Post10 j Post9 Variant1 i1 j1
                                     t0 Pre19 Inv Test12 i2 Invi j2 Invj
                                     Test11) in
                                   let (t1, result3, Post25) =
                                     let Pre16 = Pre18 in
                                     let Pre17 = Pre16 in
                                     let (t1, result5, Post26) =
                                       (swap i2 j2 t0 Pre16) in
                                     (exist_2 [t2: (array Z)][result6: unit]
                                     (exchange t2 t0 i2 j2) t1 result5
                                     Post26) in
                                   let (i3, result4, Post7) =
                                     let (result4, Post7) =
                                       (exist_1 [result4: Z]
                                       result4 = `i2 + 1` `i2 + 1`
                                       (refl_equal ? `i2 + 1`)) in
                                     (exist_2 [i4: Z][result5: unit]
                                     i4 = `i2 + 1` result4 tt Post7) in
                                   let (j3, result5, Post8) =
                                     let (result5, Post8) =
                                       (exist_1 [result5: Z]
                                       result5 = `j2 - 1` `j2 - 1`
                                       (refl_equal ? `j2 - 1`)) in
                                     (exist_2 [j4: Z][result6: unit]
                                     j4 = `j2 - 1` result5 tt Post8) in
                                   (exist_4 [i4: Z][j4: Z][t2: (array Z)]
                                   [result6: unit]((`l + 1 <= i4` /\
                                   `i4 <= r`) /\ `j4 <= r` /\
                                   (array_le t2 `l + 1` `i4 - 1` pv) /\
                                   (array_ge t2 `j4 + 1` r pv) /\
                                   (sub_permut l r t2 t) /\
                                   `(access t2 l) = (access t l)`) /\
                                   (Zwf `0` `(array_length t2) + 2 + j4 - i4` `
                                   (array_length t0) + 2 + j1 - i1`) 
                                   i3 j3 t1 result5
                                   (partition_po_13 l r t Pre32 Pre31 pv
                                   Post11 i Post10 j Post9 Variant1 i1 j1 t0
                                   Pre19 Inv Test12 i2 Invi j2 Invj Test11
                                   Pre18 t1 Post25 i3 Post7 j3 Post8)) in
                                 (exist_4 [i4: Z][j4: Z][t2: (array Z)]
                                 [result4: unit]((`l + 1 <= i4` /\
                                 `i4 <= r`) /\ `j4 <= r` /\
                                 (array_le t2 `l + 1` `i4 - 1` pv) /\
                                 (array_ge t2 `j4 + 1` r pv) /\
                                 (sub_permut l r t2 t) /\
                                 `(access t2 l) = (access t l)`) /\
                                 (Zwf `0` `(array_length t2) + 2 + j4 - i4` `
                                 (array_length t0) + 2 + j1 - i1`) i3 
                                 j3 t1 result3 Inv0)
                             | (right Test10) =>
                                 let (result3, Inv0) =
                                   (exist_1 [result3: unit]((`l + 1 <= i2` /\
                                   `i2 <= r`) /\ `j2 <= r` /\
                                   (array_le t0 `l + 1` `i2 - 1` pv) /\
                                   (array_ge t0 `j2 + 1` r pv) /\
                                   (sub_permut l r t0 t) /\
                                   `(access t0 l) = (access t l)`) /\
                                   (Zwf `0` `(array_length t0) + 2 + j2 - i2` `
                                   (array_length t0) + 2 + j1 - i1`) 
                                   tt
                                   (partition_po_14 l r t Pre32 Pre31 pv
                                   Post11 i Post10 j Post9 Variant1 i1 j1 t0
                                   Pre19 Inv Test12 i2 Invi j2 Invj Test10)) in
                                 (exist_4 [i3: Z][j3: Z][t1: (array Z)]
                                 [result4: unit]((`l + 1 <= i3` /\
                                 `i3 <= r`) /\ `j3 <= r` /\
                                 (array_le t1 `l + 1` `i3 - 1` pv) /\
                                 (array_ge t1 `j3 + 1` r pv) /\
                                 (sub_permut l r t1 t) /\
                                 `(access t1 l) = (access t l)`) /\
                                 (Zwf `0` `(array_length t1) + 2 + j3 - i3` `
                                 (array_length t0) + 2 + j1 - i1`) i2 
                                 j2 t0 result3 Inv0) end in
                           (exist_4 [i4: Z][j4: Z][t2: (array Z)]
                           [result3: unit]((`l + 1 <= i4` /\ `i4 <= r`) /\
                           `j4 <= r` /\ (array_le t2 `l + 1` `i4 - 1` pv) /\
                           (array_ge t2 `j4 + 1` r pv) /\
                           (sub_permut l r t2 t) /\
                           `(access t2 l) = (access t l)`) /\
                           (Zwf `0` `(array_length t2) + 2 + j4 - i4` `
                           (array_length t0) + 2 + j1 - i1`) i3 j3 t1 
                           result2 Inv0) in
                         ((wf1 `(array_length t1) + 2 + j2 - i2`)
                           (loop_variant_1 Pre19 Inv0) i2 j2 t1
                           (refl_equal ? `(array_length t1) + 2 + j2 - i2`)
                           (proj1 ? ? Inv0)) in
                       (exist_4 [i3: Z][j3: Z][t2: (array Z)][result1: unit]
                       ((`l + 1 <= i3` /\ `i3 <= r`) /\ `j3 <= r` /\
                       (array_le t2 `l + 1` `i3 - 1` pv) /\
                       (array_ge t2 `j3 + 1` r pv) /\
                       (sub_permut l r t2 t) /\
                       `(access t2 l) = (access t l)`) /\ `i3 >= j3` 
                       i2 j2 t1 result0 Inv0)
                   | (right Test1) =>
                       let (i2, j2, t1, result0, Inv0) = (exist_4 [i2: Z]
                         [j2: Z][t1: (array Z)][result0: unit]
                         ((`l + 1 <= i2` /\ `i2 <= r`) /\ `j2 <= r` /\
                         (array_le t1 `l + 1` `i2 - 1` pv) /\
                         (array_ge t1 `j2 + 1` r pv) /\
                         (sub_permut l r t1 t) /\
                         `(access t1 l) = (access t l)`) /\ `i2 >= j2` 
                         i1 j1 t0 tt (conj ? ? Inv Test1)) in
                       (exist_4 [i3: Z][j3: Z][t2: (array Z)][result1: unit]
                       ((`l + 1 <= i3` /\ `i3 <= r`) /\ `j3 <= r` /\
                       (array_le t2 `l + 1` `i3 - 1` pv) /\
                       (array_ge t2 `j3 + 1` r pv) /\
                       (sub_permut l r t2 t) /\
                       `(access t2 l) = (access t l)`) /\ `i3 >= j3` 
                       i2 j2 t1 result0 Inv0) end
                 `(array_length t) + 2 + j - i` i j t
                 (refl_equal ? `(array_length t) + 2 + j - i`)
                 (partition_po_15 l r t Pre32 Pre31 pv Post11 i Post10 j
                 Post9)) in
             let (t1, result0, Post27) =
               let Pre30 =
                 (partition_po_16 l r t Pre32 Pre31 pv Post11 i Post10 j
                 Post9 i1 j1 t0 Inv) in
               let (result0, Bool7) =
                 let Pre23 = Pre30 in
                 let result1 =
                   let Pre21 = Pre23 in
                   let Pre20 = Pre21 in
                   (Z_lt_ge_bool (access t0 i1)) in
                 let Pre22 = Pre23 in
                 let (result2, Post28) = (result1 pv) in
                 (exist_1 [result3: bool]
                 (if result3 then `(access t0 i1) < pv`
                  else `(access t0 i1) >= pv`) result2
                 Post28) in
               Cases
                 (btest
                  [result0:bool]
                  (if result0 then `(access t0 i1) < pv`
                   else `(access t0 i1) >= pv`) result0
                  Bool7) of
               | (left Test14) =>
                   let (t1, result1, Post33) =
                     let Pre29 =
                       (partition_po_17 l r t Pre32 Pre31 pv Post11 i Post10
                       j Post9 i1 j1 t0 Inv Pre30 Test14) in
                     let (t1, result1, Post34) =
                       let Pre27 = Pre29 in
                       let Pre28 = Pre27 in
                       let (t1, result3, Post35) = (swap l i1 t0 Pre27) in
                       (exist_2 [t2: (array Z)][result4: unit]
                       (exchange t2 t0 l i1) t1 result3 Post35) in
                     let (result2, Post36) = (exist_1 [result2: Z]
                       (`l <= result2` /\ `result2 <= r`) /\
                       (partition_p t1 l r result2) /\
                       (sub_permut l r t1 t) i1
                       (partition_po_18 l r t Pre32 Pre31 pv Post11 i Post10
                       j Post9 i1 j1 t0 Inv Pre30 Test14 Pre29 t1 Post34)) in
                     (exist_2 [t2: (array Z)][result3: Z](`l <= result3` /\
                     `result3 <= r`) /\ (partition_p t2 l r result3) /\
                     (sub_permut l r t2 t) t1 result2 Post36) in
                   (exist_2 [t2: (array Z)][result2: Z](`l <= result2` /\
                   `result2 <= r`) /\ (partition_p t2 l r result2) /\
                   (sub_permut l r t2 t) t1 result1 Post33)
               | (right Test13) =>
                   let (t1, result1, Post29) =
                     let Pre26 =
                       (partition_po_19 l r t Pre32 Pre31 pv Post11 i Post10
                       j Post9 i1 j1 t0 Inv Pre30 Test13) in
                     let (t1, result1, Post30) =
                       let Pre24 = Pre26 in
                       let Pre25 = Pre24 in
                       let (t1, result3, Post31) =
                         (swap l `i1 - 1` t0 Pre24) in
                       (exist_2 [t2: (array Z)][result4: unit]
                       (exchange t2 t0 l `i1 - 1`) t1 result3 Post31) in
                     let (result2, Post32) = (exist_1 [result2: Z]
                       (`l <= result2` /\ `result2 <= r`) /\
                       (partition_p t1 l r result2) /\
                       (sub_permut l r t1 t) `i1 - 1`
                       (partition_po_20 l r t Pre32 Pre31 pv Post11 i Post10
                       j Post9 i1 j1 t0 Inv Pre30 Test13 Pre26 t1 Post30)) in
                     (exist_2 [t2: (array Z)][result3: Z](`l <= result3` /\
                     `result3 <= r`) /\ (partition_p t2 l r result3) /\
                     (sub_permut l r t2 t) t1 result2 Post32) in
                   (exist_2 [t2: (array Z)][result2: Z](`l <= result2` /\
                   `result2 <= r`) /\ (partition_p t2 l r result2) /\
                   (sub_permut l r t2 t) t1 result1 Post29) end in
             (exist_4 [i2: Z][j2: Z][t2: (array Z)][result1: Z]
             (`l <= result1` /\ `result1 <= r`) /\
             (partition_p t2 l r result1) /\ (sub_permut l r t2 t) i1 
             j1 t1 result0 Post27) in
           (exist_3 [i2: Z][t1: (array Z)][result0: Z](`l <= result0` /\
           `result0 <= r`) /\ (partition_p t1 l r result0) /\
           (sub_permut l r t1 t) i1 t0 result Post18) in
         (exist_2 [t1: (array Z)][result0: Z](`l <= result0` /\
         `result0 <= r`) /\ (partition_p t1 l r result0) /\
         (sub_permut l r t1 t) t0 result Post17) in
       (exist_2 [t1: (array Z)][result0: Z](`l <= result0` /\
       `result0 <= r`) /\ (partition_p t1 l r result0) /\
       (sub_permut l r t1 t) t0 result Post16).

