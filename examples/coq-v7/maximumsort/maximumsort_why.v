(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.


(* ----------- PRELIMINAIRES ------------- *)
(* dÃ©finition et propriÃ©tÃ©s de "Maximize"   *)
Require Omega.
Require ZArithRing.

Tactic Definition Omega' := Abstract Omega.

Implicit Arguments On.

(* Induction pour vÃ©rifier qu'on est le maximum *)
Inductive Maximize[t:(array Z); n,m:Z] : Z -> Prop :=
  Maxim_cons : (k:Z)
     (`k <= n` -> (Zle #t[k] m)) ->
     (`k < n` -> (Maximize t n m `k+1`)) -> (Maximize t n m `k`).

(* Signification "extensionnelle" de ce prÃ©dicat: *)
Lemma Maximize_ext1 : (t:(array Z))(n,m,k,i:Z)
  (Maximize t n m k) -> `k <= i <= n` -> `(access t i) <= m`.
Proof.
  Intros t n m k i H1; Elim H1; Auto.
  Intros k0 H2 H3 HR H4; Case (Z_eq_dec k0 i).
   Intros H; Rewrite <- H; Apply H2; Omega'.
   Intros; Apply HR; Omega'.
Qed.

Lemma Maximize_ext2 : (t:(array Z))(n,m,k:Z)
   ((i:Z)`k <= i <= n` -> `(access t i) <= m`) -> (Maximize t n m k).
Proof.
  Intros t n m k.
     Refine (well_founded_ind ? (Zwf_up n) ?
       [k:Z]((i:Z)`k <= i <= n`->`(access t i) <= m`)->(Maximize t n m k) ? ?).
     Apply Zwf_up_well_founded.
     Clear k; Intros k HR H.
     Constructor 1.
       Intros; Apply H; Omega'.
       Intros; Apply HR.
         Unfold Zwf_up; Omega'.
         Intros; Apply H; Omega'.
Qed.

(* compatibilitÃ© de "Zle" avec "Maximize" *)
Lemma Maximize_Zle: (t:(array Z))(n,m1,m2,k:Z)
  (Maximize t n m1 k) -> `k <= n` -> (Zle m1 m2) -> (Maximize t n m2 k).
Proof.
  Intros t n m1 m2 k H0; Elim H0.
  Intros k0 H1 H2 H3 H4 H5; Constructor 1.
  Omega'. Intros; Apply H3; Omega'.
Qed.

Implicit Arguments Off.
(* ----------- FIN PRELIMINAIRES ----------- *)


(* DÃ©but: preuve de "swap" *)
(* Why obligation from file "maximumsort.mlw", characters 206-210 *)
Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  `0 <= j` /\ `j < (array_length t)`.
Proof.
Intuition ArraySubst t0.
Save.

(* Why obligation from file "maximumsort.mlw", characters 217-226 *)
Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  `0 <= j` /\ `j < (array_length t0)`.
Proof.
Intros; ArraySubst t0; Intuition.
Save.

(* Why obligation from file "maximumsort.mlw", characters 187-233 *)
Lemma swap_po_3 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  (Pre1: `0 <= j` /\ `j < (array_length t0)`)
  (t1: (array Z))
  (Post2: t1 = (store t0 j v))
  (exchange t1 t i j).
Proof.
 Intros; Subst t1 t0 v;
 Auto with datatypes.
Save.

(* Fin: preuve de "swap" *)


(* DÃ©but: preuve de "maximum" *)

(* Why obligation from file "maximumsort.mlw", characters 602-603 *)
Lemma maximum_po_1 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test4: `k0 = 0`)
  (`0 <= i0` /\ `i0 <= n0`) /\ (Maximize t n0 (access t i0) `0`).
Proof.
  Intros; Split.
  Omega'.
  Rewrite Test4 in Pre18; Tauto.
Save.

(* Why obligation from file "maximumsort.mlw", characters 637-642 *)
Lemma maximum_po_2 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  `0 <= nk` /\ `nk < (array_length t)`.
Proof.
   Intros; Omega'.
Save.

(* Why obligation from file "maximumsort.mlw", characters 643-647 *)
Lemma maximum_po_3 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  (Pre16: `0 <= nk` /\ `nk < (array_length t)`)
  `0 <= i0` /\ `i0 < (array_length t)`.
Proof.
  Intros; Omega'.
Save.

(* Why obligation from file "maximumsort.mlw", characters 656-675 *)
Lemma maximum_po_4 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  (Pre16: `0 <= nk` /\ `nk < (array_length t)`)
  (Pre17: `0 <= i0` /\ `i0 < (array_length t)`)
  (Test2: `(access t nk) > (access t i0)`)
  (`0 <= nk` /\ `nk <= nk`) /\ `nk <= n0` /\ `n0 < (array_length t)` /\
  (Maximize t n0 (access t nk) nk).
Proof.
Repeat (Split; [Omega' | Auto]).
Subst nk.
Ring `k0-1+1`; Intros;
 Apply Maximize_Zle with m1:=(access t i0); Omega' Orelse Tauto.
Save.

(* Why obligation from file "maximumsort.mlw", characters 503-756 *)
Lemma maximum_po_5 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  (Pre16: `0 <= nk` /\ `nk < (array_length t)`)
  (Pre17: `0 <= i0` /\ `i0 < (array_length t)`)
  (Test2: `(access t nk) > (access t i0)`)
  (Pre15: (`0 <= nk` /\ `nk <= nk`) /\ `nk <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t nk) nk))
  (Pre13: (`0 <= nk` /\ `nk <= nk`) /\ `nk <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t nk) nk))
  (Pre14: (`0 <= nk` /\ `nk <= nk`) /\ `nk <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t nk) nk))
  (Zwf `0` nk Variant1).
Proof.
  Intros; Subst nk;
  Unfold Zwf; Omega'.  
Save.

(* Why obligation from file "maximumsort.mlw", characters 684-702 *)
Lemma maximum_po_6 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  (Pre16: `0 <= nk` /\ `nk < (array_length t)`)
  (Pre17: `0 <= i0` /\ `i0 < (array_length t)`)
  (Test1: `(access t nk) <= (access t i0)`)
  (`0 <= nk` /\ `nk <= i0`) /\ `i0 <= n0` /\ `n0 < (array_length t)` /\
  (Maximize t n0 (access t i0) nk).
Proof.
  Intros; Subst nk.
  Repeat (Split; [Omega' | Auto]); Ring `k0-1+1`; Tauto.
Save.

(* Why obligation from file "maximumsort.mlw", characters 503-756 *)
Lemma maximum_po_7 : 
  (n: Z)
  (k: Z)
  (i: Z)
  (t: (array Z))
  (Pre20: (`0 <= k` /\ `k <= i`) /\ `i <= n` /\ `n < (array_length t)` /\
          (Maximize t n (access t i) k))
  (Variant1: Z)
  (n0: Z)
  (k0: Z)
  (i0: Z)
  (Pre19: Variant1 = k0)
  (Pre18: (`0 <= k0` /\ `k0 <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) k0))
  (Test3: `k0 <> 0`)
  (nk: Z)
  (Post3: nk = `k0 - 1`)
  (Pre16: `0 <= nk` /\ `nk < (array_length t)`)
  (Pre17: `0 <= i0` /\ `i0 < (array_length t)`)
  (Test1: `(access t nk) <= (access t i0)`)
  (Pre11: (`0 <= nk` /\ `nk <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) nk))
  (Pre9: (`0 <= nk` /\ `nk <= i0`) /\ `i0 <= n0` /\
         `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) nk))
  (Pre10: (`0 <= nk` /\ `nk <= i0`) /\ `i0 <= n0` /\
          `n0 < (array_length t)` /\ (Maximize t n0 (access t i0) nk))
  (Zwf `0` nk Variant1).
Proof.
  Intros; Subst nk.
  Unfold Zwf; Omega'.  
Save.


(* fin preuve de maximum *)

(* Why obligation from file "maximumsort.mlw", characters 1131-1151 *)
Lemma maxisort_po_1 : 
  (t: (array Z))
  (Pre10: `0 <= (array_length t)`)
  (i: Z)
  (Post3: i = `(array_length t) - 1`)
  (Variant1: Z)
  (i1: Z)
  (t0: (array Z))
  (Pre9: Variant1 = `i1 + 1`)
  (Pre8: (`0 <= i1 + 1` /\ `i1 + 1 <= (array_length t0)`) /\
         (sorted_array t0 `i1 + 1` `(array_length t0) - 1`) /\
         (permut t0 t) /\
         ((`i1 + 1 < (array_length t0)` ->
           (Maximize t0 i1 (access t0 `i1 + 1`) `0`))))
  (Test2: `i1 >= 0`)
  (`0 <= i1` /\ `i1 <= i1`) /\ `i1 <= i1` /\ `i1 < (array_length t0)` /\
  (Maximize t0 i1 (access t0 i1) i1).
Proof.
  Intros; Split. Omega'. Split. Omega'. Split. Omega'.
  Constructor 1. Omega'.
  Intros H; Absurd `i1 < i1`; Omega'.
Save.

(* Why obligation from file "maximumsort.mlw", characters 1163-1176 *)
Lemma maxisort_po_2 : 
  (t: (array Z))
  (Pre10: `0 <= (array_length t)`)
  (i: Z)
  (Post3: i = `(array_length t) - 1`)
  (Variant1: Z)
  (i1: Z)
  (t0: (array Z))
  (Pre9: Variant1 = `i1 + 1`)
  (Pre8: (`0 <= i1 + 1` /\ `i1 + 1 <= (array_length t0)`) /\
         (sorted_array t0 `i1 + 1` `(array_length t0) - 1`) /\
         (permut t0 t) /\
         ((`i1 + 1 < (array_length t0)` ->
           (Maximize t0 i1 (access t0 `i1 + 1`) `0`))))
  (Test2: `i1 >= 0`)
  (Pre7: (`0 <= i1` /\ `i1 <= i1`) /\ `i1 <= i1` /\
         `i1 < (array_length t0)` /\ (Maximize t0 i1 (access t0 i1) i1))
  (r: Z)
  (Post7: (`0 <= r` /\ `r <= i1`) /\ (Maximize t0 i1 (access t0 r) `0`))
  (`0 <= i1` /\ `i1 < (array_length t0)`) /\ `0 <= r` /\
  `r < (array_length t0)`.
Proof.
  Intros;  Omega'.
Save.

(* Why obligation from file "maximumsort.mlw", characters 1123-1176 *)
Lemma maxisort_po_3 : 
  (t: (array Z))
  (Pre10: `0 <= (array_length t)`)
  (i: Z)
  (Post3: i = `(array_length t) - 1`)
  (Variant1: Z)
  (i1: Z)
  (t0: (array Z))
  (Pre9: Variant1 = `i1 + 1`)
  (Pre8: (`0 <= i1 + 1` /\ `i1 + 1 <= (array_length t0)`) /\
         (sorted_array t0 `i1 + 1` `(array_length t0) - 1`) /\
         (permut t0 t) /\
         ((`i1 + 1 < (array_length t0)` ->
           (Maximize t0 i1 (access t0 `i1 + 1`) `0`))))
  (Test2: `i1 >= 0`)
  (Pre7: (`0 <= i1` /\ `i1 <= i1`) /\ `i1 <= i1` /\
         `i1 < (array_length t0)` /\ (Maximize t0 i1 (access t0 i1) i1))
  (r: Z)
  (Post7: (`0 <= r` /\ `r <= i1`) /\ (Maximize t0 i1 (access t0 r) `0`))
  (Pre6: (`0 <= i1` /\ `i1 < (array_length t0)`) /\ `0 <= r` /\
         `r < (array_length t0)`)
  (t1: (array Z))
  (Post9: (exchange t1 t0 i1 r))
  ((i:Z)
   (i = `i1 - 1` -> ((`0 <= i + 1` /\ `i + 1 <= (array_length t1)`) /\
    (sorted_array t1 `i + 1` `(array_length t1) - 1`) /\ (permut t1 t) /\
    ((`i + 1 < (array_length t1)` -> (Maximize t1 i (access t1 `i + 1`) `0`)))) /\
    (Zwf `0` `i + 1` `i1 + 1`))).
Proof.
 Intros; Decompose [and] Pre8; Clear Pre8; Split.
   ArrayLength.
   Split.
   Omega.
   Split.
   (* post-condition 1 *)
   Unfold sorted_array in H0;  Unfold sorted_array.
   Intros C1 k C2 C3;
   Case Post9.
    Intros Clength C4 C5 C6 C7 C8.
     Case (Z_eq_dec k i1).
       Intros C9; Rewrite C9; Rewrite C6; Rewrite C8; Try Omega'.
       Apply Maximize_ext1 with n:=i1 k:=`0`; Try Omega'.
         Apply H5; Omega'.
       Intros C9; Rewrite C8; Try Omega'. Rewrite C8; Try Omega'.
       Apply H0; Try Omega'.
   (* post-condition 2 *)
   Split. Apply permut_trans with t':=t0; Auto.
   EApply exchange_is_permut; EAuto.
   (* post-condition 3 *)
   Decompose [and] Post7; Clear Post7. Case Post9; Clear Post9.
   Intros Clength C1 C2 C3 C4 C5 C5a; Replace `i0+1` with i1. Rewrite C3.
     Apply Maximize_ext2; Intros i' C6.
     Case (Z_eq_dec i' r).
       Intros C7; Rewrite C7; Rewrite C4.
         Apply Maximize_ext1 with n:=i1 k:=`0`; Try Omega'; Auto.
       Intros; Rewrite C5; Try Omega'.
         Apply Maximize_ext1 with n:=i1 k:=`0`; Try Omega'; Auto.
   Omega.
   Unfold Zwf; Omega.
Save.

(* Why obligation from file "maximumsort.mlw", characters 918-1093 *)
Lemma maxisort_po_4 : 
  (t: (array Z))
  (Pre10: `0 <= (array_length t)`)
  (i: Z)
  (Post3: i = `(array_length t) - 1`)
  (`0 <= i + 1` /\ `i + 1 <= (array_length t)`) /\
  (sorted_array t `i + 1` `(array_length t) - 1`) /\ (permut t t) /\
  ((`i + 1 < (array_length t)` -> (Maximize t i (access t `i + 1`) `0`))).
Proof.
  Intros;  Subst i; Ring `(array_length t)-1+1`; Split.   Omega'.
  Split. Unfold sorted_array; Intros H; 
  Absurd `(array_length t) <= (array_length t)-1`; [Omega' | Auto].
  Split. Apply permut_refl.
  Intros H; Absurd `(array_length t) < (array_length t)`; [Omega' | Auto].
Save.

(* Why obligation from file "maximumsort.mlw", characters 844-1201 *)
Lemma maxisort_po_5 : 
  (t: (array Z))
  (Pre10: `0 <= (array_length t)`)
  (i: Z)
  (Post3: i = `(array_length t) - 1`)
  (i1: Z)
  (t0: (array Z))
  (Post2: ((`0 <= i1 + 1` /\ `i1 + 1 <= (array_length t0)`) /\
          (sorted_array t0 `i1 + 1` `(array_length t0) - 1`) /\
          (permut t0 t) /\
          ((`i1 + 1 < (array_length t0)` ->
            (Maximize t0 i1 (access t0 `i1 + 1`) `0`)))) /\
          `i1 < 0`)
  (sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t).
Proof.
  Intros; Cut `i1+1=0`; [Intros H; Rewrite H in Post2; Split; Tauto | Omega'].
Save.


