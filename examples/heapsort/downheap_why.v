(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.
Require Export heap.
Require Export Inftree.

Lemma R11 : (k:Z) `2*k+1+1` = `2*k+2`.
Proof.
Intro; Omega.
Save.

(* To annotate the recursive function downheap, it is convenient to
 * introduce the following predicate, which expresses that j is the
 * greatest son of k. *)

Implicit Arguments On.

Inductive select_son [t:(array Z); k,n,j:Z] : Prop :=
    select_left_son : 
      `j = 2*k+1` -> (`2*k+2 <= n` -> (Zge #t[j] #t[`2*k+2`])) 
        -> (select_son t k n j)
  | select_right_son :
      `j = 2*k+2` -> `j <= n` -> (Zge #t[j] #t[`2*k+1`]) 
        -> (select_son t k n j).

Implicit Arguments Off.

(* The correctness of downheap requires the two following lemmas *)

Lemma Lemma_1 : (t0,t1,t2:(array Z))
    (n0,k0,j':Z)
    `2*k0+1 <= n0`
 -> (select_son t0 k0 n0 j')
 -> `(access   t0 k0) < (access   t0 j')`
 -> (exchange t1 t0 k0 j')
 -> `0 <= k0 <= n0`
 -> `n0 < (array_length t0)`
 -> ((i:Z)`k0+1 <= i <= n0`->(heap t0 n0 i))
 -> ((i:Z)`j' <= i <= n0`->(heap t2 n0 i))
 -> ((i:Z)
        `0 <= i < j'`\/`j' < i < 2*j'+1`\/`n0 < i < (array_length t0)`
        ->`(access   t2 i) = (access   t1 i)`)
 -> ((v:Z)(inftree t1 n0 v j')->(inftree t2 n0 v j'))
 -> (i:Z)`k0 < i < j'`->(heap t2 n0 i).
Proof.
Intros. Apply heap_cons.
Elim H0; Omega'.
(* branch 2i+1 *)
Intro. Rewrite (H7 i). Rewrite (H7 `2*i+1`).
Decompose [exchange] H2. Rewrite (H16 i). Rewrite (H16 `2*i+1`).
Generalize H10. Elim (H5 i); Intros. Exact (H18 H24).
Omega'. Omega'. Omega'.
Elim H0; Omega'. Omega'. Omega'. Omega'.
Elim H0; Omega'. Elim H0; Omega'. 
Intro. Apply H6; Elim H0; Omega'.
(* branch 2i+2 *)
Intro. Rewrite (H7 i). Rewrite (H7 `2*i+2`).
Decompose [exchange] H2. Rewrite (H16 i). Rewrite (H16 `2*i+2`).
Generalize H10. Elim (H5 i); Intros. Exact (H21 H24).
Omega'. Omega'. Omega'. 
Elim H0; Omega'. Omega'. Omega'. Omega'.
Elim H0; Omega'. Elim H0; Omega'. 
Intro. Apply H6; Elim H0; Omega'.
Save.

Lemma Lemma_2 : (t0,t1,t2:(array Z))
    (n0,k0,j':Z)
    `2*k0+1 <= n0`
 -> (select_son t0 k0 n0 j')
 -> `(access   t0 k0) < (access   t0 j')`
 -> (exchange t1 t0 k0 j')
 -> `0 <= k0 <= n0`
 -> `n0 < (array_length t0)`
 -> ((i:Z)`k0+1 <= i <= n0`->(heap t0 n0 i))
 -> ((i:Z)`j' <= i <= n0`->(heap t2 n0 i))
 -> ((i:Z)
        `0 <= i < j'`\/`j' < i < 2*j'+1`\/`n0 < i < (array_length t0)`
        ->`(access   t2 i) = (access   t1 i)`)
 -> ((v:Z)(inftree t1 n0 v j')->(inftree t2 n0 v j'))
 -> (i:Z)`k0 <= i <= n0`->(heap t2 n0 i).
Proof.
Intros.
Elim (Z_lt_ge_dec i j'); Intro HHi.
Elim (Z_le_lt_eq_dec k0 i); [ Intro HHHi | Intro HHHi | Intuition ].

(* 1. k0 < i < j' *)
Apply (Lemma_1 t0 t1 t2 n0 k0 j'); Assumption Orelse Omega'.

(* 2. k0 = i *)
Apply heap_cons.
Omega'.
(* branch 2i+1 *)
(* t[k] >= t[2k+1] *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Rewrite <- HHHi. Rewrite <- H11.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H16.
  Apply Zle_ge. Apply inftree_1 with n:=n0.
  Apply H8.
  Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
  Apply inftree_3.
  Apply H5; Omega'. Assumption. Omega'. Omega'. Omega'.
  (* j' = 2k+2 *)
  Rewrite <- HHHi.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H17.
  Rewrite (H7 `2*k0+1`). Rewrite (H19 `2*k0+1`).
  Omega'. Omega'. Omega'. Omega'. Omega'. Omega'. 
(* (heap t2 n (2k+1)) *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Apply H6; Omega'.
  (* j' = 2k+2 *)
  Apply (Lemma_1 t0 t1 t2 n0 k0 j'); Assumption Orelse Omega'.
(* branch 2i+2 *)
(* t[k] >= t[2k+2] *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Rewrite <- HHHi.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H16.
  Rewrite (H7 `2*k0+2`). Rewrite (H18 `2*k0+2`).
  Omega'. Omega'. Omega'. Omega'. Omega'. Omega'. 
  (* j' = 2k+2 *)
  Rewrite <- HHHi. Rewrite <- H11.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H17.
  Apply Zle_ge. Apply inftree_1 with n:=n0.
  Apply H8.
  Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
  Apply inftree_3.
  Apply H5; Omega'. Assumption. Omega'. Omega'. Omega'.
(* (heap t2 n (2k+2)) *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Apply H6; Omega'.
  (* j' = 2k+2 *)
  Apply H6; Omega'.

(* 3. i >= j' *)
Apply H6; Omega'.
Save.


(* Obligations *)

(* Why obligation from file "downheap.mlw", characters 838-842 *)
Lemma downheap_po_1 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (Test5: `j + 1 <= n0`)
  `0 <= j` /\ `j < (array_length t0)`.
Proof.
Intros; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 845-851 *)
Lemma downheap_po_2 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (Test5: `j + 1 <= n0`)
  (Pre8: `0 <= j` /\ `j < (array_length t0)`)
  `0 <= j + 1` /\ `j + 1 < (array_length t0)`.
Proof.
Intros; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 857-860 *)
Lemma downheap_po_3 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (Test5: `j + 1 <= n0`)
  (Pre8: `0 <= j` /\ `j < (array_length t0)`)
  (Pre9: `0 <= j + 1` /\ `j + 1 < (array_length t0)`)
  (Test4: `(access t0 j) < (access t0 j + 1)`)
  (select_son t0 k0 n0 `j + 1`).
Proof.
Intros.
Subst j; Rewrite (R11 k0).
Apply select_right_son; 
  [ Reflexivity | Omega' | Rewrite (R11 k0) in Test4; Omega' ].
Save.

(* Why obligation from file "downheap.mlw", characters 866-867 *)
Lemma downheap_po_4 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (Test5: `j + 1 <= n0`)
  (Pre8: `0 <= j` /\ `j < (array_length t0)`)
  (Pre9: `0 <= j + 1` /\ `j + 1 < (array_length t0)`)
  (Test3: `(access t0 j) >= (access t0 j + 1)`)
  (select_son t0 k0 n0 j).
Proof.
Intros.
Subst j.
Apply select_left_son; 
  [ Reflexivity | Rewrite (R11 k0) in Test3; Intro; Assumption ].
Save.

(* Why obligation from file "downheap.mlw", characters 873-874 *)
Lemma downheap_po_5 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (Test2: `j + 1 > n0`)
  (select_son t0 k0 n0 j).
Proof.
Intros.
Subst j.
Apply select_left_son; [ Reflexivity | Intro; Absurd `2*k+2 <= n`; Omega' ].
Save.

(* Why obligation from file "downheap.mlw", characters 939-943 *)
Lemma downheap_po_6 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  `0 <= k0` /\ `k0 < (array_length t0)`.
Proof.
Intros; Elim Post12; Intros; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 946-951 *)
Lemma downheap_po_7 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  `0 <= j'` /\ `j' < (array_length t0)`.
Proof.
Intros; Elim Post12; Intros; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 978-995 *)
Lemma downheap_po_8 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  (Pre24: `0 <= j'` /\ `j' < (array_length t0)`)
  (Test7: `(access t0 k0) < (access t0 j')`)
  (Pre22: (`0 <= k0` /\ `k0 < (array_length t0)`) /\ `0 <= j'` /\
          `j' < (array_length t0)`)
  (t1: (array Z))
  (Post23: (exchange t1 t0 k0 j'))
  (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
  ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))).
Proof.
Intuition; Try (Elim Post12; SameLength t1 t0; Omega').
Apply heap_id with t := t0.
Apply H7; Elim Post12; Omega'.
Unfold array_id. Intros i' Hi'.
Elim Post23; Intros.
Symmetry; Apply (H22 i'); Elim Post12; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 665-1228 *)
Lemma downheap_po_9 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  (Pre24: `0 <= j'` /\ `j' < (array_length t0)`)
  (Test7: `(access t0 k0) < (access t0 j')`)
  (Pre22: (`0 <= k0` /\ `k0 < (array_length t0)`) /\ `0 <= j'` /\
          `j' < (array_length t0)`)
  (t1: (array Z))
  (Post23: (exchange t1 t0 k0 j'))
  (Pre21: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (Pre19: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (Pre20: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (Zwf `0` `n0 - j'` Variant1).
Proof.
Intros; Unfold Zwf; Decompose [select_son] Post12; Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 671-759 *)
Lemma downheap_po_10 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  (Pre24: `0 <= j'` /\ `j' < (array_length t0)`)
  (Test7: `(access t0 k0) < (access t0 j')`)
  (Pre22: (`0 <= k0` /\ `k0 < (array_length t0)`) /\ `0 <= j'` /\
          `j' < (array_length t0)`)
  (t1: (array Z))
  (Post23: (exchange t1 t0 k0 j'))
  (Pre21: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (Pre19: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (Pre20: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
  ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))).
Proof.
Trivial.
Save.

(* Why obligation from file "downheap.mlw", characters 957-999 *)
Lemma downheap_po_11 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  (Pre24: `0 <= j'` /\ `j' < (array_length t0)`)
  (Test7: `(access t0 k0) < (access t0 j')`)
  (Pre22: (`0 <= k0` /\ `k0 < (array_length t0)`) /\ `0 <= j'` /\
          `j' < (array_length t0)`)
  (t1: (array Z))
  (Post23: (exchange t1 t0 k0 j'))
  (Pre21: (`0 <= j'` /\ `j' <= n0`) /\ `n0 < (array_length t1)` /\
          ((i:Z) (`j' + 1 <= i` /\ `i <= n0` -> (heap t1 n0 i))))
  (t2: (array Z))
  (Post25: (permut t2 t1) /\
           ((i:Z) (`j' <= i` /\ `i <= n0` -> (heap t2 n0 i))) /\
           ((i:Z)
            (`0 <= i` /\ `i < j'` \/ `j' < i` /\ `i < 2 * j' + 1` \/
             `n0 < i` /\ `i < (array_length t2)` ->
             `(access t2 i) = (access t1 i)`)) /\
           ((v:Z) ((inftree t1 n0 v j') -> (inftree t2 n0 v j'))))
  (permut t2 t0) /\ ((i:Z) (`k0 <= i` /\ `i <= n0` -> (heap t2 n0 i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k0` \/ `k0 < i` /\ `i < 2 * k0 + 1` \/ `n0 < i` /\
    `i < (array_length t2)` -> `(access t2 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n0 v k0) -> (inftree t2 n0 v k0))).
Proof.
Intuition.
(* permut *)
Apply permut_trans with t' := t1.
Intuition. Apply exchange_is_permut with i:=k0 j:=j'; Assumption.
(* heap *)
Apply (Lemma_2 t0 t1 t2 n0 k0 j'); Assumption Orelse Try Omega'.
SameLength t2 t1. SameLength t1 t0.
Rewrite <- H26; Rewrite <- H22; Assumption.
(* unchanged parts of the array *)
Rewrite (H20 i);
[ Decompose [exchange] Post23; Apply H30 | Idtac ];
Decompose [select_son] Post12; Omega'.
Rewrite (H20 i); 
[ Decompose [exchange] Post23; Apply H30 | Idtac ];
Decompose [select_son] Post12; Omega'.
Rewrite (H20 i); 
[ Decompose [exchange] Post23; Apply H30 | Idtac ];
Decompose [select_son] Post12; SameLength t2 t1; Omega'.
(* inftree *)
Apply inftree_cons.
Split; Assumption.
Rewrite (H20 k0). 
Decompose [exchange] Post23. Rewrite H27. 
Elim Post12; Intros.
  (* j' = 2k+1 *)
  Rewrite H30. Generalize Test8; Rewrite Post3. Case H22; Intros.
  Apply inftree_1 with n:=n0. Auto.
  (* j' = 2k+2 *)
  Generalize H31. Rewrite H30. Case H22; Intros.
  Apply inftree_1 with n:=n0. Auto.
Elim Post12; Intros; Omega'.
  (* branch 2k+1 *)
  Intro. Elim Post12; Intros.
    (* j' = 2k+1 *)
    Rewrite <- H25. Apply H23. 
    Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
    Rewrite H25. Generalize H24. Case H22; Auto.
    Assumption. Omega'. Omega'.
    (* j' = 2k+2 *)
    Apply inftree_trans with v:=#t2[`2*k0+1`].
    Rewrite (H20 `2*k0+1`).
    Decompose [exchange] Post23. Rewrite (H33 `2*k0+1`).
    Generalize H24. Case H22; Intros.
    Apply inftree_1 with n:=n0. Auto.
    Omega'. Omega'. Omega'. Omega'.
    Apply inftree_3.
    Apply (Lemma_2 t0 t1 t2 n0 k0 j'); Assumption Orelse Try Omega'.
    SameLength t2 t1. SameLength t1 t0.
    Rewrite <- H29; Rewrite <- H28; Assumption.

  (* branch 2k+2 *)
  Intro. Elim Post12; Intros.
    (* j' = 2k+1 *)
    Apply inftree_trans with v:=#t2[`2*k0+2`].
    Rewrite (H20 `2*k0+2`).
    Decompose [exchange] Post23. Rewrite (H32 `2*k0+2`).
    Generalize H24. Case H22; Intros.
    Apply inftree_1 with n:=n0. Auto.
    Omega'. Omega'. Omega'. Omega'.
    Apply inftree_3.
    Apply H21; Omega'.
    (* j' = 2k+2 *)
    Rewrite <- H25. Apply H23. 
    Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
    Rewrite H25. Generalize H24. Case H22; Auto.
    Assumption. Omega'. Omega'.
Save.

(* Why obligation from file "downheap.mlw", characters 999-999 *)
Lemma downheap_po_12 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test8: `j <= n0`)
  (j': Z)
  (Post12: (select_son t0 k0 n0 j'))
  (Pre23: `0 <= k0` /\ `k0 < (array_length t0)`)
  (Pre24: `0 <= j'` /\ `j' < (array_length t0)`)
  (Test6: `(access t0 k0) >= (access t0 j')`)
  (permut t0 t0) /\ ((i:Z) (`k0 <= i` /\ `i <= n0` -> (heap t0 n0 i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k0` \/ `k0 < i` /\ `i < 2 * k0 + 1` \/ `n0 < i` /\
    `i < (array_length t0)` -> `(access t0 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n0 v k0) -> (inftree t0 n0 v k0))).
Proof.
Intuition.
Elim (Z_le_lt_eq_dec k0 i); [ Intro HHHi | Intro HHHi | Intuition ].
(* k0 < i *)
Apply H7; Omega'.
(* k0 = i *)
Rewrite <- HHHi. Apply heap_cons.
Omega'.
Intro. Elim Post12; Intros.
Rewrite <- H14. Assumption. Omega'.
Intro. Apply H7; Omega'.
Intro. Elim Post12; Intros.
Omega'. Rewrite <- H14. Assumption.
Intro. Apply H7; Omega'.
Save.


(* Why obligation from file "downheap.mlw", characters 999-999 *)
Lemma downheap_po_13 : 
  (k: Z)
  (n: Z)
  (t: (array Z))
  (Pre27: (`0 <= k` /\ `k <= n`) /\ `n < (array_length t)` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (Variant1: Z)
  (k0: Z)
  (n0: Z)
  (t0: (array Z))
  (Pre26: Variant1 = `n0 - k0`)
  (Pre25: (`0 <= k0` /\ `k0 <= n0`) /\ `n0 < (array_length t0)` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= n0` -> (heap t0 n0 i))))
  (j: Z)
  (Post3: j = `2 * k0 + 1`)
  (Test1: `j > n0`)
  (permut t0 t0) /\ ((i:Z) (`k0 <= i` /\ `i <= n0` -> (heap t0 n0 i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k0` \/ `k0 < i` /\ `i < 2 * k0 + 1` \/ `n0 < i` /\
    `i < (array_length t0)` -> `(access t0 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n0 v k0) -> (inftree t0 n0 v k0))).
Proof.
Intuition.
Elim (Z_le_lt_eq_dec k0 i); [ Intro HHHi | Intro HHHi | Intuition ].
Apply H7; Omega'.
Rewrite <- HHHi. Apply heap_cons.
Omega'.
Intro; Absurd `2*k0+1 > n0`; Omega'.
Intro; Absurd `2*k0+1 > n0`; Omega'.
Intro; Absurd `2*k0+2 > n0`; Omega'.
Intro; Absurd `2*k0+2 > n0`; Omega'.
Save.

Require swap_why.




