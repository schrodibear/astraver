(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.
Require Heap.
Require Inftree.

Lemma R11 : (k:Z) `2*k+1+1` = `2*k+2`.
Proof.
Intro; Omega.
Save.

(* To annotate the recursive function downheap, it is convenient to
 * introduce the following predicate, which expresses that j is the
 * greatest son of k. *)

Implicit Arguments On.

Inductive select_son [N:Z; t:(array N Z); k,n,j:Z] : Prop :=
    select_left_son : 
      `j = 2*k+1` -> (`2*k+2 <= n` -> (Zge #t[j] #t[`2*k+2`])) 
        -> (select_son t k n j)
  | select_right_son :
      `j = 2*k+2` -> `j <= n` -> (Zge #t[j] #t[`2*k+1`]) 
        -> (select_son t k n j).

Implicit Arguments Off.

(* The correctness of downheap requires the two following lemmas *)

Lemma Lemma_1 : (N:Z)(t0,t1,t2:(array N Z))
    (n0,k0,j':Z)
    `2*k0+1 <= n0`
 -> (select_son t0 k0 n0 j')
 -> `(access   t0 k0) < (access   t0 j')`
 -> (exchange t1 t0 k0 j')
 -> `0 <= k0 <= n0`
 -> `n0 < N`
 -> ((i:Z)`k0+1 <= i <= n0`->(heap t0 n0 i))
 -> ((i:Z)`j' <= i <= n0`->(heap t2 n0 i))
 -> ((i:Z)
        `0 <= i < j'`\/`j' < i < 2*j'+1`\/`n0 < i < N`
        ->`(access   t2 i) = (access   t1 i)`)
 -> ((v:Z)(inftree t1 n0 v j')->(inftree t2 n0 v j'))
 -> (i:Z)`k0 < i < j'`->(heap t2 n0 i).
Proof.
Intros. Apply heap_cons.
Elim H0; Omega'.
(* branch 2i+1 *)
Intro. Rewrite (H7 i). Rewrite (H7 `2*i+1`).
Decompose [exchange] H2. Rewrite (H15 i). Rewrite (H15 `2*i+1`).
Generalize H10. Elim (H5 i); Intros. Exact (H17 H23).
Omega'. Omega'. Omega'.
Elim H0; Omega'. Omega'. Omega'. Omega'.
Elim H0; Omega'. Elim H0; Omega'. 
Intro. Apply H6; Elim H0; Omega'.
(* branch 2i+2 *)
Intro. Rewrite (H7 i). Rewrite (H7 `2*i+2`).
Decompose [exchange] H2. Rewrite (H15 i). Rewrite (H15 `2*i+2`).
Generalize H10. Elim (H5 i); Intros. Exact (H20 H23).
Omega'. Omega'. Omega'. 
Elim H0; Omega'. Omega'. Omega'. Omega'.
Elim H0; Omega'. Elim H0; Omega'. 
Intro. Apply H6; Elim H0; Omega'.
Save.

Lemma Lemma_2 : (N:Z)(t0,t1,t2:(array N Z))
    (n0,k0,j':Z)
    `2*k0+1 <= n0`
 -> (select_son t0 k0 n0 j')
 -> `(access   t0 k0) < (access   t0 j')`
 -> (exchange t1 t0 k0 j')
 -> `0 <= k0 <= n0`
 -> `n0 < N`
 -> ((i:Z)`k0+1 <= i <= n0`->(heap t0 n0 i))
 -> ((i:Z)`j' <= i <= n0`->(heap t2 n0 i))
 -> ((i:Z)
        `0 <= i < j'`\/`j' < i < 2*j'+1`\/`n0 < i < N`
        ->`(access   t2 i) = (access   t1 i)`)
 -> ((v:Z)(inftree t1 n0 v j')->(inftree t2 n0 v j'))
 -> (i:Z)`k0 <= i <= n0`->(heap t2 n0 i).
Proof.
Intros.
Elim (Z_lt_ge_dec i j'); Intro HHi.
Elim (Z_le_lt_eq_dec k0 i); [ Intro HHHi | Intro HHHi | Intuition ].

(* 1. k0 < i < j' *)
Apply (Lemma_1 N t0 t1 t2 n0 k0 j'); Assumption Orelse Omega'.

(* 2. k0 = i *)
Apply heap_cons.
Omega'.
(* branch 2i+1 *)
(* t[k] >= t[2k+1] *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Rewrite <- HHHi. Rewrite <- H11.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H15.
  Apply Zle_ge. Apply inftree_1 with n:=n0.
  Apply H8.
  Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
  Apply inftree_3.
  Apply H5; Omega'. Assumption. Omega'. Omega'. Omega'.
  (* j' = 2k+2 *)
  Rewrite <- HHHi.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H16.
  Rewrite (H7 `2*k0+1`). Rewrite (H18 `2*k0+1`).
  Omega'. Omega'. Omega'. Omega'. Omega'. Omega'. 
(* (heap t2 n (2k+1)) *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Apply H6; Omega'.
  (* j' = 2k+2 *)
  Apply (Lemma_1 N t0 t1 t2 n0 k0 j'); Assumption Orelse Omega'.
(* branch 2i+2 *)
(* t[k] >= t[2k+2] *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Rewrite <- HHHi.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H15.
  Rewrite (H7 `2*k0+2`). Rewrite (H17 `2*k0+2`).
  Omega'. Omega'. Omega'. Omega'. Omega'. Omega'. 
  (* j' = 2k+2 *)
  Rewrite <- HHHi. Rewrite <- H11.
  Rewrite (H7 k0). Decompose [exchange] H2. Rewrite H16.
  Apply Zle_ge. Apply inftree_1 with n:=n0.
  Apply H8.
  Apply inftree_2 with t1:=t0 k:=k0. Omega'. 
  Apply inftree_3.
  Apply H5; Omega'. Assumption. Omega'. Omega'. Omega'.
(* (heap t2 n (2k+2)) *)
Intro. Elim H0; Intros.
  (* j' = 2k+1 *)
  Apply H6; Omega'.
  (* j' = 2k+2 *)
  Apply H6; Omega'.

(* 3. i >= j' *)
Apply H6; Omega'.
Save.


(* Obligations *)

Lemma downheap_po_1 : 
  (N: Z)
  (k: Z)
  (n: Z)
  (t: (array N Z))
  (Pre11: `0 <= k` /\ `k <= n` /\ `n < N` /\
          ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i))))
  (well_founded ? (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma downheap_po_2 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (Test5: `j + 1 <= n`)
  `0 <= j + 1` /\ `j + 1 < N`.
Proof.
Intros; Omega'.
Save.

Lemma downheap_po_3 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (Test5: `j + 1 <= n`)
  (Pre2: `0 <= j + 1` /\ `j + 1 < N`)
  `0 <= j` /\ `j < N`.
Proof.
Intros; Omega'.
Save.

Lemma downheap_po_4 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (Test5: `j + 1 <= n`)
  (Test4: `(access t0 j) < (access t0 j + 1)`)
  (select_son t0 k n `j + 1`).
Proof.
Intros.
Rewrite Post1; Rewrite (R11 k).
Rewrite Post1 in Test4.
Apply select_right_son; 
  [ Reflexivity | Omega' | Rewrite (R11 k) in Test4; Omega' ].
Save.

Lemma downheap_po_5 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (Test5: `j + 1 <= n`)
  (Test3: `(access t0 j) >= (access t0 j + 1)`)
  (select_son t0 k n j).
Proof.
Intros.
Rewrite Post1; Rewrite Post1 in Test3.
Apply select_left_son; 
  [ Reflexivity | Rewrite (R11 k) in Test3; Intro; Assumption ].
Save.

Lemma downheap_po_6 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (Test2: `j + 1 > n`)
  (select_son t0 k n j).
Proof.
Intros.
Rewrite Post1.
Apply select_left_son; [ Reflexivity | Intro; Absurd `2*k+2 <= n`; Omega' ].
Save.

Lemma downheap_po_7 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  `0 <= j'` /\ `j' < N`.
Proof.
Intros; Elim Post10; Intros; Omega'.
Save.

Lemma downheap_po_8 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Pre4: `0 <= j'` /\ `j' < N`)
  `0 <= k` /\ `k < N`.
Proof.
Intros; Omega'.
Save.

Lemma downheap_po_9 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test7: `(access t0 k) < (access t0 j')`)
  `0 <= k` /\ `k < N` /\ (`0 <= j'` /\ `j' < N`).
Proof.
Intros; Elim Post10; Intros; Omega'.
Save.

Lemma downheap_po_10 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test7: `(access t0 k) < (access t0 j')`)
  (t1: (array N Z))
  (Post21: (exchange t1 t0 k j'))
  `0 <= j'` /\ `j' <= n` /\ `n < N` /\
  ((i:Z) (`j' + 1 <= i` /\ `i <= n` -> (heap t1 n i))).
Proof.
Intuition; Try (Elim Post10; Omega').
Apply heap_id with t := t0.
Apply H3; Elim Post10; Omega'.
Unfold array_id. Intros i' Hi'.
Elim Post21; Intros.
Symmetry; Apply (H9 i'); Elim Post10; Omega'.
Save.

Lemma downheap_po_11 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test7: `(access t0 k) < (access t0 j')`)
  (t1: (array N Z))
  (Post21: (exchange t1 t0 k j'))
  (Pre8: `0 <= j'` /\ `j' <= n` /\ `n < N` /\
         ((i:Z) (`j' + 1 <= i` /\ `i <= n` -> (heap t1 n i))))
  (Zwf `0` `n - j'` Variant1).
Proof.
Intros; Unfold Zwf; Decompose [select_son] Post10; Omega'.
Save.

Lemma downheap_po_12 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test7: `(access t0 k) < (access t0 j')`)
  (t1: (array N Z))
  (Post21: (exchange t1 t0 k j'))
  (Pre8: `0 <= j'` /\ `j' <= n` /\ `n < N` /\
         ((i:Z) (`j' + 1 <= i` /\ `i <= n` -> (heap t1 n i))))
  `0 <= j'` /\ `j' <= n` /\ `n < N` /\
  ((i:Z) (`j' + 1 <= i` /\ `i <= n` -> (heap t1 n i))).
Proof.
Intuition.
Save.

Lemma downheap_po_13 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test7: `(access t0 k) < (access t0 j')`)
  (t1: (array N Z))
  (Post21: (exchange t1 t0 k j'))
  (t2: (array N Z))
  (Post23: (permut t2 t1) /\
           ((i:Z) (`j' <= i` /\ `i <= n` -> (heap t2 n i))) /\
           ((i:Z)
            (`0 <= i` /\ `i < j'` \/ `j' < i` /\ `i < 2 * j' + 1` \/
             `n < i` /\ `i < N` -> `(access t2 i) = (access t1 i)`)) /\
           ((v:Z) ((inftree t1 n v j') -> (inftree t2 n v j'))))
  (permut t2 t0) /\ ((i:Z) (`k <= i` /\ `i <= n` -> (heap t2 n i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
    `i < N` -> `(access t2 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n v k) -> (inftree t2 n v k))).
Proof.
Intuition.

(* permut *)
Apply permut_trans with t' := t1.
Intuition. Apply exchange_is_permut with i:=k j:=j'; Assumption.
(* heap *)
Apply (Lemma_2 N t0 t1 t2 n k j'); Assumption Orelse Omega'.
(* unchanged parts of the array *)
Rewrite (H4 i); 
[ Decompose [exchange] Post21; Apply H13 | Idtac ];
Decompose [select_son] Post10; Omega'.
Rewrite (H4 i); 
[ Decompose [exchange] Post21; Apply H13 | Idtac ];
Decompose [select_son] Post10; Omega'.
Rewrite (H4 i); 
[ Decompose [exchange] Post21; Apply H13 | Idtac ];
Decompose [select_son] Post10; Omega'.
(* inftree *)
Apply inftree_cons.
Split; Assumption.
Rewrite (H4 k). 
Decompose [exchange] Post21. Rewrite H10. 
Elim Post10; Intros.
  (* j' = 2k+1 *)
  Rewrite H13. Generalize Test8; Rewrite Post1. Case H6; Intros.
  Apply inftree_1 with n:=n. Auto.
  (* j' = 2k+2 *)
  Generalize H14. Rewrite H13. Case H6; Intros.
  Apply inftree_1 with n:=n. Auto.
Elim Post10; Intros; Omega'.
  (* branch 2k+1 *)
  Intro. Elim Post10; Intros.
    (* j' = 2k+1 *)
    Rewrite <- H9. Apply H7. 
    Apply inftree_2 with t1:=t0 k:=k. Omega'. 
    Rewrite H9. Generalize H8. Case H6; Auto.
    Assumption. Omega'. Omega'.
    (* j' = 2k+2 *)
    Apply inftree_trans with v:=#t2[`2*k+1`].
    Rewrite (H4 `2*k+1`).
    Decompose [exchange] Post21. Rewrite (H16 `2*k+1`).
    Generalize H8. Case H6; Intros.
    Apply inftree_1 with n:=n. Auto.
    Omega'. Omega'. Omega'. Omega'.
    Apply inftree_3.
    Apply (Lemma_2 N t0 t1 t2 n k j'); Assumption Orelse Omega'.
  (* branch 2k+2 *)
  Intro. Elim Post10; Intros.
    (* j' = 2k+1 *)
    Apply inftree_trans with v:=#t2[`2*k+2`].
    Rewrite (H4 `2*k+2`).
    Decompose [exchange] Post21. Rewrite (H15 `2*k+2`).
    Generalize H8. Case H6; Intros.
    Apply inftree_1 with n:=n. Auto.
    Omega'. Omega'. Omega'. Omega'.
    Apply inftree_3.
    Apply H5; Omega'.
    (* j' = 2k+2 *)
    Rewrite <- H9. Apply H7. 
    Apply inftree_2 with t1:=t0 k:=k. Omega'. 
    Rewrite H9. Generalize H8. Case H6; Auto.
    Assumption. Omega'. Omega'.
Save.

Lemma downheap_po_14 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test8: `j <= n`)
  (j': Z)
  (Post10: (select_son t0 k n j'))
  (Test6: `(access t0 k) >= (access t0 j')`)
  (permut t0 t0) /\ ((i:Z) (`k <= i` /\ `i <= n` -> (heap t0 n i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
    `i < N` -> `(access t0 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n v k) -> (inftree t0 n v k))).
Proof.
Intuition.
Elim (Z_le_lt_eq_dec k i); [ Intro HHHi | Intro HHHi | Intuition ].
(* k0 < i *)
Apply H3; Omega'.
(* k0 = i *)
Rewrite <- HHHi. Apply heap_cons.
Omega'.
Intro. Elim Post10; Intros.
Rewrite <- H6. Assumption. Omega'.
Intro. Apply H3; Omega'.
Intro. Elim Post10; Intros.
Omega'. Rewrite <- H6. Assumption.
Intro. Apply H3; Omega'.
Save.

Lemma downheap_po_15 : 
  (Variant1: Z)
  (N: Z)
  (k: Z)
  (n: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `n - k`)
  (Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
         ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
  (j: Z)
  (Post1: j = `2 * k + 1`)
  (Test1: `j > n`)
  (permut t0 t0) /\ ((i:Z) (`k <= i` /\ `i <= n` -> (heap t0 n i))) /\
  ((i:Z)
   (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
    `i < N` -> `(access t0 i) = (access t0 i)`)) /\
  ((v:Z) ((inftree t0 n v k) -> (inftree t0 n v k))).
Proof.
Intuition.
Elim (Z_le_lt_eq_dec k i); [ Intro HHHi | Intro HHHi | Intuition ].
Apply H3; Omega'.
Rewrite <- HHHi. Apply heap_cons.
Omega'.
Intro; Absurd `2*k+1 > n`; Omega'.
Intro; Absurd `2*k+1 > n`; Omega'.
Intro; Absurd `2*k+2 > n`; Omega'.
Intro; Absurd `2*k+2 > n`; Omega'.
Save.

Require swap_why.

Definition downheap := (* validation *)
  [N: Z; k: Z; n: Z; t: (array N Z); Pre11: `0 <= k` /\ `k <= n` /\
   `n < N` /\ ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t n i)))]
    (well_founded_induction Z (Zwf ZERO) (downheap_po_1 N k n t Pre11)
      [Variant1: Z](N: Z)(k: Z)(n: Z)(t0: (array N Z))(_: Variant1 = `n - k`)
      (_: `0 <= k` /\ `k <= n` /\ `n < N` /\
      ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
      (sig_2 (array N Z) unit [t1:(array N Z)][result:unit]((permut t1 t0) /\
       ((i:Z) (`k <= i` /\ `i <= n` -> (heap t1 n i))) /\
       ((i:Z)
        (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
         `i < N` -> `(access t1 i) = (access t0 i)`)) /\
       ((v:Z) ((inftree t0 n v k) -> (inftree t1 n v k)))))
      [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
       (N: Z)(k: Z)(n: Z)(t0: (array N Z))(_: Variant2 = `n - k`)
       (_: `0 <= k` /\ `k <= n` /\ `n < N` /\
       ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i))))
       (sig_2 (array N Z) unit [t1:(array N Z)][result:unit]
        ((permut t1 t0) /\ ((i:Z) (`k <= i` /\ `i <= n` -> (heap t1 n i))) /\
        ((i:Z)
         (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
          `i < N` -> `(access t1 i) = (access t0 i)`)) /\
        ((v:Z) ((inftree t0 n v k) -> (inftree t1 n v k)))));
       N: Z; k: Z; n: Z; t0: (array N Z); Pre10: Variant1 = `n - k`;
       Pre9: `0 <= k` /\ `k <= n` /\ `n < N` /\
       ((i:Z) (`k + 1 <= i` /\ `i <= n` -> (heap t0 n i)))]
        let (j, Post1) = (exist_1 [result: Z]result = `2 * k + 1` `2 * k + 1`
          (refl_equal ? `2 * k + 1`)) in
        let (t1, result, Post6) =
          let (result, Bool4) =
            let (result1, Post7) = (Z_le_gt_bool j n) in
            (exist_1 [result2: bool]
            (if result2 then `j <= n` else `j > n`) result1 Post7) in
          (Cases (btest [result:bool](if result then `j <= n` else `j > n`)
                  result Bool4) of
          | (left Test8) =>
              let (t1, result0, Post9) =
                let (j', Post10) =
                  let (result0, Bool3) =
                    let (result2, Post11) = (Z_le_gt_bool `j + 1` n) in
                    (exist_1 [result3: bool]
                    (if result3 then `j + 1 <= n` else `j + 1 > n`) result2
                    Post11) in
                  (Cases (btest
                          [result0:bool](if result0 then `j + 1 <= n`
                                         else `j + 1 > n`)
                          result0 Bool3) of
                  | (left Test5) =>
                      let (result1, Post13) =
                        let (result1, Bool2) =
                          let Pre2 =
                            (downheap_po_2 Variant1 N k n t0 Pre10 Pre9 j
                            Post1 Test8 Test5) in
                          let result2 =
                            let Pre3 =
                              (downheap_po_3 Variant1 N k n t0 Pre10 Pre9 j
                              Post1 Test8 Test5 Pre2) in
                            (Z_lt_ge_bool (access t0 j)) in
                          let (result3, Post14) =
                            (result2 (access t0 `j + 1`)) in
                          (exist_1 [result4: bool]
                          (if result4
                           then `(access t0 j) < (access t0 j + 1)`
                           else `(access t0 j) >= (access t0 j + 1)`) 
                          result3 Post14) in
                        (Cases (btest
                                [result1:bool](if result1
                                               then `(access t0 j) <
                                                     (access t0 j + 1)`
                                               else `(access t0 j) >=
                                                     (access t0 j + 1)`)
                                result1 Bool2) of
                        | (left Test4) =>
                            let (result2, Post16) = (exist_1 [result2: Z]
                              (select_son t0 k n result2) `j + 1`
                              (downheap_po_4 Variant1 N k n t0 Pre10 Pre9 j
                              Post1 Test8 Test5 Test4)) in
                            (exist_1 [result3: Z]
                            (select_son t0 k n result3) result2 Post16)
                        | (right Test3) =>
                            let (result2, Post15) = (exist_1 [result2: Z]
                              (select_son t0 k n result2) j
                              (downheap_po_5 Variant1 N k n t0 Pre10 Pre9 j
                              Post1 Test8 Test5 Test3)) in
                            (exist_1 [result3: Z]
                            (select_son t0 k n result3) result2 Post15) end) in
                      (exist_1 [result2: Z]
                      (select_son t0 k n result2) result1 Post13)
                  | (right Test2) =>
                      let (result1, Post12) = (exist_1 [result1: Z]
                        (select_son t0 k n result1) j
                        (downheap_po_6 Variant1 N k n t0 Pre10 Pre9 j Post1
                        Test8 Test2)) in
                      (exist_1 [result2: Z]
                      (select_son t0 k n result2) result1 Post12) end) in
                let (t1, result0, Post17) =
                  let (result0, Bool1) =
                    let Pre4 =
                      (downheap_po_7 Variant1 N k n t0 Pre10 Pre9 j Post1
                      Test8 j' Post10) in
                    let result1 =
                      let Pre5 =
                        (downheap_po_8 Variant1 N k n t0 Pre10 Pre9 j Post1
                        Test8 j' Post10 Pre4) in
                      (Z_lt_ge_bool (access t0 k)) in
                    let (result2, Post18) = (result1 (access t0 j')) in
                    (exist_1 [result3: bool]
                    (if result3 then `(access t0 k) < (access t0 j')`
                     else `(access t0 k) >= (access t0 j')`) result2
                    Post18) in
                  (Cases (btest
                          [result0:bool](if result0
                                         then `(access t0 k) < (access t0 j')`
                                         else `(access t0 k) >=
                                               (access t0 j')`)
                          result0 Bool1) of
                  | (left Test7) =>
                      let (t1, result1, Post20) =
                        let (t1, result1, Post21) =
                          let Pre6 =
                            (downheap_po_9 Variant1 N k n t0 Pre10 Pre9 j
                            Post1 Test8 j' Post10 Test7) in
                          let (t1, result3, Post22) =
                            (swap N k j' t0 Pre6) in
                          (exist_2 [t2: (array N Z)][result4: unit]
                          (exchange t2 t0 k j') t1 result3 Post22) in
                        let (t2, result2, Post23) =
                          let Pre8 =
                            (downheap_po_10 Variant1 N k n t0 Pre10 Pre9 j
                            Post1 Test8 j' Post10 Test7 t1 Post21) in
                          let (t2, result4, Post24) =
                            ((wf1 `n - j'`)
                              (downheap_po_11 Variant1 N k n t0 Pre10 Pre9 j
                              Post1 Test8 j' Post10 Test7 t1 Post21 Pre8) 
                              N j' n t1 (refl_equal ? `n - j'`)
                              (downheap_po_12 Variant1 N k n t0 Pre10 Pre9 j
                              Post1 Test8 j' Post10 Test7 t1 Post21 Pre8)) in
                          (exist_2 [t3: (array N Z)][result5: unit]
                          (permut t3 t1) /\
                          ((i:Z) (`j' <= i` /\ `i <= n` -> (heap t3 n i))) /\
                          ((i:Z)
                           (`0 <= i` /\ `i < j'` \/ `j' < i` /\
                            `i < 2 * j' + 1` \/ `n < i` /\ `i < N` ->
                            `(access t3 i) = (access t1 i)`)) /\
                          ((v:Z) ((inftree t1 n v j') -> (inftree t3 n v j'))) 
                          t2 result4 Post24) in
                        (exist_2 [t3: (array N Z)][result3: unit]
                        (permut t3 t0) /\
                        ((i:Z) (`k <= i` /\ `i <= n` -> (heap t3 n i))) /\
                        ((i:Z)
                         (`0 <= i` /\ `i < k` \/ `k < i` /\
                          `i < 2 * k + 1` \/ `n < i` /\ `i < N` ->
                          `(access t3 i) = (access t0 i)`)) /\
                        ((v:Z) ((inftree t0 n v k) -> (inftree t3 n v k))) 
                        t2 result2
                        (downheap_po_13 Variant1 N k n t0 Pre10 Pre9 j Post1
                        Test8 j' Post10 Test7 t1 Post21 t2 Post23)) in
                      (exist_2 [t2: (array N Z)][result2: unit]
                      (permut t2 t0) /\
                      ((i:Z) (`k <= i` /\ `i <= n` -> (heap t2 n i))) /\
                      ((i:Z)
                       (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                        `n < i` /\ `i < N` -> `(access t2 i) = (access t0 i)`)) /\
                      ((v:Z) ((inftree t0 n v k) -> (inftree t2 n v k))) 
                      t1 result1 Post20)
                  | (right Test6) =>
                      let (result1, Post19) = (exist_1 [result1: unit]
                        (permut t0 t0) /\
                        ((i:Z) (`k <= i` /\ `i <= n` -> (heap t0 n i))) /\
                        ((i:Z)
                         (`0 <= i` /\ `i < k` \/ `k < i` /\
                          `i < 2 * k + 1` \/ `n < i` /\ `i < N` ->
                          `(access t0 i) = (access t0 i)`)) /\
                        ((v:Z) ((inftree t0 n v k) -> (inftree t0 n v k))) 
                        tt
                        (downheap_po_14 Variant1 N k n t0 Pre10 Pre9 j Post1
                        Test8 j' Post10 Test6)) in
                      (exist_2 [t1: (array N Z)][result2: unit]
                      (permut t1 t0) /\
                      ((i:Z) (`k <= i` /\ `i <= n` -> (heap t1 n i))) /\
                      ((i:Z)
                       (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                        `n < i` /\ `i < N` -> `(access t1 i) = (access t0 i)`)) /\
                      ((v:Z) ((inftree t0 n v k) -> (inftree t1 n v k))) 
                      t0 result1 Post19) end) in
                (exist_2 [t2: (array N Z)][result1: unit](permut t2 t0) /\
                ((i:Z) (`k <= i` /\ `i <= n` -> (heap t2 n i))) /\
                ((i:Z)
                 (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                  `n < i` /\ `i < N` -> `(access t2 i) = (access t0 i)`)) /\
                ((v:Z) ((inftree t0 n v k) -> (inftree t2 n v k))) t1 
                result0 Post17) in
              (exist_2 [t2: (array N Z)][result1: unit](permut t2 t0) /\
              ((i:Z) (`k <= i` /\ `i <= n` -> (heap t2 n i))) /\
              ((i:Z)
               (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                `n < i` /\ `i < N` -> `(access t2 i) = (access t0 i)`)) /\
              ((v:Z) ((inftree t0 n v k) -> (inftree t2 n v k))) t1 result0
              Post9)
          | (right Test1) =>
              let (result0, Post8) = (exist_1 [result0: unit]
                (permut t0 t0) /\
                ((i:Z) (`k <= i` /\ `i <= n` -> (heap t0 n i))) /\
                ((i:Z)
                 (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                  `n < i` /\ `i < N` -> `(access t0 i) = (access t0 i)`)) /\
                ((v:Z) ((inftree t0 n v k) -> (inftree t0 n v k))) tt
                (downheap_po_15 Variant1 N k n t0 Pre10 Pre9 j Post1 Test1)) in
              (exist_2 [t1: (array N Z)][result1: unit](permut t1 t0) /\
              ((i:Z) (`k <= i` /\ `i <= n` -> (heap t1 n i))) /\
              ((i:Z)
               (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/
                `n < i` /\ `i < N` -> `(access t1 i) = (access t0 i)`)) /\
              ((v:Z) ((inftree t0 n v k) -> (inftree t1 n v k))) t0 result0
              Post8) end) in
        (exist_2 [t2: (array N Z)][result0: unit](permut t2 t0) /\
        ((i:Z) (`k <= i` /\ `i <= n` -> (heap t2 n i))) /\
        ((i:Z)
         (`0 <= i` /\ `i < k` \/ `k < i` /\ `i < 2 * k + 1` \/ `n < i` /\
          `i < N` -> `(access t2 i) = (access t0 i)`)) /\
        ((v:Z) ((inftree t0 n v k) -> (inftree t2 n v k))) t1 result Post6)
      `n - k` N k n t (refl_equal ? `n - k`) Pre11).



