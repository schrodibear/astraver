(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.
Require Heap.
Require Inftree.
Require ZArithRing.

Lemma double_div2 : (x:Z) `(Zdiv2 (2*x)) = x`.
Proof.
Destruct x; Auto.
Save.

Lemma double_div2_bis : (x:Z) `0 <= x` -> `(Zdiv2 (2*x+1)) = x`.
Proof.
Destruct x; Auto.
Intros.
Simpl in H.
Absurd `0 <= (NEG p)`.
Simpl. Compute. Auto. Assumption.
Save.

Lemma lem_div2_0 : (n:Z)`1 <= n` -> `(-1) <= (Zdiv2 (n-2)) <= n-1`.
Proof.
Intros.
Elim (Z_lt_ge_dec `1` n); Intro.
Elim (Z_modulo_2 n).
Intro H0; Elim H0; Clear H0; Intros.
Replace `n-2` with `2*(x-1)`.
Rewrite double_div2.
Omega. Omega.
Intro H0; Elim H0; Clear H0; Intros.
Replace `n-2` with `2*(x-1)+1`.
Rewrite double_div2_bis.
Omega. Omega. Omega. Omega.
Replace n with `1`.
Simpl. Omega. Omega.
Save.

Lemma lem_div2_1 : (n:Z)`1 <= n` -> `0 <= (Zdiv2 (n-2))+1`.
Proof.
Intros n Hn. Generalize (lem_div2_0 n Hn). Omega.
Save.

Lemma lem_div2_2 : (n,i:Z)
  `1 <= n` -> `(Zdiv2 (n-2))+1 <= i <= n-1` -> `2*i >= n-1`.
Proof.
Intros n i Hn.
Elim (Z_lt_ge_dec `1` n); Intro.
Elim (Z_modulo_2 n).
Intro H0; Elim H0; Clear H0; Intros x Hx.
Replace `n-2` with `2*(x-1)`.
Rewrite double_div2.
Omega. Omega. 
Intro H0; Elim H0; Clear H0; Intros x Hx.
Replace `n-2` with `2*(x-1)+1`.
Rewrite double_div2_bis.
Omega. Omega. Omega. Omega.
Replace n with `1`.
Simpl. Omega. Omega.
Save.


(* Obligations. *)

Lemma heapsort_po_1 : 
  (N: Z)
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (well_founded ? (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma heapsort_po_2 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (Variant1: Z)
  (k0: Z)
  (t0: (array N Z))
  (Pre4: Variant1 = `k0 + 1`)
  (Pre3: `(-1) <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
         (permut t0 t))
  (Test2: `k0 >= 0`)
  `0 <= k0` /\ `k0 <= N - 1` /\ `N - 1 < N` /\
  ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))).
Proof.
Intuition.
Save.

Lemma heapsort_po_3 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (Variant1: Z)
  (k0: Z)
  (t0: (array N Z))
  (Pre4: Variant1 = `k0 + 1`)
  (Pre3: `(-1) <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
         (permut t0 t))
  (Test2: `k0 >= 0`)
  (t1: (array N Z))
  (Post11: (permut t1 t0) /\
           ((i:Z) (`k0 <= i` /\ `i <= N - 1` -> (heap t1 `N - 1` i))) /\
           ((i:Z)
            (`0 <= i` /\ `i < k0` \/ `k0 < i` /\ `i < 2 * k0 + 1` \/
             `N - 1 < i` /\ `i < N` -> (access t1 i) = (access t0 i))) /\
           ((v:Z) ((inftree t0 `N - 1` v k0) -> (inftree t1 `N - 1` v k0))))
  (k1: Z)
  (Post2: k1 = `k0 - 1`)
  `(-1) <= k1` /\ `k1 <= N - 1` /\
  ((i:Z) (`k1 + 1 <= i` /\ `i <= N - 1` -> (heap t1 `N - 1` i))) /\
  (permut t1 t) /\ (Zwf `0` `k1 + 1` `k0 + 1`).
Proof.
Intuition.
Apply permut_trans with t':=t0; Assumption.
Unfold Zwf; Omega'.
Save.

Lemma heapsort_po_4 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (Variant1: Z)
  (k0: Z)
  (t0: (array N Z))
  (Pre4: Variant1 = `k0 + 1`)
  (Pre3: `(-1) <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
         (permut t0 t))
  (Test2: `k0 >= 0`)
  (k1: Z)
  (t1: (array N Z))
  (Post10: `(-1) <= k1` /\ `k1 <= N - 1` /\
           ((i:Z) (`k1 + 1 <= i` /\ `i <= N - 1` -> (heap t1 `N - 1` i))) /\
           (permut t1 t) /\ (Zwf `0` `k1 + 1` `k0 + 1`))
  (Zwf `0` `k1 + 1` Variant1).
Proof.
Intros; Rewrite Pre4; Tauto.
Save.

Lemma heapsort_po_5 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (Variant1: Z)
  (k0: Z)
  (t0: (array N Z))
  (Pre4: Variant1 = `k0 + 1`)
  (Pre3: `(-1) <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
         (permut t0 t))
  (Test2: `k0 >= 0`)
  (k1: Z)
  (t1: (array N Z))
  (Post10: `(-1) <= k1` /\ `k1 <= N - 1` /\
           ((i:Z) (`k1 + 1 <= i` /\ `i <= N - 1` -> (heap t1 `N - 1` i))) /\
           (permut t1 t) /\ (Zwf `0` `k1 + 1` `k0 + 1`))
  `(-1) <= k1` /\ `k1 <= N - 1` /\
  ((i:Z) (`k1 + 1 <= i` /\ `i <= N - 1` -> (heap t1 `N - 1` i))) /\
  (permut t1 t).
Proof.
Intuition.
Save.

Lemma heapsort_po_6 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (Variant1: Z)
  (k0: Z)
  (t0: (array N Z))
  (Pre4: Variant1 = `k0 + 1`)
  (Pre3: `(-1) <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
         (permut t0 t))
  (Test1: `k0 < 0`)
  `(-1) <= k0` /\ `k0 <= N - 1` /\
  ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
  (permut t0 t) /\ `k0 < 0`.
Proof.
Intuition.
Save.

Lemma heapsort_po_7 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  `(-1) <= result` /\ `result <= N - 1` /\
  ((i:Z) (`result + 1 <= i` /\ `i <= N - 1` -> (heap t `N - 1` i))) /\
  (permut t t).
Proof.
Intros.
Generalize (lem_div2_0 N Pre10); Intuition Try Omega'.
Apply heap_leaf.
Generalize (lem_div2_1 N Pre10); Omega'.
Apply (lem_div2_2 N i); Trivial Orelse Omega'.
Auto with datatypes.
Save.

Lemma heapsort_po_8 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (result: Z)
  (Post1: result = (Zdiv2 `N - 2`))
  (k0: Z)
  (t0: (array N Z))
  (Post6: `(-1) <= k0` /\ `k0 <= N - 1` /\
          ((i:Z) (`k0 + 1 <= i` /\ `i <= N - 1` -> (heap t0 `N - 1` i))) /\
          (permut t0 t) /\ `k0 < 0`)
  (heap t0 `N - 1` `0`) /\ (permut t0 t).
Proof.
Intuition.
Save.


Lemma heapsort_po_9 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (well_founded ? (Zwf ZERO)).
Proof.
Intuition.
Save.

Lemma heapsort_po_10 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test4: `k0 >= 1`)
  `0 <= 0` /\ `0 < N` /\ (`0 <= k0` /\ `k0 < N`).
Proof.
Intuition.
Save.

Lemma heapsort_po_11 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test4: `k0 >= 1`)
  (t2: (array N Z))
  (Post19: (exchange t2 t1 `0` k0))
  `0 <= 0` /\ `0 <= k0 - 1` /\ `k0 - 1 < N` /\
  ((i:Z) (`0 + 1 <= i` /\ `i <= k0 - 1` -> (heap t2 `k0 - 1` i))).
Proof.
Intuition.
Apply heap_id with t:=t1.
Apply heap_weakening. Omega'.
Apply H2; Omega'. Omega'.
Decompose [exchange] Post19; Clear Post19.
Unfold array_id.
Intros i0 Hi0. Symmetry. Apply H13; Omega'.
Save.

Lemma heapsort_po_12 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test4: `k0 >= 1`)
  (t2: (array N Z))
  (Post19: (exchange t2 t1 `0` k0))
  (t3: (array N Z))
  (Post21: (permut t3 t2) /\
           ((i:Z) (`0 <= i` /\ `i <= k0 - 1` -> (heap t3 `k0 - 1` i))) /\
           ((i:Z)
            (`0 <= i` /\ `i < 0` \/ `0 < i` /\ `i < 2 * 0 + 1` \/
             `k0 - 1 < i` /\ `i < N` -> (access t3 i) = (access t2 i))) /\
           ((v:Z)
            ((inftree t2 `k0 - 1` v `0`) -> (inftree t3 `k0 - 1` v `0`))))
  (k1: Z)
  (Post4: k1 = `k0 - 1`)
  `0 <= k1` /\ `k1 <= N - 1` /\
  ((i:Z) (`0 <= i` /\ `i <= k1` -> (heap t3 k1 i))) /\
  ((`k1 + 1 <= N - 1` -> `(access t3 0) <= (access t3 k1 + 1)`)) /\
  ((`k1 + 1 <= N - 1` -> (sorted_array t3 `k1 + 1` `N - 1`))) /\
  (permut t3 t) /\ (Zwf `0` k1 k0).
Proof.
Intuition.
(* heap *)
Rewrite Post4; Apply H9; Omega'.
(* t[0] <= t[k] *)
Rewrite Post4; Ring `k0-1+1`. 
Rewrite (H8 k0); [ Idtac | Omega' ].
Decompose [exchange] Post19.
Rewrite H15.
Apply inftree_1 with n:=`k0-1`.
Apply H11.
Apply inftree_weakening. Omega'.
Apply inftree_exchange with t1:=t1. Omega'.
Apply inftree_3.
Apply H2; Omega'.
Assumption. Omega'.
(* sorted *)
Rewrite Post4; Ring `k0-1+1`.  
Elim (Z_le_lt_eq_dec k0 `N-1` H3); Intro.
  (* k0 < N-1 *)
  Replace k0 with `(k0+1)-1`; [ Idtac | Omega' ].
  Apply left_extension. Omega'. Omega'.
  Apply sorted_array_id with t1:=t2. 
  Apply sorted_array_id with t1:=t1. 
  Apply H5; Omega'.
  Decompose [exchange] Post19.
  Unfold array_id. Intros i Hi. Symmetry. Apply H16; Omega'.
  Unfold array_id. Intros i Hi. Symmetry. Apply H8; Omega'.
  (* t3[k0] <= t3[k0+1] *)
  Ring `k0+1-1`. 
  Rewrite (H8 k0); [ Idtac | Omega' ].
  Rewrite (H8 `k0+1`); [ Idtac | Omega' ].
  Decompose [exchange] Post19.
  Rewrite H15. Rewrite (H16 `k0+1`); [ Idtac | Omega' | Omega' | Omega' ].
  Apply H4; Omega'.
  (* k0 = N-1 *)
  Rewrite b. 
  Unfold sorted_array.
  Intros HN x HHx Hx. Absurd `x >= N-1`; Omega'.
(* (permut t3 t) *)
Apply permut_trans with t':=t2; Try Assumption. 
Apply permut_trans with t':=t1.
Apply exchange_is_permut with i:=`0` j:=k0. Assumption. 
Assumption. 
(* Zwf *)
Unfold Zwf; Omega'.
Save.

Lemma heapsort_po_13 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test4: `k0 >= 1`)
  (k1: Z)
  (t2: (array N Z))
  (Post18: `0 <= k1` /\ `k1 <= N - 1` /\
           ((i:Z) (`0 <= i` /\ `i <= k1` -> (heap t2 k1 i))) /\
           ((`k1 + 1 <= N - 1` -> `(access t2 0) <= (access t2 k1 + 1)`)) /\
           ((`k1 + 1 <= N - 1` -> (sorted_array t2 `k1 + 1` `N - 1`))) /\
           (permut t2 t) /\ (Zwf `0` k1 k0))
  (Zwf `0` k1 Variant3).
Proof.
Intros; Rewrite Pre9; Tauto.
Save.

Lemma heapsort_po_14 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test4: `k0 >= 1`)
  (k1: Z)
  (t2: (array N Z))
  (Post18: `0 <= k1` /\ `k1 <= N - 1` /\
           ((i:Z) (`0 <= i` /\ `i <= k1` -> (heap t2 k1 i))) /\
           ((`k1 + 1 <= N - 1` -> `(access t2 0) <= (access t2 k1 + 1)`)) /\
           ((`k1 + 1 <= N - 1` -> (sorted_array t2 `k1 + 1` `N - 1`))) /\
           (permut t2 t) /\ (Zwf `0` k1 k0))
  `0 <= k1` /\ `k1 <= N - 1` /\
  ((i:Z) (`0 <= i` /\ `i <= k1` -> (heap t2 k1 i))) /\
  ((`k1 + 1 <= N - 1` -> `(access t2 0) <= (access t2 k1 + 1)`)) /\
  ((`k1 + 1 <= N - 1` -> (sorted_array t2 `k1 + 1` `N - 1`))) /\
  (permut t2 t).
Proof.
Intuition.
Save.

Lemma heapsort_po_15 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (Variant3: Z)
  (k0: Z)
  (t1: (array N Z))
  (Pre9: Variant3 = k0)
  (Pre8: `0 <= k0` /\ `k0 <= N - 1` /\
         ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
         ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
         ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
         (permut t1 t))
  (Test3: `k0 < 1`)
  `0 <= k0` /\ `k0 <= N - 1` /\
  ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
  ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
  ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
  (permut t1 t) /\ `k0 < 1`.
Proof.
Intuition.
Save.

Lemma heapsort_po_16 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  `0 <= result0` /\ `result0 <= N - 1` /\
  ((i:Z) (`0 <= i` /\ `i <= result0` -> (heap t0 result0 i))) /\
  ((`result0 + 1 <= N - 1` -> `(access t0 0) <= (access t0 result0 + 1)`)) /\
  ((`result0 + 1 <= N - 1` -> (sorted_array t0 `result0 + 1` `N - 1`))) /\
  (permut t0 t).
Proof.
Intuition.
Apply heap_all.
Rewrite Post3; Assumption.
Tauto.
Intro; Absurd `N-1+1 <= N-1`; Omega'.
Save.

Lemma heapsort_po_17 : 
  (N: Z)
  (t: (array N Z))
  (Pre10: `1 <= N`)
  (t0: (array N Z))
  (Post5: (heap t0 `N - 1` `0`) /\ (permut t0 t))
  (result0: Z)
  (Post3: result0 = `N - 1`)
  (k0: Z)
  (t1: (array N Z))
  (Post14: `0 <= k0` /\ `k0 <= N - 1` /\
           ((i:Z) (`0 <= i` /\ `i <= k0` -> (heap t1 k0 i))) /\
           ((`k0 + 1 <= N - 1` -> `(access t1 0) <= (access t1 k0 + 1)`)) /\
           ((`k0 + 1 <= N - 1` -> (sorted_array t1 `k0 + 1` `N - 1`))) /\
           (permut t1 t) /\ `k0 < 1`)
  (sorted_array t1 `0` `N - 1`) /\ (permut t1 t).
Proof.
Intuition.
Elim (Z_le_lt_eq_dec `1` N Pre10); Intro.
  (* 1 < N *)
  Replace `0` with `1-1`; [ Idtac | Omega' ].
  Apply left_extension. Omega'. Omega'.
  Replace `1` with `k0+1`; [ Idtac | Omega' ].
  Replace `N-(k0+1)` with `N-1`; [ Idtac | Omega' ].
  Apply H5; Omega'.
  Replace `1-1` with `0`; [ Idtac | Omega' ]. (* Ring `1-1`. *)
  Replace `1` with `k0+1`; [ Idtac | Omega' ].
  Apply H4; Omega'.
  (* 1 = N *)
  Unfold sorted_array. 
  Intros HN x HHx Hx. Absurd `x >= N-1`; Omega'.
Save.


