(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Import Omega.
Require Import Partition.
Require Import Quicksort.

Require Import partition_why.

Proof.
intros; omega.
Qed.

  Proof.
  intuition SameLength t1 t0; omega.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition; SameLength t2 t1; SameLength t1 t0; omega.
Qed.

Proof.
intros; unfold Zwf; omega.
Qed.

Proof.
intros.
apply quicksort_lemma with (t1 := t1) (t2 := t2) (p := p); intuition.
 Qed.

Proof.
intros; apply quicksort_trivial; intuition.
Qed.


Proof.
intuition omega.
Qed.

Proof.
intuition eauto.
SameLength t0 t; rewrite H3; trivial.
Qed.


(* Why obligation from file "quicksort.mlw", line 29, characters 16-31: *)
(*Why goal*) Lemma quick_rec_po_1 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  ((0 <= l /\ l < r) /\ r < (array_length t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 31, characters 10-29: *)
(*Why goal*) Lemma quick_rec_po_2 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (result: Z),
  forall (t0: (array Z)),
  forall (HW_4: (l <= result /\ result <= r) /\
                (partition_p t0 l r result) /\ (sub_permut l r t0 t)),
  (Zwf 0 (1 + (result - 1) - l) (1 + r - l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 31, characters 10-29: *)
(*Why goal*) Lemma quick_rec_po_3 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (result: Z),
  forall (t0: (array Z)),
  forall (HW_4: (l <= result /\ result <= r) /\
                (partition_p t0 l r result) /\ (sub_permut l r t0 t)),
  forall (HW_5: (Zwf 0 (1 + (result - 1) - l) (1 + r - l))),
  (0 <= l /\ (result - 1) < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 32, characters 3-22: *)
(*Why goal*) Lemma quick_rec_po_4 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (result: Z),
  forall (t0: (array Z)),
  forall (HW_4: (l <= result /\ result <= r) /\
                (partition_p t0 l r result) /\ (sub_permut l r t0 t)),
  forall (HW_5: (Zwf 0 (1 + (result - 1) - l) (1 + r - l))),
  forall (HW_6: 0 <= l /\ (result - 1) < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_7: (sorted_array t1 l (result - 1)) /\
                (sub_permut l (result - 1) t1 t0)),
  (Zwf 0 (1 + r - (result + 1)) (1 + r - l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 32, characters 3-22: *)
(*Why goal*) Lemma quick_rec_po_5 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (result: Z),
  forall (t0: (array Z)),
  forall (HW_4: (l <= result /\ result <= r) /\
                (partition_p t0 l r result) /\ (sub_permut l r t0 t)),
  forall (HW_5: (Zwf 0 (1 + (result - 1) - l) (1 + r - l))),
  forall (HW_6: 0 <= l /\ (result - 1) < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_7: (sorted_array t1 l (result - 1)) /\
                (sub_permut l (result - 1) t1 t0)),
  forall (HW_8: (Zwf 0 (1 + r - (result + 1)) (1 + r - l))),
  (0 <= (result + 1) /\ r < (array_length t1)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 34, characters 6-55: *)
(*Why goal*) Lemma quick_rec_po_6 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (result: Z),
  forall (t0: (array Z)),
  forall (HW_4: (l <= result /\ result <= r) /\
                (partition_p t0 l r result) /\ (sub_permut l r t0 t)),
  forall (HW_5: (Zwf 0 (1 + (result - 1) - l) (1 + r - l))),
  forall (HW_6: 0 <= l /\ (result - 1) < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_7: (sorted_array t1 l (result - 1)) /\
                (sub_permut l (result - 1) t1 t0)),
  forall (HW_8: (Zwf 0 (1 + r - (result + 1)) (1 + r - l))),
  forall (HW_9: 0 <= (result + 1) /\ r < (array_length t1)),
  forall (t2: (array Z)),
  forall (HW_10: (sorted_array t2 (result + 1) r) /\
                 (sub_permut (result + 1) r t2 t1)),
  ((sorted_array t2 l r) /\ (sub_permut l r t2 t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 34, characters 6-55: *)
(*Why goal*) Lemma quick_rec_po_7 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_11: l >= r),
  ((sorted_array t l r) /\ (sub_permut l r t t)).
Proof.
(* FILL PROOF HERE *)
Save.


Definition quick_rec_functional (* validation *)
  : forall (l: Z), forall (r: Z), forall (t: (array Z)), forall (_: 0 <= l /\
    r < (array_length t)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  => ((sorted_array t0 l r) /\
      (sub_permut l r t0 t))))
  := (fun (l: Z) (r: Z) (t: (array Z)) (H_1: 0 <= l /\ r < (array_length t)) =>
        ((well_founded_induction) (Z) ((Zwf Z0)) ((well_founded (Zwf Z0))) ((
          fun (variant2: Z) => forall (l0: Z), forall (r0: Z),
          forall (t0: (array Z)), forall (_: 0 <= l0 /\ r0 <
          (array_length t0)), (tuple_2 (array Z) unit))) ((fun (variant2: Z) (wf1: forall (variant3: Z),
                                                               forall (Pre14: (Zwf 0 variant3 variant2)),
                                                               forall (l0: Z),
                                                               forall (r0: Z),
                                                               forall (t0: (array Z)),
                                                               forall (_: 0 <=
                                                               l0 /\ r0 <
                                                               (array_length
                                                                t0)),
                                                               (tuple_2
                                                                (array Z) unit)) (l0: Z) (r0: Z) (t0: (array Z)) (H_1_0: 0 <=
                                                               l0 /\ r0 <
                                                               (array_length
                                                                t0)) =>
                                                             let (t1, result,
                                                               H_4) :=
                                                               let result :=
                                                                 let (result0,
                                                                   Post7) :=
                                                                   (lt_int_
                                                                    l0 r0) in
                                                                 (exist_1 (
                                                                 fun (result1: bool) =>
                                                                 (if result1
                                                                  then l0 <
                                                                  r0
                                                                  else l0 >=
                                                                  r0)) (
                                                                 result0) ((
                                                                 if result0
                                                                 then l0 < r0
                                                                 else l0 >=
                                                                 r0))) in
                                                               if result then
                                                                 let (t1,
                                                                   result0) :=
                                                                   let (t1,
                                                                    p) :=
                                                                    let Pre9 :=
                                                                    (0 <=
                                                                    l0 /\
                                                                    l0 <
                                                                    r0) /\
                                                                    r0 <
                                                                    (array_length
                                                                    t0) in
                                                                    let (t1,
                                                                    result1,
                                                                    Post8) :=
                                                                    (
                                                                    partition
                                                                    l0 r0 t0) in
                                                                    (exist_2 (
                                                                    fun (t2: (array Z)) =>
                                                                    (
                                                                    fun (result2: Z) =>
                                                                    (l0 <=
                                                                    result2 /\
                                                                    result2 <=
                                                                    r0) /\
                                                                    (
                                                                    partition_p
                                                                    t2 l0 r0 result2) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 r0 t2 t0))) (
                                                                    t1) (
                                                                    result1) ((l0 <=
                                                                    result1 /\
                                                                    result1 <=
                                                                    r0) /\
                                                                    (
                                                                    partition_p
                                                                    t1 l0 r0 result1) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 r0 t1 t0))) in
                                                                   let (t2,
                                                                    result0) :=
                                                                    let (t2,
                                                                    result0) :=
                                                                    let Pre11 :=
                                                                    0 <=
                                                                    l0 /\
                                                                    (p - 1) <
                                                                    (array_length
                                                                    t1) in
                                                                    let Pre10 :=
                                                                    (Zwf 0 
                                                                    (1 +
                                                                    (p - 1) -
                                                                    l0) 
                                                                    (1 + r0 -
                                                                    l0)) in
                                                                    let (t2,
                                                                    result1,
                                                                    Post9) :=
                                                                    (fun 
                                                                    (H_1_1: 0 <=
                                                                    l0 /\
                                                                    (p - 1) <
                                                                    (
                                                                    array_length
                                                                    t1)) =>
                                                                    (((
                                                                    wf1
                                                                    (1 +
                                                                    (p - 1) -
                                                                    l0))) ((Zwf 0 
                                                                    (1 +
                                                                    (p - 1) -
                                                                    l0) variant2)) (
                                                                    l0) (
                                                                    (p - 1)) (
                                                                    t1) (
                                                                    (1 +
                                                                    (p - 1) -
                                                                    l0) =
                                                                    (1 +
                                                                    (p - 1) -
                                                                    l0)) (0 <=
                                                                    l0 /\
                                                                    (p - 1) <
                                                                    (array_length
                                                                    t1)))) in
                                                                    (exist_2 (
                                                                    fun (t3: (array Z)) =>
                                                                    (
                                                                    fun (result2: unit) =>
                                                                    (
                                                                    sorted_array
                                                                    t3 l0 
                                                                    (p - 1)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 
                                                                    (p - 1) t3 t1))) (
                                                                    t2) (
                                                                    result1) ((
                                                                    sorted_array
                                                                    t2 l0 
                                                                    (p - 1)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 
                                                                    (p - 1) t2 t1))) in
                                                                    let (t3,
                                                                    result1) :=
                                                                    let Pre13 :=
                                                                    0 <=
                                                                    (p + 1) /\
                                                                    r0 <
                                                                    (array_length
                                                                    t2) in
                                                                    let Pre12 :=
                                                                    (Zwf 0 
                                                                    (1 + r0 -
                                                                    (p + 1)) 
                                                                    (1 + r0 -
                                                                    l0)) in
                                                                    let (t3,
                                                                    result2,
                                                                    Post10) :=
                                                                    (fun 
                                                                    (H_1_1: 0 <=
                                                                    (p + 1) /\
                                                                    r0 <
                                                                    (
                                                                    array_length
                                                                    t2)) =>
                                                                    (((
                                                                    wf1
                                                                    (1 + r0 -
                                                                    (p + 1)))) ((Zwf 0 
                                                                    (1 + r0 -
                                                                    (p + 1)) variant2)) (
                                                                    (p + 1)) (
                                                                    r0) (
                                                                    t2) (
                                                                    (1 + r0 -
                                                                    (p + 1)) =
                                                                    (1 + r0 -
                                                                    (p + 1))) (0 <=
                                                                    (p + 1) /\
                                                                    r0 <
                                                                    (array_length
                                                                    t2)))) in
                                                                    (exist_2 (
                                                                    fun (t4: (array Z)) =>
                                                                    (
                                                                    fun (result3: unit) =>
                                                                    (
                                                                    sorted_array
                                                                    t4 
                                                                    (p + 1) r0) /\
                                                                    (
                                                                    sub_permut
                                                                    (p + 1) r0 t4 t2))) (
                                                                    t3) (
                                                                    result2) ((
                                                                    sorted_array
                                                                    t3 
                                                                    (p + 1) r0) /\
                                                                    (
                                                                    sub_permut
                                                                    (p + 1) r0 t3 t2))) in
                                                                    (Build_tuple_2 (
                                                                    t3) (
                                                                    result1)) in
                                                                   (Build_tuple_2 (
                                                                   t2) (
                                                                   result0)) in
                                                                 (Build_tuple_2 (
                                                                 t1) (
                                                                 result0))
                                                               else
                                                                 (Build_tuple_2 (
                                                                 t0) (
                                                                 tt)) in
                                                             (Build_tuple_2 (
                                                             t1) (result)))) (
          (1 + r - l)) (l) (r) (t) ((1 + r - l) = (1 + r - l)) (0 <= l /\ r <
          (array_length t)))).


(* Why obligation from file "quicksort.mlw", line 41, characters 5-40: *)
(*Why goal*) Lemma quicksort_po_1 : 
  forall (t: (array Z)),
  forall (result: Z),
  forall (HW_1: result = (array_length t)),
  (0 <= 0 /\ (result - 1) < (array_length t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort.mlw", line 42, characters 6-61: *)
(*Why goal*) Lemma quicksort_po_2 : 
  forall (t: (array Z)),
  forall (result: Z),
  forall (HW_1: result = (array_length t)),
  forall (HW_2: 0 <= 0 /\ (result - 1) < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_3: (sorted_array t0 0 (result - 1)) /\
                (sub_permut 0 (result - 1) t0 t)),
  ((sorted_array t0 0 ((array_length t0) - 1)) /\ (permut t0 t)).
Proof.
(* FILL PROOF HERE *)
Save.


Definition quicksort_functional (* validation *)
  : forall (t: (array Z)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  =>
      ((sorted_array t0 0 ((array_length t0) - 1)) /\ (permut t0 t))))
  := (fun (t: (array Z)) =>
        let aux_2 :=
          let aux_1 :=
            let (result0, Post2) := (array_length_ t) in
            (exist_1 (fun (result1: Z) => result1 = (array_length t)) (
            result0) (result0 = (array_length t))) in
          (aux_1 - 1) in
        let (t0, result) :=
          let Pre1 := 0 <= 0 /\ aux_2 < (array_length t) in
          let (t0, result0, Post3) := (quick_rec 0 aux_2 t) in
          (exist_2 (fun (t1: (array Z)) =>
                    (fun (result1: unit) => (sorted_array t1 0 aux_2) /\
                     (sub_permut 0 aux_2 t1 t))) (t0) (result0) ((sorted_array
                                                                  t0 0 aux_2) /\
          (sub_permut 0 aux_2 t0 t))) in
        (Build_tuple_2 (t0) (result))).


