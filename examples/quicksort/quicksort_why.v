(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.
Require Partition.
Require Quicksort.

Require partition_why.

Lemma quick_rec_po_1 : 
  (l: Z)
  (r: Z)
  (Pre9: `0 <= l` /\ `r < N`)
  (well_founded ? (Zwf `(-1)`)).
Proof.
Auto with *.
Save.

Lemma quick_rec_po_2 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  `0 <= l` /\ `l < r` /\ `r < N`.
Proof.
Intros; Omega.
Save.

Lemma quick_rec_po_3 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  (t1: (array N Z))
  (p: Z)
  (Post5: `l <= p` /\ `p <= r` /\ (partition_p t1 l r p) /\
          (sub_permut l r t1 t0))
  `0 <= l` /\ `p - 1 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_4 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  (t1: (array N Z))
  (p: Z)
  (Post5: `l <= p` /\ `p <= r` /\ (partition_p t1 l r p) /\
          (sub_permut l r t1 t0))
  (Pre4: `0 <= l` /\ `p - 1 < N`)
  (Zwf `(-1)` `p - 1 - l` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_5 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  (t1: (array N Z))
  (p: Z)
  (Post5: `l <= p` /\ `p <= r` /\ (partition_p t1 l r p) /\
          (sub_permut l r t1 t0))
  (t2: (array N Z))
  (Post8: (sorted_array t2 l `p - 1`) /\ (sub_permut l `p - 1` t2 t1))
  `0 <= p + 1` /\ `r < N`.
Proof.
Intros; Omega.
Save.

Lemma quick_rec_po_6 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  (t1: (array N Z))
  (p: Z)
  (Post5: `l <= p` /\ `p <= r` /\ (partition_p t1 l r p) /\
          (sub_permut l r t1 t0))
  (t2: (array N Z))
  (Post8: (sorted_array t2 l `p - 1`) /\ (sub_permut l `p - 1` t2 t1))
  (Pre6: `0 <= p + 1` /\ `r < N`)
  (Zwf `(-1)` `r - (p + 1)` Variant1).
Proof.
Intros; Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_7 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test2: `l < r`)
  (t1: (array N Z))
  (p: Z)
  (Post5: `l <= p` /\ `p <= r` /\ (partition_p t1 l r p) /\
          (sub_permut l r t1 t0))
  (t2: (array N Z))
  (Post8: (sorted_array t2 l `p - 1`) /\ (sub_permut l `p - 1` t2 t1))
  (t3: (array N Z))
  (Post10: (sorted_array t3 `p + 1` r) /\ (sub_permut `p + 1` r t3 t2))
  (sorted_array t3 l r) /\ (sub_permut l r t3 t0).
Proof.
Intros.
Apply quicksort_lemma with t1:=t1 t2:=t2 p:=p;
Intuition. 
Save.

Lemma quick_rec_po_8 : 
  (Variant1: Z)
  (l: Z)
  (r: Z)
  (t0: (array N Z))
  (Pre8: Variant1 = `r - l`)
  (Pre7: `0 <= l` /\ `r < N`)
  (Test1: `l >= r`)
  (sorted_array t0 l r) /\ (sub_permut l r t0 t0).
Proof.
Intros; Apply quicksort_trivial; Intuition.
Save.




Definition quick_rec := (* validation *)
  [l: Z; r: Z; t: (array N Z); Pre9: `0 <= l` /\ `r < N`]
    (well_founded_induction Z (Zwf `(-1)`) (quick_rec_po_1 l r Pre9)
      [Variant1: Z](l: Z)(r: Z)(t0: (array N Z))(_: Variant1 = `r - l`)
      (_: `0 <= l` /\ `r < N`)
      (sig_2 (array N Z) unit [t1:(array N Z)][result:unit]
       ((sorted_array t1 l r) /\ (sub_permut l r t1 t0)))
      [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `(-1)` Variant2 Variant1))
       (l: Z)(r: Z)(t0: (array N Z))(_: Variant2 = `r - l`)(_: `0 <= l` /\
       `r < N`)
       (sig_2 (array N Z) unit [t1:(array N Z)][result:unit]
        ((sorted_array t1 l r) /\ (sub_permut l r t1 t0)));
       l: Z; r: Z; t0: (array N Z); Pre8: Variant1 = `r - l`;
       Pre7: `0 <= l` /\ `r < N`]
        let (result, Bool1) =
          let (result1, Post2) = (Z_lt_ge_bool l r) in
          (exist_1 [result2: bool]
          (if result2 then `l < r` else `l >= r`) result1 Post2) in
        (Cases (btest [result:bool](if result then `l < r` else `l >= r`)
                result Bool1) of
        | (left Test2) =>
            let (t1, result0, Post4) =
              let (t1, p, Post5) =
                let Pre2 = (quick_rec_po_2 Variant1 l r Pre8 Pre7 Test2) in
                let (t1, result2, Post6) = (partition l r t0 Pre2) in
                (exist_2 [t2: (array N Z)][result3: Z]`l <= result3` /\
                `result3 <= r` /\ (partition_p t2 l r result3) /\
                (sub_permut l r t2 t0) t1 result2 Post6) in
              let (t2, result0, Post7) =
                let (t2, result0, Post8) =
                  let Pre4 =
                    (quick_rec_po_3 Variant1 l r t0 Pre8 Pre7 Test2 t1 p
                    Post5) in
                  let (t2, result2, Post9) =
                    ((wf1 `p - 1 - l`)
                      (quick_rec_po_4 Variant1 l r t0 Pre8 Pre7 Test2 t1 p
                      Post5 Pre4) l `p - 1` t1 (refl_equal ? `p - 1 - l`)
                      Pre4) in
                  (exist_2 [t3: (array N Z)][result3: unit]
                  (sorted_array t3 l `p - 1`) /\
                  (sub_permut l `p - 1` t3 t1) t2 result2 Post9) in
                let (t3, result1, Post10) =
                  let Pre6 =
                    (quick_rec_po_5 Variant1 l r t0 Pre8 Pre7 Test2 t1 p
                    Post5 t2 Post8) in
                  let (t3, result3, Post11) =
                    ((wf1 `r - (p + 1)`)
                      (quick_rec_po_6 Variant1 l r t0 Pre8 Pre7 Test2 t1 p
                      Post5 t2 Post8 Pre6) `p + 1` r t2
                      (refl_equal ? `r - (p + 1)`) Pre6) in
                  (exist_2 [t4: (array N Z)][result4: unit]
                  (sorted_array t4 `p + 1` r) /\
                  (sub_permut `p + 1` r t4 t2) t3 result3 Post11) in
                (exist_2 [t4: (array N Z)][result2: unit]
                (sorted_array t4 l r) /\ (sub_permut l r t4 t0) t3 result1
                (quick_rec_po_7 Variant1 l r t0 Pre8 Pre7 Test2 t1 p Post5 t2
                Post8 t3 Post10)) in
              (exist_2 [t3: (array N Z)][result1: unit]
              (sorted_array t3 l r) /\ (sub_permut l r t3 t0) t2 result0
              Post7) in
            (exist_2 [t2: (array N Z)][result1: unit](sorted_array t2 l r) /\
            (sub_permut l r t2 t0) t1 result0 Post4)
        | (right Test1) =>
            let (result0, Post3) = (exist_1 [result0: unit]
              (sorted_array t0 l r) /\ (sub_permut l r t0 t0) tt
              (quick_rec_po_8 Variant1 l r t0 Pre8 Pre7 Test1)) in
            (exist_2 [t1: (array N Z)][result1: unit](sorted_array t1 l r) /\
            (sub_permut l r t1 t0) t0 result0 Post3) end) `r - l` l r 
      t (refl_equal ? `r - l`) Pre9).

Lemma quicksort_po_1 : 
  `0 <= 0` /\ `N - 1 < N`.
Proof.
Omega.
Save.

Lemma quicksort_po_2 : 
  (t: (array N Z))
  (Pre1: `0 <= 0` /\ `N - 1 < N`)
  (t0: (array N Z))
  (Post1: (sorted_array t0 `0` `N - 1`) /\ (sub_permut `0` `N - 1` t0 t))
  (sorted_array t0 `0` `N - 1`) /\ (permut t0 t).
Proof.
Intuition EAuto.
Save.





Definition quicksort := (* validation *)
  [t: (array N Z)]
    let Pre1 = quicksort_po_1 in
    let (t0, result1, Post1) = (quick_rec `0` `N - 1` t Pre1) in
    (exist_2 [t1: (array N Z)][result2: unit](sorted_array t1 `0` `N - 1`) /\
    (permut t1 t) t0 result1 (quicksort_po_2 t Pre1 t0 Post1)).

