(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Partition.
Require Omega.
Require ZArithRing.

(*Why*) Parameter N : Z.

Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  `0 <= i` /\ `i < N`.
Proof. 
Intros; Omega.
Save.

Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  `0 <= j` /\ `j < N`.
Proof.
Intros; Omega.
Save.

Lemma swap_po_3 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  (Pre2: `0 <= j` /\ `j < N`)
  (t0: (array N Z))
  (Post2: t0 = (store t i (access t j)))
  (t1: (array N Z))
  (Post3: t1 = (store t0 j result))
  (exchange t1 t i j).
Proof.
Intros; Rewrite Post3; Rewrite Post2; Rewrite Post1.
Auto with datatypes.
Save.


Definition swap := (* validation *)
  [i: Z; j: Z; t: (array N Z); Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\
   `j < N`)]
    let Pre1 = (swap_po_1 i j Pre5) in
    let (result, Post1) = (exist_1 [result: Z]
      result = (access t i) (access t i) (refl_equal ? (access t i))) in
    let (t0, result0, Post4) =
      let Pre2 = (swap_po_2 i j t Pre5 Pre1 result Post1) in
      let (t0, result0, Post2) =
        let (result0, Post2) = (exist_1 [result0: Z]
          (store t i result0) = (store t i (access t j)) (access t j)
          (refl_equal ? (store t i (access t j)))) in
        let Pre3 = Pre1 in
        (exist_2 [t1: (array N Z)][result2: unit]
        t1 = (store t i (access t j)) (store t i result0) tt Post2) in
      let (t1, result1, Post3) =
        let (result1, Post3) = (exist_1 [result1: Z]
          (store t0 j result1) = (store t0 j result) result
          (refl_equal ? (store t0 j result))) in
        let Pre4 = Pre2 in
        (exist_2 [t2: (array N Z)][result3: unit]
        t2 = (store t0 j result) (store t0 j result1) tt Post3) in
      (exist_2 [t2: (array N Z)][result2: unit](exchange t2 t i j) t1 
      result1
      (swap_po_3 i j t Pre5 Pre1 result Post1 Pre2 t0 Post2 t1 Post3)) in
    (exist_2 [t1: (array N Z)][result1: unit](exchange t1 t i j) t0 result0
    Post4).

Lemma partition_po_1 : 
  (l: Z)
  (r: Z)
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  `0 <= l` /\ `l < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_2 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (well_founded ? (Zwf `(-N) - 2`)).
Proof.
Auto with *.
Save.

Lemma partition_po_3 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (well_founded ? (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma partition_po_4 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  `0 <= i1` /\ `i1 < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_5 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test3: `(access t0 i1) <= result`)
  (result4: bool)
  (Bool3: (if result4 then `i1 < j0` else `i1 >= j0`))
  (if result4 then `(access t0 i1) <= result` /\ `i1 < j0` \/
   `(access t0 i1) > result` /\ true = false
   else `(access t0 i1) <= result` /\ `i1 >= j0` \/
   `(access t0 i1) > result` /\ false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_6 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test2: `(access t0 i1) > result`)
  (result4: bool)
  (Post4: result4 = false)
  (if result4 then `(access t0 i1) <= result` /\ `i1 < j0` \/
   `(access t0 i1) > result` /\ true = false
   else `(access t0 i1) <= result` /\ `i1 >= j0` \/
   `(access t0 i1) > result` /\ false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_7 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Post6: i2 = `i1 + 1`)
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
  (Zwf `0` `r - i2` `r - i1`).
Proof.
Intuition Try Discriminate.
Omega.
Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Assumption.
Ring `(i1-1+1)`. Assumption.
Omega.
Unfold Zwf; Omega.
Save.

Lemma partition_po_8 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Invi0: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
          (Zwf `0` `r - i2` `r - i1`))
  (Zwf `0` `r - i2` Variant3).
Proof. 
Intros. Rewrite Pre5; Tauto.
Save.

Lemma partition_po_9 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Invi0: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
          (Zwf `0` `r - i2` `r - i1`))
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result).
Proof.
Intuition.
Save.

Lemma partition_po_10 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre5: Variant3 = `r - i1`)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Test4: `(access t0 i1) <= result` /\ `i1 >= j0` \/
          `(access t0 i1) > result` /\ false = false)
  `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
  (`(access t0 i1) <= result` /\ `i1 >= j0` \/ `(access t0 i1) > result` /\
  false = false).
Proof.
Intuition.
Save.

Lemma partition_po_11 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  `i0 <= i0` /\ `i0 <= r` /\ (array_le t0 `l + 1` `i0 - 1` result).
Proof.
Intuition.
Save.

Lemma partition_po_12 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (well_founded ? (Zwf ZERO)).
Proof.
Intuition.
Save.

Lemma partition_po_13 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  `0 <= j1` /\ `j1 < N`.
Proof.
Intuition.
Save.

Lemma partition_po_14 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test7: `(access t0 j1) >= result`)
  (result5: bool)
  (Bool5: (if result5 then `i1 < j1` else `i1 >= j1`))
  (if result5 then `(access t0 j1) >= result` /\ `i1 < j1` \/
   `(access t0 j1) < result` /\ true = false
   else `(access t0 j1) >= result` /\ `i1 >= j1` \/
   `(access t0 j1) < result` /\ false = false).
Proof.
Intuition.
Induction result5; Auto.
Induction result5; Auto.
Save.

Lemma partition_po_15 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test6: `(access t0 j1) < result`)
  (result5: bool)
  (Post7: result5 = false)
  (if result5 then `(access t0 j1) >= result` /\ `i1 < j1` \/
   `(access t0 j1) < result` /\ true = false
   else `(access t0 j1) >= result` /\ `i1 >= j1` \/
   `(access t0 j1) < result` /\ false = false).
Proof.
Intuition.
Induction result5; Auto.
Induction result5; Auto.
Save.

Lemma partition_po_16 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Post9: j2 = `j1 - 1`)
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
  (Zwf `0` j2 j1).
Proof.
Intuition.
Apply array_ge_cons. Intros j Hj. Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Apply array_ge_cons. Intros j Hj. 
Elim (Z_le_gt_dec `j1+1` j); Intro.
Elim H19; Intros. Apply H17; Omega.
Cut `j = j1`; [ Intro | Omega ].
Rewrite H17; Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Save.

Lemma partition_po_17 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Invj0: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
          (Zwf `0` j2 j1))
  (Zwf `0` j2 Variant5).
Proof.
Intros.
Rewrite Pre8; Tauto.
Save.

Lemma partition_po_18 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Invj0: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
          (Zwf `0` j2 j1))
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result).
Proof.
Tauto. 
Save.

Lemma partition_po_19 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre8: Variant5 = j1)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Test8: `(access t0 j1) >= result` /\ `i1 >= j1` \/
          `(access t0 j1) < result` /\ false = false)
  `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
  (`(access t0 j1) >= result` /\ `i1 >= j1` \/ `(access t0 j1) < result` /\
  false = false).
Proof.
Tauto.
Save.

Lemma partition_po_20 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  `l <= j0` /\ `j0 <= j0` /\ (array_ge t0 `j0 + 1` r result).
Proof.
Intuition.
Save.

Lemma partition_po_21 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test11: `i1 < j1`)
  `0 <= i1` /\ `i1 < N` /\ (`0 <= j1` /\ `j1 < N`).
Proof.
Intuition.
Save.

Lemma partition_po_22 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test11: `i1 < j1`)
  (t1: (array N Z))
  (Post25: (exchange t1 t0 i1 j1))
  (i2: Z)
  (Post10: i2 = `i1 + 1`)
  (j2: Z)
  (Post11: j2 = `j1 - 1`)
  `l + 1 <= i2` /\ `i2 <= r` /\ `j2 <= r` /\
  (array_le t1 `l + 1` `i2 - 1` result) /\ (array_ge t1 `j2 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l) /\
  (Zwf `(-N) - 2` `j2 - i2` `j0 - i0`).
Proof.
Intros.
Decompose [and or] Invj; Clear Invj. 
Absurd `i1 < j1`; Omega.
Repeat (Apply conj); Try Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Decompose [and] Invi. Apply array_le_exchange with t:=t0 x:=i1 y:=j1.
Omega. Omega. 
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(i1-1+1)`. Elim Post25; Intros. Rewrite H6.
Omega.
Omega.
(* (array_ge t1 `(Zpred j1)+1` r (#t[l])) *)
Replace `j2+1` with `(j1+1)-1`.
Apply array_ge_left_extension.
Apply array_ge_exchange with t:=t0 x:=i1 y:=j1.
Omega. Omega. 
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(j1+1-1)`. Elim Post25; Intros. Rewrite H7.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=i1 j:=j1; [Omega | Omega | Assumption].
Decompose [and] Inv; Assumption.
(* (access t1 l) = (access t l) *)
Decompose [and] Inv. Rewrite <- H11.
Elim Post25; Intros.
Apply H15; Omega.
Unfold Zwf; Omega.
Save.

Lemma partition_po_23 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test10: `i1 >= j1`)
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t0 `l + 1` `i1 - 1` result) /\ (array_ge t0 `j1 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\
  (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`).
Proof.
Intros.
Repeat (Apply conj); Tauto Orelse Unfold Zwf; Omega.
Save.


Lemma partition_po_24 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv0: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
         (array_le t1 `l + 1` `i1 - 1` result) /\
         (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
         (access t1 l) = (access t l) /\ (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`))
  (Zwf `(-N) - 2` `j1 - i1` Variant1).
Proof. 
Intros; Rewrite Pre10; Tauto.
Save.

Lemma partition_po_25 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test12: `i0 < j0`)
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv0: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
         (array_le t1 `l + 1` `i1 - 1` result) /\
         (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
         (access t1 l) = (access t l) /\ (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`))
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t1 `l + 1` `i1 - 1` result) /\ (array_ge t1 `j1 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l).
Proof.
Tauto.
Save.

Lemma partition_po_26 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Pre10: Variant1 = `j0 - i0`)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Test1: `i0 >= j0`)
  `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
  (array_le t0 `l + 1` `i0 - 1` result) /\ (array_ge t0 `j0 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\ `i0 >= j0`.
Proof.
Intuition.
Save.

Lemma partition_po_27 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  `l + 1 <= result0` /\ `result0 <= r` /\ `result1 <= r` /\
  (array_le t `l + 1` `result0 - 1` result) /\
  (array_ge t `result1 + 1` r result) /\ (sub_permut l r t t) /\
  (access t l) = (access t l).
Proof.
Intuition.
Apply array_le_empty; Omega.
Apply array_ge_empty; Omega.
Save.

Lemma partition_po_28 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma partition_po_29 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test14: `(access t0 i0) < result`)
  `0 <= l` /\ `l < N` /\ (`0 <= i0` /\ `i0 < N`).
Proof.
Intuition.
Save.

Lemma partition_po_30 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test14: `(access t0 i0) < result`)
  (t1: (array N Z))
  (Post34: (exchange t1 t0 l i0))
  `l <= i0` /\ `i0 <= r` /\ (partition_p t1 l r i0) /\ (sub_permut l r t1 t).
Proof.
Intuition; Clear result3 Bool7.
Apply piv.
Omega.
Omega.
Apply array_le_cons.
Intros i Hi. Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post34; Intros.
Elim H7; Intros.
Rewrite H15. 
Rewrite (H16 i). Rewrite H10. Rewrite <- Post1.
Apply H17; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Elim Post34; Intros.
Rewrite <- b. Rewrite H14. Rewrite H15.
Rewrite H10.
Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intros j Hj.
Elim Post34; Intros. Rewrite H15.
Rewrite H10.
Rewrite (H16 j).
Elim H8; Intros. Rewrite <- Post1. Apply H17; Omega.
Omega.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=i0.
Omega.
Omega.
Assumption.
Assumption.
Save.

Lemma partition_po_31 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test13: `(access t0 i0) >= result`)
  `0 <= l` /\ `l < N` /\ (`0 <= i0 - 1` /\ `i0 - 1 < N`).
Proof. 
Intuition.
Save.

Lemma partition_po_32 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test13: `(access t0 i0) >= result`)
  (t1: (array N Z))
  (Post30: (exchange t1 t0 l `i0 - 1`))
  `l <= i0 - 1` /\ `i0 - 1 <= r` /\ (partition_p t1 l r `i0 - 1`) /\
  (sub_permut l r t1 t).
Proof.
Intuition; Clear result3 Bool7.
Apply piv.
Omega.
Omega.
(* array_le *)
Apply array_le_cons.
Intros i Hi. 
Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post30; Intros. Rewrite H15.
Rewrite H10.
Rewrite (H16 i). Elim H7; Intros. 
Rewrite <- Post1. Apply H17; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Rewrite <- b. 
Elim Post30; Intros.
Rewrite H15. Rewrite H10.
Rewrite H14.
Elim H7; Intros. 
Rewrite <- Post1. Apply H17; Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intro j. Ring `i0-1+1`. Intro Hj. 
Elim Post30; Intros.
Rewrite H15. Rewrite (H16 j).
Rewrite H10.
Elim H8; Intros. 
Elim (Z_le_lt_eq_dec i0 j); Intros.
(* case i0 < j *)
Rewrite <- Post1. Apply H17; Omega.
(* case i0 = j *)
Rewrite <- b. Omega.
Omega.
Omega.
Omega.
Omega.
(* (sub_permut t1 t l r) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=(Zpred i0).
Omega.
Unfold Zpred; Omega.
Assumption.
Assumption.
Save.


Definition partition := (* validation *)
  [l: Z; r: Z; t: (array N Z); Pre14: `0 <= l` /\ `l < r` /\ `r < N`]
    let Pre1 = (partition_po_1 l r Pre14) in
    let (result, Post1) = (exist_1 [result: Z]
      result = (access t l) (access t l) (refl_equal ? (access t l))) in
    let (t0, result0, Post16) =
      let (result0, Post2) = (exist_1 [result0: Z]result0 = `l + 1` `l + 1`
        (refl_equal ? `l + 1`)) in
      let (i0, t0, result1, Post17) =
        let (result1, Post3) = (exist_1 [result1: Z]result1 = r r
          (refl_equal ? r)) in
        let (i0, j0, t0, result2, Post18) =
          let (i0, j0, t0, result2, Inv) =
            (well_founded_induction Z (Zwf `(-N) - 2`)
              (partition_po_2 l r t Pre14 Pre1 result Post1 result0 Post2
              result1 Post3) [Variant1: Z](i0: Z)(j0: Z)(t0: (array N Z))
              (_: Variant1 = `j0 - i0`)(Inv: `l + 1 <= i0` /\ `i0 <= r` /\
              `j0 <= r` /\ (array_le t0 `l + 1` `i0 - 1` result) /\
              (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
              (access t0 l) = (access t l))
              (sig_4 Z Z (array N Z) unit [i1:Z][j1:Z][t1:(array N Z)]
               [result:unit](`l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
               (array_le t1 `l + 1` `i1 - 1` result) /\
               (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
               (access t1 l) = (access t l) /\ `i1 >= j1`))
              [Variant1: Z; wf1: (Variant2: Z)
               (Pre2: (Zwf `(-N) - 2` Variant2 Variant1))(i0: Z)(j0: Z)
               (t0: (array N Z))(_: Variant2 = `j0 - i0`)
               (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
               (array_le t0 `l + 1` `i0 - 1` result) /\
               (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
               (access t0 l) = (access t l))
               (sig_4 Z Z (array N Z) unit [i1:Z][j1:Z][t1:(array N Z)]
                [result:unit](`l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
                (array_le t1 `l + 1` `i1 - 1` result) /\
                (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
                (access t1 l) = (access t l) /\ `i1 >= j1`));
               i0: Z; j0: Z; t0: (array N Z); Pre10: Variant1 = `j0 - i0`;
               Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
               (array_le t0 `l + 1` `i0 - 1` result) /\
               (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
               (access t0 l) = (access t l)]
                let (result2, Bool1) =
                  let (result4, Post19) = (Z_lt_ge_bool i0 j0) in
                  (exist_1 [result5: bool]
                  (if result5 then `i0 < j0` else `i0 >= j0`) result4 Post19) in
                (Cases (btest
                        [result2:bool](if result2 then `i0 < j0`
                                       else `i0 >= j0`)
                        result2 Bool1) of
                | (left Test12) =>
                    let (i1, j1, t1, result3, Inv) =
                      let (i1, j1, t1, result3, Inv0) =
                        let (i1, result3, Invi) =
                          (well_founded_induction Z (Zwf ZERO)
                            (partition_po_3 l r t Pre14 Pre1 result Post1
                            result0 Post2 result1 Post3 Variant1 i0 j0 t0
                            Pre10 Inv Test12) [Variant3: Z](i1: Z)
                            (_: Variant3 = `r - i1`)(Invi: `i0 <= i1` /\
                            `i1 <= r` /\
                            (array_le t0 `l + 1` `i1 - 1` result))
                            (sig_2 Z unit [i2:Z][result:unit](`i0 <= i2` /\
                             `i2 <= r` /\
                             (array_le t0 `l + 1` `i2 - 1` result) /\
                             (`(access t0 i2) <= result` /\ `i2 >= j0` \/
                             `(access t0 i2) > result` /\ false = false)))
                            [Variant3: Z; wf2: (Variant4: Z)
                             (Pre3: (Zwf `0` Variant4 Variant3))(i1: Z)
                             (_: Variant4 = `r - i1`)(Invi: `i0 <= i1` /\
                             `i1 <= r` /\
                             (array_le t0 `l + 1` `i1 - 1` result))
                             (sig_2 Z unit [i2:Z][result:unit](`i0 <= i2` /\
                              `i2 <= r` /\
                              (array_le t0 `l + 1` `i2 - 1` result) /\
                              (`(access t0 i2) <= result` /\ `i2 >= j0` \/
                              `(access t0 i2) > result` /\ false = false)));
                             i1: Z; Pre5: Variant3 = `r - i1`;
                             Invi: `i0 <= i1` /\ `i1 <= r` /\
                             (array_le t0 `l + 1` `i1 - 1` result)]
                              let (result3, Post5) =
                                let (result3, Bool2) =
                                  let result4 =
                                    let Pre4 =
                                      (partition_po_4 l r t Pre14 Pre1 result
                                      Post1 result0 Post2 result1 Post3
                                      Variant1 i0 j0 t0 Pre10 Inv Test12
                                      Variant3 i1 Pre5 Invi) in
                                    (Z_le_gt_bool (access t0 i1)) in
                                  let (result5, Post20) = (result4 result) in
                                  (exist_1 [result6: bool]
                                  (if result6 then `(access t0 i1) <= result`
                                   else `(access t0 i1) > result`) result5
                                  Post20) in
                                (Cases (btest
                                        [result3:bool](if result3
                                                       then `(access t0 i1) <=
                                                             result`
                                                       else `(access t0 i1) >
                                                             result`)
                                        result3 Bool2) of
                                | (left Test3) =>
                                    let (result4, Bool3) =
                                      let (result6, Post21) =
                                        (Z_lt_ge_bool i1 j0) in
                                      (exist_1 [result7: bool]
                                      (if result7 then `i1 < j0`
                                       else `i1 >= j0`) result6
                                      Post21) in
                                    (exist_1 [result5: bool]
                                    (if result5
                                     then `(access t0 i1) <= result` /\
                                     `i1 < j0` \/
                                     `(access t0 i1) > result` /\
                                     true = false
                                     else `(access t0 i1) <= result` /\
                                     `i1 >= j0` \/
                                     `(access t0 i1) > result` /\
                                     false = false) result4
                                    (partition_po_5 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12
                                    Variant3 i1 Pre5 Invi Test3 result4
                                    Bool3))
                                | (right Test2) =>
                                    let (result4, Post4) =
                                      (exist_1 [result4: bool]
                                      result4 = false false
                                      (refl_equal ? false)) in
                                    (exist_1 [result5: bool]
                                    (if result5
                                     then `(access t0 i1) <= result` /\
                                     `i1 < j0` \/
                                     `(access t0 i1) > result` /\
                                     true = false
                                     else `(access t0 i1) <= result` /\
                                     `i1 >= j0` \/
                                     `(access t0 i1) > result` /\
                                     false = false) result4
                                    (partition_po_6 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12
                                    Variant3 i1 Pre5 Invi Test2 result4
                                    Post4)) end) in
                              (Cases (btest
                                      [result3:bool](if result3
                                                     then `(access t0 i1) <=
                                                           result` /\
                                                     `i1 < j0` \/
                                                     `(access t0 i1) > result` /\
                                                     true = false
                                                     else `(access t0 i1) <=
                                                           result` /\
                                                     `i1 >= j0` \/
                                                     `(access t0 i1) > result` /\
                                                     false = false)
                                      result3 Post5) of
                              | (left Test5) =>
                                  let (i2, result4, Invi) =
                                    let (i2, result4, Invi0) =
                                      let (i2, result4, Post6) =
                                        let (result4, Post6) =
                                          (exist_1 [result4: Z]
                                          result4 = `i1 + 1` `i1 + 1`
                                          (refl_equal ? `i1 + 1`)) in
                                        (exist_2 [i3: Z][result5: unit]
                                        i3 = `i1 + 1` result4 tt Post6) in
                                      (exist_2 [i3: Z][result5: unit]
                                      `i0 <= i3` /\ `i3 <= r` /\
                                      (array_le t0 `l + 1` `i3 - 1` result) /\
                                      (Zwf `0` `r - i3` `r - i1`) i2 
                                      result4
                                      (partition_po_7 l r t Pre14 Pre1 result
                                      Post1 result0 Post2 result1 Post3
                                      Variant1 i0 j0 t0 Pre10 Inv Test12
                                      Variant3 i1 Pre5 Invi Test5 i2 Post6)) in
                                    ((wf2 `r - i2`)
                                      (partition_po_8 l r t Pre14 Pre1 result
                                      Post1 result0 Post2 result1 Post3
                                      Variant1 i0 j0 t0 Pre10 Inv Test12
                                      Variant3 i1 Pre5 Invi Test5 i2 Invi0)
                                      i2 (refl_equal ? `r - i2`)
                                      (partition_po_9 l r t Pre14 Pre1 result
                                      Post1 result0 Post2 result1 Post3
                                      Variant1 i0 j0 t0 Pre10 Inv Test12
                                      Variant3 i1 Pre5 Invi Test5 i2 Invi0)) in
                                  (exist_2 [i3: Z][result5: unit]
                                  `i0 <= i3` /\ `i3 <= r` /\
                                  (array_le t0 `l + 1` `i3 - 1` result) /\
                                  (`(access t0 i3) <= result` /\
                                  `i3 >= j0` \/ `(access t0 i3) > result` /\
                                  false = false) i2 result4 Invi)
                              | (right Test4) =>
                                  let (i2, result4, Invi) = (exist_2 [i2: Z]
                                    [result4: unit]`i0 <= i2` /\ `i2 <= r` /\
                                    (array_le t0 `l + 1` `i2 - 1` result) /\
                                    (`(access t0 i2) <= result` /\
                                    `i2 >= j0` \/
                                    `(access t0 i2) > result` /\
                                    false = false) i1 tt
                                    (partition_po_10 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12
                                    Variant3 i1 Pre5 Invi Test4)) in
                                  (exist_2 [i3: Z][result5: unit]
                                  `i0 <= i3` /\ `i3 <= r` /\
                                  (array_le t0 `l + 1` `i3 - 1` result) /\
                                  (`(access t0 i3) <= result` /\
                                  `i3 >= j0` \/ `(access t0 i3) > result` /\
                                  false = false) i2 result4 Invi) end)
                            `r - i0` i0 (refl_equal ? `r - i0`)
                            (partition_po_11 l r t Pre14 Pre1 result Post1
                            result0 Post2 result1 Post3 Variant1 i0 j0 t0
                            Pre10 Inv Test12)) in
                        let (j1, result4, Invj) =
                          (well_founded_induction Z (Zwf ZERO)
                            (partition_po_12 l r t Pre14 Pre1 result Post1
                            result0 Post2 result1 Post3 Variant1 i0 j0 t0
                            Pre10 Inv Test12 i1 Invi) [Variant5: Z](j1: Z)
                            (_: Variant5 = j1)(Invj: `l <= j1` /\
                            `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
                            (sig_2 Z unit [j2:Z][result:unit](`l <= j2` /\
                             `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
                             (`(access t0 j2) >= result` /\ `i1 >= j2` \/
                             `(access t0 j2) < result` /\ false = false)))
                            [Variant5: Z; wf3: (Variant6: Z)
                             (Pre6: (Zwf `0` Variant6 Variant5))(j1: Z)
                             (_: Variant6 = j1)(Invj: `l <= j1` /\
                             `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
                             (sig_2 Z unit [j2:Z][result:unit](`l <= j2` /\
                              `j2 <= j0` /\
                              (array_ge t0 `j2 + 1` r result) /\
                              (`(access t0 j2) >= result` /\ `i1 >= j2` \/
                              `(access t0 j2) < result` /\ false = false)));
                             j1: Z; Pre8: Variant5 = j1; Invj: `l <= j1` /\
                             `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result)]
                              let (result4, Post8) =
                                let (result4, Bool4) =
                                  let result5 =
                                    let Pre7 =
                                      (partition_po_13 l r t Pre14 Pre1
                                      result Post1 result0 Post2 result1
                                      Post3 Variant1 i0 j0 t0 Pre10 Inv
                                      Test12 i1 Invi Variant5 j1 Pre8 Invj) in
                                    (Z_ge_lt_bool (access t0 j1)) in
                                  let (result6, Post22) = (result5 result) in
                                  (exist_1 [result7: bool]
                                  (if result7 then `(access t0 j1) >= result`
                                   else `(access t0 j1) < result`) result6
                                  Post22) in
                                (Cases (btest
                                        [result4:bool](if result4
                                                       then `(access t0 j1) >=
                                                             result`
                                                       else `(access t0 j1) <
                                                             result`)
                                        result4 Bool4) of
                                | (left Test7) =>
                                    let (result5, Bool5) =
                                      let (result7, Post23) =
                                        (Z_lt_ge_bool i1 j1) in
                                      (exist_1 [result8: bool]
                                      (if result8 then `i1 < j1`
                                       else `i1 >= j1`) result7
                                      Post23) in
                                    (exist_1 [result6: bool]
                                    (if result6
                                     then `(access t0 j1) >= result` /\
                                     `i1 < j1` \/
                                     `(access t0 j1) < result` /\
                                     true = false
                                     else `(access t0 j1) >= result` /\
                                     `i1 >= j1` \/
                                     `(access t0 j1) < result` /\
                                     false = false) result5
                                    (partition_po_14 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12 i1
                                    Invi Variant5 j1 Pre8 Invj Test7 result5
                                    Bool5))
                                | (right Test6) =>
                                    let (result5, Post7) =
                                      (exist_1 [result5: bool]
                                      result5 = false false
                                      (refl_equal ? false)) in
                                    (exist_1 [result6: bool]
                                    (if result6
                                     then `(access t0 j1) >= result` /\
                                     `i1 < j1` \/
                                     `(access t0 j1) < result` /\
                                     true = false
                                     else `(access t0 j1) >= result` /\
                                     `i1 >= j1` \/
                                     `(access t0 j1) < result` /\
                                     false = false) result5
                                    (partition_po_15 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12 i1
                                    Invi Variant5 j1 Pre8 Invj Test6 result5
                                    Post7)) end) in
                              (Cases (btest
                                      [result4:bool](if result4
                                                     then `(access t0 j1) >=
                                                           result` /\
                                                     `i1 < j1` \/
                                                     `(access t0 j1) < result` /\
                                                     true = false
                                                     else `(access t0 j1) >=
                                                           result` /\
                                                     `i1 >= j1` \/
                                                     `(access t0 j1) < result` /\
                                                     false = false)
                                      result4 Post8) of
                              | (left Test9) =>
                                  let (j2, result5, Invj) =
                                    let (j2, result5, Invj0) =
                                      let (j2, result5, Post9) =
                                        let (result5, Post9) =
                                          (exist_1 [result5: Z]
                                          result5 = `j1 - 1` `j1 - 1`
                                          (refl_equal ? `j1 - 1`)) in
                                        (exist_2 [j3: Z][result6: unit]
                                        j3 = `j1 - 1` result5 tt Post9) in
                                      (exist_2 [j3: Z][result6: unit]
                                      `l <= j3` /\ `j3 <= j0` /\
                                      (array_ge t0 `j3 + 1` r result) /\
                                      (Zwf `0` j3 j1) j2 result5
                                      (partition_po_16 l r t Pre14 Pre1
                                      result Post1 result0 Post2 result1
                                      Post3 Variant1 i0 j0 t0 Pre10 Inv
                                      Test12 i1 Invi Variant5 j1 Pre8 Invj
                                      Test9 j2 Post9)) in
                                    ((wf3 j2)
                                      (partition_po_17 l r t Pre14 Pre1
                                      result Post1 result0 Post2 result1
                                      Post3 Variant1 i0 j0 t0 Pre10 Inv
                                      Test12 i1 Invi Variant5 j1 Pre8 Invj
                                      Test9 j2 Invj0) j2 (refl_equal ? j2)
                                      (partition_po_18 l r t Pre14 Pre1
                                      result Post1 result0 Post2 result1
                                      Post3 Variant1 i0 j0 t0 Pre10 Inv
                                      Test12 i1 Invi Variant5 j1 Pre8 Invj
                                      Test9 j2 Invj0)) in
                                  (exist_2 [j3: Z][result6: unit]`l <= j3` /\
                                  `j3 <= j0` /\
                                  (array_ge t0 `j3 + 1` r result) /\
                                  (`(access t0 j3) >= result` /\
                                  `i1 >= j3` \/ `(access t0 j3) < result` /\
                                  false = false) j2 result5 Invj)
                              | (right Test8) =>
                                  let (j2, result5, Invj) = (exist_2 [j2: Z]
                                    [result5: unit]`l <= j2` /\ `j2 <= j0` /\
                                    (array_ge t0 `j2 + 1` r result) /\
                                    (`(access t0 j2) >= result` /\
                                    `i1 >= j2` \/
                                    `(access t0 j2) < result` /\
                                    false = false) j1 tt
                                    (partition_po_19 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12 i1
                                    Invi Variant5 j1 Pre8 Invj Test8)) in
                                  (exist_2 [j3: Z][result6: unit]`l <= j3` /\
                                  `j3 <= j0` /\
                                  (array_ge t0 `j3 + 1` r result) /\
                                  (`(access t0 j3) >= result` /\
                                  `i1 >= j3` \/ `(access t0 j3) < result` /\
                                  false = false) j2 result5 Invj) end) 
                            j0 j0 (refl_equal ? j0)
                            (partition_po_20 l r t Pre14 Pre1 result Post1
                            result0 Post2 result1 Post3 Variant1 i0 j0 t0
                            Pre10 Inv Test12 i1 Invi)) in
                        let (i2, j2, t1, result5, Inv0) =
                          let (result5, Bool6) =
                            let (result7, Post24) = (Z_lt_ge_bool i1 j1) in
                            (exist_1 [result8: bool]
                            (if result8 then `i1 < j1` else `i1 >= j1`) 
                            result7 Post24) in
                          (Cases (btest
                                  [result5:bool](if result5 then `i1 < j1`
                                                 else `i1 >= j1`)
                                  result5 Bool6) of
                          | (left Test11) =>
                              let (i2, j2, t1, result6, Inv0) =
                                let (t1, result6, Post25) =
                                  let Pre9 =
                                    (partition_po_21 l r t Pre14 Pre1 result
                                    Post1 result0 Post2 result1 Post3
                                    Variant1 i0 j0 t0 Pre10 Inv Test12 i1
                                    Invi j1 Invj Test11) in
                                  let (t1, result8, Post26) =
                                    (swap i1 j1 t0 Pre9) in
                                  (exist_2 [t2: (array N Z)][result9: unit]
                                  (exchange t2 t0 i1 j1) t1 result8 Post26) in
                                let (i2, result7, Post10) =
                                  let (result7, Post10) =
                                    (exist_1 [result7: Z]
                                    result7 = `i1 + 1` `i1 + 1`
                                    (refl_equal ? `i1 + 1`)) in
                                  (exist_2 [i3: Z][result8: unit]
                                  i3 = `i1 + 1` result7 tt Post10) in
                                let (j2, result8, Post11) =
                                  let (result8, Post11) =
                                    (exist_1 [result8: Z]
                                    result8 = `j1 - 1` `j1 - 1`
                                    (refl_equal ? `j1 - 1`)) in
                                  (exist_2 [j3: Z][result9: unit]
                                  j3 = `j1 - 1` result8 tt Post11) in
                                (exist_4 [i3: Z][j3: Z][t2: (array N Z)]
                                [result9: unit]`l + 1 <= i3` /\ `i3 <= r` /\
                                `j3 <= r` /\
                                (array_le t2 `l + 1` `i3 - 1` result) /\
                                (array_ge t2 `j3 + 1` r result) /\
                                (sub_permut l r t2 t) /\
                                (access t2 l) = (access t l) /\
                                (Zwf `(-N) - 2` `j3 - i3` `j0 - i0`) 
                                i2 j2 t1 result8
                                (partition_po_22 l r t Pre14 Pre1 result
                                Post1 result0 Post2 result1 Post3 Variant1 i0
                                j0 t0 Pre10 Inv Test12 i1 Invi j1 Invj Test11
                                t1 Post25 i2 Post10 j2 Post11)) in
                              (exist_4 [i3: Z][j3: Z][t2: (array N Z)]
                              [result7: unit]`l + 1 <= i3` /\ `i3 <= r` /\
                              `j3 <= r` /\
                              (array_le t2 `l + 1` `i3 - 1` result) /\
                              (array_ge t2 `j3 + 1` r result) /\
                              (sub_permut l r t2 t) /\
                              (access t2 l) = (access t l) /\
                              (Zwf `(-N) - 2` `j3 - i3` `j0 - i0`) i2 
                              j2 t1 result6 Inv0)
                          | (right Test10) =>
                              let (result6, Inv0) = (exist_1 [result6: unit]
                                `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
                                (array_le t0 `l + 1` `i1 - 1` result) /\
                                (array_ge t0 `j1 + 1` r result) /\
                                (sub_permut l r t0 t) /\
                                (access t0 l) = (access t l) /\
                                (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`) 
                                tt
                                (partition_po_23 l r t Pre14 Pre1 result
                                Post1 result0 Post2 result1 Post3 Variant1 i0
                                j0 t0 Pre10 Inv Test12 i1 Invi j1 Invj
                                Test10)) in
                              (exist_4 [i2: Z][j2: Z][t1: (array N Z)]
                              [result7: unit]`l + 1 <= i2` /\ `i2 <= r` /\
                              `j2 <= r` /\
                              (array_le t1 `l + 1` `i2 - 1` result) /\
                              (array_ge t1 `j2 + 1` r result) /\
                              (sub_permut l r t1 t) /\
                              (access t1 l) = (access t l) /\
                              (Zwf `(-N) - 2` `j2 - i2` `j0 - i0`) i1 
                              j1 t0 result6 Inv0) end) in
                        (exist_4 [i3: Z][j3: Z][t2: (array N Z)]
                        [result6: unit]`l + 1 <= i3` /\ `i3 <= r` /\
                        `j3 <= r` /\ (array_le t2 `l + 1` `i3 - 1` result) /\
                        (array_ge t2 `j3 + 1` r result) /\
                        (sub_permut l r t2 t) /\
                        (access t2 l) = (access t l) /\
                        (Zwf `(-N) - 2` `j3 - i3` `j0 - i0`) i2 j2 t1 
                        result5 Inv0) in
                      ((wf1 `j1 - i1`)
                        (partition_po_24 l r t Pre14 Pre1 result Post1
                        result0 Post2 result1 Post3 Variant1 i0 j0 t0 Pre10
                        Inv Test12 i1 j1 t1 Inv0) i1 j1 t1
                        (refl_equal ? `j1 - i1`)
                        (partition_po_25 l r t Pre14 Pre1 result Post1
                        result0 Post2 result1 Post3 Variant1 i0 j0 t0 Pre10
                        Inv Test12 i1 j1 t1 Inv0)) in
                    (exist_4 [i2: Z][j2: Z][t2: (array N Z)][result4: unit]
                    `l + 1 <= i2` /\ `i2 <= r` /\ `j2 <= r` /\
                    (array_le t2 `l + 1` `i2 - 1` result) /\
                    (array_ge t2 `j2 + 1` r result) /\
                    (sub_permut l r t2 t) /\ (access t2 l) = (access t l) /\
                    `i2 >= j2` i1 j1 t1 result3 Inv)
                | (right Test1) =>
                    let (i1, j1, t1, result3, Inv) = (exist_4 [i1: Z][j1: Z]
                      [t1: (array N Z)][result3: unit]`l + 1 <= i1` /\
                      `i1 <= r` /\ `j1 <= r` /\
                      (array_le t1 `l + 1` `i1 - 1` result) /\
                      (array_ge t1 `j1 + 1` r result) /\
                      (sub_permut l r t1 t) /\
                      (access t1 l) = (access t l) /\ `i1 >= j1` i0 j0 
                      t0 tt
                      (partition_po_26 l r t Pre14 Pre1 result Post1 result0
                      Post2 result1 Post3 Variant1 i0 j0 t0 Pre10 Inv Test1)) in
                    (exist_4 [i2: Z][j2: Z][t2: (array N Z)][result4: unit]
                    `l + 1 <= i2` /\ `i2 <= r` /\ `j2 <= r` /\
                    (array_le t2 `l + 1` `i2 - 1` result) /\
                    (array_ge t2 `j2 + 1` r result) /\
                    (sub_permut l r t2 t) /\ (access t2 l) = (access t l) /\
                    `i2 >= j2` i1 j1 t1 result3 Inv) end) `result1 - result0`
              result0 result1 t (refl_equal ? `result1 - result0`)
              (partition_po_27 l r t Pre14 Pre1 result Post1 result0 Post2
              result1 Post3)) in
          let (t1, result3, Post27) =
            let (result3, Bool7) =
              let result4 =
                let Pre11 =
                  (partition_po_28 l r t Pre14 Pre1 result Post1 result0
                  Post2 result1 Post3 i0 j0 t0 Inv) in
                (Z_lt_ge_bool (access t0 i0)) in
              let (result5, Post28) = (result4 result) in
              (exist_1 [result6: bool]
              (if result6 then `(access t0 i0) < result`
               else `(access t0 i0) >= result`) result5
              Post28) in
            (Cases (btest
                    [result3:bool](if result3 then `(access t0 i0) < result`
                                   else `(access t0 i0) >= result`)
                    result3 Bool7) of
            | (left Test14) =>
                let (t1, result4, Post33) =
                  let (t1, result4, Post34) =
                    let Pre13 =
                      (partition_po_29 l r t Pre14 Pre1 result Post1 result0
                      Post2 result1 Post3 i0 j0 t0 Inv Test14) in
                    let (t1, result6, Post35) = (swap l i0 t0 Pre13) in
                    (exist_2 [t2: (array N Z)][result7: unit]
                    (exchange t2 t0 l i0) t1 result6 Post35) in
                  let (result5, Post36) = (exist_1 [result5: Z]
                    `l <= result5` /\ `result5 <= r` /\
                    (partition_p t1 l r result5) /\ (sub_permut l r t1 t) 
                    i0
                    (partition_po_30 l r t Pre14 Pre1 result Post1 result0
                    Post2 result1 Post3 i0 j0 t0 Inv Test14 t1 Post34)) in
                  (exist_2 [t2: (array N Z)][result6: Z]`l <= result6` /\
                  `result6 <= r` /\ (partition_p t2 l r result6) /\
                  (sub_permut l r t2 t) t1 result5 Post36) in
                (exist_2 [t2: (array N Z)][result5: Z]`l <= result5` /\
                `result5 <= r` /\ (partition_p t2 l r result5) /\
                (sub_permut l r t2 t) t1 result4 Post33)
            | (right Test13) =>
                let (t1, result4, Post29) =
                  let (t1, result4, Post30) =
                    let Pre12 =
                      (partition_po_31 l r t Pre14 Pre1 result Post1 result0
                      Post2 result1 Post3 i0 j0 t0 Inv Test13) in
                    let (t1, result6, Post31) = (swap l `i0 - 1` t0 Pre12) in
                    (exist_2 [t2: (array N Z)][result7: unit]
                    (exchange t2 t0 l `i0 - 1`) t1 result6 Post31) in
                  let (result5, Post32) = (exist_1 [result5: Z]
                    `l <= result5` /\ `result5 <= r` /\
                    (partition_p t1 l r result5) /\
                    (sub_permut l r t1 t) `i0 - 1`
                    (partition_po_32 l r t Pre14 Pre1 result Post1 result0
                    Post2 result1 Post3 i0 j0 t0 Inv Test13 t1 Post30)) in
                  (exist_2 [t2: (array N Z)][result6: Z]`l <= result6` /\
                  `result6 <= r` /\ (partition_p t2 l r result6) /\
                  (sub_permut l r t2 t) t1 result5 Post32) in
                (exist_2 [t2: (array N Z)][result5: Z]`l <= result5` /\
                `result5 <= r` /\ (partition_p t2 l r result5) /\
                (sub_permut l r t2 t) t1 result4 Post29) end) in
          (exist_4 [i1: Z][j1: Z][t2: (array N Z)][result4: Z]
          `l <= result4` /\ `result4 <= r` /\ (partition_p t2 l r result4) /\
          (sub_permut l r t2 t) i0 j0 t1 result3 Post27) in
        (exist_3 [i1: Z][t1: (array N Z)][result3: Z]`l <= result3` /\
        `result3 <= r` /\ (partition_p t1 l r result3) /\
        (sub_permut l r t1 t) i0 t0 result2 Post18) in
      (exist_2 [t1: (array N Z)][result2: Z]`l <= result2` /\
      `result2 <= r` /\ (partition_p t1 l r result2) /\
      (sub_permut l r t1 t) t0 result1 Post17) in
    (exist_2 [t1: (array N Z)][result1: Z]`l <= result1` /\ `result1 <= r` /\
    (partition_p t1 l r result1) /\ (sub_permut l r t1 t) t0 result0 Post16).

