(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Export Partition.
Require Import Omega.
Require Import ZArithRing.


 Proof.
 tauto.
Qed.

Proof.
intuition.
intros; ArraySubst t0.
Qed.


Proof.
intros; subst t1 t0 v.
auto with datatypes.
Qed.

Proof.
intros; omega.
Qed.

Proof.
intuition ArrayLength; omega.
Qed.

Proof.
intuition.
destruct result1; intuition.
Qed.

Proof.
intuition.
induction result1; auto.
 discriminate Post2.
Qed.

Proof.
intuition try discriminate.
omega.
omega.
replace (i3 - 1)%Z with (i2 - 1 + 1)%Z.
apply array_le_right_extension.
assumption.
ring (i2 - 1 + 1)%Z.
 assumption.
omega.
unfold Zwf; omega.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition ArrayLength; omega.
Qed.

 Proof.
 intuition.
induction result2; auto.
induction result2; auto.
Qed.

Proof.
intuition.
induction result2; auto || discriminate Post5.
induction result2; auto || discriminate Post5.
Qed.

Proof.
intuition.
apply array_ge_cons.
 intros j0 Hj0.
 elim (Z_le_gt_dec (j2 + 1) j0); intro.
elim H16; intros.
 apply H12; omega.
cut (j0 = j2); [ intro | omega ].
rewrite H12; omega.
apply array_ge_cons.
 intros j0 Hj0.
 omega.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition ArrayLength; omega.
Qed.

Proof.
intros.
decompose [and or] Invj; clear Invj.
 intuition unfold Zwf; ArrayLength; try omega.
replace (i3 - 1)%Z with (i2 - 1 + 1)%Z.
apply array_le_right_extension.
apply array_le_exchange with (t := t0) (x := i2) (y := j2).
omega.
 omega.
 assumption.
omega.
 apply exchange_sym; assumption.
ring (i2 - 1 + 1)%Z.
 elim Post25; intros.
 rewrite H26.
omega.
omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 generalize (sub_permut_length H20); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H27.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
rewrite <- H23.
elim Post25; intros.
apply H28; omega.
absurd (i2 < j2)%Z; omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 intuition; generalize (sub_permut_length H21); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H28.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
absurd (i2 < j2)%Z; omega.
Qed.

Proof.
intuition unfold Zwf; SameLength t t0; omega.
Qed.

Proof.
intuition.
apply array_le_empty; omega.
apply array_ge_empty; omega.
Qed.

Proof.
intuition SameLength t t0; omega.
Qed.

Proof.
intuition SameLength t t0; auto with *.
Qed.

Proof.
intuition.
apply piv.
omega.
omega.
apply array_le_cons.
intros i0 Hi0.
 elim (Z_le_lt_eq_dec l i0); intros.
(* case l < i *)
elim Post34; intros.
elim H11; intros.
rewrite H22.
 rewrite (H23 i0).
 rewrite H18.
 rewrite <- Post11.
apply H24; omega.
omega.
omega.
omega.
(* case l = i *)
elim Post34; intros.
rewrite <- b.
 rewrite H21.
 rewrite H22.
rewrite H18.
omega.
omega.
(* array_ge *)
apply array_ge_cons.
intros j0 Hj0.
elim Post34; intros.
 rewrite H22.
rewrite H18.
rewrite (H23 j0).
elim H15; intros.
 rewrite <- Post11.
 apply H24; omega.
SameLength t1 t0; SameLength t0 t; omega.
omega.
omega.
(* (sub_permut l r t1 t) *)
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := l) (j := i1).
omega.
omega.
assumption.
assumption.
Qed.

Proof.
intuition SameLength t0 t; omega.
Qed.

Proof.
intuition.
apply piv.
omega.
omega.
(* array_le *)
apply array_le_cons.
intros i0 Hi0.
 elim (Z_le_lt_eq_dec l i0); intros.
(* case l < i *)
elim Post30; intros.
 rewrite H22.
rewrite H18.
rewrite (H23 i0).
 elim H11; intros.
 rewrite <- Post11.
 apply H24; omega.
omega.
omega.
omega.
(* case l = i *)
rewrite <- b.
 elim Post30; intros.
rewrite H22.
 rewrite H18.
rewrite H21.
elim H11; intros.
 rewrite <- Post11.
 apply H24; omega.
omega.
(* array_ge *)
apply array_ge_cons.
intro j0.
 ring (i1 - 1 + 1)%Z.
 intro Hj.
 elim Post30; intros.
rewrite H22.
 rewrite (H23 j0).
rewrite H18.
elim H15; intros.
 elim (Z_le_lt_eq_dec i1 j0); intros.
(* case i0 < j *)
rewrite <- Post11.
 apply H24; omega.
(* case i0 = j *)
rewrite <- b.
 omega.
omega.
SameLength t1 t0; SameLength t0 t; omega.
omega.
omega.
(* (sub_permut t1 t l r) *)
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := l) (j := Zpred i1).
omega.
unfold Zpred; omega.
assumption.
assumption.
Qed.


Proof.
(* FILL PROOF HERE *)
Save.

