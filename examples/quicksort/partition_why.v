(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Exchange.
Require ArrayPermut.
Require Sorted.
Require Partition.

Tactic Definition Omega' := Abstract Omega.

(*Why*) Parameter N : Z.

Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (Pre3: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  `0 <= i` /\ `i < N`.
Proof. 
Intros; Omega.
Save.

Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre3: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  `0 <= j` /\ `j < N`.
Proof.
Intros; Omega.
Save.

Lemma swap_po_3 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre3: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  (Pre2: `0 <= j` /\ `j < N`)
  (exchange (store (store t i (access t j)) j result) t i j).
Proof.
Intros; Rewrite Post1.
Auto with datatypes.
Save.

Lemma partition_po_1 : 
  (l: Z)
  (r: Z)
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  `0 <= l` /\ `l < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_2 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (well_founded ? (Zwf `(-(N - 2))`)).
Proof.
Auto with *.
Save.

Lemma partition_po_3 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (well_founded ? (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma partition_po_4 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  `0 <= i1` /\ `i1 < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_5 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test3: (if true then `(access t0 i1) <= result`
           else `(access t0 i1) > result`))
  (result4: bool)
  (Bool3: (if result4 then `i1 < j0` else `i1 >= j0`))
  (if result4
   then ((if true then `(access t0 i1) <= result`
          else `(access t0 i1) > result`)) /\
   ((if true then `i1 < j0` else `i1 >= j0`)) \/
   ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
   true = false
   else ((if true then `(access t0 i1) <= result`
          else `(access t0 i1) > result`)) /\
   ((if false then `i1 < j0` else `i1 >= j0`)) \/
   ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
   false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_6 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test2: (if false then `(access t0 i1) <= result`
           else `(access t0 i1) > result`))
  (result4: bool)
  (Post4: result4 = false)
  (if result4
   then ((if true then `(access t0 i1) <= result`
          else `(access t0 i1) > result`)) /\
   ((if true then `i1 < j0` else `i1 >= j0`)) \/
   ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
   true = false
   else ((if true then `(access t0 i1) <= result`
          else `(access t0 i1) > result`)) /\
   ((if false then `i1 < j0` else `i1 >= j0`)) \/
   ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
   false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_7 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: (if true
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false))
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (i2: Z)
  (Post6: i2 = `i1 + 1`)
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
  (Zwf `0` `r - i2` `r - i1`).
Proof.
Intuition.
ICI.
Save.

Lemma partition_po_8 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: (if true
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false))
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (i2: Z)
  (Invi: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
         (Zwf `0` `r - i2` `r - i1`))
  (Zwf `0` `r - i2` Variant3).
Proof. (* partition_po_8 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_9 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: (if true
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false))
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (i2: Z)
  (Invi: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
         (Zwf `0` `r - i2` `r - i1`))
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result).
Proof. (* partition_po_9 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_10 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test4: (if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false))
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
  ((if false
    then ((if true then `(access t0 i1) <= result`
           else `(access t0 i1) > result`)) /\
    ((if true then `i1 < j0` else `i1 >= j0`)) \/
    ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
    true = false
    else ((if true then `(access t0 i1) <= result`
           else `(access t0 i1) > result`)) /\
    ((if false then `i1 < j0` else `i1 >= j0`)) \/
    ((if false then `(access t0 i1) <= result` else `(access t0 i1) > result`)) /\
    false = false)).
Proof. (* partition_po_10 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_11 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  `i0 <= i0` /\ `i0 <= r` /\ (array_le t0 `l + 1` `i0 - 1` result).
Proof. (* partition_po_11 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_12 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (well_founded ? (Zwf ZERO)).
Proof. (* partition_po_12 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_13 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  `0 <= j1` /\ `j1 < N`.
Proof. (* partition_po_13 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_14 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test7: (if true then `(access t0 j1) >= result`
           else `(access t0 j1) < result`))
  (result5: bool)
  (Bool5: (if result5 then `i1 < j1` else `i1 >= j1`))
  (if result5
   then ((if true then `(access t0 j1) >= result`
          else `(access t0 j1) < result`)) /\
   ((if true then `i1 < j1` else `i1 >= j1`)) \/
   ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
   true = false
   else ((if true then `(access t0 j1) >= result`
          else `(access t0 j1) < result`)) /\
   ((if false then `i1 < j1` else `i1 >= j1`)) \/
   ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
   false = false).
Proof. (* partition_po_14 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_15 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test6: (if false then `(access t0 j1) >= result`
           else `(access t0 j1) < result`))
  (result5: bool)
  (Post7: result5 = false)
  (if result5
   then ((if true then `(access t0 j1) >= result`
          else `(access t0 j1) < result`)) /\
   ((if true then `i1 < j1` else `i1 >= j1`)) \/
   ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
   true = false
   else ((if true then `(access t0 j1) >= result`
          else `(access t0 j1) < result`)) /\
   ((if false then `i1 < j1` else `i1 >= j1`)) \/
   ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
   false = false).
Proof. (* partition_po_15 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_16 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: (if true
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false))
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (j2: Z)
  (Post9: j2 = `j1 - 1`)
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
  (Zwf `0` j2 j1).
Proof. (* partition_po_16 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_17 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: (if true
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false))
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (j2: Z)
  (Invj: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
         (Zwf `0` j2 j1))
  (Zwf `0` j2 Variant5).
Proof. (* partition_po_17 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_18 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: (if true
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false))
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (j2: Z)
  (Invj: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
         (Zwf `0` j2 j1))
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result).
Proof. (* partition_po_18 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_19 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test8: (if false
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false))
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
  ((if false
    then ((if true then `(access t0 j1) >= result`
           else `(access t0 j1) < result`)) /\
    ((if true then `i1 < j1` else `i1 >= j1`)) \/
    ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
    true = false
    else ((if true then `(access t0 j1) >= result`
           else `(access t0 j1) < result`)) /\
    ((if false then `i1 < j1` else `i1 >= j1`)) \/
    ((if false then `(access t0 j1) >= result` else `(access t0 j1) < result`)) /\
    false = false)).
Proof. (* partition_po_19 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_20 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  `l <= j0` /\ `j0 <= j0` /\ (array_ge t0 `j0 + 1` r result).
Proof. (* partition_po_20 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_21 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         ((if false
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false)))
  (Test11: (if true then `i1 < j1` else `i1 >= j1`))
  `0 <= i1` /\ `i1 < N` /\ (`0 <= j1` /\ `j1 < N`).
Proof. (* partition_po_21 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_22 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         ((if false
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false)))
  (Test11: (if true then `i1 < j1` else `i1 >= j1`))
  (t1: (array N Z))
  (Post25: (exchange t1 t0 i1 j1))
  (i2: Z)
  (Post10: i2 = `i1 + 1`)
  (j2: Z)
  (Post11: j2 = `j1 - 1`)
  `l + 1 <= i2` /\ `i2 <= r` /\ `j2 <= r` /\
  (array_le t1 `l + 1` `i2 - 1` result) /\ (array_ge t1 `j2 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l) /\
  (Zwf `(-(N - 2))` `j2 - i2` `j0 - i0`).
Proof. (* partition_po_22 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_23 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         ((if false
           then ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if true then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           true = false
           else ((if true then `(access t0 i1) <= result`
                  else `(access t0 i1) > result`)) /\
           ((if false then `i1 < j0` else `i1 >= j0`)) \/
           ((if false then `(access t0 i1) <= result`
             else `(access t0 i1) > result`)) /\
           false = false)))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         ((if false
           then ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if true then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           true = false
           else ((if true then `(access t0 j1) >= result`
                  else `(access t0 j1) < result`)) /\
           ((if false then `i1 < j1` else `i1 >= j1`)) \/
           ((if false then `(access t0 j1) >= result`
             else `(access t0 j1) < result`)) /\
           false = false)))
  (Test10: (if false then `i1 < j1` else `i1 >= j1`))
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t0 `l + 1` `i1 - 1` result) /\ (array_ge t0 `j1 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\
  (Zwf `(-(N - 2))` `j1 - i1` `j0 - i0`).
Proof. (* partition_po_23 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_24 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
        (array_le t1 `l + 1` `i1 - 1` result) /\
        (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
        (access t1 l) = (access t l) /\
        (Zwf `(-(N - 2))` `j1 - i1` `j0 - i0`))
  (Zwf `(-(N - 2))` `j1 - i1` Variant1).
Proof. (* partition_po_24 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_25 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: (if true then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
        (array_le t1 `l + 1` `i1 - 1` result) /\
        (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
        (access t1 l) = (access t l) /\
        (Zwf `(-(N - 2))` `j1 - i1` `j0 - i0`))
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t1 `l + 1` `i1 - 1` result) /\ (array_ge t1 `j1 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l).
Proof. (* partition_po_25 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_26 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test1: (if false then `i0 < j0` else `i0 >= j0`))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
  (array_le t0 `l + 1` `i0 - 1` result) /\ (array_ge t0 `j0 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\
  ((if false then `i0 < j0` else `i0 >= j0`)).
Proof. (* partition_po_26 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_27 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  `l + 1 <= result0` /\ `result0 <= r` /\ `result1 <= r` /\
  (array_le t `l + 1` `result0 - 1` result) /\
  (array_ge t `result1 + 1` r result) /\ (sub_permut l r t t) /\
  (access t l) = (access t l).
Proof. (* partition_po_27 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_28 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\
        ((if false then `i0 < j0` else `i0 >= j0`)))
  `0 <= i0` /\ `i0 < N`.
Proof. (* partition_po_28 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_29 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\
        ((if false then `i0 < j0` else `i0 >= j0`)))
  (Test14: (if true then `(access t0 i0) < result`
            else `(access t0 i0) >= result`))
  `0 <= l` /\ `l < N` /\ (`0 <= i0` /\ `i0 < N`).
Proof. (* partition_po_29 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_30 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\
        ((if false then `i0 < j0` else `i0 >= j0`)))
  (Test14: (if true then `(access t0 i0) < result`
            else `(access t0 i0) >= result`))
  (t1: (array N Z))
  (Post34: (exchange t1 t0 l i0))
  `l <= i0` /\ `i0 <= r` /\ (partition_p t1 l r i0) /\ (sub_permut l r t1 t).
Proof. (* partition_po_30 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_31 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\
        ((if false then `i0 < j0` else `i0 >= j0`)))
  (Test13: (if false then `(access t0 i0) < result`
            else `(access t0 i0) >= result`))
  `0 <= l` /\ `l < N` /\ (`0 <= i0 - 1` /\ `i0 - 1 < N`).
Proof. (* partition_po_31 *)
(* FILL PROOF HERE *)
Save.

Lemma partition_po_32 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\
        ((if false then `i0 < j0` else `i0 >= j0`)))
  (Test13: (if false then `(access t0 i0) < result`
            else `(access t0 i0) >= result`))
  (t1: (array N Z))
  (Post30: (exchange t1 t0 l `i0 - 1`))
  `l <= i0 - 1` /\ `i0 - 1 <= r` /\ (partition_p t1 l r `i0 - 1`) /\
  (sub_permut l r t1 t).
Proof. (* partition_po_32 *)
(* FILL PROOF HERE *)
Save.

