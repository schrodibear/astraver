(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Export Partition.
Require Omega.
Require ZArithRing.


(* Why obligation from file "partition.mlw", characters 1353-1362 *)
Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  `0 <= j` /\ `j < (array_length t0)`.
Proof. 
Intros; ArraySubst t0.
Save.

(* Why obligation from file "partition.mlw", characters 1319-1371 *)
Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  (Pre1: `0 <= j` /\ `j < (array_length t0)`)
  (t1: (array Z))
  (Post2: t1 = (store t0 j v))
  (exchange t1 t i j).
Proof.
Intros; Subst t1 t0 v.
Auto with datatypes.
Save.


(* Why obligation from file "partition.mlw", characters 1579-1583 *)
Lemma partition_po_1 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  `0 <= l` /\ `l < (array_length t)`.
Proof.
Intros; Omega.
Save.

(* Why obligation from file "partition.mlw", characters 1932-1937 *)
Lemma partition_po_2 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre4: Variant3 = `r - i1`)
  (Invi: (`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv))
  `0 <= i1` /\ `i1 < (array_length t0)`.
Proof.
Intuition (ArrayLength; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 1947-1954 *)
Lemma partition_po_3 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre4: Variant3 = `r - i1`)
  (Invi: (`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv))
  (Test3: `(access t0 i1) <= pv`)
  (result3: bool)
  (Bool2: (if result3 then `i1 < j0` else `i1 >= j0`))
  (if result3 then `(access t0 i1) <= pv` /\ `i1 < j0` \/
   `(access t0 i1) > pv` /\ true = false else `(access t0 i1) <= pv` /\
   `i1 >= j0` \/ `(access t0 i1) > pv` /\ false = false).
Proof.
Intuition.
Induction result3; Auto.
Save.

(* Why obligation from file "partition.mlw", characters 1932-1954 *)
Lemma partition_po_4 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre4: Variant3 = `r - i1`)
  (Invi: (`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv))
  (Test2: `(access t0 i1) > pv`)
  (result3: bool)
  (Post2: result3 = false)
  (if result3 then `(access t0 i1) <= pv` /\ `i1 < j0` \/
   `(access t0 i1) > pv` /\ true = false else `(access t0 i1) <= pv` /\
   `i1 >= j0` \/ `(access t0 i1) > pv` /\ false = false).
Proof.
Intuition.
Induction result3; Auto.
Save.

(* Why obligation from file "partition.mlw", characters 1926-2077 *)
Lemma partition_po_5 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Pre4: Variant3 = `r - i1`)
  (Invi: (`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv))
  (Test5: `(access t0 i1) <= pv` /\ `i1 < j0` \/ `(access t0 i1) > pv` /\
          true = false)
  (i2: Z)
  (Post1: i2 = `i1 + 1`)
  ((`i0 <= i2` /\ `i2 <= r`) /\ (array_le t0 `l + 1` `i2 - 1` pv)) /\
  (Zwf `0` `r - i2` `r - i1`).
Proof.
Intuition Try Discriminate.
Omega.
Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Assumption.
Ring `(i1-1+1)`. Assumption.
Omega.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "partition.mlw", characters 1979-2030 *)
Lemma partition_po_6 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (`i0 <= i0` /\ `i0 <= r`) /\ (array_le t0 `l + 1` `i0 - 1` pv).
Proof.
Intuition.
Save.

(* Why obligation from file "partition.mlw", characters 2086-2091 *)
Lemma partition_po_7 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre7: Variant5 = j1)
  (Invj: (`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv))
  `0 <= j1` /\ `j1 < (array_length t0)`.
Proof.
Intuition (ArrayLength; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 2101-2108 *)
Lemma partition_po_8 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre7: Variant5 = j1)
  (Invj: (`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv))
  (Test7: `(access t0 j1) >= pv`)
  (result4: bool)
  (Bool4: (if result4 then `i1 < j1` else `i1 >= j1`))
  (if result4 then `(access t0 j1) >= pv` /\ `i1 < j1` \/
   `(access t0 j1) < pv` /\ true = false else `(access t0 j1) >= pv` /\
   `i1 >= j1` \/ `(access t0 j1) < pv` /\ false = false).
Proof. 
Intuition.
Induction result4; Auto.
Induction result4; Auto.
Save.

(* Why obligation from file "partition.mlw", characters 2086-2108 *)
Lemma partition_po_9 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre7: Variant5 = j1)
  (Invj: (`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv))
  (Test6: `(access t0 j1) < pv`)
  (result4: bool)
  (Post5: result4 = false)
  (if result4 then `(access t0 j1) >= pv` /\ `i1 < j1` \/
   `(access t0 j1) < pv` /\ true = false else `(access t0 j1) >= pv` /\
   `i1 >= j1` \/ `(access t0 j1) < pv` /\ false = false).
Proof.
Intuition.
Induction result4; Auto.
Induction result4; Auto.
Save.

(* Why obligation from file "partition.mlw", characters 2080-2221 *)
Lemma partition_po_10 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (Variant5: Z)
  (j1: Z)
  (Pre7: Variant5 = j1)
  (Invj: (`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv))
  (Test9: `(access t0 j1) >= pv` /\ `i1 < j1` \/ `(access t0 j1) < pv` /\
          true = false)
  (j2: Z)
  (Post4: j2 = `j1 - 1`)
  ((`l <= j2` /\ `j2 <= j0`) /\ (array_ge t0 `j2 + 1` r pv)) /\
  (Zwf `0` j2 j1).
Proof.
Intuition.
Apply array_ge_cons. Intros j Hj. Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Apply array_ge_cons. Intros j Hj. 
Elim (Z_le_gt_dec `j1+1` j); Intro.
Elim H17; Intros. Apply H13; Omega.
Cut `j = j1`; [ Intro | Omega ].
Rewrite H13; Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Save.

(* Why obligation from file "partition.mlw", characters 2127-2176 *)
Lemma partition_po_11 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (`l <= j0` /\ `j0 <= j0`) /\ (array_ge t0 `j0 + 1` r pv).
Proof.
Intuition.
Save.

(* Why obligation from file "partition.mlw", characters 2255-2269 *)
Lemma partition_po_12 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (j1: Z)
  (Invj: ((`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv)) /\
         (`(access t0 j1) >= pv` /\ `i1 >= j1` \/ `(access t0 j1) < pv` /\
         false = false))
  (Test11: `i1 < j1`)
  (`0 <= i1` /\ `i1 < (array_length t0)`) /\ `0 <= j1` /\
  `j1 < (array_length t0)`.
Proof.
Intuition (ArrayLength; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 2240-2306 *)
Lemma partition_po_13 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (j1: Z)
  (Invj: ((`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv)) /\
         (`(access t0 j1) >= pv` /\ `i1 >= j1` \/ `(access t0 j1) < pv` /\
         false = false))
  (Test11: `i1 < j1`)
  (Pre10: (`0 <= i1` /\ `i1 < (array_length t0)`) /\ `0 <= j1` /\
          `j1 < (array_length t0)`)
  (t1: (array Z))
  (Post25: (exchange t1 t0 i1 j1))
  (i2: Z)
  (Post7: i2 = `i1 + 1`)
  (j2: Z)
  (Post8: j2 = `j1 - 1`)
  ((`l + 1 <= i2` /\ `i2 <= r`) /\ `j2 <= r` /\
  (array_le t1 `l + 1` `i2 - 1` pv) /\ (array_ge t1 `j2 + 1` r pv) /\
  (sub_permut l r t1 t) /\ `(access t1 l) = (access t l)`) /\
  (Zwf `0` `(array_length t1) + 2 + j2 - i2` `(array_length t0) + 2 + j0 - i0`).
Proof.
Intros.
Decompose [and or] Invj; Clear Invj. 
Absurd `i1 < j1`; Omega.
Repeat (Apply conj); Try Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Decompose [and] Invi. Apply array_le_exchange with t:=t0 x:=i1 y:=j1.
Omega. Omega. 
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(i1-1+1)`. Elim Post25; Intros. Rewrite H7.
Omega.
Omega.
(* (array_ge t1 `(Zpred j1)+1` r (#t[l])) *)
Replace `j2+1` with `(j1+1)-1`.
Apply array_ge_left_extension.
Apply array_ge_exchange with t:=t0 x:=i1 y:=j1.
Omega. 
Intuition; Generalize (sub_permut_length H21); Intro; Omega.
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(j1+1-1)`. Elim Post25; Intros. Rewrite H8.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=i1 j:=j1; [Omega | Omega | Assumption].
Decompose [and] Inv; Assumption.
(* (access t1 l) = (access t l) *)
Decompose [and] Inv. Rewrite <- H11.
Elim Post25; Intros.
Apply H16; Omega.
Unfold Zwf; ArrayLength; Omega.
Save.

(* Why obligation from file "partition.mlw", characters 2224-2306 *)
Lemma partition_po_14 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (Variant1: Z)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Pre11: Variant1 = `(array_length t0) + 2 + j0 - i0`)
  (Inv: (`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: ((`i0 <= i1` /\ `i1 <= r`) /\ (array_le t0 `l + 1` `i1 - 1` pv)) /\
         (`(access t0 i1) <= pv` /\ `i1 >= j0` \/ `(access t0 i1) > pv` /\
         false = false))
  (j1: Z)
  (Invj: ((`l <= j1` /\ `j1 <= j0`) /\ (array_ge t0 `j1 + 1` r pv)) /\
         (`(access t0 j1) >= pv` /\ `i1 >= j1` \/ `(access t0 j1) < pv` /\
         false = false))
  (Test10: `i1 >= j1`)
  ((`l + 1 <= i1` /\ `i1 <= r`) /\ `j1 <= r` /\
  (array_le t0 `l + 1` `i1 - 1` pv) /\ (array_ge t0 `j1 + 1` r pv) /\
  (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
  (Zwf `0` `(array_length t0) + 2 + j1 - i1` `(array_length t0) + 2 + j0 - i0`).
Proof.
Intuition (Unfold Zwf; SameLength t t0; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 1685-1865 *)
Lemma partition_po_15 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (`l + 1 <= result` /\ `result <= r`) /\ `result0 <= r` /\
  (array_le t `l + 1` `result - 1` pv) /\ (array_ge t `result0 + 1` r pv) /\
  (sub_permut l r t t) /\ `(access t l) = (access t l)`.
Proof.
Intuition.
Apply array_le_empty; Omega.
Apply array_ge_empty; Omega.
Save.

(* Why obligation from file "partition.mlw", characters 2329-2334 *)
Lemma partition_po_16 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Inv: ((`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
        `i0 >= j0`)
  `0 <= i0` /\ `i0 < (array_length t0)`.
Proof.
Intuition (SameLength t t0; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 2359-2372 *)
Lemma partition_po_17 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Inv: ((`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
        `i0 >= j0`)
  (Test14: `(access t0 i0) < pv`)
  (`0 <= l` /\ `l < (array_length t0)`) /\ `0 <= i0` /\
  `i0 < (array_length t0)`.
Proof.
Intuition (SameLength t t0; Auto with *).
Save.

(* Why obligation from file "partition.mlw", characters 2383-2385 *)
Lemma partition_po_18 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Inv: ((`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
        `i0 >= j0`)
  (Test14: `(access t0 i0) < pv`)
  (Pre18: (`0 <= l` /\ `l < (array_length t0)`) /\ `0 <= i0` /\
          `i0 < (array_length t0)`)
  (t1: (array Z))
  (Post34: (exchange t1 t0 l i0))
  (`l <= i0` /\ `i0 <= r`) /\ (partition_p t1 l r i0) /\
  (sub_permut l r t1 t).
Proof.
Intuition.
Apply piv.
Omega.
Omega.
Apply array_le_cons.
Intros i Hi. Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post34; Intros.
Elim H9; Intros.
Rewrite H20. 
Rewrite (H21 i). Rewrite H16. Rewrite <- Post11.
Apply H22; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Elim Post34; Intros.
Rewrite <- b. Rewrite H19. Rewrite H20.
Rewrite H16.
Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intros j Hj.
Elim Post34; Intros. Rewrite H20.
Rewrite H16.
Rewrite (H21 j).
Elim H13; Intros. Rewrite <- Post11. Apply H22; Omega.
SameLength t1 t0; SameLength t0 t; Omega.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=i0.
Omega.
Omega.
Assumption.
Assumption.
Save.

(* Why obligation from file "partition.mlw", characters 2416-2435 *)
Lemma partition_po_19 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Inv: ((`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
        `i0 >= j0`)
  (Test13: `(access t0 i0) >= pv`)
  (`0 <= l` /\ `l < (array_length t0)`) /\ `0 <= i0 - 1` /\
  `i0 - 1 < (array_length t0)`.
Proof.
Intuition (SameLength t0 t; Omega).
Save.

(* Why obligation from file "partition.mlw", characters 2445-2451 *)
Lemma partition_po_20 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre20: (`0 <= l` /\ `l < r`) /\ `r < (array_length t)`)
  (Pre19: `0 <= l` /\ `l < (array_length t)`)
  (pv: Z)
  (Post11: pv = (access t l))
  (result: Z)
  (Post10: result = `l + 1`)
  (result0: Z)
  (Post9: result0 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array Z))
  (Inv: ((`l + 1 <= i0` /\ `i0 <= r`) /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` pv) /\ (array_ge t0 `j0 + 1` r pv) /\
        (sub_permut l r t0 t) /\ `(access t0 l) = (access t l)`) /\
        `i0 >= j0`)
  (Test13: `(access t0 i0) >= pv`)
  (Pre15: (`0 <= l` /\ `l < (array_length t0)`) /\ `0 <= i0 - 1` /\
          `i0 - 1 < (array_length t0)`)
  (t1: (array Z))
  (Post30: (exchange t1 t0 l `i0 - 1`))
  (`l <= i0 - 1` /\ `i0 - 1 <= r`) /\ (partition_p t1 l r `i0 - 1`) /\
  (sub_permut l r t1 t).
Proof.
Intuition.
Apply piv.
Omega.
Omega.
(* array_le *)
Apply array_le_cons.
Intros i Hi. 
Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post30; Intros. Rewrite H20.
Rewrite H16.
Rewrite (H21 i). Elim H9; Intros. 
Rewrite <- Post11. Apply H22; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Rewrite <- b. 
Elim Post30; Intros.
Rewrite H20. Rewrite H16.
Rewrite H19.
Elim H9; Intros. 
Rewrite <- Post11. Apply H22; Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intro j. Ring `i0-1+1`. Intro Hj. 
Elim Post30; Intros.
Rewrite H20. Rewrite (H21 j).
Rewrite H16.
Elim H13; Intros. 
Elim (Z_le_lt_eq_dec i0 j); Intros.
(* case i0 < j *)
Rewrite <- Post11. Apply H22; Omega.
(* case i0 = j *)
Rewrite <- b. Omega.
Omega.
SameLength t1 t0; SameLength t0 t; Omega.
Omega.
Omega.
(* (sub_permut t1 t l r) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=(Zpred i0).
Omega.
Unfold Zpred; Omega.
Assumption.
Assumption.
Save.


