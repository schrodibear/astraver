(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Exchange.
Require ArrayPermut.
Require Sorted.
Require Partition.
Require Omega.
Require ZArithRing.

(*Why*) Parameter N : Z.

Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  `0 <= i` /\ `i < N`.
Proof. 
Intros; Omega.
Save.

Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  `0 <= j` /\ `j < N`.
Proof.
Intros; Omega.
Save.

Lemma swap_po_3 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: `0 <= i` /\ `i < N` /\ (`0 <= j` /\ `j < N`))
  (Pre1: `0 <= i` /\ `i < N`)
  (result: Z)
  (Post1: result = (access t i))
  (Pre2: `0 <= j` /\ `j < N`)
  (t0: (array N Z))
  (Post2: t0 = (store t i (access t j)))
  (t1: (array N Z))
  (Post3: t1 = (store t0 j result))
  (exchange t1 t i j).
Proof.
Intros; Rewrite Post3; Rewrite Post2; Rewrite Post1.
Auto with datatypes.
Save.

Lemma partition_po_1 : 
  (l: Z)
  (r: Z)
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  `0 <= l` /\ `l < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_2 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (well_founded ? (Zwf `(-N) - 2`)).
Proof.
Auto with *.
Save.

Lemma partition_po_3 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (well_founded ? (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma partition_po_4 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  `0 <= i1` /\ `i1 < N`.
Proof.
Intros; Omega.
Save.

Lemma partition_po_5 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test3: `(access t0 i1) <= result`)
  (result4: bool)
  (Bool3: (if result4 then `i1 < j0` else `i1 >= j0`))
  (if result4 then `(access t0 i1) <= result` /\ `i1 < j0` \/
   `(access t0 i1) > result` /\ true = false
   else `(access t0 i1) <= result` /\ `i1 >= j0` \/
   `(access t0 i1) > result` /\ false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_6 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test2: `(access t0 i1) > result`)
  (result4: bool)
  (Post4: result4 = false)
  (if result4 then `(access t0 i1) <= result` /\ `i1 < j0` \/
   `(access t0 i1) > result` /\ true = false
   else `(access t0 i1) <= result` /\ `i1 >= j0` \/
   `(access t0 i1) > result` /\ false = false).
Proof.
Intuition.
Induction result4; Auto.
Save.

Lemma partition_po_7 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Post6: i2 = `i1 + 1`)
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
  (Zwf `0` `r - i2` `r - i1`).
Proof.
Intuition Try Discriminate.
Omega.
Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Assumption.
Ring `(i1-1+1)`. Assumption.
Omega.
Unfold Zwf; Omega.
Save.

Lemma partition_po_8 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Invi: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
         (Zwf `0` `r - i2` `r - i1`))
  (Zwf `0` `r - i2` Variant3).
Proof. 
Intros. Rewrite Pre5; Tauto.
Save.

Lemma partition_po_9 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test5: `(access t0 i1) <= result` /\ `i1 < j0` \/
          `(access t0 i1) > result` /\ true = false)
  (i2: Z)
  (Invi: `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result) /\
         (Zwf `0` `r - i2` `r - i1`))
  `i0 <= i2` /\ `i2 <= r` /\ (array_le t0 `l + 1` `i2 - 1` result).
Proof.
Intuition.
Save.

Lemma partition_po_10 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (Variant3: Z)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result))
  (Pre5: Variant3 = `r - i1`)
  (Test4: `(access t0 i1) <= result` /\ `i1 >= j0` \/
          `(access t0 i1) > result` /\ false = false)
  `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
  (`(access t0 i1) <= result` /\ `i1 >= j0` \/ `(access t0 i1) > result` /\
  false = false).
Proof.
Intuition.
Save.

Lemma partition_po_11 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  `i0 <= i0` /\ `i0 <= r` /\ (array_le t0 `l + 1` `i0 - 1` result).
Proof.
Intuition.
Save.

Lemma partition_po_12 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (well_founded ? (Zwf ZERO)).
Proof.
Intuition.
Save.

Lemma partition_po_13 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  `0 <= j1` /\ `j1 < N`.
Proof.
Intuition.
Save.

Lemma partition_po_14 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test7: `(access t0 j1) >= result`)
  (result5: bool)
  (Bool5: (if result5 then `i1 < j1` else `i1 >= j1`))
  (if result5 then `(access t0 j1) >= result` /\ `i1 < j1` \/
   `(access t0 j1) < result` /\ true = false
   else `(access t0 j1) >= result` /\ `i1 >= j1` \/
   `(access t0 j1) < result` /\ false = false).
Proof.
Intuition.
Induction result5; Auto.
Induction result5; Auto.
Save.

Lemma partition_po_15 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test6: `(access t0 j1) < result`)
  (result5: bool)
  (Post7: result5 = false)
  (if result5 then `(access t0 j1) >= result` /\ `i1 < j1` \/
   `(access t0 j1) < result` /\ true = false
   else `(access t0 j1) >= result` /\ `i1 >= j1` \/
   `(access t0 j1) < result` /\ false = false).
Proof.
Intuition.
Induction result5; Auto.
Induction result5; Auto.
Save.

Lemma partition_po_16 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Post9: j2 = `j1 - 1`)
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
  (Zwf `0` j2 j1).
Proof.
Intuition.
Apply array_ge_cons. Intros j Hj. Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Apply array_ge_cons. Intros j Hj. 
Elim (Z_le_gt_dec `j1+1` j); Intro.
Elim H19; Intros. Apply H17; Omega.
Cut `j = j1`; [ Intro | Omega ].
Rewrite H17; Omega.
Unfold Zwf; Omega.
Discriminate H21.
Discriminate H21.
Discriminate H21.
Save.

Lemma partition_po_17 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Invj: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
         (Zwf `0` j2 j1))
  (Zwf `0` j2 Variant5).
Proof.
Intros.
Rewrite Pre8; Tauto.
Save.

Lemma partition_po_18 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test9: `(access t0 j1) >= result` /\ `i1 < j1` \/
          `(access t0 j1) < result` /\ true = false)
  (j2: Z)
  (Invj: `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result) /\
         (Zwf `0` j2 j1))
  `l <= j2` /\ `j2 <= j0` /\ (array_ge t0 `j2 + 1` r result).
Proof.
Tauto. 
Save.

Lemma partition_po_19 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (Variant5: Z)
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result))
  (Pre8: Variant5 = j1)
  (Test8: `(access t0 j1) >= result` /\ `i1 >= j1` \/
          `(access t0 j1) < result` /\ false = false)
  `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
  (`(access t0 j1) >= result` /\ `i1 >= j1` \/ `(access t0 j1) < result` /\
  false = false).
Proof.
Tauto.
Save.

Lemma partition_po_20 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  `l <= j0` /\ `j0 <= j0` /\ (array_ge t0 `j0 + 1` r result).
Proof.
Intuition.
Save.

Lemma partition_po_21 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test11: `i1 < j1`)
  `0 <= i1` /\ `i1 < N` /\ (`0 <= j1` /\ `j1 < N`).
Proof.
Intuition.
Save.

Lemma partition_po_22 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test11: `i1 < j1`)
  (t1: (array N Z))
  (Post25: (exchange t1 t0 i1 j1))
  (i2: Z)
  (Post10: i2 = `i1 + 1`)
  (j2: Z)
  (Post11: j2 = `j1 - 1`)
  `l + 1 <= i2` /\ `i2 <= r` /\ `j2 <= r` /\
  (array_le t1 `l + 1` `i2 - 1` result) /\ (array_ge t1 `j2 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l) /\
  (Zwf `(-N) - 2` `j2 - i2` `j0 - i0`).
Proof.
Intros.
Decompose [and or] Invj; Clear Invj. 
Absurd `i1 < j1`; Omega.
Repeat (Apply conj); Try Omega.
Replace `i2-1` with `(i1-1)+1`.
Apply array_le_right_extension.
Decompose [and] Invi. Apply array_le_exchange with t:=t0 x:=i1 y:=j1.
Omega. Omega. 
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(i1-1+1)`. Elim Post25; Intros. Rewrite H6.
Omega.
Omega.
(* (array_ge t1 `(Zpred j1)+1` r (#t[l])) *)
Replace `j2+1` with `(j1+1)-1`.
Apply array_ge_left_extension.
Apply array_ge_exchange with t:=t0 x:=i1 y:=j1.
Omega. Omega. 
Assumption. Omega. Apply exchange_sym; Assumption.
Ring `(j1+1-1)`. Elim Post25; Intros. Rewrite H7.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=i1 j:=j1; [Omega | Omega | Assumption].
Decompose [and] Inv; Assumption.
(* (access t1 l) = (access t l) *)
Decompose [and] Inv. Rewrite <- H11.
Elim Post25; Intros.
Apply H15; Omega.
Unfold Zwf; Omega.
Save.

Lemma partition_po_23 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (Invi: `i0 <= i1` /\ `i1 <= r` /\ (array_le t0 `l + 1` `i1 - 1` result) /\
         (`(access t0 i1) <= result` /\ `i1 >= j0` \/
         `(access t0 i1) > result` /\ false = false))
  (j1: Z)
  (Invj: `l <= j1` /\ `j1 <= j0` /\ (array_ge t0 `j1 + 1` r result) /\
         (`(access t0 j1) >= result` /\ `i1 >= j1` \/
         `(access t0 j1) < result` /\ false = false))
  (Test10: `i1 >= j1`)
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t0 `l + 1` `i1 - 1` result) /\ (array_ge t0 `j1 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\
  (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`).
Proof.
Intros.
Repeat (Apply conj); Tauto Orelse Unfold Zwf; Omega.
Save.


Lemma partition_po_24 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
        (array_le t1 `l + 1` `i1 - 1` result) /\
        (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
        (access t1 l) = (access t l) /\ (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`))
  (Zwf `(-N) - 2` `j1 - i1` Variant1).
Proof. 
Intros; Rewrite Pre10; Tauto.
Save.

Lemma partition_po_25 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test12: `i0 < j0`)
  (i1: Z)
  (j1: Z)
  (t1: (array N Z))
  (Inv: `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
        (array_le t1 `l + 1` `i1 - 1` result) /\
        (array_ge t1 `j1 + 1` r result) /\ (sub_permut l r t1 t) /\
        (access t1 l) = (access t l) /\ (Zwf `(-N) - 2` `j1 - i1` `j0 - i0`))
  `l + 1 <= i1` /\ `i1 <= r` /\ `j1 <= r` /\
  (array_le t1 `l + 1` `i1 - 1` result) /\ (array_ge t1 `j1 + 1` r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l).
Proof.
Tauto.
Save.

Lemma partition_po_26 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (Variant1: Z)
  (t0: (array N Z))
  (j0: Z)
  (i0: Z)
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l))
  (Pre10: Variant1 = `j0 - i0`)
  (Test1: `i0 >= j0`)
  `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
  (array_le t0 `l + 1` `i0 - 1` result) /\ (array_ge t0 `j0 + 1` r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l) /\ `i0 >= j0`.
Proof.
Intuition.
Save.

Lemma partition_po_27 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  `l + 1 <= result0` /\ `result0 <= r` /\ `result1 <= r` /\
  (array_le t `l + 1` `result0 - 1` result) /\
  (array_ge t `result1 + 1` r result) /\ (sub_permut l r t t) /\
  (access t l) = (access t l).
Proof.
Intuition.
Apply array_le_empty; Omega.
Apply array_ge_empty; Omega.
Save.

Lemma partition_po_28 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma partition_po_29 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test14: `(access t0 i0) < result`)
  `0 <= l` /\ `l < N` /\ (`0 <= i0` /\ `i0 < N`).
Proof.
Intuition.
Save.

Lemma partition_po_30 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test14: `(access t0 i0) < result`)
  (t1: (array N Z))
  (Post34: (exchange t1 t0 l i0))
  `l <= i0` /\ `i0 <= r` /\ (partition_p t1 l r i0) /\ (sub_permut l r t1 t).
Proof.
Intuition; Clear result3 Bool7.
Apply piv.
Omega.
Omega.
Apply array_le_cons.
Intros i Hi. Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post34; Intros.
Elim H7; Intros.
Rewrite H15. 
Rewrite (H16 i). Rewrite H10. Rewrite <- Post1.
Apply H17; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Elim Post34; Intros.
Rewrite <- b. Rewrite H14. Rewrite H15.
Rewrite H10.
Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intros j Hj.
Elim Post34; Intros. Rewrite H15.
Rewrite H10.
Rewrite (H16 j).
Elim H8; Intros. Rewrite <- Post1. Apply H17; Omega.
Omega.
Omega.
Omega.
(* (sub_permut l r t1 t) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=i0.
Omega.
Omega.
Assumption.
Assumption.
Save.

Lemma partition_po_31 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test13: `(access t0 i0) >= result`)
  `0 <= l` /\ `l < N` /\ (`0 <= i0 - 1` /\ `i0 - 1 < N`).
Proof. 
Intuition.
Save.

Lemma partition_po_32 : 
  (l: Z)
  (r: Z)
  (t: (array N Z))
  (Pre14: `0 <= l` /\ `l < r` /\ `r < N`)
  (Pre1: `0 <= l` /\ `l < N`)
  (result: Z)
  (Post1: result = (access t l))
  (result0: Z)
  (Post2: result0 = `l + 1`)
  (result1: Z)
  (Post3: result1 = r)
  (i0: Z)
  (j0: Z)
  (t0: (array N Z))
  (Inv: `l + 1 <= i0` /\ `i0 <= r` /\ `j0 <= r` /\
        (array_le t0 `l + 1` `i0 - 1` result) /\
        (array_ge t0 `j0 + 1` r result) /\ (sub_permut l r t0 t) /\
        (access t0 l) = (access t l) /\ `i0 >= j0`)
  (Test13: `(access t0 i0) >= result`)
  (t1: (array N Z))
  (Post30: (exchange t1 t0 l `i0 - 1`))
  `l <= i0 - 1` /\ `i0 - 1 <= r` /\ (partition_p t1 l r `i0 - 1`) /\
  (sub_permut l r t1 t).
Proof.
Intuition; Clear result3 Bool7.
Apply piv.
Omega.
Omega.
(* array_le *)
Apply array_le_cons.
Intros i Hi. 
Elim (Z_le_lt_eq_dec l i); Intros.
(* case l < i *)
Elim Post30; Intros. Rewrite H15.
Rewrite H10.
Rewrite (H16 i). Elim H7; Intros. 
Rewrite <- Post1. Apply H17; Omega.
Omega.
Omega.
Omega.
(* case l = i *)
Rewrite <- b. 
Elim Post30; Intros.
Rewrite H15. Rewrite H10.
Rewrite H14.
Elim H7; Intros. 
Rewrite <- Post1. Apply H17; Omega.
Omega.
(* array_ge *)
Apply array_ge_cons.
Intro j. Ring `i0-1+1`. Intro Hj. 
Elim Post30; Intros.
Rewrite H15. Rewrite (H16 j).
Rewrite H10.
Elim H8; Intros. 
Elim (Z_le_lt_eq_dec i0 j); Intros.
(* case i0 < j *)
Rewrite <- Post1. Apply H17; Omega.
(* case i0 = j *)
Rewrite <- b. Omega.
Omega.
Omega.
Omega.
Omega.
(* (sub_permut t1 t l r) *)
Apply sub_permut_trans with t':=t0.
Apply exchange_is_sub_permut with i:=l j:=(Zpred i0).
Omega.
Unfold Zpred; Omega.
Assumption.
Assumption.
Save.

