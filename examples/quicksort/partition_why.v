(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Export Partition.
Require Import Omega.
Require Import ZArithRing.

(* Why obligation from file "partition.mlw", line 25, characters 7-16: *)
(*Why goal*) Lemma swap_po_1 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  (0 <= j /\ j < (array_length t0)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 27, characters 6-27: *)
(*Why goal*) Lemma swap_po_2 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  forall (HW_8: 0 <= j /\ j < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_9: t1 = (update t0 j result)),
  (exchange t1 t i j).
Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
ArraySubst t0.
Save.

Proof.
intuition.
subst; auto with *.
Save.


Definition swap_functional (* validation *)
  : forall (i: Z), forall (j: Z), forall (t: (array Z)), forall (_: (0 <=
    i /\ i < (array_length t)) /\ 0 <= j /\ j < (array_length t)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  => ((exchange t0 t i j))))
  := (fun (i: Z) (j: Z) (t: (array Z)) (H_1: (0 <= i /\ i <
          (array_length t)) /\ 0 <= j /\ j < (array_length t)) =>
        let v :=
          let Pre1 := 0 <= i /\ i < (array_length t) in
          let (result0, Post1) := (array_get i t) in
          (exist_1 (fun (result1: Z) => result1 = (access t i)) (result0) (
          result0 = (access t i))) in
        let (t0, result) :=
          let (t0, result) :=
            let aux_1 :=
              let Pre2 := 0 <= j /\ j < (array_length t) in
              let (result0, Post2) := (array_get j t) in
              (exist_1 (fun (result1: Z) => result1 = (access t j)) (
              result0) (result0 = (access t j))) in
            let (t0, result) :=
              let Pre3 := 0 <= i /\ i < (array_length t) in
              let (t0, result0, Post3) := (array_set i aux_1 t) in
              (exist_2 (fun (t1: (array Z)) =>
                        (fun (result1: unit) => t1 = (update t i aux_1))) (
              t0) (result0) (t0 = (update t i aux_1))) in
            (Build_tuple_2 (t0) (result)) in
          let (t1, result0) :=
            let Pre4 := 0 <= j /\ j < (array_length t0) in
            let (t1, result1, Post4) := (array_set j v t0) in
            (exist_2 (fun (t2: (array Z)) =>
                      (fun (result2: unit) => t2 = (update t0 j v))) (
            t1) (result1) (t1 = (update t0 j v))) in
          (Build_tuple_2 (t1) (result0)) in
        (Build_tuple_2 (t0) (result))).


(*Why logic*) Definition array_le : (array Z) -> Z -> Z -> Z -> Prop.
Admitted.

(*Why logic*) Definition array_ge : (array Z) -> Z -> Z -> Z -> Prop.
Admitted.

(* Why obligation from file "partition.mlw", line 38, characters 13-17: *)
(*Why goal*) Lemma partition_po_1 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  (0 <= l /\ l < (array_length t)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_2 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  (((l + 1) <= (l + 1) /\ (l + 1) <= r) /\ r <= r /\
  (array_le t (l + 1) (l + 1 - 1) result) /\ (array_ge t (r + 1) r result) /\
  (sub_permut l r t t) /\ (access t l) = (access t l)).
Proof.
intuition.
apply array_le_empty; omega.
apply array_ge_empty; omega.
Save.

(* Why obligation from file "partition.mlw", line 52, characters 21-72: *)
(*Why goal*) Lemma partition_po_3 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  ((i <= i /\ i <= r) /\ (array_le t0 (l + 1) (i - 1) result)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 51, characters 7-12: *)
(*Why goal*) Lemma partition_po_4 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  (0 <= i0 /\ i0 < (array_length t0)).
Proof.
intuition ArrayLength; omega.
Save.

(* Why obligation from file "partition.mlw", line 52, characters 21-72: *)
(*Why goal*) Lemma partition_po_5 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_10: i0 < j),
  forall (i1: Z),
  forall (HW_11: i1 = (i0 + 1)),
  ((i <= i1 /\ i1 <= r) /\ (array_le t0 (l + 1) (i1 - 1) result)).
Proof.
intuition; subst.
replace (i0+1-1) with ((i0-1)+1).
apply array_le_right_extension; intuition.
ring (i0-1+1); auto.
omega.
Save.

(* Why obligation from file "partition.mlw", line 53, characters 20-23: *)
(*Why goal*) Lemma partition_po_6 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_10: i0 < j),
  forall (i1: Z),
  forall (HW_11: i1 = (i0 + 1)),
  (Zwf 0 (r - i1) (r - i0)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 57, characters 15-64: *)
(*Why goal*) Lemma partition_po_7 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  ((l <= j /\ j <= j) /\ (array_ge t0 (j + 1) r result)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 56, characters 7-12: *)
(*Why goal*) Lemma partition_po_8 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  (0 <= j0 /\ j0 < (array_length t0)).
Proof.
intuition; subst.
apply array_ge_cons.
 intros j1 Hj1.
 elim (Z_le_gt_dec (j0 + 1) j1); intro.
assert (h: array_ge t0 (j + 1) r (access t l)). assumption.
elim h; intros.
auto with *.
cut (j0 = j1); [ intro | omega ].
subst.
 omega.
Save.

(* Why obligation from file "partition.mlw", line 57, characters 15-64: *)
(*Why goal*) Lemma partition_po_9 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_17: i0 < j0),
  forall (j1: Z),
  forall (HW_18: j1 = (j0 - 1)),
  ((l <= j1 /\ j1 <= j) /\ (array_ge t0 (j1 + 1) r result)).
Proof.
intuition.
Save.

Ltac elimh p :=  match goal with
  | h:p |- _ => elim h
end.

(* Why obligation from file "partition.mlw", line 58, characters 20-21: *)
(*Why goal*) Lemma partition_po_10 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_17: i0 < j0),
  forall (j1: Z),
  forall (HW_18: j1 = (j0 - 1)),
  (Zwf 0 j1 j0).
Proof.
intuition.
replace (i1 - 1)%Z with (i0 - 1 + 1)%Z.
apply array_le_right_extension.
apply array_le_exchange with (t := t0) (x := i0) (y := j0).
omega.
 omega.
 assumption.
omega.
 apply exchange_sym; assumption.
ring (i0 - 1 + 1)%Z.
 elimh (exchange t1 t0 i0 j0); intros.
 replace (access t1 i0) with (access t0 j0); auto.
omega.
omega.
replace (j1 + 1)%Z with (j0 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i0) (y := j0).
omega.
  SameLength t t0.
 omega.
assumption.
omega.
 apply exchange_sym; assumption.
ring (j0 + 1 - 1)%Z.
 elimh (exchange t1 t0 i0 j0); intros.
 replace (access t1 j0) with (access t0 i0); auto.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i0) (j := j0);
 [ omega | omega | assumption ].
assumption.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_11 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_19: i0 >= j0),
  forall (HW_20: i0 < j0),
  forall (HW_21: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_22: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_23: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_24: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_12 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_19: i0 >= j0),
  forall (HW_20: i0 < j0),
  forall (HW_21: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_22: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_23: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_24: j1 = (j0 - 1)),
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_13 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_25: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)).
Proof.
intuition.
replace (i1 - 1)%Z with (i0 - 1 + 1)%Z.
apply array_le_right_extension.
apply array_le_exchange with (t := t0) (x := i0) (y := j0).
omega.
 omega.
 assumption.
omega.
 apply exchange_sym; assumption.
ring (i0 - 1 + 1)%Z.
  elimh (exchange t1 t0 i0 j0); intros.
  replace (access t1 i0) with (access t0 j0); auto.
omega.
omega.
replace (j1 + 1)%Z with (j0 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i0) (y := j0).
omega.
 SameLength t t0.
 omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j0 + 1 - 1)%Z.
  elimh (exchange t1 t0 i0 j0); intros.
  replace (access t1 j0) with (access t0 i0); auto.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i0) (j := j0);
 [ omega | omega | assumption ].
assumption.
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_14 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_25: i0 >= j0),
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_15 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_27: i0 < j0),
  forall (HW_28: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_29: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_30: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_31: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_16 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_27: i0 < j0),
  forall (HW_28: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_29: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_30: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_31: j1 = (j0 - 1)),
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
SameLength t t0.
omega.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_17 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_32: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)).
Proof.
intuition.
apply array_ge_cons.
 intros j' Hj'.
 elim (Z_le_gt_dec (j0 + 1) j'); intro.
 elimh (array_ge t0 (j0 + 1) r result); intros.
  auto with *.
cut (j' = j0); [ intro | omega ].
subst; omega.
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_18 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_32: i0 >= j0),
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 57, characters 15-64: *)
(*Why goal*) Lemma partition_po_19 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  ((l <= j /\ j <= j) /\ (array_ge t0 (j + 1) r result)).
Proof.
intros; absurd (i0 < j0); omega.
Save.

(* Why obligation from file "partition.mlw", line 56, characters 7-12: *)
(*Why goal*) Lemma partition_po_20 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  (0 <= j0 /\ j0 < (array_length t0)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 57, characters 15-64: *)
(*Why goal*) Lemma partition_po_21 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_38: i0 < j0),
  forall (j1: Z),
  forall (HW_39: j1 = (j0 - 1)),
  ((l <= j1 /\ j1 <= j) /\ (array_ge t0 (j1 + 1) r result)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 58, characters 20-21: *)
(*Why goal*) Lemma partition_po_22 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_38: i0 < j0),
  forall (j1: Z),
  forall (HW_39: j1 = (j0 - 1)),
  (Zwf 0 j1 j0).
Proof.
intuition.
apply array_le_cons.
intros i' Hi'.
 elim (Z_le_lt_eq_dec l i'); intros.
(* case l < i' *)
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
assert (i' < i0 \/ i'=i0). omega. intuition.
rewrite h6; try omega.
elimh (array_le t0 (l + 1) (i0 - 1) result); auto with *.
subst i'; rewrite h4; omega.
(* case l = i' *)
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
omega.
omega.
(* array_ge *)
apply array_ge_cons.
intros j' Hj'.
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
assert (j0 < j' \/ j'=j0). omega. intuition.
rewrite h6; try omega.
elimh (array_ge t0 (j0 + 1) r result); auto with *.
SameLength t0 t; omega.
subst j'; rewrite h5; omega.
(* (sub_permut l r t1 t) *)
apply sub_permut_trans with (t' := t0); auto.
apply exchange_is_sub_permut with (i := i0) (j := j0).
omega.
omega.
assumption.
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
rewrite (h6 l); try omega.
unfold Zwf; intuition.
SameLength t1 t0; omega.
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_23 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_40: i0 >= j0),
  forall (HW_41: i0 < j0),
  forall (HW_42: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_43: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_44: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_45: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)).
Proof.
intuition.
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_24 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_40: i0 >= j0),
  forall (HW_41: i0 < j0),
  forall (HW_42: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_43: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_44: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_45: j1 = (j0 - 1)),
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
SameLength t0 t; omega.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
apply piv.
omega.
omega.
(* array_le *)
apply array_le_cons.
intros i' Hi'.
 elim (Z_le_lt_eq_dec l i'); intros.
(* case l < i *)
elimh (exchange t1 t0 l i); intros h1 h2 h3 h4 h5 h6.
rewrite h6.
rewrite h5.
subst.
replace (access t0 l) with (access t l); auto.
elimh (array_le t0 (l + 1) (i - 1) (access t l)); auto with *.
omega.
omega.
omega.
(* case l = i *)
subst.
elimh (exchange t1 t0 i' i); intros h1 h2 h3 h4 h5 h6.
rewrite h4.
rewrite h5.
omega.
omega.
(* array_ge *)
apply array_ge_cons.
intros i' Hi'.
subst.
 ring (i1 - 1 + 1)%Z.
 intro Hj.
 elim Post30; intros.
rewrite H22.
 rewrite (H23 j0).
rewrite H18.
elim H15; intros.
 elim (Z_le_lt_eq_dec i1 j0); intros.
(* case i0 < j *)
rewrite <- Post11.
 apply H24; omega.
(* case i0 = j *)
rewrite <- b.
 omega.
omega.
SameLength t1 t0; SameLength t0 t; omega.
omega.
omega.
(* (sub_permut t1 t l r) *)
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := l) (j := Zpred i1).
omega.
unfold Zpred; omega.
assumption.
assumption.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition ArrayLength; omega.
Qed.

 Proof.
 intuition.
induction result2; auto.
induction result2; auto.
Qed.

Proof.
intuition.
induction result2; auto || discriminate Post5.
induction result2; auto || discriminate Post5.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition.
rewrite <- H23.
elim Post25; intros.
apply H28; omega.
absurd (i2 < j2)%Z; omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 intuition; generalize (sub_permut_length H21); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H28.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
absurd (i2 < j2)%Z; omega.
Qed.

Proof.
intuition ArrayLength; omega.
Qed.

Proof.
intros.
decompose [and or] Invj; clear Invj.
 intuition unfold Zwf; ArrayLength; try omega.
Qed.

Proof.
intuition unfold Zwf; SameLength t t0; omega.
rewrite <- H23.
elim Post25; intros.
apply H28; omega.
absurd (i2 < j2)%Z; omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 intuition; generalize (sub_permut_length H21); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H28.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
absurd (i2 < j2)%Z; omega.
Qed.

Proof.
intuition.
apply array_le_empty; omega.
apply array_ge_empty; omega.
Qed.

Proof.
intuition SameLength t t0; omega.
Qed.

Proof.
intuition SameLength t t0; auto with *.
Qed.

Proof.
intuition.
apply piv.
omega.
omega.
Qed.

Proof.
intuition SameLength t0 t; omega.
Qed.

Proof.
intuition.
Qed.


Proof.
intuition.
Save.


(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_25 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_46: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_26 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_46: i0 >= j0),
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_27 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_48: i0 < j0),
  forall (HW_49: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_50: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_51: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_52: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_28 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_48: i0 < j0),
  forall (HW_49: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_50: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_51: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_52: j1 = (j0 - 1)),
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 44, characters 19-199: *)
(*Why goal*) Lemma partition_po_29 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_53: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 49, characters 18-39: *)
(*Why goal*) Lemma partition_po_30 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_53: i0 >= j0),
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 67, characters 10-15: *)
(*Why goal*) Lemma partition_po_31 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  (0 <= i /\ i < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 68, characters 9-20: *)
(*Why goal*) Lemma partition_po_32 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_57: result0 < result),
  ((0 <= l /\ l < (array_length t0)) /\ 0 <= i /\ i < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 75, characters 6-90: *)
(*Why goal*) Lemma partition_po_33 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_57: result0 < result),
  forall (HW_58: (0 <= l /\ l < (array_length t0)) /\ 0 <= i /\ i <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_59: (exchange t1 t0 l i)),
  ((l <= i /\ i <= r) /\ (partition_p t1 l r i) /\ (sub_permut l r t1 t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 71, characters 9-26: *)
(*Why goal*) Lemma partition_po_34 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_60: result0 >= result),
  ((0 <= l /\ l < (array_length t0)) /\ 0 <= (i - 1) /\ (i - 1) <
  (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "partition.mlw", line 75, characters 6-90: *)
(*Why goal*) Lemma partition_po_35 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_60: result0 >= result),
  forall (HW_61: (0 <= l /\ l < (array_length t0)) /\ 0 <= (i - 1) /\
                 (i - 1) < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_62: (exchange t1 t0 l (i - 1))),
  ((l <= (i - 1) /\ (i - 1) <= r) /\ (partition_p t1 l r (i - 1)) /\
  (sub_permut l r t1 t)).
Proof.
(* FILL PROOF HERE *)
Save.

Definition partition_functional (* validation *)
  : forall (l: Z), forall (r: Z), forall (t: (array Z)), forall (_: (0 <=
    l /\ l < r) /\ r < (array_length t)),
    (sig_2 (array Z) Z
     (fun (t0: (array Z)) (result: Z)  => ((l <= result /\ result <= r) /\
      (partition_p t0 l r result) /\ (sub_permut l r t0 t))))
  := (fun (l: Z) (r: Z) (t: (array Z)) (H_1: (0 <= l /\ l < r) /\ r <
          (array_length t)) =>
        let pv :=
          let Pre1 := 0 <= l /\ l < (array_length t) in
          let (result0, Post1) := (array_get l t) in
          (exist_1 (fun (result1: Z) => result1 = (access t l)) (result0) (
          result0 = (access t l))) in
        let (t0, result) :=
          let (i1, t0, result) :=
            let (i1, j1, t0, result) :=
              let (i1, j1, t0, result) :=
                let (i1, j1, t0, result) :=
                  ((well_founded_induction) (Z) ((Zwf Z0)) ((well_founded (Zwf Z0))) ((
                    fun (variant1: Z) => forall (i1: Z), forall (j1: Z),
                    forall (t0: (array Z)), forall (_: ((l + 1) <= i1 /\
                    i1 <= r) /\ j1 <= r /\
                    (array_le t0 (l + 1) (i1 - 1) pv) /\
                    (array_ge t0 (j1 + 1) r pv) /\ (sub_permut l r t0 t) /\
                    (access t0 l) = (access t l)),
                    (tuple_4 Z Z (array Z) (EM unit unit)))) ((fun (variant1: Z) (wf1: forall (variant2: Z),
                                                                   forall (Pre11: (Zwf 0 variant2 variant1)),
                                                                   forall (i1: Z),
                                                                   forall (j1: Z),
                                                                   forall (t0: (array Z)),
                                                                   forall (_: (
                                                                   (l + 1) <=
                                                                   i1 /\
                                                                   i1 <=
                                                                   r) /\
                                                                   j1 <= r /\
                                                                   (array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i1 - 1) pv) /\
                                                                   (array_ge
                                                                    t0 
                                                                    (j1 + 1) r pv) /\
                                                                   (sub_permut
                                                                    l r t0 t) /\
                                                                   (access
                                                                    t0 l) =
                                                                   (access
                                                                    t l)),
                                                                   (tuple_4
                                                                    Z Z (array Z) (
                                                                    EM
                                                                    unit unit))) (i1: Z) (j1: Z) (t0: (array Z)) (Inv: (
                                                                   (l + 1) <=
                                                                   i1 /\
                                                                   i1 <=
                                                                   r) /\
                                                                   j1 <= r /\
                                                                   (array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i1 - 1) pv) /\
                                                                   (array_ge
                                                                    t0 
                                                                    (j1 + 1) r pv) /\
                                                                   (sub_permut
                                                                    l r t0 t) /\
                                                                   (access
                                                                    t0 l) =
                                                                   (access
                                                                    t l)) =>
                                                                 let (i2, j2,
                                                                   t1,
                                                                   result) :=
                                                                   let result :=
                                                                    let (result0,
                                                                    Post2) :=
                                                                    (
                                                                    lt_int_
                                                                    i1 j1) in
                                                                    (exist_1 (
                                                                    fun (result1: bool) =>
                                                                    (
                                                                    if result1
                                                                    then i1 <
                                                                    j1
                                                                    else i1 >=
                                                                    j1)) (
                                                                    result0) ((
                                                                    if result0
                                                                    then i1 <
                                                                    j1
                                                                    else i1 >=
                                                                    j1))) in
                                                                   if 
                                                                   result then
                                                                     
                                                                   let (i2,
                                                                    j2, t1,
                                                                    result0) :=
                                                                    let (i2,
                                                                    result0) :=
                                                                    let (i2,
                                                                    result0) :=
                                                                    ((well_founded_induction) (Z) (
                                                                    (Zwf Z0)) (
                                                                    (well_founded (Zwf Z0))) ((
                                                                    fun (variant3: Z) =>
                                                                    forall (i2: Z),
                                                                    forall (_: (i1 <=
                                                                    i2 /\
                                                                    i2 <=
                                                                    r) /\
                                                                    (
                                                                    array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i2 - 1) pv)),
                                                                    (
                                                                    tuple_2
                                                                    Z (
                                                                    EM
                                                                    unit unit)))) ((
                                                                    fun 
                                                                    (variant3: Z) (wf2: forall (variant4: Z),
                                                                    forall (Pre12: (Zwf 0 variant4 variant3)),
                                                                    forall (i2: Z),
                                                                    forall (_: (i1 <=
                                                                    i2 /\
                                                                    i2 <=
                                                                    r) /\
                                                                    (
                                                                    array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i2 - 1) pv)),
                                                                    (
                                                                    tuple_2
                                                                    Z (
                                                                    EM
                                                                    unit unit))) (i2: Z) (Invi: (i1 <=
                                                                    i2 /\
                                                                    i2 <=
                                                                    r) /\
                                                                    (
                                                                    array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i2 - 1) pv)) =>
                                                                    let (i3,
                                                                    result0) :=
                                                                    let result0 :=
                                                                    let result0 :=
                                                                    let aux_1 :=
                                                                    let Pre3 :=
                                                                    0 <=
                                                                    i2 /\
                                                                    i2 <
                                                                    (array_length
                                                                    t0) in
                                                                    let (result1,
                                                                    Post4) :=
                                                                    (
                                                                    array_get
                                                                    i2 t0) in
                                                                    (exist_1 (
                                                                    fun (result2: Z) =>
                                                                    result2 =
                                                                    (
                                                                    access
                                                                    t0 i2)) (
                                                                    result1) (
                                                                    result1 =
                                                                    (
                                                                    access
                                                                    t0 i2))) in
                                                                    let result0 :=
                                                                    let (result1,
                                                                    Post5) :=
                                                                    (
                                                                    le_int_
                                                                    aux_1 pv) in
                                                                    (exist_1 (
                                                                    fun (result2: bool) =>
                                                                    (
                                                                    if result2
                                                                    then aux_1 <=
                                                                    pv
                                                                    else aux_1 >
                                                                    pv)) (
                                                                    result1) ((
                                                                    if result1
                                                                    then aux_1 <=
                                                                    pv
                                                                    else aux_1 >
                                                                    pv))) in
                                                                    result0 in
                                                                    if 
                                                                    result0 then
                                                                      
                                                                    let result1 :=
                                                                    let (result2,
                                                                    Post6) :=
                                                                    (
                                                                    lt_int_
                                                                    i2 j1) in
                                                                    (exist_1 (
                                                                    fun (result3: bool) =>
                                                                    (
                                                                    if result3
                                                                    then i2 <
                                                                    j1
                                                                    else i2 >=
                                                                    j1)) (
                                                                    result2) ((
                                                                    if result2
                                                                    then i2 <
                                                                    j1
                                                                    else i2 >=
                                                                    j1))) in
                                                                    result1
                                                                    else
                                                                      
                                                                    false in
                                                                    if 
                                                                    result0 then
                                                                      
                                                                    let (i3,
                                                                    result1) :=
                                                                    let (i3,
                                                                    result2,
                                                                    Post7) :=
                                                                    (
                                                                    ref_set
                                                                    (i2 + 1) i2) in
                                                                    (exist_2 (
                                                                    fun (i4: Z) =>
                                                                    (
                                                                    fun (result3: unit) =>
                                                                    i4 =
                                                                    (i2 + 1))) (
                                                                    i3) (
                                                                    result2) (
                                                                    i3 =
                                                                    (i2 + 1))) in
                                                                    (Build_tuple_2 (
                                                                    i3) (
                                                                    ((Val) (unit) (
                                                                    result1))))
                                                                    else
                                                                      
                                                                    let result1 :=
                                                                    ((Exn) (unit) (
                                                                    tt)) in
                                                                    match 
                                                                    result1 with
                                                                    | (Val result1_0) =>
                                                                    (Build_tuple_2 (
                                                                    i2) (
                                                                    ((Val) (unit) (
                                                                    result1_0))))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    i2) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end in
                                                                    match 
                                                                    result0 with
                                                                    | (Val result0_0) =>
                                                                    (((
                                                                    wf2
                                                                    (r - i3))) ((Zwf 0 
                                                                    (r - i3) variant3)) (
                                                                    i3) (
                                                                    (r - i3) =
                                                                    (r - i3)) ((i1 <=
                                                                    i3 /\
                                                                    i3 <=
                                                                    r) /\
                                                                    (array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i3 - 1) pv)))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    i3) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end)) (
                                                                    (r - i1)) (
                                                                    i1) (
                                                                    (r - i1) =
                                                                    (r - i1)) ((i1 <=
                                                                    i1 /\
                                                                    i1 <=
                                                                    r) /\
                                                                    (array_le
                                                                    t0 
                                                                    (l + 1) 
                                                                    (i1 - 1) pv))) in
                                                                    match 
                                                                    result0 with
                                                                    | (Val result0_0) =>
                                                                    (Build_tuple_2 (
                                                                    i2) (
                                                                    result0_0))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    i2) (
                                                                    tt))
                                                                    end in
                                                                    let (i3,
                                                                    j2, t1,
                                                                    result1) :=
                                                                    let (j2,
                                                                    result1) :=
                                                                    let (j2,
                                                                    result1) :=
                                                                    ((well_founded_induction) (Z) (
                                                                    (Zwf Z0)) (
                                                                    (well_founded (Zwf Z0))) ((
                                                                    fun (variant5: Z) =>
                                                                    forall (j2: Z),
                                                                    forall (_: (l <=
                                                                    j2 /\
                                                                    j2 <=
                                                                    j1) /\
                                                                    (
                                                                    array_ge
                                                                    t0 
                                                                    (j2 + 1) r pv)),
                                                                    (
                                                                    tuple_2
                                                                    Z (
                                                                    EM
                                                                    unit unit)))) ((
                                                                    fun 
                                                                    (variant5: Z) (wf3: forall (variant6: Z),
                                                                    forall (Pre13: (Zwf 0 variant6 variant5)),
                                                                    forall (j2: Z),
                                                                    forall (_: (l <=
                                                                    j2 /\
                                                                    j2 <=
                                                                    j1) /\
                                                                    (
                                                                    array_ge
                                                                    t0 
                                                                    (j2 + 1) r pv)),
                                                                    (
                                                                    tuple_2
                                                                    Z (
                                                                    EM
                                                                    unit unit))) (j2: Z) (Invj: (l <=
                                                                    j2 /\
                                                                    j2 <=
                                                                    j1) /\
                                                                    (
                                                                    array_ge
                                                                    t0 
                                                                    (j2 + 1) r pv)) =>
                                                                    let (j3,
                                                                    result1) :=
                                                                    let result1 :=
                                                                    let result1 :=
                                                                    let aux_2 :=
                                                                    let Pre5 :=
                                                                    0 <=
                                                                    j2 /\
                                                                    j2 <
                                                                    (array_length
                                                                    t0) in
                                                                    let (result2,
                                                                    Post9) :=
                                                                    (
                                                                    array_get
                                                                    j2 t0) in
                                                                    (exist_1 (
                                                                    fun (result3: Z) =>
                                                                    result3 =
                                                                    (
                                                                    access
                                                                    t0 j2)) (
                                                                    result2) (
                                                                    result2 =
                                                                    (
                                                                    access
                                                                    t0 j2))) in
                                                                    let result1 :=
                                                                    let (result2,
                                                                    Post10) :=
                                                                    (
                                                                    ge_int_
                                                                    aux_2 pv) in
                                                                    (exist_1 (
                                                                    fun (result3: bool) =>
                                                                    (
                                                                    if result3
                                                                    then aux_2 >=
                                                                    pv
                                                                    else aux_2 <
                                                                    pv)) (
                                                                    result2) ((
                                                                    if result2
                                                                    then aux_2 >=
                                                                    pv
                                                                    else aux_2 <
                                                                    pv))) in
                                                                    result1 in
                                                                    if 
                                                                    result1 then
                                                                      
                                                                    let result2 :=
                                                                    let (result3,
                                                                    Post11) :=
                                                                    (
                                                                    lt_int_
                                                                    i2 j2) in
                                                                    (exist_1 (
                                                                    fun (result4: bool) =>
                                                                    (
                                                                    if result4
                                                                    then i2 <
                                                                    j2
                                                                    else i2 >=
                                                                    j2)) (
                                                                    result3) ((
                                                                    if result3
                                                                    then i2 <
                                                                    j2
                                                                    else i2 >=
                                                                    j2))) in
                                                                    result2
                                                                    else
                                                                      
                                                                    false in
                                                                    if 
                                                                    result1 then
                                                                      
                                                                    let (j3,
                                                                    result2) :=
                                                                    let (j3,
                                                                    result3,
                                                                    Post12) :=
                                                                    (
                                                                    ref_set
                                                                    (j2 - 1) j2) in
                                                                    (exist_2 (
                                                                    fun (j4: Z) =>
                                                                    (
                                                                    fun (result4: unit) =>
                                                                    j4 =
                                                                    (j2 - 1))) (
                                                                    j3) (
                                                                    result3) (
                                                                    j3 =
                                                                    (j2 - 1))) in
                                                                    (Build_tuple_2 (
                                                                    j3) (
                                                                    ((Val) (unit) (
                                                                    result2))))
                                                                    else
                                                                      
                                                                    let result2 :=
                                                                    ((Exn) (unit) (
                                                                    tt)) in
                                                                    match 
                                                                    result2 with
                                                                    | (Val result2_0) =>
                                                                    (Build_tuple_2 (
                                                                    j2) (
                                                                    ((Val) (unit) (
                                                                    result2_0))))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    j2) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end in
                                                                    match 
                                                                    result1 with
                                                                    | (Val result1_0) =>
                                                                    (((
                                                                    wf3 j3)) ((Zwf 0 j3 variant5)) (
                                                                    j3) (
                                                                    j3 = j3) ((l <=
                                                                    j3 /\
                                                                    j3 <=
                                                                    j1) /\
                                                                    (array_ge
                                                                    t0 
                                                                    (j3 + 1) r pv)))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    j3) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end)) (
                                                                    j1) (
                                                                    j1) (
                                                                    j1 = j1) ((l <=
                                                                    j1 /\
                                                                    j1 <=
                                                                    j1) /\
                                                                    (array_ge
                                                                    t0 
                                                                    (j1 + 1) r pv))) in
                                                                    match 
                                                                    result1 with
                                                                    | (Val result1_0) =>
                                                                    (Build_tuple_2 (
                                                                    j2) (
                                                                    result1_0))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_2 (
                                                                    j2) (
                                                                    tt))
                                                                    end in
                                                                    let (i3,
                                                                    j3, t1,
                                                                    result2) :=
                                                                    let result2 :=
                                                                    let (result3,
                                                                    Post13) :=
                                                                    (
                                                                    lt_int_
                                                                    i2 j2) in
                                                                    (exist_1 (
                                                                    fun (result4: bool) =>
                                                                    (
                                                                    if result4
                                                                    then i2 <
                                                                    j2
                                                                    else i2 >=
                                                                    j2)) (
                                                                    result3) ((
                                                                    if result3
                                                                    then i2 <
                                                                    j2
                                                                    else i2 >=
                                                                    j2))) in
                                                                    if 
                                                                    result2 then
                                                                      
                                                                    let (i3,
                                                                    j3, t1,
                                                                    result3) :=
                                                                    let (t1,
                                                                    result3) :=
                                                                    let Pre6 :=
                                                                    (0 <=
                                                                    i2 /\
                                                                    i2 <
                                                                    (array_length
                                                                    t0)) /\
                                                                    0 <=
                                                                    j2 /\
                                                                    j2 <
                                                                    (array_length
                                                                    t0) in
                                                                    let (t1,
                                                                    result4,
                                                                    Post14) :=
                                                                    (
                                                                    swap
                                                                    i2 j2 t0) in
                                                                    (exist_2 (
                                                                    fun (t2: (array Z)) =>
                                                                    (
                                                                    fun (result5: unit) =>
                                                                    (
                                                                    exchange
                                                                    t2 t0 i2 j2))) (
                                                                    t1) (
                                                                    result4) ((
                                                                    exchange
                                                                    t1 t0 i2 j2))) in
                                                                    let (i3,
                                                                    j3,
                                                                    result4) :=
                                                                    let (i3,
                                                                    result4) :=
                                                                    let (i3,
                                                                    result5,
                                                                    Post15) :=
                                                                    (
                                                                    ref_set
                                                                    (i2 + 1) i2) in
                                                                    (exist_2 (
                                                                    fun (i4: Z) =>
                                                                    (
                                                                    fun (result6: unit) =>
                                                                    i4 =
                                                                    (i2 + 1))) (
                                                                    i3) (
                                                                    result5) (
                                                                    i3 =
                                                                    (i2 + 1))) in
                                                                    let (j3,
                                                                    result5) :=
                                                                    let (j3,
                                                                    result6,
                                                                    Post16) :=
                                                                    (
                                                                    ref_set
                                                                    (j2 - 1) j2) in
                                                                    (exist_2 (
                                                                    fun (j4: Z) =>
                                                                    (
                                                                    fun (result7: unit) =>
                                                                    j4 =
                                                                    (j2 - 1))) (
                                                                    j3) (
                                                                    result6) (
                                                                    j3 =
                                                                    (j2 - 1))) in
                                                                    (Build_tuple_3 (
                                                                    i3) (
                                                                    j3) (
                                                                    result5)) in
                                                                    (Build_tuple_4 (
                                                                    i3) (
                                                                    j3) (
                                                                    t1) (
                                                                    result4)) in
                                                                    (Build_tuple_4 (
                                                                    i3) (
                                                                    j3) (
                                                                    t1) (
                                                                    result3))
                                                                    else
                                                                      
                                                                    (Build_tuple_4 (
                                                                    i2) (
                                                                    j2) (
                                                                    t0) (
                                                                    tt)) in
                                                                    (Build_tuple_4 (
                                                                    i3) (
                                                                    j3) (
                                                                    t1) (
                                                                    result2)) in
                                                                    (Build_tuple_4 (
                                                                    i3) (
                                                                    j2) (
                                                                    t1) (
                                                                    result1)) in
                                                                   (Build_tuple_4 (
                                                                   i2) (
                                                                   j2) (
                                                                   t1) (
                                                                   ((Val) (unit) (
                                                                    result0))))
                                                                   else
                                                                     
                                                                   let result0 :=
                                                                    ((Exn) (unit) (
                                                                    tt)) in
                                                                   match 
                                                                   result0 with
                                                                   | (Val result0_0) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    j1) (
                                                                    t0) (
                                                                    ((Val) (unit) (
                                                                    result0_0))))
                                                                   | (Exn _) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    j1) (
                                                                    t0) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                   end in
                                                                 match 
                                                                 result with
                                                                 | (Val result0) =>
                                                                   (((
                                                                    wf1
                                                                    ((
                                                                    array_length
                                                                    t1) + 2 +
                                                                    j2 - i2))) ((Zwf 0 
                                                                    ((
                                                                    array_length
                                                                    t1) + 2 +
                                                                    j2 - i2) variant1)) (
                                                                    i2) (
                                                                    j2) (
                                                                    t1) (
                                                                    ((
                                                                    array_length
                                                                    t1) + 2 +
                                                                    j2 - i2) =
                                                                    ((
                                                                    array_length
                                                                    t1) + 2 +
                                                                    j2 - i2)) ((
                                                                    (l + 1) <=
                                                                    i2 /\
                                                                    i2 <=
                                                                    r) /\
                                                                    j2 <=
                                                                    r /\
                                                                    (array_le
                                                                    t1 
                                                                    (l + 1) 
                                                                    (i2 - 1) pv) /\
                                                                    (array_ge
                                                                    t1 
                                                                    (j2 + 1) r pv) /\
                                                                    (sub_permut
                                                                    l r t1 t) /\
                                                                    (access
                                                                    t1 l) =
                                                                    (access
                                                                    t l)))
                                                                 | (Exn _) =>
                                                                   (Build_tuple_4 (
                                                                   i2) (
                                                                   j2) (
                                                                   t1) (
                                                                   ((Exn) (unit) (
                                                                    tt))))
                                                                 end)) (
                    ((array_length t) + 2 + r - (l + 1))) ((l + 1)) (
                    r) (t) (((array_length t) + 2 + r - (l + 1)) =
                            ((array_length t) + 2 + r - (l + 1))) (((l + 1) <=
                    (l + 1) /\ (l + 1) <= r) /\ r <= r /\
                    (array_le t (l + 1) (l + 1 - 1) pv) /\
                    (array_ge t (r + 1) r pv) /\ (sub_permut l r t t) /\
                    (access t l) = (access t l))) in
                match result with
                | (Val result0) => (Build_tuple_4 (i1) (j1) (t0) (result0))
                | (Exn _) => (Build_tuple_4 (i1) (j1) (t0) (tt))
                end in
              let (t1, result0) :=
                let result0 :=
                  let aux_3 :=
                    let Pre8 := 0 <= i1 /\ i1 < (array_length t0) in
                    let (result1, Post18) := (array_get i1 t0) in
                    (exist_1 (fun (result2: Z) => result2 = (access t0 i1)) (
                    result1) (result1 = (access t0 i1))) in
                  let result0 :=
                    let (result1, Post19) := (lt_int_ aux_3 pv) in
                    (exist_1 (fun (result2: bool) =>
                              (if result2 then aux_3 < pv else aux_3 >= pv)) (
                    result1) ((if result1 then aux_3 < pv else aux_3 >= pv))) in
                  result0 in
                if result0 then
                  let (t1, result1) :=
                    let (t1, result1) :=
                      let Pre9 := (0 <= l /\ l < (array_length t0)) /\ 0 <=
                        i1 /\ i1 < (array_length t0) in
                      let (t1, result2, Post20) := (swap l i1 t0) in
                      (exist_2 (fun (t2: (array Z)) =>
                                (fun (result3: unit) => (exchange t2 t0 l i1))) (
                      t1) (result2) ((exchange t1 t0 l i1))) in
                    (Build_tuple_2 (t1) (i1)) in
                  (Build_tuple_2 (t1) (result1))
                else
                  let (t1, result1) :=
                    let (t1, result1) :=
                      let Pre10 := (0 <= l /\ l < (array_length t0)) /\ 0 <=
                        (i1 - 1) /\ (i1 - 1) < (array_length t0) in
                      let (t1, result2, Post21) := (swap l (i1 - 1) t0) in
                      (exist_2 (fun (t2: (array Z)) =>
                                (fun (result3: unit) =>
                                 (exchange t2 t0 l (i1 - 1)))) (t1) (
                      result2) ((exchange t1 t0 l (i1 - 1)))) in
                    (Build_tuple_2 (t1) ((i1 - 1))) in
                  (Build_tuple_2 (t1) (result1)) in
              (Build_tuple_4 (i1) (j1) (t1) (result0)) in
            (Build_tuple_3 (i1) (t0) (result)) in
          (Build_tuple_2 (t0) (result)) in
        (Build_tuple_2 (t0) (result))).


