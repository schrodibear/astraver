(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Export Partition.
Require Import Omega.
Require Import ZArithRing.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma swap_po_1 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  0 <= j /\ j < (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma swap_po_2 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  forall (HW_8: 0 <= j /\ j < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_9: t1 = (update t0 j result)),
  (exchange t1 t i j).
Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
ArraySubst t0.
Save.

Proof.
intuition.
subst; auto with *.
Save.

(*Why*) Parameter swap_valid :
  forall (i: Z), forall (j: Z), forall (t: (array Z)), forall (_: (0 <= i /\
  i < (array_length t)) /\ 0 <= j /\ j < (array_length t)),
  (sig_2 (array Z) unit
   (fun (t0: (array Z)) (result: unit)  => ((exchange t0 t i j)))).

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_1 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  0 <= l /\ l < (array_length t).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_2 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  ((l + 1) <= (l + 1) /\ (l + 1) <= r) /\ r <= r /\
  (array_le t (l + 1) (l + 1 - 1) result) /\ (array_ge t (r + 1) r result) /\
  (sub_permut l r t t) /\ (access t l) = (access t l).
Proof.
intuition.
apply array_le_empty; omega.
apply array_ge_empty; omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_3 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  (i <= i /\ i <= r) /\ (array_le t0 (l + 1) (i - 1) result).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_4 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  0 <= i0 /\ i0 < (array_length t0).
Proof.
intuition ArrayLength; omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_5 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_10: i0 < j),
  forall (i1: Z),
  forall (HW_11: i1 = (i0 + 1)),
  ((i <= i1 /\ i1 <= r) /\ (array_le t0 (l + 1) (i1 - 1) result)) /\
  (Zwf 0 (r - i1) (r - i0)).
Proof.
intuition; subst.
replace (i0+1-1) with ((i0-1)+1).
apply array_le_right_extension; intuition.
ring (i0-1+1); auto.
omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_6 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  (l <= j /\ j <= j) /\ (array_ge t0 (j + 1) r result).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_7 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  0 <= j0 /\ j0 < (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_8 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_17: i0 < j0),
  forall (j1: Z),
  forall (HW_18: j1 = (j0 - 1)),
  ((l <= j1 /\ j1 <= j) /\ (array_ge t0 (j1 + 1) r result)) /\ (Zwf 0 j1 j0).
Proof.
intuition; subst.
apply array_ge_cons.
 intros j1 Hj1.
 elim (Z_le_gt_dec (j0 + 1) j1); intro.
assert (h: array_ge t0 (j + 1) r (access t l)). assumption.
elim h; intros.
auto with *.
cut (j0 = j1); [ intro | omega ].
subst.
 omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_9 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_19: i0 >= j0),
  forall (HW_20: i0 < j0),
  forall (HW_21: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_22: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_23: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_24: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)) /\
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

Ltac elimh p :=  match goal with
  | h:p |- _ => elim h
end.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_10 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_16: result1 >= result),
  forall (HW_25: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)) /\
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
replace (i1 - 1)%Z with (i0 - 1 + 1)%Z.
apply array_le_right_extension.
apply array_le_exchange with (t := t0) (x := i0) (y := j0).
omega.
 omega.
 assumption.
omega.
 apply exchange_sym; assumption.
ring (i0 - 1 + 1)%Z.
 elimh (exchange t1 t0 i0 j0); intros.
 replace (access t1 i0) with (access t0 j0); auto.
omega.
omega.
replace (j1 + 1)%Z with (j0 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i0) (y := j0).
omega.
  SameLength t t0.
 omega.
assumption.
omega.
 apply exchange_sym; assumption.
ring (j0 + 1 - 1)%Z.
 elimh (exchange t1 t0 i0 j0); intros.
 replace (access t1 j0) with (access t0 i0); auto.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i0) (j := j0);
 [ omega | omega | assumption ].
assumption.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_11 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_27: i0 < j0),
  forall (HW_28: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_29: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_30: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_31: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)) /\
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_12 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_9: result0 <= result),
  forall (HW_12: i0 >= j),
  forall (j0: Z),
  forall (HW_13: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_14: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_15: result1 = (access t0 j0)),
  forall (HW_26: result1 < result),
  forall (HW_32: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)) /\
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_13 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  (l <= j /\ j <= j) /\ (array_ge t0 (j + 1) r result).
Proof.
intuition.
replace (i1 - 1)%Z with (i0 - 1 + 1)%Z.
apply array_le_right_extension.
apply array_le_exchange with (t := t0) (x := i0) (y := j0).
omega.
 omega.
 assumption.
omega.
 apply exchange_sym; assumption.
ring (i0 - 1 + 1)%Z.
  elimh (exchange t1 t0 i0 j0); intros.
  replace (access t1 i0) with (access t0 j0); auto.
omega.
omega.
replace (j1 + 1)%Z with (j0 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i0) (y := j0).
omega.
 SameLength t t0.
 omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j0 + 1 - 1)%Z.
  elimh (exchange t1 t0 i0 j0); intros.
  replace (access t1 j0) with (access t0 i0); auto.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i0) (j := j0);
 [ omega | omega | assumption ].
assumption.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_14 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  0 <= j0 /\ j0 < (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_15 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_38: i0 < j0),
  forall (j1: Z),
  forall (HW_39: j1 = (j0 - 1)),
  ((l <= j1 /\ j1 <= j) /\ (array_ge t0 (j1 + 1) r result)) /\ (Zwf 0 j1 j0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_16 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_40: i0 >= j0),
  forall (HW_41: i0 < j0),
  forall (HW_42: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_43: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_44: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_45: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)) /\
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
SameLength t t0.
omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_17 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_37: result1 >= result),
  forall (HW_46: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)) /\
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
apply array_ge_cons.
 intros j' Hj'.
 elim (Z_le_gt_dec (j0 + 1) j'); intro.
 elimh (array_ge t0 (j0 + 1) r result); intros.
  auto with *.
cut (j' = j0); [ intro | omega ].
subst; omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_18 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_48: i0 < j0),
  forall (HW_49: (0 <= i0 /\ i0 < (array_length t0)) /\ 0 <= j0 /\ j0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_50: (exchange t1 t0 i0 j0)),
  forall (i1: Z),
  forall (HW_51: i1 = (i0 + 1)),
  forall (j1: Z),
  forall (HW_52: j1 = (j0 - 1)),
  (((l + 1) <= i1 /\ i1 <= r) /\ j1 <= r /\
  (array_le t1 (l + 1) (i1 - 1) result) /\ (array_ge t1 (j1 + 1) r result) /\
  (sub_permut l r t1 t) /\ (access t1 l) = (access t l)) /\
  (Zwf 0 ((array_length t1) + 2 + j1 - i1) ((array_length t0) + 2 + j - i)).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_19 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_5: i < j),
  forall (i0: Z),
  forall (HW_6: (i <= i0 /\ i0 <= r) /\ (array_le t0 (l + 1) (i0 - 1) result)),
  forall (HW_7: 0 <= i0 /\ i0 < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i0)),
  forall (HW_33: result0 > result),
  forall (j0: Z),
  forall (HW_34: (l <= j0 /\ j0 <= j) /\ (array_ge t0 (j0 + 1) r result)),
  forall (HW_35: 0 <= j0 /\ j0 < (array_length t0)),
  forall (result1: Z),
  forall (HW_36: result1 = (access t0 j0)),
  forall (HW_47: result1 < result),
  forall (HW_53: i0 >= j0),
  (((l + 1) <= i0 /\ i0 <= r) /\ j0 <= r /\
  (array_le t0 (l + 1) (i0 - 1) result) /\ (array_ge t0 (j0 + 1) r result) /\
  (sub_permut l r t0 t) /\ (access t0 l) = (access t l)) /\
  (Zwf 0 ((array_length t0) + 2 + j0 - i0) ((array_length t0) + 2 + j - i)).
Proof.
intros; absurd (i0 < j0); omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_20 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  0 <= i /\ i < (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_21 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_57: result0 < result),
  (0 <= l /\ l < (array_length t0)) /\ 0 <= i /\ i < (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_22 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_57: result0 < result),
  forall (HW_58: (0 <= l /\ l < (array_length t0)) /\ 0 <= i /\ i <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_59: (exchange t1 t0 l i)),
  (l <= i /\ i <= r) /\ (partition_p t1 l r i) /\ (sub_permut l r t1 t).
Proof.
intuition.
apply array_le_cons.
intros i' Hi'.
 elim (Z_le_lt_eq_dec l i'); intros.
(* case l < i' *)
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
assert (i' < i0 \/ i'=i0). omega. intuition.
rewrite h6; try omega.
elimh (array_le t0 (l + 1) (i0 - 1) result); auto with *.
subst i'; rewrite h4; omega.
(* case l = i' *)
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
omega.
omega.
(* array_ge *)
apply array_ge_cons.
intros j' Hj'.
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
assert (j0 < j' \/ j'=j0). omega. intuition.
rewrite h6; try omega.
elimh (array_ge t0 (j0 + 1) r result); auto with *.
SameLength t0 t; omega.
subst j'; rewrite h5; omega.
(* (sub_permut l r t1 t) *)
apply sub_permut_trans with (t' := t0); auto.
apply exchange_is_sub_permut with (i := i0) (j := j0).
omega.
omega.
assumption.
elimh (exchange t1 t0 i0 j0); intros h1 h2 h3 h4 h5 h6.
rewrite (h6 l); try omega.
unfold Zwf; intuition.
SameLength t1 t0; omega.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_23 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_60: result0 >= result),
  (0 <= l /\ l < (array_length t0)) /\ 0 <= (i - 1) /\ (i - 1) <
  (array_length t0).
Proof.
intuition.
Save.

(* Why obligation from file "", line 0, characters 0-0: *)
(*Why goal*) Lemma partition_po_24 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= l /\ l < r) /\ r < (array_length t)),
  forall (HW_2: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t l)),
  forall (i: Z),
  forall (j: Z),
  forall (t0: (array Z)),
  forall (HW_4: ((l + 1) <= i /\ i <= r) /\ j <= r /\
                (array_le t0 (l + 1) (i - 1) result) /\
                (array_ge t0 (j + 1) r result) /\ (sub_permut l r t0 t) /\
                (access t0 l) = (access t l)),
  forall (HW_54: i >= j),
  forall (HW_55: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_56: result0 = (access t0 i)),
  forall (HW_60: result0 >= result),
  forall (HW_61: (0 <= l /\ l < (array_length t0)) /\ 0 <= (i - 1) /\
                 (i - 1) < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_62: (exchange t1 t0 l (i - 1))),
  (l <= (i - 1) /\ (i - 1) <= r) /\ (partition_p t1 l r (i - 1)) /\
  (sub_permut l r t1 t).
Proof.
intuition.
SameLength t0 t; omega.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
apply piv.
omega.
omega.
(* array_le *)
apply array_le_cons.
intros i' Hi'.
 elim (Z_le_lt_eq_dec l i'); intros.
(* case l < i *)
elimh (exchange t1 t0 l i); intros h1 h2 h3 h4 h5 h6.
rewrite h6.
rewrite h5.
subst.
replace (access t0 l) with (access t l); auto.
elimh (array_le t0 (l + 1) (i - 1) (access t l)); auto with *.
omega.
omega.
omega.
(* case l = i *)
subst.
elimh (exchange t1 t0 i' i); intros h1 h2 h3 h4 h5 h6.
rewrite h4.
rewrite h5.
omega.
omega.
(* array_ge *)
apply array_ge_cons.
intros i' Hi'.
subst.
 ring (i1 - 1 + 1)%Z.
 intro Hj.
 elim Post30; intros.
rewrite H22.
 rewrite (H23 j0).
rewrite H18.
elim H15; intros.
 elim (Z_le_lt_eq_dec i1 j0); intros.
(* case i0 < j *)
rewrite <- Post11.
 apply H24; omega.
(* case i0 = j *)
rewrite <- b.
 omega.
omega.
SameLength t1 t0; SameLength t0 t; omega.
omega.
omega.
(* (sub_permut t1 t l r) *)
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := l) (j := Zpred i1).
omega.
unfold Zpred; omega.
assumption.
assumption.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition ArrayLength; omega.
Qed.

 Proof.
 intuition.
induction result2; auto.
induction result2; auto.
Qed.

Proof.
intuition.
induction result2; auto || discriminate Post5.
induction result2; auto || discriminate Post5.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition.
rewrite <- H23.
elim Post25; intros.
apply H28; omega.
absurd (i2 < j2)%Z; omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 intuition; generalize (sub_permut_length H21); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H28.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
absurd (i2 < j2)%Z; omega.
Qed.

Proof.
intuition ArrayLength; omega.
Qed.

Proof.
intros.
decompose [and or] Invj; clear Invj.
 intuition unfold Zwf; ArrayLength; try omega.
Qed.

Proof.
intuition unfold Zwf; SameLength t t0; omega.
rewrite <- H23.
elim Post25; intros.
apply H28; omega.
absurd (i2 < j2)%Z; omega.
replace (j3 + 1)%Z with (j2 + 1 - 1)%Z.
apply array_ge_left_extension.
apply array_ge_exchange with (t := t0) (x := i2) (y := j2).
omega.
 intuition; generalize (sub_permut_length H21); intro; omega.
assumption.
 omega.
 apply exchange_sym; assumption.
ring (j2 + 1 - 1)%Z.
 elim Post25; intros.
 rewrite H28.
omega.
omega.
apply sub_permut_trans with (t' := t0).
apply exchange_is_sub_permut with (i := i2) (j := j2);
 [ omega | omega | assumption ].
assumption.
absurd (i2 < j2)%Z; omega.
Qed.

Proof.
intuition.
apply array_le_empty; omega.
apply array_ge_empty; omega.
Qed.

Proof.
intuition SameLength t t0; omega.
Qed.

Proof.
intuition SameLength t t0; auto with *.
Qed.

Proof.
intuition.
apply piv.
omega.
omega.
Qed.

Proof.
intuition SameLength t0 t; omega.
Qed.

Proof.
intuition.
Qed.


Proof.
intuition.
Save.

(*Why*) Parameter partition_valid :
  forall (l: Z), forall (r: Z), forall (t: (array Z)), forall (_: (0 <= l /\
  l < r) /\ r < (array_length t)),
  (sig_2 (array Z) Z
   (fun (t0: (array Z)) (result: Z)  => ((l <= result /\ result <= r) /\
    (partition_p t0 l r result) /\ (sub_permut l r t0 t)))).

