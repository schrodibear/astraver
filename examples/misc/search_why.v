(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

(*Why*) Parameter N : Z.

Lemma search1_po_1 : 
  (result: Z)
  (Post3: result = `0`)
  (well_founded (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma search1_po_2 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma search1_po_3 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (Test2: `(access t i0) <> 0`)
  ((i:Z)
   (i = `i0 + 1` -> (`0 <= i` /\
    ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
    (Zwf `0` `N - i` `N - i0`))).
Proof.
Intuition.
Assert k=i0 \/ `k<i0`. Omega. Intuition.
Subst k. Auto.
Apply (H0 k). Omega. Assumption.
Unfold Zwf; Omega.
Save.

Lemma search1_po_4 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (Post21: ((i:Z)
            (i = `i0 + 1` -> (`0 <= i` /\
             ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
             (Zwf `0` `N - i` `N - i0`))))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (`0 <= i1` /\ ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
  (Zwf `0` `N - i1` `N - i0`).
Proof.
Intuition.
Save.

Lemma search1_po_5 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (i1: Z)
  (Post4: (`0 <= i1` /\
          ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
          (Zwf `0` `N - i1` `N - i0`))
  (Zwf `0` `N - i1` Variant1).
Proof.
Intros; Subst Variant1; Tauto.
Save.

Lemma search1_po_6 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  `0 <= result` /\ ((k:Z) (`0 <= k` /\ `k < result` -> `(access t k) <> 0`)).
Proof.
Intuition. Omega.
Save.

Lemma search1_po_7 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (i0: Z)
  (Post2: (`0 <= i0` /\
          ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))) /\ `
          i0 >= N`)
  ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)).
Proof.
Intuition.
Apply (H2 k); Omega.
Save.

Definition search1 := (* validation *)
  [t: (array N Z)]
    let (result, Post6) =
      let (result, Post3) = (exist_1 [result: Z]result = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, result0, Post7) =
        let (i0, result0, Post8) =
          (well_founded_induction Z (Zwf ZERO) (search1_po_1 result Post3)
            [Variant1: Z](i0: Z)(_: Variant1 = `N - i0`)(_0: `0 <= i0` /\
            ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
            (sig_2 Z (EM Z unit) [i1: Z][result0: (EM Z unit)]
             (((qcomb [result1: Z]`(access t result1) = 0` [result1: unit]
                (`0 <= i1` /\
                ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                `i1 >= N`)
               result0)))
            [Variant1: Z; wf1: (Variant2: Z)
             (Pre1: (Zwf `0` Variant2 Variant1))(i0: Z)
             (_: Variant2 = `N - i0`)(_0: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
             (sig_2 Z (EM Z unit) [i1: Z][result0: (EM Z unit)]
              (((qcomb [result1: Z]`(access t result1) = 0` [result1: unit]
                 (`0 <= i1` /\
                 ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                 `i1 >= N`)
                result0)));
             i0: Z; Pre4: Variant1 = `N - i0`; Pre3: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))]
              let (result0, Bool2) =
                let (result2, Post9) = (Z_lt_ge_bool i0 N) in
                (exist_1 [result3: bool]
                (if result3 then `i0 < N` else `i0 >= N`) result2 Post9) in
              (Cases (btest
                      [result0:bool](if result0 then `i0 < N` else `i0 >= N`)
                      result0 Bool2) of
              | (left Test4) =>
                  let (i1, result1, Post12) =
                    let (i1, result1, Post13) =
                      let (result1, Post14) =
                        let (result1, Bool1) =
                          let result2 =
                            let Pre2 =
                              (search1_po_2 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4) in
                            (Z_eq_bool (access t i0)) in
                          let (result3, Post15) = (result2 `0`) in
                          (exist_1 [result4: bool]
                          (if result4 then `(access t i0) = 0`
                           else `(access t i0) <> 0`) result3
                          Post15) in
                        (Cases (btest
                                [result1:bool](if result1
                                               then `(access t i0) = 0`
                                               else `(access t i0) <> 0`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (result2, Post17) =
                              let (result2, Post18) = (exist_1 [result2: Z]
                                `(access t result2) = 0` i0 Test3) in
                              (exist_1 (qcomb [result3: Z]
                                        `(access t result3) = 0`
                                        [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Exn unit result2) Post18) in
                            Cases (decomp1 Post17) of
                            | (Qval (exist result2 Post19)) =>
                              (exist_1 (qcomb [result3: Z]
                                        `(access t result3) = 0`
                                        [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Val Z result2) Post19)
                            | (Qexn result2 Post20) =>
                              (exist_1 (qcomb [result3: Z]
                                        `(access t result3) = 0`
                                        [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Exn unit result2) Post20)
                            end
                        | (right Test2) =>
                            let (result2, Post16) = (exist_1 [result2: unit]
                              ((i:Z)
                               (i = `i0 + 1` -> (`0 <= i` /\
                                ((k:Z)
                                 (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
                                (Zwf `0` `N - i` `N - i0`))) tt
                              (search1_po_3 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4 Test2)) in
                            (exist_1 (qcomb [result3: Z]
                                      `(access t result3) = 0`
                                      [result3: unit]
                                      ((i:Z)
                                       (i = `i0 + 1` -> (`0 <= i` /\
                                        ((k:Z)
                                         (`0 <= k` /\ `k < i` ->
                                          `(access t k) <> 0`))) /\
                                        (Zwf `0` `N - i` `N - i0`)))) 
                            (Val Z result2) Post16) end) in
                      Cases (decomp1 Post14) of
                      | (Qval (exist result1 Post21)) =>
                        let (i1, result2, Post1) =
                          let (result2, Post1) = (exist_1 [result2: Z]
                            result2 = `i0 + 1` `i0 + 1`
                            (refl_equal ? `i0 + 1`)) in
                          (exist_2 [i2: Z][result3: unit]
                          i2 = `i0 + 1` result2 tt Post1) in
                        (exist_2 [i2: Z]
                        (qcomb [result3: Z]`(access t result3) = 0`
                         [result3: unit](`0 <= i2` /\
                         ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `N - i2` `N - i0`)) i1
                        (Val Z result2)
                        (search1_po_4 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 Post21 i1 Post1))
                      | (Qexn result1 Post22) => (exist_2 [i1: Z]
                        (qcomb [result2: Z]`(access t result2) = 0`
                         [result2: unit](`0 <= i1` /\
                         ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `N - i1` `N - i0`)) i0 (Exn unit result1)
                        Post22)
                      end in
                    Cases (decomp1 Post13) of
                    | (Qval (exist result1 Post4)) =>
                      ((wf1 `N - i1`)
                        (search1_po_5 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 i1 Post4) i1 (refl_equal ? `N - i1`)
                        (proj1 ? ? Post4))
                    | (Qexn result1 Post23) => (exist_2 [i2: Z]
                      (qcomb [result2: Z]`(access t result2) = 0`
                       [result2: unit](`0 <= i2` /\
                       ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                       `i2 >= N`) i1 (Exn unit result1) Post23)
                    end in
                  Cases (decomp1 Post12) of
                  | (Qval (exist result1 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result2: Z]`(access t result2) = 0`
                     [result2: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Val Z result1) Post2)
                  | (Qexn result1 Post24) => (exist_2 [i2: Z]
                    (qcomb [result2: Z]`(access t result2) = 0`
                     [result2: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Exn unit result1) Post24)
                  end
              | (right Test1) =>
                  let (i1, result1, Post10) = (exist_2 [i1: Z]
                    (qcomb [result1: Z]`(access t result1) = 0`
                     [result1: unit](`0 <= i1` /\
                     ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                     `i1 >= N`) i0 (Val Z tt) (conj ? ? Pre3 Test1)) in
                  Cases (decomp1 Post10) of
                  | (Qval (exist result1 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result2: Z]`(access t result2) = 0`
                     [result2: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Val Z result1) Post2)
                  | (Qexn result1 Post11) => (exist_2 [i2: Z]
                    (qcomb [result2: Z]`(access t result2) = 0`
                     [result2: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Exn unit result1) Post11)
                  end end) `N - result` result (refl_equal ? `N - result`)
            (search1_po_6 t result Post3)) in
        Cases (decomp1 Post8) of
        | (Qval (exist result0 Post2)) =>
          let (result1, Post26) =
            (exist_1 (qcomb [result1: unit]
                      ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                      [result1: Z]`(access t result1) = 0`) (Exn Z tt)
            (search1_po_7 t result Post3 i0 Post2)) in
          Cases (decomp1 Post26) of
          | (Qval (exist result1 Post27)) => (exist_2 [i1: Z]
            (qcomb [result2: Z]`(access t result2) = 0`
             (qcomb [result2: unit]
              ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
              [result2: Z]`(access t result2) = 0`)) i0
            (Val Z (Val unit result1)) Post27)
          | (Qexn _ Post28) => (exist_2 [i1: Z]
            (qcomb [result2: Z]`(access t result2) = 0`
             (qcomb [result2: unit]
              ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
              [result2: Z]`(access t result2) = 0`)) i0 (Val Z (Exn Z tt))
            Post28)
          end
        | (Qexn result0 Post25) => (exist_2 [i1: Z]
          (qcomb [result1: Z]`(access t result1) = 0`
           (qcomb [result1: unit]
            ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)) [result1: Z]
            `(access t result1) = 0`)) i0 (Exn (EM unit Z) result0) Post25)
        end in
      Cases (decomp2 Post7) of
      | (Qval (Qval (exist result0 Post29))) =>
        (exist_1 (qcomb [result1: Z]`(access t result1) = 0`
                  (qcomb [result1: unit]
                   ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                   [result1: Z]`(access t result1) = 0`)) (Val Z
                                                            (Val unit
                                                              result0))
        Post29)
      | (Qexn result0 Post30) =>
        (exist_1 (qcomb [result1: Z]`(access t result1) = 0`
                  (qcomb [result1: unit]
                   ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                   [result1: Z]`(access t result1) = 0`)) (Exn (EM unit Z)
                                                            result0) Post30)
      | (Qval (Qexn _ Post31)) =>
        (exist_1 (qcomb [result1: Z]`(access t result1) = 0`
                  (qcomb [result1: unit]
                   ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                   [result1: Z]`(access t result1) = 0`)) (Val Z (Exn Z tt))
        Post31)
      end in
    Cases (decomp2 Post6) of
    | (Qval (Qval (exist result Post32))) =>
      (exist_1 (qcomb [result0: unit]
                ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                [result0: Z]`(access t result0) = 0`) (Val unit result)
      Post32)
    | (Qexn result Post33) =>
      let (result0, Post34) = (exist_1 [result0: Z]
        `(access t result0) = 0` result Post33) in
      (exist_1 (qcomb [result1: unit]
                ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Val unit result0)
      Post34)
    | (Qval (Qexn _ Post35)) =>
      (exist_1 (qcomb [result0: unit]
                ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                [result0: Z]`(access t result0) = 0`) (Exn Z tt) Post35)
    end.

Lemma search2_po_1 : 
  (result: Z)
  (Post3: result = `0`)
  (well_founded (Zwf ZERO)).
Proof.
Auto with *.
Save.

Lemma search2_po_2 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma search2_po_3 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (Test2: `(access t i0) <> 0`)
  ((i:Z)
   (i = `i0 + 1` -> (`0 <= i` /\
    ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
    (Zwf `0` `N - i` `N - i0`))).
Proof.
Intuition.
Assert k=i0 \/ `k<i0`. Omega. Intuition.
Subst k. Auto.
Apply (H0 k). Omega. Assumption.
Unfold Zwf; Omega.
Save.

Lemma search2_po_4 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (Post20: ((i:Z)
            (i = `i0 + 1` -> (`0 <= i` /\
             ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
             (Zwf `0` `N - i` `N - i0`))))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (`0 <= i1` /\ ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
  (Zwf `0` `N - i1` `N - i0`).
Proof.
Intuition.
Save.

Lemma search2_po_5 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `N - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < N`)
  (i1: Z)
  (Post4: (`0 <= i1` /\
          ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
          (Zwf `0` `N - i1` `N - i0`))
  (Zwf `0` `N - i1` Variant1).
Proof.
Intros; Subst Variant1; Tauto.
Save.

Lemma search2_po_6 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  `0 <= result` /\ ((k:Z) (`0 <= k` /\ `k < result` -> `(access t k) <> 0`)).
Proof.
Intuition. Omega.
Save.

Lemma search2_po_7 : 
  (t: (array N Z))
  (result: Z)
  (Post3: result = `0`)
  (i0: Z)
  (Post2: (`0 <= i0` /\
          ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))) /\ `
          i0 >= N`)
  ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)).
Proof.
Intuition.
Apply (H2 k); Omega.
Save.

Definition search2 := (* validation *)
  [t: (array N Z)]
    let (result, Post3) = (exist_1 [result: Z]result = `0` `0`
      (refl_equal ? `0`)) in
    let (i0, result0, Post6) =
      let (i0, result0, Post7) =
        let (i0, result0, Post8) =
          (well_founded_induction Z (Zwf ZERO) (search2_po_1 result Post3)
            [Variant1: Z](i0: Z)(_: Variant1 = `N - i0`)(_0: `0 <= i0` /\
            ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
            (sig_2 Z (EM unit unit) [i1: Z][result0: (EM unit unit)]
             (((qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                (`0 <= i1` /\
                ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                `i1 >= N`)
               result0)))
            [Variant1: Z; wf1: (Variant2: Z)
             (Pre1: (Zwf `0` Variant2 Variant1))(i0: Z)
             (_: Variant2 = `N - i0`)(_0: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
             (sig_2 Z (EM unit unit) [i1: Z][result0: (EM unit unit)]
              (((qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                 (`0 <= i1` /\
                 ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                 `i1 >= N`)
                result0)));
             i0: Z; Pre4: Variant1 = `N - i0`; Pre3: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))]
              let (result0, Bool2) =
                let (result2, Post9) = (Z_lt_ge_bool i0 N) in
                (exist_1 [result3: bool]
                (if result3 then `i0 < N` else `i0 >= N`) result2 Post9) in
              (Cases (btest
                      [result0:bool](if result0 then `i0 < N` else `i0 >= N`)
                      result0 Bool2) of
              | (left Test4) =>
                  let (i1, result1, Post12) =
                    let (i1, result1, Post13) =
                      let (result1, Post14) =
                        let (result1, Bool1) =
                          let result2 =
                            let Pre2 =
                              (search2_po_2 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4) in
                            (Z_eq_bool (access t i0)) in
                          let (result3, Post15) = (result2 `0`) in
                          (exist_1 [result4: bool]
                          (if result4 then `(access t i0) = 0`
                           else `(access t i0) <> 0`) result3
                          Post15) in
                        (Cases (btest
                                [result1:bool](if result1
                                               then `(access t i0) = 0`
                                               else `(access t i0) <> 0`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (result2, Post17) =
                              (exist_1 (qcomb [result2: unit]
                                        `(access t i0) = 0` [result2: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Exn unit tt) Test3) in
                            Cases (decomp1 Post17) of
                            | (Qval (exist result2 Post18)) =>
                              (exist_1 (qcomb [result3: unit]
                                        `(access t i0) = 0` [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Val unit result2) Post18)
                            | (Qexn _ Post19) =>
                              (exist_1 (qcomb [result3: unit]
                                        `(access t i0) = 0` [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `N - i` `N - i0`)))) 
                              (Exn unit tt) Post19)
                            end
                        | (right Test2) =>
                            let (result2, Post16) = (exist_1 [result2: unit]
                              ((i:Z)
                               (i = `i0 + 1` -> (`0 <= i` /\
                                ((k:Z)
                                 (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
                                (Zwf `0` `N - i` `N - i0`))) tt
                              (search2_po_3 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4 Test2)) in
                            (exist_1 (qcomb [result3: unit]
                                      `(access t i0) = 0` [result3: unit]
                                      ((i:Z)
                                       (i = `i0 + 1` -> (`0 <= i` /\
                                        ((k:Z)
                                         (`0 <= k` /\ `k < i` ->
                                          `(access t k) <> 0`))) /\
                                        (Zwf `0` `N - i` `N - i0`)))) 
                            (Val unit result2) Post16) end) in
                      Cases (decomp1 Post14) of
                      | (Qval (exist result1 Post20)) =>
                        let (i1, result2, Post1) =
                          let (result2, Post1) = (exist_1 [result2: Z]
                            result2 = `i0 + 1` `i0 + 1`
                            (refl_equal ? `i0 + 1`)) in
                          (exist_2 [i2: Z][result3: unit]
                          i2 = `i0 + 1` result2 tt Post1) in
                        (exist_2 [i2: Z]
                        (qcomb [result3: unit]`(access t i2) = 0`
                         [result3: unit](`0 <= i2` /\
                         ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `N - i2` `N - i0`)) i1
                        (Val unit result2)
                        (search2_po_4 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 Post20 i1 Post1))
                      | (Qexn _ Post21) => (exist_2 [i1: Z]
                        (qcomb [result2: unit]`(access t i1) = 0`
                         [result2: unit](`0 <= i1` /\
                         ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `N - i1` `N - i0`)) i0 (Exn unit tt)
                        Post21)
                      end in
                    Cases (decomp1 Post13) of
                    | (Qval (exist result1 Post4)) =>
                      ((wf1 `N - i1`)
                        (search2_po_5 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 i1 Post4) i1 (refl_equal ? `N - i1`)
                        (proj1 ? ? Post4))
                    | (Qexn _ Post22) => (exist_2 [i2: Z]
                      (qcomb [result2: unit]`(access t i2) = 0`
                       [result2: unit](`0 <= i2` /\
                       ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                       `i2 >= N`) i1 (Exn unit tt) Post22)
                    end in
                  Cases (decomp1 Post12) of
                  | (Qval (exist result1 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Val unit result1) Post2)
                  | (Qexn _ Post23) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Exn unit tt) Post23)
                  end
              | (right Test1) =>
                  let (i1, result1, Post10) = (exist_2 [i1: Z]
                    (qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                     (`0 <= i1` /\
                     ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                     `i1 >= N`) i0 (Val unit tt) (conj ? ? Pre3 Test1)) in
                  Cases (decomp1 Post10) of
                  | (Qval (exist result1 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Val unit result1) Post2)
                  | (Qexn _ Post11) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= N`) i1 (Exn unit tt) Post11)
                  end end) `N - result` result (refl_equal ? `N - result`)
            (search2_po_6 t result Post3)) in
        Cases (decomp1 Post8) of
        | (Qval (exist result0 Post2)) =>
          let (result1, Post25) =
            (exist_1 (qcomb [result1: unit]
                      ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                      [result1: Z]`(access t result1) = 0`) (Exn Z tt)
            (search2_po_7 t result Post3 i0 Post2)) in
          Cases (decomp1 Post25) of
          | (Qval (exist result1 Post26)) => (exist_2 [i1: Z]
            (qcomb [result2: unit]`(access t i1) = 0`
             (qcomb [result2: unit]
              ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
              [result2: Z]`(access t result2) = 0`)) i0
            (Val unit (Val unit result1)) Post26)
          | (Qexn _ Post27) => (exist_2 [i1: Z]
            (qcomb [result2: unit]`(access t i1) = 0`
             (qcomb [result2: unit]
              ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
              [result2: Z]`(access t result2) = 0`)) i0 (Val unit (Exn Z tt))
            Post27)
          end
        | (Qexn _ Post24) => (exist_2 [i1: Z]
          (qcomb [result1: unit]`(access t i1) = 0`
           (qcomb [result1: unit]
            ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)) [result1: Z]
            `(access t result1) = 0`)) i0 (Exn (EM unit Z) tt) Post24)
        end in
      Cases (decomp2 Post7) of
      | (Qval (Qval (exist result0 Post28))) => (exist_2 [i1: Z]
        (qcomb [result1: unit]
         ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)) [result1: Z]
         `(access t result1) = 0`) i0 (Val unit result0) Post28)
      | (Qexn _ Post29) =>
        let (result1, Post30) = (exist_1 [result1: Z]
          `(access t result1) = 0` i0 Post29) in
        (exist_2 [i1: Z]
        (qcomb [result2: unit]
         ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)) [result2: Z]
         `(access t result2) = 0`) i0
        (Val unit result1) Post30)
      | (Qval (Qexn _ Post31)) => (exist_2 [i1: Z]
        (qcomb [result1: unit]
         ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`)) [result1: Z]
         `(access t result1) = 0`) i0 (Exn Z tt) Post31)
      end in
    Cases (decomp1 Post6) of
    | (Qval (exist result0 Post32)) =>
      (exist_1 (qcomb [result1: unit]
                ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Val unit result0)
      Post32)
    | (Qexn _ Post33) =>
      (exist_1 (qcomb [result1: unit]
                ((k:Z) (`0 <= k` /\ `k < N` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Exn Z tt) Post33)
    end.

