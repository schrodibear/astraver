(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.


(* Why obligation from file "search.mlw", characters 384-389 *)
Lemma search1_po_1 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  `0 <= i0` /\ `i0 < (array_length t)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "search.mlw", characters 381-415 *)
Lemma search1_po_2 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  (Test2: `(access t i0) <> 0`)
  ((i:Z)
   (i = `i0 + 1` -> (`0 <= i` /\
    ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
    (Zwf `0` `(array_length t) - i` `(array_length t) - i0`))).
Proof.
Intuition.
Assert k=i0 \/ `k<i0`. Omega. Intuition.
Subst k. Auto.
Apply (H0 k). Omega. Assumption.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "search.mlw", characters 231-443 *)
Lemma search1_po_3 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  (Post21: ((i:Z)
            (i = `i0 + 1` -> (`0 <= i` /\
             ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
             (Zwf `0` `(array_length t) - i` `(array_length t) - i0`))))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (`0 <= i1` /\ ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
  (Zwf `0` `(array_length t) - i1` `(array_length t) - i0`).
Proof.
Intuition.
Save.

(* Why obligation from file "search.mlw", characters 280-328 *)
Lemma search1_po_4 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  `0 <= result` /\ ((k:Z) (`0 <= k` /\ `k < result` -> `(access t k) <> 0`)).
Proof.
Intuition. Omega.
Save.

(* Why obligation from file "search.mlw", characters 449-470 *)
Lemma search1_po_5 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (i0: Z)
  (Post2: (`0 <= i0` /\
          ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))) /\
          `i0 >= (array_length t)`)
  ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)).
Proof.
Intuition.
Apply (H2 k); Omega.
Save.

Definition search1 := (* validation *)
  [t: (array Z)]
    let (result, Post6) =
      let (result, Post3) = (exist_1 [result: Z]result = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, result0, Post7) =
        let (i0, result0, Post8) =
          (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
            [Variant1: Z](i0: Z)(_: Variant1 = `(array_length t) - i0`)
            (_0: `0 <= i0` /\
            ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
            (sig_2 Z (EM Z unit) [i1: Z][result0: (EM Z unit)]
             (((qcomb [result1: Z]`(access t result1) = 0` [result1: unit]
                (`0 <= i1` /\
                ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                `i1 >= (array_length t)`)
               result0)))
            [Variant1: Z; wf1: (Variant2: Z)
             (Pre1: (Zwf `0` Variant2 Variant1))(i0: Z)
             (_: Variant2 = `(array_length t) - i0`)(_0: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
             (sig_2 Z (EM Z unit) [i1: Z][result0: (EM Z unit)]
              (((qcomb [result1: Z]`(access t result1) = 0` [result1: unit]
                 (`0 <= i1` /\
                 ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                 `i1 >= (array_length t)`)
                result0)));
             i0: Z; Pre4: Variant1 = `(array_length t) - i0`;
             Pre3: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))]
              let (result0, Bool2) =
                let (result2, Post9) = (Z_lt_ge_bool i0 (array_length t)) in
                (exist_1 [result3: bool]
                (if result3 then `i0 < (array_length t)`
                 else `i0 >= (array_length t)`) result2
                Post9) in
              (Cases (btest
                      [result0:bool](if result0 then `i0 < (array_length t)`
                                     else `i0 >= (array_length t)`)
                      result0 Bool2) of
              | (left Test4) =>
                  let (i1, result1, Post12) =
                    let (i1, result1, Post13) =
                      let (result1, Post14) =
                        let (result1, Bool1) =
                          let result2 =
                            let Pre2 =
                              (search1_po_1 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4) in
                            (Z_eq_bool (access t i0)) in
                          let (result3, Post15) = (result2 `0`) in
                          (exist_1 [result4: bool]
                          (if result4 then `(access t i0) = 0`
                           else `(access t i0) <> 0`) result3
                          Post15) in
                        (Cases (btest
                                [result1:bool](if result1
                                               then `(access t i0) = 0`
                                               else `(access t i0) <> 0`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (result2, Post17) =
                              let (result2, Post18) = (exist_1 [result2: Z]
                                `(access t result2) = 0` i0 Test3) in
                              (exist_1 (qcomb [result3: Z]
                                        `(access t result3) = 0`
                                        [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Exn unit result2) Post18) in
                            Cases (decomp1 Post17) of
                            | (Qval (exist result3 Post19)) =>
                              (exist_1 (qcomb [result4: Z]
                                        `(access t result4) = 0`
                                        [result4: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Val Z result3) Post19)
                            | (Qexn result3 Post20) =>
                              (exist_1 (qcomb [result4: Z]
                                        `(access t result4) = 0`
                                        [result4: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Exn unit result3) Post20)
                            end
                        | (right Test2) =>
                            let (result2, Post16) = (exist_1 [result2: unit]
                              ((i:Z)
                               (i = `i0 + 1` -> (`0 <= i` /\
                                ((k:Z)
                                 (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
                                (Zwf `0` `(array_length t) - i` `(array_length t) -
                                                                 i0`))) 
                              tt
                              (search1_po_2 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4 Test2)) in
                            (exist_1 (qcomb [result3: Z]
                                      `(access t result3) = 0`
                                      [result3: unit]
                                      ((i:Z)
                                       (i = `i0 + 1` -> (`0 <= i` /\
                                        ((k:Z)
                                         (`0 <= k` /\ `k < i` ->
                                          `(access t k) <> 0`))) /\
                                        (Zwf `0` `(array_length t) - i` `
                                        (array_length t) - i0`)))) (Val Z
                                                                    result2)
                            Post16) end) in
                      Cases (decomp1 Post14) of
                      | (Qval (exist result2 Post21)) =>
                        let (i1, result3, Post1) =
                          let (result3, Post1) = (exist_1 [result3: Z]
                            result3 = `i0 + 1` `i0 + 1`
                            (refl_equal ? `i0 + 1`)) in
                          (exist_2 [i2: Z][result4: unit]
                          i2 = `i0 + 1` result3 tt Post1) in
                        (exist_2 [i2: Z]
                        (qcomb [result4: Z]`(access t result4) = 0`
                         [result4: unit](`0 <= i2` /\
                         ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `(array_length t) - i2` `(array_length t) -
                                                           i0`)) i1
                        (Val Z result3)
                        (search1_po_3 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 Post21 i1 Post1))
                      | (Qexn result2 Post22) => (exist_2 [i1: Z]
                        (qcomb [result3: Z]`(access t result3) = 0`
                         [result3: unit](`0 <= i1` /\
                         ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `(array_length t) - i1` `(array_length t) -
                                                           i0`)) i0
                        (Exn unit result2) Post22)
                      end in
                    Cases (decomp1 Post13) of
                    | (Qval (exist result2 Post4)) =>
                      ((wf1 `(array_length t) - i1`)
                        (loop_variant_1 Pre4 Post4) i1
                        (refl_equal ? `(array_length t) - i1`)
                        (proj1 ? ? Post4))
                    | (Qexn result2 Post23) => (exist_2 [i2: Z]
                      (qcomb [result3: Z]`(access t result3) = 0`
                       [result3: unit](`0 <= i2` /\
                       ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                       `i2 >= (array_length t)`) i1 (Exn unit result2)
                      Post23)
                    end in
                  Cases (decomp1 Post12) of
                  | (Qval (exist result2 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result3: Z]`(access t result3) = 0`
                     [result3: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Val Z result2) Post2)
                  | (Qexn result2 Post24) => (exist_2 [i2: Z]
                    (qcomb [result3: Z]`(access t result3) = 0`
                     [result3: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Exn unit result2) Post24)
                  end
              | (right Test1) =>
                  let (i1, result1, Post10) = (exist_2 [i1: Z]
                    (qcomb [result1: Z]`(access t result1) = 0`
                     [result1: unit](`0 <= i1` /\
                     ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                     `i1 >= (array_length t)`) i0 (Val Z tt)
                    (conj ? ? Pre3 Test1)) in
                  Cases (decomp1 Post10) of
                  | (Qval (exist result2 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result3: Z]`(access t result3) = 0`
                     [result3: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Val Z result2) Post2)
                  | (Qexn result2 Post11) => (exist_2 [i2: Z]
                    (qcomb [result3: Z]`(access t result3) = 0`
                     [result3: unit](`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Exn unit result2) Post11)
                  end end) `(array_length t) - result` result
            (refl_equal ? `(array_length t) - result`)
            (search1_po_4 t result Post3)) in
        Cases (decomp1 Post8) of
        | (Qval (exist result1 Post2)) =>
          let (result2, Post26) =
            (exist_1 (qcomb [result2: unit]
                      ((k:Z)
                       (`0 <= k` /\ `k < (array_length t)` ->
                        `(access t k) <> 0`))
                      [result2: Z]`(access t result2) = 0`) (Exn Z tt)
            (search1_po_5 t result Post3 i0 Post2)) in
          Cases (decomp1 Post26) of
          | (Qval (exist result3 Post27)) => (exist_2 [i1: Z]
            (qcomb [result4: Z]`(access t result4) = 0`
             (qcomb [result4: unit]
              ((k:Z)
               (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
              [result4: Z]`(access t result4) = 0`)) i0
            (Val Z (Val unit result3)) Post27)
          | (Qexn _ Post28) => (exist_2 [i1: Z]
            (qcomb [result3: Z]`(access t result3) = 0`
             (qcomb [result3: unit]
              ((k:Z)
               (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
              [result3: Z]`(access t result3) = 0`)) i0 (Val Z (Exn Z tt))
            Post28)
          end
        | (Qexn result1 Post25) => (exist_2 [i1: Z]
          (qcomb [result2: Z]`(access t result2) = 0`
           (qcomb [result2: unit]
            ((k:Z)
             (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
            [result2: Z]`(access t result2) = 0`)) i0
          (Exn (EM unit Z) result1) Post25)
        end in
      Cases (decomp2 Post7) of
      | (Qval (Qval (exist result1 Post29))) =>
        (exist_1 (qcomb [result2: Z]`(access t result2) = 0`
                  (qcomb [result2: unit]
                   ((k:Z)
                    (`0 <= k` /\ `k < (array_length t)` ->
                     `(access t k) <> 0`))
                   [result2: Z]`(access t result2) = 0`)) (Val Z
                                                            (Val unit
                                                              result1))
        Post29)
      | (Qexn result1 Post30) =>
        (exist_1 (qcomb [result2: Z]`(access t result2) = 0`
                  (qcomb [result2: unit]
                   ((k:Z)
                    (`0 <= k` /\ `k < (array_length t)` ->
                     `(access t k) <> 0`))
                   [result2: Z]`(access t result2) = 0`)) (Exn (EM unit Z)
                                                            result1) Post30)
      | (Qval (Qexn _ Post31)) =>
        (exist_1 (qcomb [result1: Z]`(access t result1) = 0`
                  (qcomb [result1: unit]
                   ((k:Z)
                    (`0 <= k` /\ `k < (array_length t)` ->
                     `(access t k) <> 0`))
                   [result1: Z]`(access t result1) = 0`)) (Val Z (Exn Z tt))
        Post31)
      end in
    Cases (decomp2 Post6) of
    | (Qval (Qval (exist result0 Post32))) =>
      (exist_1 (qcomb [result1: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Val unit result0)
      Post32)
    | (Qexn result0 Post33) =>
      let (result1, Post34) = (exist_1 [result1: Z]
        `(access t result1) = 0` result0 Post33) in
      (exist_1 (qcomb [result2: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result2: Z]`(access t result2) = 0`) (Val unit result1)
      Post34)
    | (Qval (Qexn _ Post35)) =>
      (exist_1 (qcomb [result0: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result0: Z]`(access t result0) = 0`) (Exn Z tt) Post35)
    end.

(* Why obligation from file "search.mlw", characters 880-885 *)
Lemma search2_po_1 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  `0 <= i0` /\ `i0 < (array_length t)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "search.mlw", characters 877-906 *)
Lemma search2_po_2 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  (Test2: `(access t i0) <> 0`)
  ((i:Z)
   (i = `i0 + 1` -> (`0 <= i` /\
    ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
    (Zwf `0` `(array_length t) - i` `(array_length t) - i0`))).
Proof.
Intuition.
Assert k=i0 \/ `k<i0`. Omega. Intuition.
Subst k. Auto.
Apply (H0 k). Omega. Assumption.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "search.mlw", characters 735-934 *)
Lemma search2_po_3 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (Pre4: Variant1 = `(array_length t) - i0`)
  (Pre3: `0 <= i0` /\ ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
  (Test4: `i0 < (array_length t)`)
  (Post20: ((i:Z)
            (i = `i0 + 1` -> (`0 <= i` /\
             ((k:Z) (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
             (Zwf `0` `(array_length t) - i` `(array_length t) - i0`))))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (`0 <= i1` /\ ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
  (Zwf `0` `(array_length t) - i1` `(array_length t) - i0`).
Proof.
Intuition.
Save.

(* Why obligation from file "search.mlw", characters 784-832 *)
Lemma search2_po_4 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  `0 <= result` /\ ((k:Z) (`0 <= k` /\ `k < result` -> `(access t k) <> 0`)).
Proof.
Intuition. Omega.
Save.

(* Why obligation from file "search.mlw", characters 940-961 *)
Lemma search2_po_5 : 
  (t: (array Z))
  (result: Z)
  (Post3: result = `0`)
  (i0: Z)
  (Post2: (`0 <= i0` /\
          ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))) /\
          `i0 >= (array_length t)`)
  ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)).
Proof.
Intuition.
Apply (H2 k); Omega.
Save.

Definition search2 := (* validation *)
  [t: (array Z)]
    let (result, Post3) = (exist_1 [result: Z]result = `0` `0`
      (refl_equal ? `0`)) in
    let (i0, result0, Post6) =
      let (i0, result0, Post7) =
        let (i0, result0, Post8) =
          (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
            [Variant1: Z](i0: Z)(_: Variant1 = `(array_length t) - i0`)
            (_0: `0 <= i0` /\
            ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
            (sig_2 Z (EM unit unit) [i1: Z][result0: (EM unit unit)]
             (((qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                (`0 <= i1` /\
                ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                `i1 >= (array_length t)`)
               result0)))
            [Variant1: Z; wf1: (Variant2: Z)
             (Pre1: (Zwf `0` Variant2 Variant1))(i0: Z)
             (_: Variant2 = `(array_length t) - i0`)(_0: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`)))
             (sig_2 Z (EM unit unit) [i1: Z][result0: (EM unit unit)]
              (((qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                 (`0 <= i1` /\
                 ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                 `i1 >= (array_length t)`)
                result0)));
             i0: Z; Pre4: Variant1 = `(array_length t) - i0`;
             Pre3: `0 <= i0` /\
             ((k:Z) (`0 <= k` /\ `k < i0` -> `(access t k) <> 0`))]
              let (result0, Bool2) =
                let (result2, Post9) = (Z_lt_ge_bool i0 (array_length t)) in
                (exist_1 [result3: bool]
                (if result3 then `i0 < (array_length t)`
                 else `i0 >= (array_length t)`) result2
                Post9) in
              (Cases (btest
                      [result0:bool](if result0 then `i0 < (array_length t)`
                                     else `i0 >= (array_length t)`)
                      result0 Bool2) of
              | (left Test4) =>
                  let (i1, result1, Post12) =
                    let (i1, result1, Post13) =
                      let (result1, Post14) =
                        let (result1, Bool1) =
                          let result2 =
                            let Pre2 =
                              (search2_po_1 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4) in
                            (Z_eq_bool (access t i0)) in
                          let (result3, Post15) = (result2 `0`) in
                          (exist_1 [result4: bool]
                          (if result4 then `(access t i0) = 0`
                           else `(access t i0) <> 0`) result3
                          Post15) in
                        (Cases (btest
                                [result1:bool](if result1
                                               then `(access t i0) = 0`
                                               else `(access t i0) <> 0`)
                                result1 Bool1) of
                        | (left Test3) =>
                            let (result2, Post17) =
                              (exist_1 (qcomb [result2: unit]
                                        `(access t i0) = 0` [result2: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Exn unit tt) Test3) in
                            Cases (decomp1 Post17) of
                            | (Qval (exist result3 Post18)) =>
                              (exist_1 (qcomb [result4: unit]
                                        `(access t i0) = 0` [result4: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Val unit result3) Post18)
                            | (Qexn _ Post19) =>
                              (exist_1 (qcomb [result3: unit]
                                        `(access t i0) = 0` [result3: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` -> (`0 <= i` /\
                                          ((k:Z)
                                           (`0 <= k` /\ `k < i` ->
                                            `(access t k) <> 0`))) /\
                                          (Zwf `0` `(array_length t) - i` `
                                          (array_length t) - i0`)))) 
                              (Exn unit tt) Post19)
                            end
                        | (right Test2) =>
                            let (result2, Post16) = (exist_1 [result2: unit]
                              ((i:Z)
                               (i = `i0 + 1` -> (`0 <= i` /\
                                ((k:Z)
                                 (`0 <= k` /\ `k < i` -> `(access t k) <> 0`))) /\
                                (Zwf `0` `(array_length t) - i` `(array_length t) -
                                                                 i0`))) 
                              tt
                              (search2_po_2 t result Post3 Variant1 i0 Pre4
                              Pre3 Test4 Test2)) in
                            (exist_1 (qcomb [result3: unit]
                                      `(access t i0) = 0` [result3: unit]
                                      ((i:Z)
                                       (i = `i0 + 1` -> (`0 <= i` /\
                                        ((k:Z)
                                         (`0 <= k` /\ `k < i` ->
                                          `(access t k) <> 0`))) /\
                                        (Zwf `0` `(array_length t) - i` `
                                        (array_length t) - i0`)))) (Val unit
                                                                    result2)
                            Post16) end) in
                      Cases (decomp1 Post14) of
                      | (Qval (exist result2 Post20)) =>
                        let (i1, result3, Post1) =
                          let (result3, Post1) = (exist_1 [result3: Z]
                            result3 = `i0 + 1` `i0 + 1`
                            (refl_equal ? `i0 + 1`)) in
                          (exist_2 [i2: Z][result4: unit]
                          i2 = `i0 + 1` result3 tt Post1) in
                        (exist_2 [i2: Z]
                        (qcomb [result4: unit]`(access t i2) = 0`
                         [result4: unit](`0 <= i2` /\
                         ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `(array_length t) - i2` `(array_length t) -
                                                           i0`)) i1
                        (Val unit result3)
                        (search2_po_3 t result Post3 Variant1 i0 Pre4 Pre3
                        Test4 Post20 i1 Post1))
                      | (Qexn _ Post21) => (exist_2 [i1: Z]
                        (qcomb [result2: unit]`(access t i1) = 0`
                         [result2: unit](`0 <= i1` /\
                         ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                         (Zwf `0` `(array_length t) - i1` `(array_length t) -
                                                           i0`)) i0
                        (Exn unit tt) Post21)
                      end in
                    Cases (decomp1 Post13) of
                    | (Qval (exist result2 Post4)) =>
                      ((wf1 `(array_length t) - i1`)
                        (loop_variant_1 Pre4 Post4) i1
                        (refl_equal ? `(array_length t) - i1`)
                        (proj1 ? ? Post4))
                    | (Qexn _ Post22) => (exist_2 [i2: Z]
                      (qcomb [result2: unit]`(access t i2) = 0`
                       [result2: unit](`0 <= i2` /\
                       ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                       `i2 >= (array_length t)`) i1 (Exn unit tt) Post22)
                    end in
                  Cases (decomp1 Post12) of
                  | (Qval (exist result2 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result3: unit]`(access t i2) = 0` [result3: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Val unit result2) Post2)
                  | (Qexn _ Post23) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Exn unit tt) Post23)
                  end
              | (right Test1) =>
                  let (i1, result1, Post10) = (exist_2 [i1: Z]
                    (qcomb [result1: unit]`(access t i1) = 0` [result1: unit]
                     (`0 <= i1` /\
                     ((k:Z) (`0 <= k` /\ `k < i1` -> `(access t k) <> 0`))) /\
                     `i1 >= (array_length t)`) i0 (Val unit tt)
                    (conj ? ? Pre3 Test1)) in
                  Cases (decomp1 Post10) of
                  | (Qval (exist result2 Post2)) => (exist_2 [i2: Z]
                    (qcomb [result3: unit]`(access t i2) = 0` [result3: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Val unit result2) Post2)
                  | (Qexn _ Post11) => (exist_2 [i2: Z]
                    (qcomb [result2: unit]`(access t i2) = 0` [result2: unit]
                     (`0 <= i2` /\
                     ((k:Z) (`0 <= k` /\ `k < i2` -> `(access t k) <> 0`))) /\
                     `i2 >= (array_length t)`) i1 (Exn unit tt) Post11)
                  end end) `(array_length t) - result` result
            (refl_equal ? `(array_length t) - result`)
            (search2_po_4 t result Post3)) in
        Cases (decomp1 Post8) of
        | (Qval (exist result1 Post2)) =>
          let (result2, Post25) =
            (exist_1 (qcomb [result2: unit]
                      ((k:Z)
                       (`0 <= k` /\ `k < (array_length t)` ->
                        `(access t k) <> 0`))
                      [result2: Z]`(access t result2) = 0`) (Exn Z tt)
            (search2_po_5 t result Post3 i0 Post2)) in
          Cases (decomp1 Post25) of
          | (Qval (exist result3 Post26)) => (exist_2 [i1: Z]
            (qcomb [result4: unit]`(access t i1) = 0`
             (qcomb [result4: unit]
              ((k:Z)
               (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
              [result4: Z]`(access t result4) = 0`)) i0
            (Val unit (Val unit result3)) Post26)
          | (Qexn _ Post27) => (exist_2 [i1: Z]
            (qcomb [result3: unit]`(access t i1) = 0`
             (qcomb [result3: unit]
              ((k:Z)
               (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
              [result3: Z]`(access t result3) = 0`)) i0 (Val unit (Exn Z tt))
            Post27)
          end
        | (Qexn _ Post24) => (exist_2 [i1: Z]
          (qcomb [result1: unit]`(access t i1) = 0`
           (qcomb [result1: unit]
            ((k:Z)
             (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
            [result1: Z]`(access t result1) = 0`)) i0 (Exn (EM unit Z) tt)
          Post24)
        end in
      Cases (decomp2 Post7) of
      | (Qval (Qval (exist result1 Post28))) => (exist_2 [i1: Z]
        (qcomb [result2: unit]
         ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
         [result2: Z]`(access t result2) = 0`) i0 (Val unit result1) Post28)
      | (Qexn _ Post29) =>
        let (result1, Post30) = (exist_1 [result1: Z]
          `(access t result1) = 0` i0 Post29) in
        (exist_2 [i1: Z]
        (qcomb [result2: unit]
         ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
         [result2: Z]`(access t result2) = 0`) i0
        (Val unit result1) Post30)
      | (Qval (Qexn _ Post31)) => (exist_2 [i1: Z]
        (qcomb [result1: unit]
         ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
         [result1: Z]`(access t result1) = 0`) i0 (Exn Z tt) Post31)
      end in
    Cases (decomp1 Post6) of
    | (Qval (exist result1 Post32)) =>
      (exist_1 (qcomb [result2: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result2: Z]`(access t result2) = 0`) (Val unit result1)
      Post32)
    | (Qexn _ Post33) =>
      (exist_1 (qcomb [result1: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Exn Z tt) Post33)
    end.

(* Why obligation from file "search.mlw", characters 1499-1513 *)
Lemma search3_po_1 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  `0 <= 0` /\ `0 <= (array_length t)`.
Proof.
Intros; Omega.
Save.

(* Why obligation from file "search.mlw", characters 1310-1331 *)
Lemma search3_po_2 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre10: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre11: `0 <= 0` /\ `0 <= (array_length t)`)
  (Variant1: Z)
  (i0: Z)
  (Pre8: Variant1 = `(array_length t) - i0`)
  (Pre7: `0 <= i0` /\ `i0 <= (array_length t)`)
  (Test4: `i0 = (array_length t)`)
  ((k:Z) (`i0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)).
Proof.
Intros; Omega.
Save.

(* Why obligation from file "search.mlw", characters 1346-1350 *)
Lemma search3_po_3 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre10: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre11: `0 <= 0` /\ `0 <= (array_length t)`)
  (Variant1: Z)
  (i0: Z)
  (Pre8: Variant1 = `(array_length t) - i0`)
  (Pre7: `0 <= i0` /\ `i0 <= (array_length t)`)
  (Test3: `i0 <> (array_length t)`)
  `0 <= i0` /\ `i0 < (array_length t)`.
Proof.
Intuition.
Save.

(* Why obligation from file "search.mlw", characters 1373-1393 *)
Lemma search3_po_4 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre10: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre11: `0 <= 0` /\ `0 <= (array_length t)`)
  (Variant1: Z)
  (i0: Z)
  (Pre8: Variant1 = `(array_length t) - i0`)
  (Pre7: `0 <= i0` /\ `i0 <= (array_length t)`)
  (Test3: `i0 <> (array_length t)`)
  (Test1: `(access t i0) <> 0`)
  `0 <= i0 + 1` /\ `i0 + 1 <= (array_length t)`.
Proof.
Intuition.
Save.

(* Why obligation from file "search.mlw", characters 1245-1490 *)
Lemma search3_po_5 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre10: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre11: `0 <= 0` /\ `0 <= (array_length t)`)
  (Variant1: Z)
  (i0: Z)
  (Pre8: Variant1 = `(array_length t) - i0`)
  (Pre7: `0 <= i0` /\ `i0 <= (array_length t)`)
  (Test3: `i0 <> (array_length t)`)
  (Test1: `(access t i0) <> 0`)
  (Pre6: `0 <= i0 + 1` /\ `i0 + 1 <= (array_length t)`)
  (Pre4: `0 <= i0 + 1` /\ `i0 + 1 <= (array_length t)`)
  (Pre5: `0 <= i0 + 1` /\ `i0 + 1 <= (array_length t)`)
  (Zwf `0` `(array_length t) - (i0 + 1)` Variant1).
Proof.
Unfold Zwf; Intuition.
Save.

(* Why obligation from file "search.mlw", characters 1373-1393 *)
Lemma search3_po_6 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre10: `0 <= 0` /\ `0 <= (array_length t)`)
  (Pre11: `0 <= 0` /\ `0 <= (array_length t)`)
  (Variant1: Z)
  (i0: Z)
  (Pre8: Variant1 = `(array_length t) - i0`)
  (Pre7: `0 <= i0` /\ `i0 <= (array_length t)`)
  (Test3: `i0 <> (array_length t)`)
  (Test1: `(access t i0) <> 0`)
  (Pre6: `0 <= i0 + 1` /\ `i0 + 1 <= (array_length t)`)
  (Post11: ((k:Z)
            (`i0 + 1 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)))
  ((k:Z) (`i0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)).
Proof.
Intuition.
Assert k=i0 \/ `i0<k`. Omega. Intuition.
Subst k; Auto.
Apply Post11 with k; Omega.
Save.

(* Why obligation from file "search.mlw", characters 1145-1604 *)
Lemma search3_po_7 : 
  (t: (array Z))
  (Pre13: `0 <= (array_length t)`)
  (Pre12: `0 <= 0` /\ `0 <= (array_length t)`)
  (Post23: ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)))
  ((k:Z) (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`)).
Proof.
Intuition.
Save.

Definition search3 := (* validation *)
  [t: (array Z); Pre13: `0 <= (array_length t)`]
    let Pre12 = (search3_po_1 t Pre13) in
    let (result, Post18) =
      let Pre10 = Pre12 in
      let Pre11 = Pre10 in
      let (result1, Post19) =
        (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
          [Variant1: Z](i0: Z)(_: Variant1 = `(array_length t) - i0`)
          (_0: `0 <= i0` /\ `i0 <= (array_length t)`)
          (sig_1 (EM unit Z) [result: (EM unit Z)]
           (((qcomb [result0: unit]
              ((k:Z)
               (`i0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
              [result0: Z]`(access t result0) = 0`)
             result)))
          [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
           (i0: Z)(_: Variant2 = `(array_length t) - i0`)(_0: `0 <= i0` /\
           `i0 <= (array_length t)`)
           (sig_1 (EM unit Z) [result: (EM unit Z)]
            (((qcomb [result0: unit]
               ((k:Z)
                (`i0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
               [result0: Z]`(access t result0) = 0`)
              result)));
           i0: Z; Pre8: Variant1 = `(array_length t) - i0`;
           Pre7: `0 <= i0` /\ `i0 <= (array_length t)`]
            let (result, Bool6) =
              let (result1, Post3) = (Z_eq_bool i0 (array_length t)) in
              (exist_1 [result2: bool]
              (if result2 then `i0 = (array_length t)`
               else `i0 <> (array_length t)`) result1
              Post3) in
            (Cases (btest
                    [result:bool](if result then `i0 = (array_length t)`
                                  else `i0 <> (array_length t)`)
                    result Bool6) of
            | (left Test4) =>
                let (result0, Post15) =
                  (exist_1 (qcomb [result0: unit]
                            ((k:Z)
                             (`i0 <= k` /\ `k < (array_length t)` ->
                              `(access t k) <> 0`))
                            [result0: Z]`(access t result0) = 0`) (Exn Z tt)
                  (search3_po_2 t Pre13 Pre12 Pre10 Pre11 Variant1 i0 Pre8
                  Pre7 Test4)) in
                Cases (decomp1 Post15) of
                | (Qval (exist result1 Post16)) =>
                  (exist_1 (qcomb [result2: unit]
                            ((k:Z)
                             (`i0 <= k` /\ `k < (array_length t)` ->
                              `(access t k) <> 0`))
                            [result2: Z]`(access t result2) = 0`) (Val unit
                                                                    result1)
                  Post16)
                | (Qexn _ Post17) =>
                  (exist_1 (qcomb [result1: unit]
                            ((k:Z)
                             (`i0 <= k` /\ `k < (array_length t)` ->
                              `(access t k) <> 0`))
                            [result1: Z]`(access t result1) = 0`) (Exn Z tt)
                  Post17)
                end
            | (right Test3) =>
                let (result0, Post4) =
                  let (result0, Bool5) =
                    let result1 =
                      let Pre2 =
                        (search3_po_3 t Pre13 Pre12 Pre10 Pre11 Variant1 i0
                        Pre8 Pre7 Test3) in
                      (Z_eq_bool (access t i0)) in
                    let (result2, Post5) = (result1 `0`) in
                    (exist_1 [result3: bool]
                    (if result3 then `(access t i0) = 0`
                     else `(access t i0) <> 0`) result2
                    Post5) in
                  (Cases (btest
                          [result0:bool](if result0 then `(access t i0) = 0`
                                         else `(access t i0) <> 0`)
                          result0 Bool5) of
                  | (left Test2) =>
                      let (result1, Post12) = (exist_1 [result1: Z]
                        `(access t result1) = 0` i0 Test2) in
                      (exist_1 (qcomb [result2: unit]
                                ((k:Z)
                                 (`i0 <= k` /\ `k < (array_length t)` ->
                                  `(access t k) <> 0`))
                                [result2: Z]`(access t result2) = 0`) 
                      (Val unit result1) Post12)
                  | (right Test1) =>
                      let Pre6 =
                        (search3_po_4 t Pre13 Pre12 Pre10 Pre11 Variant1 i0
                        Pre8 Pre7 Test3 Test1) in
                      let (result1, Post6) =
                        let Pre4 = Pre6 in
                        let Pre5 = Pre4 in
                        let (result3, Post7) =
                          ((wf1 `(array_length t) - (i0 + 1)`)
                            (search3_po_5 t Pre13 Pre12 Pre10 Pre11 Variant1
                            i0 Pre8 Pre7 Test3 Test1 Pre6 Pre4 Pre5) 
                            `i0 + 1`
                            (refl_equal ? `(array_length t) - (i0 + 1)`)
                            Pre5) in
                        Cases (decomp1 Post7) of
                        | (Qval (exist result4 Post8)) =>
                          (exist_1 (qcomb [result5: unit]
                                    ((k:Z)
                                     (`i0 + 1 <= k` /\
                                      `k < (array_length t)` ->
                                      `(access t k) <> 0`))
                                    [result5: Z]`(access t result5) = 0`) 
                          (Val unit result4) Post8)
                        | (Qexn _ Post9) =>
                          (exist_1 (qcomb [result4: unit]
                                    ((k:Z)
                                     (`i0 + 1 <= k` /\
                                      `k < (array_length t)` ->
                                      `(access t k) <> 0`))
                                    [result4: Z]`(access t result4) = 0`) 
                          (Exn Z tt) Post9)
                        end in
                      Cases (decomp1 Post6) of
                      | (Qval (exist result2 Post10)) =>
                        (exist_1 (qcomb [result3: unit]
                                  ((k:Z)
                                   (`i0 <= k` /\ `k < (array_length t)` ->
                                    `(access t k) <> 0`))
                                  [result3: Z]`(access t result3) = 0`) 
                        (Val unit result2) Post10)
                      | (Qexn _ Post11) =>
                        (exist_1 (qcomb [result2: unit]
                                  ((k:Z)
                                   (`i0 <= k` /\ `k < (array_length t)` ->
                                    `(access t k) <> 0`))
                                  [result2: Z]`(access t result2) = 0`) 
                        (Exn Z tt)
                        (search3_po_6 t Pre13 Pre12 Pre10 Pre11 Variant1 i0
                        Pre8 Pre7 Test3 Test1 Pre6 Post11))
                      end end) in
                Cases (decomp1 Post4) of
                | (Qval (exist result1 Post13)) =>
                  (exist_1 (qcomb [result2: unit]
                            ((k:Z)
                             (`i0 <= k` /\ `k < (array_length t)` ->
                              `(access t k) <> 0`))
                            [result2: Z]`(access t result2) = 0`) (Val unit
                                                                    result1)
                  Post13)
                | (Qexn _ Post14) =>
                  (exist_1 (qcomb [result1: unit]
                            ((k:Z)
                             (`i0 <= k` /\ `k < (array_length t)` ->
                              `(access t k) <> 0`))
                            [result1: Z]`(access t result1) = 0`) (Exn Z tt)
                  Post14)
                end end) `(array_length t) - 0` `0`
          (refl_equal ? `(array_length t) - 0`) Pre11) in
      Cases (decomp1 Post19) of
      | (Qval (exist result2 Post20)) =>
        (exist_1 (qcomb [result3: unit]
                  ((k:Z)
                   (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                  [result3: Z]`(access t result3) = 0`) (Val unit result2)
        Post20)
      | (Qexn _ Post21) =>
        (exist_1 (qcomb [result2: unit]
                  ((k:Z)
                   (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                  [result2: Z]`(access t result2) = 0`) (Exn Z tt) Post21)
      end in
    Cases (decomp1 Post18) of
    | (Qval (exist result0 Post22)) =>
      (exist_1 (qcomb [result1: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result1: Z]`(access t result1) = 0`) (Val unit result0)
      Post22)
    | (Qexn _ Post23) =>
      (exist_1 (qcomb [result0: unit]
                ((k:Z)
                 (`0 <= k` /\ `k < (array_length t)` -> `(access t k) <> 0`))
                [result0: Z]`(access t result0) = 0`) (Exn Z tt)
      (search3_po_7 t Pre13 Pre12 Post23))
    end.

