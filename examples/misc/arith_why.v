(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Import Omega.
Require Import Zdiv.
Require Import ZArithRing.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_1 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  x >= 0 /\ (0 + x * y) = (x * y).
Proof.
intuition.
Save.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_2 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  forall (a: Z),
  forall (b: Z),
  forall (p: Z),
  forall (HW_2: a >= 0 /\ (p + a * b) = (x * y)),
  forall (HW_3: a <> 0),
  forall (HW_4: ((Zmod a 2)) = 1),
  forall (p0: Z),
  forall (HW_5: p0 = (p + b)),
  forall (result: Z),
  forall (HW_6: result = ((Zdiv a 2))),
  forall (a0: Z),
  forall (HW_7: a0 = result),
  forall (b0: Z),
  forall (HW_8: b0 = (2 * b)),
  (a0 >= 0 /\ (p0 + a0 * b0) = (x * y)) /\ (Zwf 0 a0 a).
Proof.
intuition.
subst; apply Z_div_ge0; omega.
rewrite (Z_div_mod_eq a 2) in H2.
rewrite <- H2.
subst.
rewrite HW_4.
ring.
omega.
unfold Zwf.
 repeat split; try omega.
subst; apply Z_div_lt; try omega.
Save.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_3 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  forall (a: Z),
  forall (b: Z),
  forall (p: Z),
  forall (HW_2: a >= 0 /\ (p + a * b) = (x * y)),
  forall (HW_3: a <> 0),
  forall (HW_4: ((Zmod a 2)) = 1),
  forall (p0: Z),
  forall (HW_5: p0 = (p + b)),
  2 <> 0.
Proof.
intuition.
Save.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_4 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  forall (a: Z),
  forall (b: Z),
  forall (p: Z),
  forall (HW_2: a >= 0 /\ (p + a * b) = (x * y)),
  forall (HW_3: a <> 0),
  forall (HW_9: ((Zmod a 2)) <> 1),
  forall (result: Z),
  forall (HW_10: result = ((Zdiv a 2))),
  forall (a0: Z),
  forall (HW_11: a0 = result),
  forall (b0: Z),
  forall (HW_12: b0 = (2 * b)),
  (a0 >= 0 /\ (p + a0 * b0) = (x * y)) /\ (Zwf 0 a0 a).
Proof.
intuition.
subst; apply Z_div_ge0; try omega.
rewrite (Z_div_mod_eq a 2) in H2.
rewrite <- H2.
subst.
replace (a mod 2)%Z with 0%Z.
ring.
cut (2 > 0)%Z; [ intro h | omega ].
generalize (Z_mod_lt a 2 h).
cut ((a mod 2)%Z <> 1%Z); intros; try omega.
omega.
unfold Zwf.
repeat split; try omega.
subst; apply Z_div_lt; try omega.
Save.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_5 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  forall (a: Z),
  forall (b: Z),
  forall (p: Z),
  forall (HW_2: a >= 0 /\ (p + a * b) = (x * y)),
  forall (HW_3: a <> 0),
  forall (HW_9: ((Zmod a 2)) <> 1),
  2 <> 0.
Proof.
intuition.
Save.

(* Why obligation from file "arith.mlw", line 0, characters 0-0: *)
(*Why goal*) Lemma mult_po_6 : 
  forall (x: Z),
  forall (y: Z),
  forall (HW_1: x >= 0 /\ y >= 0),
  forall (a: Z),
  forall (b: Z),
  forall (p: Z),
  forall (HW_2: a >= 0 /\ (p + a * b) = (x * y)),
  forall (HW_13: a = 0),
  p = (x * y).
Proof.
intuition; subst.
rewrite <- H2; ring.
Save.

