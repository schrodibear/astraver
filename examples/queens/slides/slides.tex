\documentclass[handout,compress]{beamer}
%\documentclass[compress]{beamer}

\usepackage{amssymb}
\usepackage{beamerjcf}

\title{Queens on a Chessboard}
\author{Jean-Christophe Filli\^atre}
%\institute{CNRS -- Universit\'e Paris Sud}
\date[Krakatoa/Caduceus WG]{Dec 15th, 2006\\
  Krakatoa/Caduceus working group}

\newcommand{\kw}[1]{{\color{blue}#1}}
\newcommand{\minelt}[1]{\ensuremath{\mathit{min\_elt}(#1)}}

\begin{document}

\begin{frame}
  \begin{center}
    {\Huge\emph{Queens on a Chessboard}} \\[1em]
    {\LARGE\emph{an exercise in program verification}} \\[3em]
    {\large Jean-Christophe Filli\^atre} \\[2em]
    Krakatoa/Caduceus working group \\[0.5em]
    December 15th, 2006
  \end{center}
\end{frame}
 
\begin{frame}[fragile]
  \frametitle{Introduction}

challenge for \emph{the verified program of the month}:

\bigskip

{\scriptsize
\begin{verbatim}
   t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
   c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
\end{verbatim}}

\Pause

appears on a web page collecting C signature programs 

\bigskip

due to Marcel van Kervinck, \par
author of MSCP (Marcel's Simple Chess Program)
\end{frame}

\begin{frame}
  \frametitle{Unobfuscating...}
\begin{caduceus}
int t(int a, int b, int c) {
  int d=0, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=(e-=d)&-e;)
      f+=t(a-d,(b+d)*2,(c+d)/2);
  return f;
}
\end{caduceus}
\only<1>{%
\begin{caduceus}
int main(int q) {
  scanf("%d",&q);
  printf("%d\n",t(~(~0<<q),0,0));
}
\end{caduceus}
}%
\only<2>{%
\begin{caduceus}
int f(int n) {
  return t(~(~0<<n), 0, 0);
}
\end{caduceus}

\bigskip

we end up with a mysterious function 
\texttt{f} : $\mathbb{N} \rightarrow \mathbb{N}$
}
\end{frame}

\begin{frame}
  \frametitle{Queens on a chessboard}

given a number $n$ smaller than 32, 
$\mathtt{f}(n)$ is the number of ways to put $n$ queens on $n\times n$
chessboard so that they cannot beat each other

\Pause

let us prove that this program is \emph{correct}, that is:
\begin{itemize}
\item it does not crash
\item it terminates
\item it computes the right number
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why is it challenging?}
  in two lines of code we have
  \begin{itemize}
  \item C idiomatic bitwise operations
  \item loops \&\ recursion, involved in a backtracking algorithm
  \item highly efficient code
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How does it work?}
  \begin{itemize}
  \item backtracking algorithm (no better way to solve the $N$ queens)
  \item integers used as \emph{sets} (bit vectors)
  \end{itemize}
  \pause
  \begin{center}
    \begin{tabular}{r|l}
      integers & sets \\\hline
    \verb!0! & $\emptyset$ \\
   \verb!a&b! & $a\cap b$ \\
       \verb!a+b! & $a\cup b$, \quad when $a\cap b=\emptyset$ \\
       \verb!a-b! & $a\backslash\,b$, \quad when $b\subseteq a$ \\
     \verb!~a! & $\complement a$ \\
     \verb!a&-a! & $\minelt{a}$, \quad when $a\not=\emptyset$ \\
     \verb!~(~0<<n)! & $\{0,1,\dots,n-1\}$ \\
     \verb!a*2! & $\{i+1~|~i\in a\}$, \quad written $S(a)$ \\
     \verb!a/2! & $\{i-1~|~i\in a \land i\not=0\}$, \quad written $P(a)$ \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Code rephrased on sets}
{\tt\begin{obeylines}
  int t($a$, $b$, $c$) \\
  ~~ \kw{if} $a \not= \emptyset$ \\
  ~~~~ $e$ $\leftarrow$ $(a \backslash  b) \backslash c$ \\
  ~~~~ $f$ $\leftarrow$ 0 \\
  ~~~~ \kw{while} $e \not=\emptyset$ \\
  ~~~~~~ $d$ $\leftarrow$ $\minelt{e}$ \\
  ~~~~~~ $f$ $\leftarrow$ $f$ $+$ t($a\backslash \{d\}$, $S(b\cup\{d\})$, $P(c\cup\{d\})$) \\
  ~~~~~~ $e$ $\leftarrow$ $e \backslash  \{d\}$ \\
  ~~~~ \kw{return} $f$ \\
  ~~ \kw{else} \\
  ~~~~ \kw{return} $1$ \\
  ~~ \\
  int f($n$) \\
  ~~ \kw{return} t($\{0,1,\dots,n-1\}$, $\emptyset$, $\emptyset$)
\end{obeylines}}
\end{frame}

\font\Chess=chess10
\newcommand{\qw}{\vrule height 1.5em width 0pt{\Chess Q}}
\newcommand{\qb}{\vrule height 1.5em width 0pt{\Chess q}}
\newcommand{\qr}{\vrule height 1.5em width 0pt{\color{red}\Chess q}}
\newcommand{\vide}{\vrule height 1.5em width 0pt\phantom{\Chess q}}
\newcommand{\qm}{\vrule height 1.5em width 0pt\hfil?\hfil}

\begin{frame}
  \frametitle{What $a$, $b$ and $c$ mean}
\only<1>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \vide & \vide & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \vide & \vide & \vide & \vide \\\hline
      \qm & \qm & \qm & \qm & \qm & \qm & \qm & \qm \\\hline
    \end{tabular}
  \end{center}
\bigskip
\phantom{$a$ = columns to be filled = $11100101_2$}
}
\only<2>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \qw   & \vide & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \qw   & \vide & \qw   & \vide \\\hline
      \qr   & \qr   & \qr   & \qw   & \qw   & \qr   & \qw   & \qr   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$a$ = columns to be filled = $11100101_2$
}
\only<3>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \qw   & \vide & \vide & \qb   & \vide \\\hline
      \vide & \vide & \qw   & \qb   & \vide & \qw   & \vide & \vide \\\hline
      \vide & \qr   & \qr   & \vide & \qr   & \vide & \vide & \vide \\\hline
    \end{tabular}
  \end{center}
\bigskip
$b$ = positions to avoid because of left diagonals = $01101000_2$
}
\only<4>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \vide & \qw   & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \vide & \vide & \qw   & \qw   \\\hline
      \vide & \vide & \vide & \vide & \qr   & \vide & \vide & \qr   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$c$ = positions to avoid because of right diagonals = $00001001_2$
}
\only<5>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \qw   & \qw   & \qw   & \qb   & \vide \\\hline
      \vide & \vide & \qw   & \qb   & \qw   & \qw   & \qw   & \qw   \\\hline
      \qr   & \qw   & \qw   & \qw   & \qw   & \qr   & \qw   & \qw   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$a$\&\~{}$b$\&\~{}$c$ = positions to try = $10000100_2$
}
\end{frame}

\begin{frame}
  \frametitle{Now it is clear}
\begin{caduceus}
int t(int a, int b, int c) {
  int d=0, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=(e-=d)&-e;)
      f += t(a-d,(b+d)*2,(c+d)/2);
  return f;
}

int f(int n) {
  return t(~(~0<<n), 0, 0);
}
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Abstract finite sets}
\begin{caduceus}
//@ type iset

//@ predicate in_(int x, iset s)

/*@ predicate included(iset a, iset b) 
  @  { \forall int i; in_(i,a) => in_(i,b) } */

//@ logic iset empty()

//@ axiom empty_def : \forall int i; !in_(i,empty())

...    
\end{caduceus}

total: \emph{66 lines} of functions, predicates and axioms
\end{frame}

\begin{frame}
  \frametitle{C ints as abstract sets}
\begin{caduceus}
//@ logic iset iset(int x)

/*@ axiom iset_c_zero : \forall int x; 
  @   iset(x)==empty() <=> x==0 */

/*@ axiom iset_c_min_elt :
  @   \forall int x; x != 0 => 
  @     iset(x&-x) == singleton(min_elt(iset(x))) */

/*@ axiom iset_c_diff : \forall int a, int b; 
  @   iset(a&~b) == diff(iset(a), iset(b)) */

...
\end{caduceus}

total: \emph{27 lines} / should be proved independently
\end{frame}

\begin{frame}
  \frametitle{Warmup: termination of the for loop}
\begin{caduceus}
int t(int a, int b, int c){
  int d=0, e=a&~b&~c, f=1;
  if (a)
    //@ variant card(iset(e-d))
    for (f=0; d=(e-=d)&-e; ) {
      f += t(a-d,(b+d)*2,(c+d)/2);
    }
  return f;
}
\end{caduceus}
\bigskip
3 verification conditions, all proved automatically
\end{frame}

\begin{frame}
  \frametitle{Warmup: termination of the recursive function}
\small
\begin{caduceus}
int t(int a, int b, int c){
  int d=0, e=a&~b&~c, f=1;
  //@ label L
  if (a)
    /*@ invariant 
      @   included(iset(e-d), iset(e)) &&
      @   included(iset(e),\at(iset(e),L)) 
      @*/
    for (f=0; d=(e-=d)&-e; ) {
      /*@ assert \exists int x; 
        @   iset(d) == singleton(x) && in_(x,iset(e)) */
      //@ assert card(iset(a-d)) < card(iset(a))
      f += t(a-d,(b+d)*2,(c+d)/2);
    }
  return f;
}
\end{caduceus}
\bigskip
7 verification conditions, all proved automatically
\end{frame}

\begin{frame}
  \frametitle{Soundness}
  how to express that we compute the right number, \par
  since the program is not storing anything, \par 
  not even the current solution?

  \Pause
  answer: by introducing \emph{ghost code} to perform the missing operations
\end{frame}

\begin{frame}
  \frametitle{Ghost code}
  
  ghost code can be regarded as regular code, as soon as
  \begin{itemize}
  \item ghost code does not modify program data
  \item program code does not access ghost data
  \end{itemize}

  \bigskip
  ghost data is purely logical $\Rightarrow$ ne need to check the validity
  of pointers

  \bigskip

  ghost code is currently restricted in Caduceus, but should not be
\end{frame}

\begin{frame}
  \frametitle{Program instrumented with ghost code}
\small
\begin{caduceus}
//@ int** sol; 
//@ int s; 
//@ int* col;  
//@ int k;     

int t(int a, int b, int c){
  int d=0, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=(e-=d)&-e; ) {
      //@ col[k] = min_elt(d);                 
      //@ k++;                        
      f += t3(a-d, (b+d)*2, (c+d)/2);
      //@ k--;
    }
  //@ else 
  //@   store_solution();
  return f;
}
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Annotations (1/4)}
\begin{caduceus}
/*@ requires solution(col)
  @ assigns  s, sol[s][0..N()-1]
  @ ensures  s==\old(s)+1 && eq_sol(sol[\old(s)], col)
  @*/
void store_solution();

/*@ requires 
  @   n == N() && s == 0 && k == 0
  @ ensures 
  @   \result == s &&
  @   \forall int* t; solution(t) <=> 
  @      (\exists int i; 0<=i<\result && eq_sol(t,sol[i]))
  @*/
int queens(int n) {
  return t(~(~0<<n),0,0);
}
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Annotations (2/4)}
\begin{caduceus}
//@ logic int N()

/*@ predicate partial_solution(int k, int* s) {
  @   \forall int i; 0 <= i < k => 
  @     0 <= s[i] < N() &&
  @     (\forall int j; 0 <= j < i => s[i] != s[j] &&
  @                                   s[i]-s[j] != i-j &&
  @                                   s[i]-s[j] != j-i)
  @ }
  @*/

//@ predicate solution(int* s) { partial_solution(N(), s) }
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Annotations (3/4): specification of \texttt{t}}
\small
\begin{caduceus}
/*@ requires
  @   0 <= k && k + card(iset(a)) == N() && 0 <= s &&
  @   pre_a:: (\forall int i; in_(i,iset(a)) <=> 
  @            (0<=i<N() && \forall int j; 0<=j<k => i != col[j])) &&
  @   pre_b:: (\forall int i; i>=0 => (in_(i,iset(b)) <=> 
  @            (\exists int j; 0<=j<k && col[j] == i+j-k))) &&
  @   pre_c:: (\forall int i; i>=0 => (in_(i,iset(c)) <=> 
  @            (\exists int j; 0<=j<k && col[j] == i+k-j))) &&
  @   partial_solution(k, col)
  @ assigns
  @   col[k..], s, k, sol[s..][..]
  @ ensures  
  @   \result == s - \old(s) && \result >= 0 && k == \old(k) &&
  @   \forall int* t; 
  @      ((solution(t) && eq_prefix(col,t,k)) <=>
  @      (\exists int i; \old(s)<=i<s && eq_sol(t, sol[i])))
  @*/
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Annotations (4/4): loop invariant}
\small
\begin{caduceus}
/*@ invariant 
  @   included(iset(e-d),iset(e)) && 
  @   included(iset(e),\at(iset(e),L)) &&
  @   f == s - \at(s,L) && f >= 0 && k == \old(k) && 
  @   partial_solution(k, col) &&
  @   \forall int *t; 
  @     (solution(t) && 
  @      \exists int di; in_(di, diff(iset(e),\at(iset(e),L))) &&
  @        eq_prefix(col,t,k) && t[k]==di) <=>
  @     (\exists int i; \at(s,L)<=i<s && eq_sol(t, sol[i]))
  @ loop_assigns
  @   col[k..], s, k, sol[s..][..]
  @*/
for (f=0; d=(e-=d)&-e; ) {
  ...
\end{caduceus}
\end{frame}

\begin{frame}
  \frametitle{Finally, we get...}

\emph{256} lines of code and specification

\Pause
on a slightly more abstract Why version of the program:
\begin{itemize}
\item main function \texttt{queens}: \emph{15} verification conditions
  \begin{itemize}
  \item \emph{all} proved automatically (Simplify, Ergo or Yices)
  \end{itemize}
\item recursive function \texttt{t}: \emph{51} verification conditions
  \begin{itemize}
  \item \emph{42} proved automatically: 41 by Simplify, 37 by Ergo and
    35 by Yices
  \item \emph{9} proved manually using Coq (and Simplify)
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Missing}

  we need to show that there is no duplicate among the solutions

  \Pause
  improve the results on the C version:
  \begin{itemize}
  \item \texttt{queens}: 13/15
  \item \texttt{t}: 39/54 (72\% instead of 80\%)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Overflows}
  the requirement $n<32$ is not an issue

  world record is $n=25$ 

  all computers will be 64 bits before we reach $n=32$

  \Pause
  \emph{but} the program contains unrelevant overflows when $n\ge 16$

  thus ensuring the absence of overflows would require $n<16$

  we need a \emph{model of overflows} for this program
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
