%\documentclass[handout,compress]{beamer}
\documentclass[compress]{beamer}

\usepackage{amssymb}
\usepackage{beamerjcf}

\title{Queens on a Chessboard}
\author{Jean-Christophe Filli\^atre}
%\institute{CNRS -- Universit\'e Paris Sud}
\date[Krakatoa/Caduceus WG]{Dec 15th, 2006\\
  Krakatoa/Caduceus working group}

\newcommand{\kw}[1]{{\color{blue}#1}}
\newcommand{\minelt}[1]{\ensuremath{\mathit{min\_elt}(#1)}}

\begin{document}

\begin{frame}
  \begin{center}
    {\Huge\emph{Queens on a Chessboard}} \\[1em]
    {\LARGE\emph{an exercise in program verification}} \\[3em]
    {\large Jean-Christophe Filli\^atre} \\[2em]
    Krakatoa/Caduceus working group \\[0.5em]
    December 15th, 2006
  \end{center}
\end{frame}
 
\begin{frame}[fragile]
  \frametitle{Introduction}

challenge for \emph{the verified program of the month}:

\bigskip

{\scriptsize
\begin{verbatim}
   t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
   c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
\end{verbatim}}

\Pause

appears on a web page collecting C signature programs 

\bigskip

due to Marcel van Kervinck, \par
author of MSCP (Marcel's Simple Chess Program)
\end{frame}

\begin{frame}
  \frametitle{Unobfuscating...}
\begin{caduceus}
int t(int a, int b, int c) {
  int d=0, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=(e-=d)&-e;)
      f+=t(a-d,(b+d)*2,(c+d)/2);
  return f;
}
\end{caduceus}
\only<1>{%
\begin{caduceus}
int main(int q) {
  scanf("%d",&q);
  printf("%d\n",t(~(~0<<q),0,0));
}
\end{caduceus}
}%
\only<2>{%
\begin{caduceus}
int f(int n) {
  return t(~(~0<<n), 0, 0);
}
\end{caduceus}

\bigskip

we end up with a mysterious function 
\texttt{f} : $\mathbb{N} \rightarrow \mathbb{N}$
}
\end{frame}

\begin{frame}
  \frametitle{Queens on a chessboard}

given a number $n$ smaller than 32, 
$\mathtt{f}(n)$ is the number of ways to put $n$ queens on $n\times n$
chessboard so that they cannot beat each other

\Pause

let us prove that this program is \emph{correct}, that is:
\begin{itemize}
\item it does not crash
\item it terminates
\item it computes the right number
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why is it challenging?}
  in two lines of code we have
  \begin{itemize}
  \item C idiomatic bitwise operations
  \item loops \&\ recursion, involved in a backtracking algorithm
  \item highly efficient code
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How does it work?}
  \begin{itemize}
  \item backtracking algorithm (no better way to solve the $N$ queens)
  \item integers used as \emph{sets} (bit vectors)
  \end{itemize}
  \pause
  \begin{center}
    \begin{tabular}{r|l}
      integers & sets \\\hline
    \verb!0! & $\emptyset$ \\
   \verb!a&b! & $a\cap b$ \\
       \verb!a+b! & $a\cup b$, \quad when $a\cap b=\emptyset$ \\
       \verb!a-b! & $a\backslash\,b$, \quad when $b\subseteq a$ \\
     \verb!~a! & $\complement a$ \\
     \verb!a&-a! & $\minelt{a}$, \quad when $a\not=\emptyset$ \\
     \verb!~(~0<<n)! & $\{0,1,\dots,n-1\}$ \\
     \verb!a*2! & $\{i+1~|~i\in a\}$, \quad written $S(a)$ \\
     \verb!a/2! & $\{i-1~|~i\in a \land i\not=0\}$, \quad written $P(a)$ \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Code rephrased on sets}
{\tt\begin{obeylines}
  int t($a$, $b$, $c$) \\
  ~~ \kw{if} $a \not= \emptyset$ \\
  ~~~~ $e$ $\leftarrow$ $(a \backslash  b) \backslash c$ \\
  ~~~~ $f$ $\leftarrow$ 0 \\
  ~~~~ \kw{while} $e \not=\emptyset$ \\
  ~~~~~~ $d$ $\leftarrow$ $\minelt{e}$ \\
  ~~~~~~ $f$ $\leftarrow$ $f$ $+$ t($a\backslash \{d\}$, $S(b\cup\{d\})$, $P(c\cup\{d\})$) \\
  ~~~~~~ $e$ $\leftarrow$ $e \backslash  \{d\}$ \\
  ~~~~ \kw{return} $f$ \\
  ~~ \kw{else} \\
  ~~~~ \kw{return} $1$ \\
  ~~ \\
  int f($n$) \\
  ~~ \kw{return} t($\{0,1,\dots,n-1\}$, $\emptyset$, $\emptyset$)
\end{obeylines}}
\end{frame}

\font\Chess=chess10
\newcommand{\qw}{\vrule height 1.5em width 0pt{\Chess Q}}
\newcommand{\qb}{\vrule height 1.5em width 0pt{\Chess q}}
\newcommand{\qr}{\vrule height 1.5em width 0pt{\color{red}\Chess q}}
\newcommand{\vide}{\vrule height 1.5em width 0pt\phantom{\Chess q}}
\newcommand{\qm}{\vrule height 1.5em width 0pt\hfil?\hfil}

\begin{frame}
  \frametitle{What $a$, $b$ and $c$ mean}
\only<1>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \vide & \vide & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \vide & \vide & \vide & \vide \\\hline
      \qm & \qm & \qm & \qm & \qm & \qm & \qm & \qm \\\hline
    \end{tabular}
  \end{center}
\bigskip
\phantom{$a$ = columns to be filled = $11100101_2$}
}
\only<2>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \qw   & \vide & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \qw   & \vide & \qw   & \vide \\\hline
      \qr   & \qr   & \qr   & \qw   & \qw   & \qr   & \qw   & \qr   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$a$ = columns to be filled = $11100101_2$
}
\only<3>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \qw   & \vide & \vide & \qb   & \vide \\\hline
      \vide & \vide & \qw   & \qb   & \vide & \qw   & \vide & \vide \\\hline
      \vide & \qr   & \qr   & \vide & \qr   & \vide & \vide & \vide \\\hline
    \end{tabular}
  \end{center}
\bigskip
$b$ = positions to avoid because of left diagonals = $01101000_2$
}
\only<4>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \vide & \vide & \qw   & \qb   & \vide \\\hline
      \vide & \vide & \vide & \qb   & \vide & \vide & \qw   & \qw   \\\hline
      \vide & \vide & \vide & \vide & \qr   & \vide & \vide & \qr   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$c$ = positions to avoid because of right diagonals = $00001001_2$
}
\only<5>{
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      \vide & \vide & \vide & \vide & \qb   & \vide & \vide & \vide \\\hline
      \vide & \vide & \vide & \qw   & \qw   & \qw   & \qb   & \vide \\\hline
      \vide & \vide & \qw   & \qb   & \qw   & \qw   & \qw   & \qw   \\\hline
      \qr   & \qw   & \qw   & \qw   & \qw   & \qr   & \qw   & \qw   \\\hline
    \end{tabular}
  \end{center}
\bigskip
$a$\&\~{}$b$\&\~{}$c$ = positions to try = $10000100_2$
}
\end{frame}

\begin{frame}
  \frametitle{Abstract finite sets}
\begin{caduceus}
//@ type iset

//@ predicate in_(int x, iset s)

/*@ predicate included(iset a, iset b) 
  @  { \forall int i; in_(i,a) => in_(i,b) } */

//@ logic iset empty()

//@ axiom empty_def : \forall int i; !in_(i,empty())

...    
\end{caduceus}

total: \emph{66 lines} of functions, predicates and axioms
\end{frame}

\begin{frame}
  \frametitle{C ints as abstract sets}
\begin{caduceus}
//@ logic iset iset(int x)

/*@ axiom iset_c_zero : \forall int x; 
  @   iset(x)==empty() <=> x==0 */

/*@ axiom iset_c_min_elt :
  @   \forall int x; x != 0 => 
  @     iset(x&-x) == singleton(min_elt(iset(x))) */

/*@ axiom iset_c_diff : \forall int a, int b; 
  @   iset(a&~b) == diff(iset(a), iset(b)) */

...
\end{caduceus}

total: \emph{27 lines} / should be proved independently
\end{frame}

\begin{frame}
  \frametitle{Warmup: termination of the for loop}
\begin{caduceus}
int t(int a, int b, int c){
  int d=0, e=a&~b&~c, f=1;
  if (a)
    /*@ variant card(iset(e-d)) */
    for (f=0; d=(e-=d)&-e; ) {
      f+=t1(a-d,(b+d)*2,(c+d)/2);
    }
  return f;
}
\end{caduceus}
\Pause
\end{frame}

\begin{frame}
  TODO: INTRODUCTION DU CODE GHOST POUR STOCKER LES SOLUTIONS
\end{frame}

\begin{frame}
  TODO: ANNOTATIONS DU CODE
\end{frame}

\begin{frame}
  TODO: PREUVE AVEC SIMPLIFY/ERGO ET AVEC COQ+SIMPLIFY
\end{frame}

\begin{frame}
  \frametitle{Ghost code}
  
  ghost code can be handled as regular code, as soon as
  \begin{itemize}
  \item ghost code does not modify program data
  \item program code does not access ghost data
  \end{itemize}

  ghost code should not be otherwise restricted
\end{frame}

\begin{frame}
  \frametitle{Overflows}
  the requirement $n<32$ is not an issue

  world record is $n=25$ 

  all computers will be 64 bits before we reach $n=32$

  \Pause
  \emph{but} the program contains unrelevant overflows when $n\ge 16$

  thus ensuring the absence of overflows would require $n<16$

  we need a \emph{model of overflows} for this program
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
