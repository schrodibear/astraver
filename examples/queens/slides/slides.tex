%\documentclass[handout,compress]{beamer}
\documentclass[compress]{beamer}

\usepackage{amssymb}
\usepackage{beamerjcf}

\title{Queens on a Chessboard}
\author{Jean-Christophe Filli\^atre}
%\institute{CNRS -- Universit\'e Paris Sud}
\date[Krakatoa/Caduceus WG]{Dec 15th, 2006\\
  Krakatoa/Caduceus working group}

\newcommand{\kw}[1]{{\color{blue}#1}}
\newcommand{\minelt}[1]{\ensuremath{\mathit{min\_elt}(#1)}}

\begin{document}

\begin{frame}
  \begin{center}
    {\Huge\emph{Queens on a Chessboard}} \\[1em]
    {\LARGE\emph{an exercise in program verification}} \\[3em]
    {\large Jean-Christophe Filli\^atre} \\[2em]
    Krakatoa/Caduceus working group \\[0.5em]
    December 15th, 2006
  \end{center}
\end{frame}
 
\begin{frame}[fragile]
  \frametitle{Introduction}

challenge for \emph{the verified program of the month}:

\bigskip

{\scriptsize
\begin{verbatim}
   t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
   c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
\end{verbatim}}

\Pause

appears on a web page collecting C signature programs 

\bigskip

due to Marcel van Kervinck, \par
author of MSCP (Marcel's Simple Chess Program)
\end{frame}

\begin{frame}
  \frametitle{Unobfuscating...}
\begin{caduceus}
int t(int a, int b, int c) {
  int d=0, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=(e-=d)&-e;)
      f+=t(a-d,(b+d)*2,(c+d)/2);
  return f;
}
\end{caduceus}
\only<1>{%
\begin{caduceus}
int main(int q) {
  scanf("%d",&q);
  printf("%d\n",t(~(~0<<q),0,0));
}
\end{caduceus}
}%
\only<2>{%
\begin{caduceus}
int f(int n) {
  return t(~(~0<<n), 0, 0);
}
\end{caduceus}

\bigskip

we end up with a mysterious function 
\texttt{f} : $\mathbb{N} \rightarrow \mathbb{N}$
}
\end{frame}

\begin{frame}
  \frametitle{Queens on a chessboard}

given a number $n$ smaller than 32, 
$\mathtt{f}(n)$ is the number of ways to put $n$ queens on $n\times n$
chessboard so that they cannot beat each other

\Pause

let us prove that this program is \emph{correct}, that is:
\begin{itemize}
\item it does not crash
\item it terminates
\item it computes the right number
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why is it challenging?}
  in two lines of code we have
  \begin{itemize}
  \item C idiomatic bitwise operations
  \item loops \&\ recursion, involved in a backtracking algorithm
  \item highly efficient code
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How does it work?}
  \begin{itemize}
  \item backtracking algorithm (no better way to solve the $N$ queens)
  \item integers used as \emph{sets} (bit vectors)
  \end{itemize}
  \pause
  \begin{center}
    \begin{tabular}{r|l}
      integers & sets \\\hline
    \verb!0! & $\emptyset$ \\
   \verb!a&b! & $a\cap b$ \\
       \verb!a+b! & $a\cup b$, \quad when $a\cap b=\emptyset$ \\
       \verb!a-b! & $a\backslash\,b$, \quad when $b\subseteq a$ \\
     \verb!~a! & $\complement a$ \\
     \verb!a&-a! & $\minelt{a}$, \quad when $a\not=\emptyset$ \\
     \verb!~(~0<<n)! & $\{0,1,\dots,n-1\}$ \\
     \verb!a*2! & $\{i+1~|~i\in a\}$, \quad written $S(a)$ \\
     \verb!a/2! & $\{i-1~|~i\in a \land i\not=0\}$, \quad written $P(a)$ \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Code rephrased on sets}
{\tt\begin{obeylines}
  \kw{int} t($a$, $b$, $c$) \\
  ~~ \kw{if} $a \not= \emptyset$ \\
  ~~~~ $e$ $\leftarrow$ $(a \backslash  b) \backslash c$ \\
  ~~~~ $f$ $\leftarrow$ 0 \\
  ~~~~ \kw{while} $e \not=\emptyset$ \\
  ~~~~~~ $d$ $\leftarrow$ $\minelt{e}$ \\
  ~~~~~~ $f$ $\leftarrow$ $f$ $+$ t($a\backslash \{d\}$, $S(b\cup\{d\})$, $P(c\cup\{d\})$) \\
  ~~~~~~ $e$ $\leftarrow$ $e \backslash  \{d\}$ \\
  ~~~~ \kw{return} $f$ \\
  ~~ \kw{else} \\
  ~~~~ \kw{return} $1$ \\
  ~~ \\
  \kw{int} f($n$) \\
  ~~ \kw{return} t($\{0,1,\dots,n-1\}$, $\emptyset$, $\emptyset$)
\end{obeylines}}
\end{frame}

\begin{frame}
  \frametitle{}
  TODO: DESSIN ICI
\end{frame}

\begin{frame}
  \frametitle{Warmup: termination}
  TODO: PREUVE TERMINAISON
\end{frame}

\begin{frame}
  TODO: AXIOMATISATION ENSEMBLES FINIS EN CADUCEUS
\end{frame}

\begin{frame}
  TODO: INTRODUCTION DU CODE GHOST POUR STOCKER LES SOLUTIONS
\end{frame}

\begin{frame}
  TODO: ANNOTATIONS DU CODE
\end{frame}

\begin{frame}
  TODO: PREUVE AVEC SIMPLIFY/ERGO ET AVEC COQ+SIMPLIFY
\end{frame}

\begin{frame}
  \frametitle{Ghost code}
  
  ghost code can be handled as regular code, as soon as
  \begin{itemize}
  \item ghost code does not modify program data
  \item program code does not access ghost data
  \end{itemize}

  ghost code should not be otherwise restricted
\end{frame}

\begin{frame}
  \frametitle{Overflows}
  the requirement $n<32$ is not an issue

  world record is $n=25$ 

  all computers will be 64 bits before we reach $n=32$

  \Pause
  \emph{but} the program contains unrelevant overflows when $n\ge 16$

  thus ensuring the absence of overflows would require $n<16$

  we need a \emph{model of overflows} for this program
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
