
-----------------------------------------------------------

  Paper: 17
  Title: Queens on a Chessboard: an Exercise in Program Verification


-------------------- review 1 --------------------
  
REVIEWER'S CONFIDENCE: 2 (medium)  
----------------------- REVIEW --------------------

This is a nice example of verification of highly optimized code. It
proves correctness of a curious two-liner C program for counting the
number of solutions to the n-queens problem. The relevance of the
effort is in demonstrating how dificult correctness problems can be
tackled with the aid of a set of mechanical provers and with an
elaborate methodology for specification and generation of verification
conditions.

The author uses his own tool Caduceus to extend the original C code
with annotations in a rich specification language. Caduceus then
produces verification conditions that are in turn disposed of by
either (1) some integrated off-the-shelf automated theorem prover, or
(2) interactive proof within an integrated off-the-shelf proof
assistant (interactive theorem prover).

The annotation language and its use are interesting. In particular,
the use of the "ghost code" to introduce and track some auxiliary
state for reasoning purposes is quite impressive.

The paper is clear and elegant. It's a relatively light but rewarding
reading. The author can be praised for devoloping a technique
applicable to hard program correctness problems and for demonstrating
the power and applicability of the technique on a convincing example.


** Minor suggestions

The author applies automated provers Simplify and Ergo to simpler
verification conditions, while the harder ones are handled with
additional use of the interactive prover Coq. It is implicit that both
Simplify and Ergo were needed and were used for different kinds of
goals. Could the readers be given some clue about the differences?

page 2: The phrase "unravel the mystery" is used three times. Reword.

Section 3, paragraph 2: "To make it clear" --> "To illustrate"

Section 4.2: Remove or rephrase the sentence "This is some kind of
warmup..."

Section 4.3: "It consists in..." --> "It consists of..."

Aren't "ghost" variables simply history variables that strengthen the
invariant? 


-------------------- review 2 --------------------
  
REVIEWER'S CONFIDENCE: 3 (high)  
----------------------- REVIEW --------------------

The paper presents a tool that automatically extracts verification conditions.
The contributions of the paper are the ability to handle C programs and to introduce the abstract model. Once the verification conditions are generated they can be solved by several theorem provers. 

This tool was already presneted in previous papers and I believe the novelty in this paper relative to the previous ones is not big enough. 


-------------------- review 3 --------------------
  
REVIEWER'S CONFIDENCE: 3 (high)  
----------------------- REVIEW --------------------

The paper is a specification and verification case study, showing the
verification of a program that computes the number of Queens solutions
for any given chessboard size.  The paper explains things clearly and
makes for a fun read.

Pros:

- The case study is different from the kind of verifications where the
user guides a theorem prover to produce a proof of a deeply embedded
program (as you could undertake with tools like Jive or ACL2, or
straight in Coq).  Instead, this verification starts with a tool that
generates verification conditions (VCs), and most of the VCs are
discharged by automatic SMT solvers; the rest were carried out
manually in Coq.  This shows the use of a VC generator that targets
both SMT solvers and interactive theorem provers.

- The specification is not entirely trivial.  In particular, it's not
immediately clear how to specify and verify that the program does
count all solutions.

Cons:

- The proof needs support theory and axioms (the paper argues that
these could be part of a common Caduceus library, but there will
always be additional functions--like min_elt, succ, and pred--that are
more specific to the program at hand).  The paper doesn't give many
details of this axiomatization.  Would the axioms be useful in other
tools?  Could they be rephrased to work better with automatic SMT
solvers?  How does one know that the special functions are axiomatized
correctly?

- A fifth of the verification conditions had to be discharged
manually.  With such a high proportion of manual proofs, it might be
that standard tactics in interactive theorem provers could have
discharged the ones that Simplify did automatically in this case
study.  Thus, the first pro I mention above is less strong.

- There is no comparison to other program verifiers and proof checkers
with similar capabilities (what made the verification with Caduceus
especially easy? What could other tools have done equally well or
better? Etc.) or to related case studies.  An accepted version of this
paper certainly would need to address this.

Detailed comments:

* p.1 "this is a very efficient program to compute this number"  Since there is a limit on the word size, a more efficient program would be to use a lookup table that contains pre-computed solutions.
* p.5 "wide panel" -> "wide selection"
* p.6 ff.  "cardinal" -> "cardinality"
* p.6 If you also had one's and two's complement, perhaps you could derive the properties of min_elt as theorems?
* p.6 "empties" -> "becomes empty"
* p.7 "Two verification conditions ... cannot be discharged automatically"  What is the error message?  Just "loop invariant not maintained" or something more (or less?) specific than that?
* p.8 col is a ghost variable, but does it point into the actual memory or into some ghost memory?  If the latter, there's still an issue of aliasing.  Is that how Caduceus does it, or does a ghost declaration like "int* col" declare its own "memory"?  That is, is col a map variable or a pointer into some memory?
* p.9 "Stated otherwise" -> "Stated differently"
* p.10 "requires that col must be" -> "requires that col be"
* p.10 "... this collaboration between interactive and automatic provers can be considered successful".  This is nice to hear
* p.10, 600 lines of Coq scripts.  How are these stored?  How can they be replayed?
* p.11 "unrelevant" -> "irrelevant"
* p.11 about n>16 and overflow.  A simple tweak of the program would strip out the high bit before doing a left shift.  Then overflow approach (2) can be used. 


-------------------- review 4 --------------------
  
REVIEWER'S CONFIDENCE: 3 (high)  
----------------------- REVIEW --------------------

The paper is a specification and verification case study, showing the
verification of a program that computes the number of Queens solutions
for any given chessboard size.  The paper explains things clearly and
makes for a fun read.

Pros:

- The case study is different from the kind of verifications where the
user guides a theorem prover to produce a proof of a deeply embedded
program (as you could undertake with tools like Jive or ACL2, or
straight in Coq).  Instead, this verification starts with a tool that
generates verification conditions (VCs), and most of the VCs are
discharged by automatic SMT solvers; the rest were carried out
manually in Coq.  This shows the use of a VC generator that targets
both SMT solvers and interactive theorem provers.

- The specification is not entirely trivial.  In particular, it's not
immediately clear how to specify and verify that the program does
count all solutions.

Cons:

- The proof needs support theory and axioms (the paper argues that
these could be part of a common Caduceus library, but there will
always be additional functions--like min_elt, succ, and pred--that are
more specific to the program at hand).  The paper doesn't give many
details of this axiomatization.  Would the axioms be useful in other
tools?  Could they be rephrased to work better with automatic SMT
solvers?  How does one know that the special functions are axiomatized
correctly?

- A fifth of the verification conditions had to be discharged
manually.  With such a high proportion of manual proofs, it might be
that standard tactics in interactive theorem provers could have
discharged the ones that Simplify did automatically in this case
study.  Thus, the first pro I mention above is less strong.

- There is no comparison to other program verifiers and proof checkers
with similar capabilities (what made the verification with Caduceus
especially easy? What could other tools have done equally well or
better? Etc.) or to related case studies.  An accepted version of this
paper certainly would need to address this.

Detailed comments:

* p.1 "this is a very efficient program to compute this number"  Since there is a limit on the word size, a more efficient program would be to use a lookup table that contains pre-computed solutions.
* p.5 "wide panel" -> "wide selection"
* p.6 ff.  "cardinal" -> "cardinality"
* p.6 If you also had one's and two's complement, perhaps you could derive the properties of min_elt as theorems?
* p.6 "empties" -> "becomes empty"
* p.7 "Two verification conditions ... cannot be discharged automatically"  What is the error message?  Just "loop invariant not maintained" or something more (or less?) specific than that?
* p.8 col is a ghost variable, but does it point into the actual memory or into some ghost memory?  If the latter, there's still an issue of aliasing.  Is that how Caduceus does it, or does a ghost declaration like "int* col" declare its own "memory"?  That is, is col a map variable or a pointer into some memory?
* p.9 "Stated otherwise" -> "Stated differently"
* p.10 "requires that col must be" -> "requires that col be"
* p.10 "... this collaboration between interactive and automatic provers can be considered successful".  This is nice to hear
* p.10, 600 lines of Coq scripts.  How are these stored?  How can they be replayed?
* p.11 "unrelevant" -> "irrelevant"
* p.11 about n>16 and overflow.  A simple tweak of the program would strip out the high bit before doing a left shift.  Then overflow approach (2) can be used. 
