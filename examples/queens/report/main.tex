\documentclass[a4paper]{llncs}
\usepackage{url}
\usepackage{epsfig}

\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\caduceus}{\textsc{Caduceus}}
\newcommand{\minelt}[1]{\ensuremath{\mathit{min\_elt}(#1)}}

\begin{document}

\title{Queens on a Chessboard: \\
       an Exercise in Program Verification}
\author{Jean-Christophe Filli\^atre}
\institute{CNRS -- Universit\'e Paris Sud \\ 91405 Orsay, France}
\maketitle

\begin{abstract}
  This article details the formal verification of a 2-lines C program
  which computes the number of solutions to the $N$-queens problem.
\end{abstract}

\section{Introduction}

Formal methods deal either with small properties of big programs or
big properties of small programs. This paper describes a case study
which definitely belongs to the latter category.
Indeed, it details the formal verification of the following 2-lines C program:
{\small%
\begin{verbatim}
t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
\end{verbatim}}
\noindent 
This rather obfuscated code was found on a web page gathering C signature
programs\footnote{\url{http://www.iwriteiam.nl/SigProgC.html}} and is
apparently due to Marcel van Kervinc. This is a standalone C program
which reads an integer on the standard input, say $n$, and then prints another
integer on the standard output, say $f(n)$. If $n$ is smaller than the
machine word size (typically 32), then
$f(n)$ appears to be the number of solutions to the famous $n$-queens
problem, that is the number of ways to put $n$ queens on a $n\times n$
chessboard so that they cannot beat each other. And even more
surprisingly, this is a very efficient program to compute this number.

As a case study for \caduceus, a tool we are
co-developing~\cite{caduceus}, we considered 
the formal verification of this program. By verification, we mean here
the mechanically-assisted proof that this program (1) does not crash, 
(2) terminates, and (3) indeed computes the right number. We find this
challenging since these two lines of code are at the same time idiomatic C
programming, complex from an algorithmic point of view and highly
efficient. Thus we can demonstrate the ability of our tools to tackle
a wide range of verification issues without considering a too long
program. 

This paper is organized as follows. First Section~\ref{unobf}
``unobfuscates'' the program, unravelling the mystery of its algorithm
and data. Then Section~\ref{caduceus} briefly introduces \caduceus.
Finally Section~\ref{verif} details the formal verification,
namely the logical annotations inserted in the program
and the methods used to discharge the resulting verification conditions.
The annotated source code and the proofs are available online at
\url{http://why.lri.fr/queens/}.


\section{Unobfuscation}\label{unobf}

Before entering the formal verification process, we first unravel the
mystery behind this obfuscated code. The code is composed of two
parts: a recursive function \texttt{t}, which takes three integers as
arguments and returns an integer; and a main function which reads an
integer from the standard input, makes a call to the function
\texttt{t} and prints the result on the standard output.
With type declarations and a bit of indentation, the function
\texttt{t} reads as follows:
\begin{verbatim}
int t(int a, int b, int c) {
  int d=0,e=a&~b&~c,f=1;
  if(a) for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(c+d)/2));
  return f;
}
\end{verbatim}
The assignment \verb!d=(e-=d)&-e! actually does not conform with the
ANSI norm, because it assumes that the inner assignment \verb!e-=d! is
performed before the evaluation of \verb!-e!. This is not guaranteed
and the compiler may freely choose between the two possible evaluation
strategies. Since \caduceus\ only deals with ANSI C programs,
we need to modify the code. Fortunately, this is quite easy:
since \verb!d! is initialized to 0 we can move the
assignment \verb!e-=d! to the end of the loop body and save the
initialization. We have even reduced the size of the original code.
The second modification we make is to replace the \texttt{main}
function with a \texttt{queens} function from \texttt{int} to
\texttt{int}, since \caduceus\ does not support the \texttt{scanf} and
\texttt{printf} library functions.
We end up with the code given in Figure~\ref{fig:code}, which is the
one we prove correct in this paper.
\begin{figure}[t]
  \centering\hrulefill\vspace{-1em}
\begin{verbatim}
int t(int a, int b, int c) {
  int d, e=a&~b&~c, f=1;
  if (a)
    for (f=0; d=e&-e; e-=d)
      f += t(a-d,(b+d)*2,(c+d)/2));
  return f;
}
int queens(int n) {
  return t(~(~0<<n),0,0);
}
\end{verbatim}  
\vspace{-1.2em}\hrulefill\vspace{-1em}
  \caption{The C code to be verified}
  \label{fig:code}
\end{figure}

We now explain how the program works. This is a backtracking algorithm
which fills the rows of the chessboard one at a time.
%--- there is no better way to solve the $N$-queens problem --- 
More precisely, each call to \texttt{t} enumerates all possible
positions for a queen on the current row with the \texttt{for} loop
and, for each of them, recursively calls \texttt{t} to set the next
rows.  The number of solutions is accumulated in \texttt{f} and
returned.  The key idea is the use of integers as \emph{sets} or
equivalently as \emph{bit vectors}: $i$ belongs to the ``set'' $x$ if and
only if the $i$-th bit of $x$ is set.
Following this idea, the program variables
\texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} and \texttt{e} must
be interpreted as subsets of $\{0,1,\dots,n-1\}$.
Then almost all computations in this program are actually to be
understood as set operations. Some of them are obvious: \verb!a&~b&~c!
computes the set $\mathtt{a}\backslash\mathtt{b}\backslash\mathtt{c}$,
the test \verb!if(a)! checks whether \texttt{a} is empty, etc. Other
are more subtle. For instance, \verb!e&-e! computes the smallest
element of \texttt{e} (as a singleton set). This is a 
property of the twos-complement representation, exploited in
Patricia trees~\cite{patricia} implementations in particular.
Another trick is the computation of the set
$\{0,1,\dots,\mathtt{n}-1\}$ as \verb!~(~0<<n)!. Finally,
multiplication by 2 (resp. division by 2) is used to add 1 (resp.
subtract 1) to each element of a set; we write $\mathit{succ}$ and
$\mathit{pred}$ these two 
set operations in the following. We can thus write a more
abstract version of the code which only deals with finite sets. It is
displayed in Figure~\ref{fig:abstract}.

\begin{figure}[t]
  \hrulefill\vspace{-0.2em}
{\begin{obeylines}
  \kw{int} $t$($a$, $b$, $c$) 
  ~~ \kw{if} $a \not= \emptyset$ 
  ~~~~ $e$ $\leftarrow$ $(a \backslash  b) \backslash c$ 
  ~~~~ $f$ $\leftarrow$ 0 
  ~~~~ \kw{while} $e \not=\emptyset$ 
  ~~~~~~ $d$ $\leftarrow$ $\minelt{e}$ 
  ~~~~~~ $f$ $\leftarrow$ $f$ $+$ $t$($a\backslash \{d\}$, $\mathit{succ}(b\cup\{d\})$, $\mathit{pred}(c\cup\{d\})$) 
  ~~~~~~ $e$ $\leftarrow$ $e \backslash  \{d\}$ 
  ~~~~ \kw{return} $f$ 
  ~~ \kw{else} 
  ~~~~ \kw{return} $1$ 
  ~~ 
  \kw{int} \textit{queens}($n$) 
  ~~ \kw{return} $t$($\{0,1,\dots,n-1\}$, $\emptyset$, $\emptyset$)
\end{obeylines}}
\vspace{-0.6em}\hrulefill\vspace{-1em}
  \caption{Abstract version of the code}
  \label{fig:abstract}
\end{figure}

It is now easier to explain the algorithm. The set $a$ contains the
columns not yet assigned to a queen, thus the candidate positions
for the queen to be set on the current row. Initially, $a$ contains
all possible positions, that is  $a = \{0,1,\dots,n-1\}$. 
We have found one solution whenever $a$ becomes empty and then we return 1.
Otherwise, we have to consider all possible positions on the current
row. The sets $b$ and $c$ respectively contain the positions which
must be avoided because they are on an ascending (resp. descending)
diagonal of a queen on a previous row.
Thus $e = a\backslash b\backslash c$ precisely contain the positions to be
considered for the current row. They are all examined one at a time by
repeatedly removing the smallest element from $e$, which is set to $d$.
Then the next rows are considered by a recursive call to $t$ with $a$,
$b$ and $c$ being updated according to the choice of the column $d$
for the current row: $d$ is removed from the set of possible columns
($a\backslash\{d\}$), added to the set of ascending diagonals which is
shifted ($\mathit{succ}(b\cup\{d\})$, and similarly  added to the set of
descending diagonals which is shifted the other way
($\mathit{pred}(c\cup\{d\})$). 
The values of $a$, $b$ and $c$ are illustrated in Figure~\ref{fig:abc}
for $n=8$ and 3 rows already set.

\begin{figure}
  \hspace*{-3em}\psfig{file=figabc.eps,width=\textwidth}
  \caption{Interpretation of $a$, $b$ and $c$ as sets}
  \label{fig:abc}
\end{figure}

\section{Overview of Caduceus}\label{caduceus}

\cite{caduceus,FilliatreMarche04} \cite{why}

\cite{simplify} \cite{yices} \cite{ergo} \cite{coq}

% To do so, we are going to annotate the source code with logical
% assertions, run \caduceus\ to get verification conditions and
% discharge them with one or several provers.

\section{Formal Verification}\label{verif}

As stated in the introduction, we want to show that the C program in
Figure~\ref{fig:code} is correct using \caduceus. More precisely, we
are going to show that (1) the program does not crash; (2)
it terminates; and (3) it computes the right number.
The first property is easily obtained, since the program is not using
pointers or arrays. Thus the only threat in the code is the division and
\caduceus\ produces the corresponding verification condition $2\not=0$
which is obviously discharged. The other two properties are much more
difficult to establish.

\subsection{Integers Modelling Finite Sets}

We start with an abstraction of integers as finite sets, in order to
annotate the code with assertions about the sets represented by the
program variables. To do so, we proceed in two steps. First we
introduce an axiomatization of finite sets of integers. Then we make
connections between C integers and these abstract sets.

\subsubsection{Abstract Finite Sets.}
We introduce an abstract data type \texttt{iset} for finite sets of
integers with the following \caduceus\ declaration:
\begin{verbatim}
//@ type iset
\end{verbatim}
It is a purely logical data type which is axiomatized through a set of
constants, function symbols, predicates and axioms. We give here a small 
excerpt of this axiomatization. It is based on a
membership predicate  introduced as follows:
\begin{verbatim}
//@ predicate in_(int x, iset s)
\end{verbatim}
As we can notice, this is an abstract predicate. Then we can introduce
the various set operations. For instance, the empty set is introduced
with the following two declarations:
\begin{verbatim}
//@ logic iset empty()
//@ axiom empty_def : \forall int i; !in_(i,empty())
\end{verbatim}
Similarly we introduce set inclusion (\texttt{included}), cardinal
(\texttt{card}), addition and removal
of one element (\texttt{add} and 
\texttt{remove}), set difference (\texttt{diff}), smallest element
(\texttt{min\_elt}) and the \texttt{succ} and \texttt{pred} operations.
This axiomatization is 66 lines long and could obviously be a 
\caduceus\ library.

\subsubsection{C Integers as Finite Sets.}

Next we make the connection between C operations over integers and
abstract sets. This is introduced by a function symbol \texttt{iset}
which interprets an integer as a finite set:
\begin{verbatim}
//@ logic iset iset(int x)
\end{verbatim}
Then several axioms give interpretations to the C operations.
Here is one example:
\begin{verbatim}
/*@ axiom iset_c_min_elt :
  @   \forall int x; x != 0 =>
  @      iset(x&-x) == singleton(min_elt(iset(x)))
  @*/
\end{verbatim}
This new axiomatization is 30 lines long. Again it could be part of some
\caduceus\ library.

\subsection{Termination}

We now start the verification process itself by showing that the
program terminates. This is some kind of a warmup before the
correctness verification of Section~\ref{correctness}.

\subsubsection{Termination of the \texttt{for} loop.}
The termination of the \texttt{for} loop is easy to prove.
Since we are removing elements from \texttt{e} one by one until it
empties, the cardinal of \texttt{e} is the obvious variant for this
loop. It is declared with the following annotation:
\begin{verbatim}
    /*@ variant card(iset(e)) */
    for (f=0; d=e&-e; e-=d) f+=t(a-d,(b+d)*2,(c+d)/2);
\end{verbatim}
Two verification conditions are generated: one to ensure that the
variant is nonnegative and another one to ensure that the variant
decreases at each run of the loop body. Both are automatically
discharged by Simplify.

\subsubsection{Termination of the recursive function.}
Proving the termination of the recursive function \texttt{t} is more
tricky. There is also an obvious variant, namely the cardinal of
\texttt{a}, but showing that it decreases is not as easy as in the
previous case. First \caduceus\ does not support variants for
recursive functions and thus we have to introduce the corresponding
assertions manually, rigth before the recursive call:
\begin{verbatim}
    for (f=0; d=e&-e; e-=d) {
      //@ assert card(iset(a-d)) < card(iset(a))
      f+=t2(a-d,(b+d)*2,(c+d)/2); 
    }
\end{verbatim}


\subsection{Correctness}\label{correctness}

\section{Conclusion}

OVERFLOWS

\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}
