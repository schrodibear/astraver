(* This file is generated by Why; do not edit *)

Require Why.
Require Export see_why.

Definition f (* validation *)
  : (u: unit)(b: Z)
    (sig_2 Z Z [b0: Z][result: Z](`result = b0` /\ `b0 = 1 - b`))
  := [u: unit; b: Z]
       let (b0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1 - b` `1 - b`
           (refl_equal ? `1 - b`)) in
         (exist_2 [b3: Z][result0: unit]b3 = `1 - b` result tt Post1) in
       let (result0, Post2) = (exist_1 [result0: Z]`result0 = b0` /\
         `b0 = 1 - b` b0 (f_po_1 b b0 Post1)) in
       (exist_2 [b3: Z][result1: Z]`result1 = b3` /\ `b3 = 1 - b` b0 
       result0 Post2).

Definition k (* validation *)
  : (u: unit)(b: Z)(b1: Z)(b2: Z)
    (sig_4 Z Z Z unit [b0: Z][b4: Z][b3: Z][result: unit](`b4 = 0` /\
     `b3 = 1`))
  := [u: unit; b: Z; b1: Z; b2: Z]
       let (b0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [b3: Z][result0: unit]b3 = `1` result tt Post1) in
       let (b4, b3, result0, WP8) =
         let (b3, result0, WP8) =
           let (b3, aux_4, Post2) =
             let (b3, result2, Post3) = (f tt b0) in
             (exist_2 [b4: Z][result3: Z]`result3 = b4` /\ `b4 = 1 - b0` 
             b3 result2 Post3) in
           let (b4, result0, WP8) =
             let (b4, aux_3, WP9) =
               let (b4, aux_2, Post4) =
                 let (b4, result2, Post5) = (f tt b3) in
                 (exist_2 [b5: Z][result3: Z]`result3 = b5` /\
                 `b5 = 1 - b3` b4 result2 Post5) in
               let (result0, WP9) = (exist_1 [result0: Z]
                 ((result:Z)
                  ((b:Z)
                   (`result = b` /\ `b = 1 - b4` ->
                    ((result1:Z)
                     ((b0:Z)
                      (`result1 = b0` /\ `b0 = 1 - b` ->
                       `result0 + aux_4 = 0` /\ `result1 * (1 - result) = 1`)))))) 
                 `1 - aux_2`
                 (k_po_1 b0 Post1 b3 aux_4 Post2 b4 aux_2 Post4)) in
               (exist_2 [b5: Z][result1: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b5` ->
                  ((result0:Z)
                   ((b0:Z)
                    (`result0 = b0` /\ `b0 = 1 - b` ->
                     `result1 + aux_4 = 0` /\ `result0 * (1 - result) = 1`)))))) 
               b4 result0 WP9) in
             let (result0, WP8) = (exist_1 [result0: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b4` ->
                  ((result1:Z)
                   ((b0:Z)
                    (`result1 = b0` /\ `b0 = 1 - b` -> `result0 = 0` /\
                     `result1 * (1 - result) = 1`)))))) `aux_3 + aux_4`
               WP9) in
             (exist_2 [b5: Z][result1: Z]
             ((result:Z)
              ((b:Z)
               (`result = b` /\ `b = 1 - b5` ->
                ((result0:Z)
                 ((b0:Z)
                  (`result0 = b0` /\ `b0 = 1 - b` -> `result1 = 0` /\
                   `result0 * (1 - result) = 1`)))))) b4
             result0 WP8) in
           (exist_2 [b5: Z][result1: Z]
           ((result:Z)
            ((b:Z)
             (`result = b` /\ `b = 1 - b5` ->
              ((result0:Z)
               ((b0:Z)
                (`result0 = b0` /\ `b0 = 1 - b` -> `result1 = 0` /\
                 `result0 * (1 - result) = 1`)))))) b4
           result0 WP8) in
         (exist_3 [b6: Z][b5: Z][result1: unit]
         ((result:Z)
          ((b:Z)
           (`result = b` /\ `b = 1 - b6` ->
            ((result0:Z)
             ((b0:Z)
              (`result0 = b0` /\ `b0 = 1 - b` -> `b5 = 0` /\
               `result0 * (1 - result) = 1`)))))) b3
         result0 tt WP8) in
       let (b6, b5, result1, Post6) =
         let (b5, result1, Post7) =
           let (b5, aux_7, WP3) =
             let (b5, aux_6, Post8) =
               let (b5, result3, Post9) = (f tt b4) in
               (exist_2 [b6: Z][result4: Z]`result4 = b6` /\ `b6 = 1 - b4` 
               b5 result3 Post9) in
             let (result1, WP3) = (exist_1 [result1: Z]
               ((result:Z)
                ((b:Z)
                 (`result = b` /\ `b = 1 - b5` -> `b3 = 0` /\
                  `result * result1 = 1`))) `1 - aux_6`
               [result: Z]
                 [b: Z]
                   [HW_3: `result = b` /\ `b = 1 - b5`]
                     let HW_4 = (WP8 aux_6 b5 Post8) in
                     let HW_5 = (HW_4 result b HW_3) in
                     HW_5) in
             (exist_2 [b6: Z][result2: Z]
             ((result:Z)
              ((b:Z)
               (`result = b` /\ `b = 1 - b6` -> `b3 = 0` /\
                `result * result2 = 1`))) b5
             result1 WP3) in
           let (b6, result1, Post10) =
             let (b6, aux_5, Post11) =
               let (b6, result3, Post12) = (f tt b5) in
               (exist_2 [b7: Z][result4: Z]`result4 = b7` /\ `b7 = 1 - b5` 
               b6 result3 Post12) in
             let (result1, Post13) = (exist_1 [result1: Z]`b3 = 0` /\
               `result1 = 1` `aux_5 * aux_7`
               let HW_6 = (WP3 aux_5 b6 Post11) in
               HW_6) in
             (exist_2 [b7: Z][result2: Z]`b3 = 0` /\ `result2 = 1` b6 
             result1 Post13) in
           (exist_2 [b7: Z][result2: Z]`b3 = 0` /\ `result2 = 1` b6 result1
           Post10) in
         (exist_3 [b8: Z][b7: Z][result2: unit]`b3 = 0` /\ `b7 = 1` b5
         result1 tt Post7) in
       (exist_4 [b9: Z][b8: Z][b7: Z][result2: unit]`b8 = 0` /\ `b7 = 1` 
       b6 b3 b5 result1 Post6).

