(* This file is generated by Why; do not edit *)

Require Why.
Require Export po_why.

Definition p1 (* validation *)
  : (x: Z)(_: (q `x + 1`))(sig_2 Z unit [x0: Z][result: unit]((q x0)))
  := [x: Z; Pre1: (q `x + 1`)]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
           (refl_equal ? `x + 1`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
       (exist_2 [x1: Z][result0: unit](q x1) x0 result
       (p1_po_1 x Pre1 x0 Post1)).

Definition p2 (* validation *)
  : (x: Z)(_: (q `7`))(sig_2 Z unit [x0: Z][result: unit]((q x0)))
  := [x: Z; Pre1: (q `7`)]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `3 + 4` `3 + 4`
           (refl_equal ? `3 + 4`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `3 + 4` result tt Post1) in
       (exist_2 [x1: Z][result0: unit](q x1) x0 result
       (p2_po_1 Pre1 x0 Post1)).

Definition p3 (* validation *)
  : (x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = x + 3`))
  := [x: Z]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
           (refl_equal ? `x + 1`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
       let (x1, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]
           result0 = `x0 + 2` `x0 + 2` (refl_equal ? `x0 + 2`)) in
         (exist_2 [x2: Z][result1: unit]x2 = `x0 + 2` result0 tt Post2) in
       (exist_2 [x2: Z][result1: unit]`x2 = x + 3` x1 result0
       (p3_po_1 x x0 Post1 x1 Post2)).

Definition p4 (* validation *)
  : (x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = 14`))
  := [x: Z]
       let (x0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `7` `7`
           (refl_equal ? `7`)) in
         (exist_2 [x1: Z][result0: unit]x1 = `7` result tt Post1) in
       let (x1, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]
           result0 = `2 * x0` `2 * x0` (refl_equal ? `2 * x0`)) in
         (exist_2 [x2: Z][result1: unit]x2 = `2 * x0` result0 tt Post2) in
       (exist_2 [x2: Z][result1: unit]`x2 = 14` x1 result0
       (p4_po_1 x0 Post1 x1 Post2)).

Definition p5 (* validation *)
  : (sig_1 Z [result: Z](`result = 7`))
  := (exist_1 [result: Z]`result = 7` `3 + 4` p5_po_1).

Definition p6 (* validation *)
  : (sig_1 Z [result: Z](`result = 7`))
  := let (a, Post1) = (exist_1 [result: Z]result = `3` `3`
       (refl_equal ? `3`)) in
     let (result, Post2) = (exist_1 [result: Z]`result = 7` `a + 4`
       (p6_po_1 a Post1)) in
     (exist_1 [result0: Z]`result0 = 7` result Post2).

Definition p7 (* validation *)
  : (sig_1 Z [result: Z](`result = 11`))
  := let (aux_1, WP1) =
       let (a, Post1) = (exist_1 [result: Z]result = `4` `4`
         (refl_equal ? `4`)) in
       let (result, WP1) = (exist_1 [result: Z]`3 + result = 11` `a + a`
         (p7_po_1 a Post1)) in
       (exist_1 [result0: Z]`3 + result0 = 11` result WP1) in
     let (result, Post2) = (exist_1 [result: Z]`result = 11` `3 + aux_1`
       WP1) in
     (exist_1 [result0: Z]`result0 = 11` result Post2).

Definition p8 (* validation *)
  : (x: Z)(_: (q `x + 1`))
    (sig_2 Z Z [x0: Z][result: Z]((q x0) /\ `result = x + 4`))
  := [x: Z; Pre1: (q `x + 1`)]
       let (x0, aux_1, WP1) =
         let (x0, result, Post1) =
           let (result, Post1) = (exist_1 [result: Z]result = `x + 1` 
             `x + 1` (refl_equal ? `x + 1`)) in
           (exist_2 [x1: Z][result0: unit]x1 = `x + 1` result tt Post1) in
         let (result0, WP1) = (exist_1 [result0: Z](q x0) /\
           `3 + result0 = x + 4` x0 (p8_po_1 x Pre1 x0 Post1)) in
         (exist_2 [x1: Z][result1: Z](q x1) /\ `3 + result1 = x + 4` 
         x0 result0 WP1) in
       let (result, Post2) = (exist_1 [result: Z](q x0) /\
         `result = x + 4` `3 + aux_1` WP1) in
       (exist_2 [x1: Z][result0: Z](q x1) /\ `result0 = x + 4` x0 result
       Post2).

Definition p9 (* validation *)
  : (x: Z)(sig_2 Z Z [x0: Z][result: Z](`result = 2` /\ `x0 = 1`))
  := [x: Z]
       let (x0, aux_2, WP6) =
         let (x0, result, Post3) =
           let (result, Post3) = (exist_1 [result: Z]result = `2` `2`
             (refl_equal ? `2`)) in
           (exist_2 [x1: Z][result0: unit]x1 = `2` result tt Post3) in
         let (result0, WP6) = (exist_1 [result0: Z]
           ((x:Z) (x = `1` -> `1 + result0 = 2` /\ `x = 1`)) `1`
           (p9_po_1 x0 Post3)) in
         (exist_2 [x1: Z][result1: Z]
         ((x:Z) (x = `1` -> `1 + result1 = 2` /\ `x = 1`)) x0 result0 WP6) in
       let (x1, result, Post4) =
         let (x1, aux_1, WP1) =
           let (x1, result, Post2) =
             let (result, Post2) = (exist_1 [result: Z]result = `1` `1`
               (refl_equal ? `1`)) in
             (exist_2 [x2: Z][result0: unit]x2 = `1` result tt Post2) in
           let (result0, WP1) = (exist_1 [result0: Z]`result0 + aux_2 = 2` /\
             `x1 = 1` `1` let HW_2 = (WP6 x1 Post2) in
                          HW_2) in
           (exist_2 [x2: Z][result1: Z]`result1 + aux_2 = 2` /\ `x2 = 1` 
           x1 result0 WP1) in
         let (result, Post5) = (exist_1 [result: Z]`result = 2` /\
           `x1 = 1` `aux_1 + aux_2` WP1) in
         (exist_2 [x2: Z][result0: Z]`result0 = 2` /\ `x2 = 1` x1 result
         Post5) in
       (exist_2 [x2: Z][result0: Z]`result0 = 2` /\ `x2 = 1` x1 result Post4).

Definition p9a (* validation *)
  : (x: Z)(sig_2 Z Z [x0: Z][result: Z](`result = 2` /\ `x0 = 1`))
  := [x: Z]
       let (x0, aux_1, WP1) =
         let (x0, result, Post2) =
           let (result, Post2) = (exist_1 [result: Z]result = `1` `1`
             (refl_equal ? `1`)) in
           (exist_2 [x1: Z][result0: unit]x1 = `1` result tt Post2) in
         let (result0, WP1) = (exist_1 [result0: Z]`result0 + 1 = 2` /\
           `x0 = 1` `1` (p9a_po_1 x0 Post2)) in
         (exist_2 [x1: Z][result1: Z]`result1 + 1 = 2` /\ `x1 = 1` x0 
         result0 WP1) in
       let (result, Post3) = (exist_1 [result: Z]`result = 2` /\
         `x0 = 1` `aux_1 + 1` WP1) in
       (exist_2 [x1: Z][result0: Z]`result0 = 2` /\ `x1 = 1` x0 result Post3).

Definition p10 (* validation *)
  : (sig_1 Z [result: Z](`result = 1`))
  := let (result1, Post1) = (fsucc `0`) in
     (exist_1 [result2: Z]`result2 = 1` result1 (p10_po_1 result1 Post1)).

Definition p11 (* validation *)
  : (sig_1 Z [result: Z](`result = 5`))
  := let (aux_2, Post1) =
       let (result1, Post2) = (fsucc `3`) in
       (exist_1 [result2: Z]`result2 = 3 + 1` result1 Post2) in
     let (result, Post3) =
       let (aux_1, Post4) =
         let (result1, Post5) = (fsucc `0`) in
         (exist_1 [result2: Z]`result2 = 0 + 1` result1 Post5) in
       let (result, Post6) = (exist_1 [result: Z]`result = 5` `aux_1 + aux_2`
         (p11_po_1 aux_2 Post1 aux_1 Post4)) in
       (exist_1 [result0: Z]`result0 = 5` result Post6) in
     (exist_1 [result0: Z]`result0 = 5` result Post3).

Definition p11a (* validation *)
  : (sig_1 Z [result: Z](`result = 4`))
  := let (a, Post1) =
       let (result1, Post2) = (fsucc `1`) in
       (exist_1 [result2: Z]`result2 = 1 + 1` result1 Post2) in
     let (result, Post3) = (exist_1 [result: Z]`result = 4` `a + a`
       (p11a_po_1 a Post1)) in
     (exist_1 [result0: Z]`result0 = 4` result Post3).

Definition p12 (* validation *)
  : (x: Z)(_: `x = 0`)(sig_2 Z unit [x0: Z][result: unit](`x0 = 1`))
  := [x: Z; Pre1: `x = 0`]
       let (x0, result1, Post1) = (incrx tt x) in
       (exist_2 [x1: Z][result2: unit]`x1 = 1` x0 result1
       (p12_po_1 x Pre1 x0 Post1)).

Definition p13 (* validation *)
  : (x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = x + 2`))
  := [x: Z]
       let (x0, result, Post1) =
         let (x0, result1, Post2) = (incrx tt x) in
         (exist_2 [x1: Z][result2: unit]`x1 = x + 1` x0 result1 Post2) in
       let (x1, result0, Post3) =
         let (x1, result2, Post4) = (incrx tt x0) in
         (exist_2 [x2: Z][result3: unit]`x2 = x0 + 1` x1 result2 Post4) in
       (exist_2 [x2: Z][result1: unit]`x2 = x + 2` x1 result0
       (p13_po_1 x x0 Post1 x1 Post3)).

Definition p13a (* validation *)
  : (x: Z)(sig_2 Z unit [x0: Z][result: unit](`x0 = x + 2`))
  := [x: Z]
       let (x0, aux_1, Post1) =
         let (x0, result1, Post2) = (incrx tt x) in
         (exist_2 [x1: Z][result2: unit]`x1 = x + 1` x0 result1 Post2) in
       let (x1, result, Post3) =
         let (x1, result1, Post4) = (incrx aux_1 x0) in
         (exist_2 [x2: Z][result2: unit]`x2 = x0 + 1` x1 result1 Post4) in
       (exist_2 [x2: Z][result0: unit]`x2 = x + 2` x1 result
       (p13a_po_1 x x0 Post1 x1 Post3)).

Definition p14 (* validation *)
  : (x: Z)(_: `x = 0`)(sig_2 Z Z [x0: Z][result: Z](`result = 1`))
  := [x: Z; Pre1: `x = 0`]
       let (x0, result1, Post1) = (incrx2 tt x) in
       (exist_2 [x1: Z][result2: Z]`result2 = 1` x0 result1
       (p14_po_1 x Pre1 x0 result1 Post1)).

Definition p15 (* validation *)
  : (t: (array Z))(_: `(array_length t) = 10`)Z
  := [t: (array Z); Pre2: `(array_length t) = 10`]
       let Pre1 = (p15_po_1 t Pre2) in
       (access t `0`).

Definition p16 (* validation *)
  : (t: (array Z))(_: `(array_length t) = 10`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     (t0 = (store t `9` `1`)))
  := [t: (array Z); Pre2: `(array_length t) = 10`]
       let Pre1 = (p16_po_1 t Pre2) in
       (exist_2 [t1: (array Z)][result1: unit]
       t1 = (store t `9` `1`) (store t `9` `1`) tt
       (refl_equal ? (store t `9` `1`))).

Definition p17 (* validation *)
  : (t: (array Z))(_: `(array_length t) = 10` /\ `0 <= (access t 0)` /\
    `(access t 0) < 10`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     (t0 = (store t (access t `0`) `1`)))
  := [t: (array Z); Pre3: `(array_length t) = 10` /\ `0 <= (access t 0)` /\
      `(access t 0) < 10`]
       let Pre2 = (p17_po_1 t Pre3) in
       let Pre1 = (p17_po_2 t Pre3 Pre2) in
       (exist_2 [t1: (array Z)][result1: unit]
       t1 = (store t (access t `0`) `1`) (store t (access t `0`) `1`) 
       tt (refl_equal ? (store t (access t `0`) `1`))).

Definition p18 (* validation *)
  : (t: (array Z))(x: Z)(_: `(array_length t) = 10`)
    (sig_3 (array Z) Z unit [t0: (array Z)][x0: Z][result: unit]
     (`(access t0 0) = x`))
  := [t: (array Z); x: Z; Pre2: `(array_length t) = 10`]
       let (aux_2, Post2) = (exist_1 [result: Z]result = x x
         (refl_equal ? x)) in
       let (t0, x0, result, Post3) =
         let (x0, aux_1, WP1) =
           let (x0, result, Post1) =
             let (result, Post1) = (exist_1 [result: Z]result = `0` `0`
               (refl_equal ? `0`)) in
             (exist_2 [x1: Z][result0: unit]x1 = `0` result tt Post1) in
           let (result0, WP1) = (exist_1 [result0: Z]
             `(access (store t result0 aux_2) 0) = x` /\ `0 <= result0` /\
             `result0 < (array_length t)` x0
             (p18_po_1 t x Pre2 aux_2 Post2 x0 Post1)) in
           (exist_2 [x1: Z][result1: Z]
           `(access (store t result1 aux_2) 0) = x` /\ `0 <= result1` /\
           `result1 < (array_length t)` x0 result0 WP1) in
         let Pre1 = let (HW_1, HW_2) = WP1 in
                    HW_2 in
         let (t0, result, Post4) = (exist_2 [t1: (array Z)][result1: unit]
           `(access t1 0) = x` (store t aux_1 aux_2) tt (proj1 ? ? WP1)) in
         (exist_3 [t1: (array Z)][x1: Z][result0: unit]`(access t1 0) = x` 
         t0 x0 result Post4) in
       (exist_3 [t1: (array Z)][x1: Z][result0: unit]`(access t1 0) = x` 
       t0 x0 result Post3).

