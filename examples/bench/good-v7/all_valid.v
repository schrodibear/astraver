(* This file is generated by Why; do not edit *)

Require Import Why.
Require Export all_why.

Definition p1 (* validation *)
  : (sig_1 Z [result: Z](True))
  := (exist_1 [result: Z]True `0` I).

Definition p2 (* validation *)
  : (sig_1 Z [result: Z](~False))
  := (exist_1 [result: Z]~False `0` p2_po_1).

Definition p3 (* validation *)
  : (sig_1 Z [result: Z](True /\ True))
  := (exist_1 [result: Z]True /\ True `0` p3_po_1).

Definition p4 (* validation *)
  : (sig_1 Z [result: Z](True \/ False))
  := (exist_1 [result: Z]True \/ False `0` p4_po_1).

Definition p5 (* validation *)
  : (sig_1 Z [result: Z](False \/ ~False))
  := (exist_1 [result: Z]False \/ ~False `0` p5_po_1).

Definition p6 (* validation *)
  : (sig_1 Z [result: Z]((True -> ~False)))
  := (exist_1 [result: Z](True -> ~False) `0` p6_po_1).

Definition p7 (* validation *)
  : (sig_1 Z [result: Z](((x:Z) `x = x`)))
  := (exist_1 [result: Z]((x:Z) `x = x`) `0` p7_po_1).

Definition p8 (* validation *)
  : (sig_1 Z [result: Z](True /\ ((x:Z) `x = x`)))
  := (exist_1 [result: Z]True /\ ((x:Z) `x = x`) `0` p8_po_1).

Definition p9 (* validation *)
  : (sig_1 Z [result: Z](((x:Z) ((y:Z) (`x = y` -> `x = y`)))))
  := (exist_1 [result: Z]((x:Z) ((y:Z) (`x = y` -> `x = y`))) `0` p9_po_1).

Definition acc1 (* validation *)
  : Z
  := v2.

Definition acc2 (* validation *)
  : Z
  := acc1.

Definition acc3 (* validation *)
  : (t: (array Z))(sig_1 unit [result: unit](`(access t 1) = 2`))
  := f8.

Definition d1 (* validation *)
  : (v1: bool)bool
  := [v1: bool]v1.

Definition d2 (* validation *)
  : (v4: Z)Z
  := [v4: Z]v4.

Definition ar1 (* validation *)
  : Z
  := `1`.

Definition ar2 (* validation *)
  : Z
  := `(-1)`.

Definition ar3 (* validation *)
  : Z
  := `1 + 1`.

Definition ar4 (* validation *)
  : Z
  := `1 - 1`.

Definition ar5 (* validation *)
  : Z
  := `1 * 1`.

Definition ar6 (* validation *)
  : Z
  := let Pre1 = ar6_po_1 in
     (Zdiv `1` `1`).

Definition ar7 (* validation *)
  : Z
  := let Pre1 = ar7_po_1 in
     (Zmod `1` `1`).

Definition a1 (* validation *)
  : (v4: Z)(sig_2 Z unit [v4_0: Z][result: unit](v4_0 = `1`))
  := [v4: Z]
       let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
         (refl_equal ? `1`)) in
       (exist_2 [v4_1: Z][result0: unit]v4_1 = `1` result tt Post1).

Definition a2 (* validation *)
  : (v1: bool)(sig_2 bool unit [v1_0: bool][result: unit](v1_0 = true))
  := [v1: bool]
       let (result, Post1) = (exist_1 [result: bool]result = true true
         (refl_equal ? true)) in
       (exist_2 [v1_1: bool][result0: unit]v1_1 = true result tt Post1).

Definition a3 (* validation *)
  : (v4: Z)(sig_2 Z unit [v4_0: Z][result: unit](v4_0 = `2 + 2`))
  := [v4: Z]
       let (result, Post1) = (exist_1 [result: Z]result = `2 + 2` `2 + 2`
         (refl_equal ? `2 + 2`)) in
       (exist_2 [v4_1: Z][result0: unit]v4_1 = `2 + 2` result tt Post1).

Definition a4 (* validation *)
  : (v4: Z)(sig_2 Z unit [v4_0: Z][result: unit](v4_0 = v4))
  := [v4: Z]
       let (result, Post1) = (exist_1 [result: Z]result = v4 v4
         (refl_equal ? v4)) in
       (exist_2 [v4_1: Z][result0: unit]v4_1 = v4 result tt Post1).

Definition s1 (* validation *)
  : (v4: Z)(tuple_2 Z unit)
  := [v4: Z]
       let (v4_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [v4_1: Z][result0: unit]v4_1 = `1` result tt Post1) in
       let (v4_1, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]result0 = `2` `2`
           (refl_equal ? `2`)) in
         (exist_2 [v4_2: Z][result1: unit]v4_2 = `2` result0 tt Post2) in
       (Build_tuple_2 v4_1 result0).

Definition s2 (* validation *)
  : (v1: bool)(v4: Z)(tuple_3 bool Z unit)
  := [v1: bool; v4: Z]
       let (v1_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: bool]result = true true
           (refl_equal ? true)) in
         (exist_2 [v1_1: bool][result0: unit]v1_1 = true result tt Post1) in
       let (v4_0, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]result0 = `2` `2`
           (refl_equal ? `2`)) in
         (exist_2 [v4_1: Z][result1: unit]v4_1 = `2` result0 tt Post2) in
       (Build_tuple_3 v1_0 v4_0 result0).

Definition s3 (* validation *)
  : (v4: Z)(tuple_2 Z unit)
  := [v4: Z]
       let (v4_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [v4_1: Z][result0: unit]v4_1 = `1` result tt Post1) in
       let (v4_1, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]result0 = v4_0 v4_0
           (refl_equal ? v4_0)) in
         (exist_2 [v4_2: Z][result1: unit]v4_2 = v4_0 result0 tt Post2) in
       let (v4_2, result1, Post3) =
         let (result1, Post3) = (exist_1 [result1: Z]result1 = `3` `3`
           (refl_equal ? `3`)) in
         (exist_2 [v4_3: Z][result2: unit]v4_3 = `3` result1 tt Post3) in
       (Build_tuple_2 v4_2 result1).

Definition s4 (* validation *)
  : (v4: Z)(tuple_2 Z Z)
  := [v4: Z]
       let (v4_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         (exist_2 [v4_1: Z][result0: unit]v4_1 = `1` result tt Post1) in
       (Build_tuple_2 v4_0 `2`).

Definition c1 (* validation *)
  : Z
  := if true then
       `1`
     else
       `2`.

Definition c2 (* validation *)
  : (v1: bool)Z
  := [v1: bool]if v1 then
                 `1`
               else
                 `2`.

Definition c3 (* validation *)
  : (v4: Z)(tuple_2 Z unit)
  := [v4: Z]
       let (result, Bool1) =
         let (result1, Post4) = (Z_eq_bool v4 `1`) in
         (exist_1 [result2: bool]
         (if result2 then `v4 = 1` else `v4 <> 1`) result1 Post4) in
       Cases
         (btest [result:bool](if result then `v4 = 1` else `v4 <> 1`) result
          Bool1) of
       | (left Test2) =>
           let (v4_0, result0, Post1) =
             let (result0, Post1) = (exist_1 [result0: Z]result0 = `2` 
               `2` (refl_equal ? `2`)) in
             (exist_2 [v4_1: Z][result1: unit]v4_1 = `2` result0 tt Post1) in
           (Build_tuple_2 v4_0 result0)
       | (right Test1) =>
           let (v4_0, result0, Post2) =
             let (result0, Post2) = (exist_1 [result0: Z]result0 = `3` 
               `3` (refl_equal ? `3`)) in
             (exist_2 [v4_1: Z][result1: unit]v4_1 = `3` result0 tt Post2) in
           (Build_tuple_2 v4_0 result0) end.

Definition l1 (* validation *)
  : Z
  := let (x, Post1) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     x.

Definition l2 (* validation *)
  : (v4: Z)(tuple_2 Z unit)
  := [v4: Z]
       let (x, Post2) = (exist_1 [result: Z]result = `1` `1`
         (refl_equal ? `1`)) in
       let (v4_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = x x
           (refl_equal ? x)) in
         (exist_2 [v4_1: Z][result0: unit]v4_1 = x result tt Post1) in
       (Build_tuple_2 v4_0 result).

Definition l3 (* validation *)
  : Z
  := let (x, Post2) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     let result =
       let (y, Post1) = (exist_1 [result: Z]result = `2` `2`
         (refl_equal ? `2`)) in
       `x + y` in
     result.

Definition l4 (* validation *)
  : (v4: Z)(tuple_2 Z unit)
  := [v4: Z]
       let result =
         let (x, Post1) = (exist_1 [result: Z]result = `1` `1`
           (refl_equal ? `1`)) in
         `1` in
       (Build_tuple_2 result tt).

Definition l5 (* validation *)
  : (v1: bool)(v4: Z)(tuple_3 bool Z unit)
  := [v1: bool; v4: Z]
       let (x, Post3) = (exist_1 [result: Z]result = `1` `1`
         (refl_equal ? `1`)) in
       let (v1_0, v4_0, result) =
         let (v1_0, result, Post1) =
           let (result, Post1) = (exist_1 [result: bool]result = true 
             true (refl_equal ? true)) in
           (exist_2 [v1_1: bool][result0: unit]v1_1 = true result tt Post1) in
         let (v4_0, result0, Post2) =
           let (result0, Post2) = (exist_1 [result0: Z]result0 = x x
             (refl_equal ? x)) in
           (exist_2 [v4_1: Z][result1: unit]v4_1 = x result0 tt Post2) in
         (Build_tuple_3 v1_0 v4_0 result0) in
       (Build_tuple_3 v1_0 v4_0 result).

Definition lr1 (* validation *)
  : unit
  := let (x, Post2) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     let (x1, result, Post1) =
       let (result, Post1) = (exist_1 [result: Z]result = `2` `2`
         (refl_equal ? `2`)) in
       (exist_2 [x2: Z][result0: unit]x2 = `2` result tt Post1) in
     result.

Definition lr2 (* validation *)
  : Z
  := let (x, Post2) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     let (x1, result) =
       let (x1, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `x + 1` `x + 1`
           (refl_equal ? `x + 1`)) in
         (exist_2 [x2: Z][result0: unit]x2 = `x + 1` result tt Post1) in
       (Build_tuple_2 x1 x1) in
     result.

Definition lr3 (* validation *)
  : unit
  := let (x, Post3) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     let (x1, result) =
       let (y, Post2) = (exist_1 [result: Z]result = x x (refl_equal ? x)) in
       let (x1, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = y y
           (refl_equal ? y)) in
         (exist_2 [x2: Z][result0: unit]x2 = y result tt Post1) in
       (Build_tuple_2 x1 result) in
     result.

Definition r1 (* validation *)
  : (sig_1 bool [result: bool]((if result then `1 = 1` else `1 <> 1`)))
  := let (result1, Post1) = (Z_eq_bool `1` `1`) in
     (exist_1 [result2: bool](if result2 then `1 = 1` else `1 <> 1`) 
     result1 Post1).

Definition r2 (* validation *)
  : (sig_1 bool [result: bool]((if result then `2 > 1` else `2 <= 1`)))
  := let (result1, Post1) = (Z_gt_le_bool `2` `1`) in
     (exist_1 [result2: bool](if result2 then `2 > 1` else `2 <= 1`) 
     result1 Post1).

Definition r3 (* validation *)
  : (sig_1 bool [result: bool]((if result then `2 >= 1` else `2 < 1`)))
  := let (result1, Post1) = (Z_ge_lt_bool `2` `1`) in
     (exist_1 [result2: bool](if result2 then `2 >= 1` else `2 < 1`) 
     result1 Post1).

Definition r4 (* validation *)
  : (sig_1 bool [result: bool]((if result then `1 < 2` else `1 >= 2`)))
  := let (result1, Post1) = (Z_lt_ge_bool `1` `2`) in
     (exist_1 [result2: bool](if result2 then `1 < 2` else `1 >= 2`) 
     result1 Post1).

Definition r5 (* validation *)
  : (sig_1 bool [result: bool]((if result then `1 <= 2` else `1 > 2`)))
  := let (result1, Post1) = (Z_le_gt_bool `1` `2`) in
     (exist_1 [result2: bool](if result2 then `1 <= 2` else `1 > 2`) 
     result1 Post1).

Definition r6 (* validation *)
  : (sig_1 bool [result: bool]((if result then `1 <> 2` else `1 = 2`)))
  := let (result1, Post1) = (Z_noteq_bool `1` `2`) in
     (exist_1 [result2: bool](if result2 then `1 <> 2` else `1 = 2`) 
     result1 Post1).

Definition r7 (* validation *)
  : bool
  := let (result, Bool1) =
       let (result1, Post1) = (Z_eq_bool `1` `2`) in
       (exist_1 [result2: bool]
       (if result2 then `1 = 2` else `1 <> 2`) result1 Post1) in
     Cases
       (btest [result:bool](if result then `1 = 2` else `1 <> 2`) result
        Bool1) of
     | (left Test2) => true
     | (right Test1) =>
         let (result0, Post2) =
           let (result2, Post3) = (Z_eq_bool `2` `3`) in
           (exist_1 [result3: bool]
           (if result3 then `2 = 3` else `2 <> 3`) result2 Post3) in
         result0 end.

Definition r8 (* validation *)
  : bool
  := let (result, Bool1) =
       let (result1, Post1) = (Z_eq_bool `1` `2`) in
       (exist_1 [result2: bool]
       (if result2 then `1 = 2` else `1 <> 2`) result1 Post1) in
     Cases
       (btest [result:bool](if result then `1 = 2` else `1 <> 2`) result
        Bool1) of
     | (left Test2) =>
         let (result0, Post2) =
           let (result2, Post3) = (Z_eq_bool `2` `3`) in
           (exist_1 [result3: bool]
           (if result3 then `2 = 3` else `2 <> 3`) result2 Post3) in
         result0
     | (right Test1) => false end.

Definition arr1 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 1`)Z
  := [v6: (array Z); Pre2: `(array_length v6) >= 1`]
       let Pre1 = (arr1_po_1 v6 Pre2) in
       (access v6 `0`).

Definition arr2 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 4`)Z
  := [v6: (array Z); Pre2: `(array_length v6) >= 4`]
       let Pre1 = (arr2_po_1 v6 Pre2) in
       (access v6 `1 + 2`).

Definition arr3 (* validation *)
  : (v4: Z)(v6: (array Z))(H: `(array_length v6) >= 1` /\ `v4 = 0`)Z
  := [v4: Z; v6: (array Z); Pre2: `(array_length v6) >= 1` /\ `v4 = 0`]
       let Pre1 = (arr3_po_1 v4 v6 Pre2) in
       (access v6 v4).

Definition arr4 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 10` /\ `(access v6 0) = 9`)Z
  := [v6: (array Z); Pre3: `(array_length v6) >= 10` /\ `(access v6 0) = 9`]
       let Pre2 = (arr4_po_1 v6 Pre3) in
       let Pre1 = (arr4_po_2 v6 Pre3 Pre2) in
       (access v6 (access v6 `0`)).

Definition arr5 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 1`)
    (sig_2 (array Z) unit [v6_0: (array Z)][result: unit]
     (v6_0 = (store v6 `0` `1`)))
  := [v6: (array Z); Pre2: `(array_length v6) >= 1`]
       let Pre1 = (arr5_po_1 v6 Pre2) in
       (exist_2 [v6_1: (array Z)][result1: unit]
       v6_1 = (store v6 `0` `1`) (store v6 `0` `1`) tt
       (refl_equal ? (store v6 `0` `1`))).

Definition arr6 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 4`)
    (sig_2 (array Z) unit [v6_0: (array Z)][result: unit]
     (v6_0 = (store v6 `1 + 2` `3 + 4`)))
  := [v6: (array Z); Pre2: `(array_length v6) >= 4`]
       let Pre1 = (arr6_po_1 v6 Pre2) in
       (exist_2 [v6_1: (array Z)][result1: unit]
       v6_1 = (store v6 `1 + 2` `3 + 4`) (store v6 `1 + 2` `3 + 4`) tt
       (refl_equal ? (store v6 `1 + 2` `3 + 4`))).

Definition arr7 (* validation *)
  : (v6: (array Z))(H: `(array_length v6) >= 10` /\ `(access v6 0) = 9`)
    (sig_2 (array Z) unit [v6_0: (array Z)][result: unit]
     (v6_0 = (store v6 (access v6 `0`) `1`)))
  := [v6: (array Z); Pre3: `(array_length v6) >= 10` /\ `(access v6 0) = 9`]
       let Pre2 = (arr7_po_1 v6 Pre3) in
       let Pre1 = (arr7_po_2 v6 Pre3 Pre2) in
       (exist_2 [v6_1: (array Z)][result1: unit]
       v6_1 = (store v6 (access v6 `0`) `1`) (store v6 (access v6 `0`) `1`)
       tt (refl_equal ? (store v6 (access v6 `0`) `1`))).

Definition fc1 (* validation *)
  : foo
  := (f5 v5).

Definition fc2 (* validation *)
  : unit
  := (f4 tt).

Definition fc3 (* validation *)
  : Z
  := let (a, Post2) = (exist_1 [result: Z]result = `0` `0`
       (refl_equal ? `0`)) in
     let result =
       let (b, Post1) = (exist_1 [result: Z]result = `0` `0`
         (refl_equal ? `0`)) in
       let Pre3 = (fc3_po_1 a Post2 b Post1) in
       let (b1, result, Post3) =
         let Pre1 = Pre3 in
         let Pre2 = Pre1 in
         let (b1, r, Post4) = (f3 a b Pre1) in
         (exist_2 [b2: Z][result0: Z]`b2 = b + a + result0` b1 r Post4) in
       result in
     result.

Definition an1 (* validation *)
  : (sig_1 Z [result: Z](`result = 0`))
  := (exist_1 [result: Z]`result = 0` `0` (refl_equal ? `0`)).

Definition an2 (* validation *)
  : (v4: Z)(H: `v4 >= 0`)(sig_2 Z unit [v4_0: Z][result: unit](`v4_0 > v4`))
  := [v4: Z; Pre1: `v4 >= 0`]
       let (v4_0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `v4 + 1` 
           `v4 + 1` (refl_equal ? `v4 + 1`)) in
         (exist_2 [v4_1: Z][result0: unit]v4_1 = `v4 + 1` result tt Post1) in
       (exist_2 [v4_1: Z][result0: unit]`v4_1 > v4` v4_0 result
       (an2_po_1 v4 Pre1 v4_0 Post1)).

