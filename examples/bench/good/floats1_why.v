(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Why.
Require Export JessieGappa.


(* Why obligation from file "floats1.why", line 16, characters 2-23: *)
(*Why goal*) Lemma tes1_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_finite x) /\ (is_finite y) /\
                ~(eq (float_value x) (0)%R) /\ ~(eq (float_value y) (0)%R) /\
                (eq (float_value x) (float_value y))),
  forall (result: gen_float),
  forall (HW_2: result = (gen_float_of_real_logic Double nearest_even (1)%R)),
  forall (one: gen_float),
  forall (HW_3: one = result),
  forall (result0: gen_float),
  forall (HW_4: (((is_NaN one) \/ (is_NaN x) -> (is_NaN result0))) /\
                (((is_finite one) /\ (is_infinite x) -> (is_gen_zero result0))) /\
                (((is_infinite one) /\ (is_finite x) -> (is_infinite result0))) /\
                (((is_infinite one) /\ (is_infinite x) -> (is_NaN result0))) /\
                (((is_finite one) /\ (is_finite x) /\
                  ~(eq (float_value x) (0)%R) /\
                  (no_overflow
                   Double nearest_even (Rdiv
                                        (float_value one) (float_value x))) ->
                  (is_finite result0) /\
                  (eq (float_value result0) (round_float
                                             Double nearest_even (Rdiv
                                                                  (float_value
                                                                   one) (
                                                                  float_value
                                                                  x)))))) /\
                (((is_finite one) /\ (is_finite x) /\
                  ~(eq (float_value x) (0)%R) /\
                  ~(no_overflow
                    Double nearest_even (Rdiv
                                         (float_value one) (float_value x))) ->
                  (overflow_value Double nearest_even result0))) /\
                (((is_finite one) /\ (is_gen_zero x) /\
                  ~(eq (float_value one) (0)%R) -> (is_infinite result0))) /\
                (((is_gen_zero one) /\ (is_gen_zero x) -> (is_NaN result0))) /\
                (product_sign result0 one x) /\
                (eq (exact_value result0) (Rdiv
                                           (exact_value one) (exact_value x))) /\
                (eq (model_value result0) (Rdiv
                                           (model_value one) (model_value x)))),
  forall (z1: gen_float),
  forall (HW_5: z1 = result0),
  forall (result1: gen_float),
  forall (HW_6: (((is_NaN one) \/ (is_NaN y) -> (is_NaN result1))) /\
                (((is_finite one) /\ (is_infinite y) -> (is_gen_zero result1))) /\
                (((is_infinite one) /\ (is_finite y) -> (is_infinite result1))) /\
                (((is_infinite one) /\ (is_infinite y) -> (is_NaN result1))) /\
                (((is_finite one) /\ (is_finite y) /\
                  ~(eq (float_value y) (0)%R) /\
                  (no_overflow
                   Double nearest_even (Rdiv
                                        (float_value one) (float_value y))) ->
                  (is_finite result1) /\
                  (eq (float_value result1) (round_float
                                             Double nearest_even (Rdiv
                                                                  (float_value
                                                                   one) (
                                                                  float_value
                                                                  y)))))) /\
                (((is_finite one) /\ (is_finite y) /\
                  ~(eq (float_value y) (0)%R) /\
                  ~(no_overflow
                    Double nearest_even (Rdiv
                                         (float_value one) (float_value y))) ->
                  (overflow_value Double nearest_even result1))) /\
                (((is_finite one) /\ (is_gen_zero y) /\
                  ~(eq (float_value one) (0)%R) -> (is_infinite result1))) /\
                (((is_gen_zero one) /\ (is_gen_zero y) -> (is_NaN result1))) /\
                (product_sign result1 one y) /\
                (eq (exact_value result1) (Rdiv
                                           (exact_value one) (exact_value y))) /\
                (eq (model_value result1) (Rdiv
                                           (model_value one) (model_value y)))),
  forall (z2: gen_float),
  forall (HW_7: z2 = result1),
  (float_eq_float z1 z2).
Proof.
unfold float_eq_float,is_finite,is_infinite,same_sign,is_not_NaN.
intros.
decompose [and or] HW_4;clear HW_4.
decompose [and or] HW_6;clear HW_6.
decompose [and] HW_1;clear HW_1.
subst.
repeat split.
case (overflow_dec Double nearest_even (float_value (gen_float_of_real_logic Double nearest_even 1) /
        float_value x));intro.
assert (Rabs 1 <= max_gen_float Double)%R.
unfold max_gen_float.
gappa.
generalize (H3 (conj (proj1 
(gen_bounded_real_no_overflow Double nearest_even 1%R H27))
(conj H20 (conj H22 H25))));intros (h1,h2).
rewrite H26 in H25.
generalize (H14 (conj (proj1 
(gen_bounded_real_no_overflow Double nearest_even 1%R H27))
(conj H23 (conj H24 H25))));intros (h3,h4).
left.
repeat split;trivial.
rewrite h2,H26;auto.
assert (Rabs 1 <= max_gen_float Double)%R.
unfold max_gen_float.
gappa.
generalize (proj2 (proj2 (proj2 (H4 (conj (proj1 
(gen_bounded_real_no_overflow Double nearest_even 1%R H27))
(conj H20 (conj H22 H25)))))));intro h5.
rewrite H26 in H25.
generalize (proj2 (proj2 (proj2 (H15 (conj (proj1 
(gen_bounded_real_no_overflow Double nearest_even 1%R H27))
(conj H23 (conj H24 H25)))))));intro h6.
right.
repeat split;clear -h5 h6 H7 H18 H20 H23 H22 H24 H26;intuition.
unfold product_sign in *.
assert (float_sign x = float_sign y).
generalize (sign_invariant x H20 H22);intro.
generalize (sign_invariant y H23 H24);intro.
unfold float_value in *.
rewrite H26 in H2.
destruct (float_sign x).
unfold same_sign_real_bool in H2.
symmetry.
apply (proj1 (same_sign_real_bool_correct2 (float_sign y) (genf y) H4)).
auto.
unfold same_sign_real_bool in H2.
symmetry.
apply (proj1 (same_sign_real_bool_correct3 (float_sign y) (genf y) H4)).
auto.
unfold same_sign,diff_sign in *.
rewrite H2 in *.
case (same_sign_dec (gen_float_of_real_logic Double nearest_even 1) y).
intro.
unfold same_sign in *.
rewrite ((proj1 H7) H4).
symmetry.
apply ((proj1 H18) H4).
intro.
unfold diff_sign in *.
rewrite ((proj2 H7) H4).
symmetry.
apply ((proj2 H18) H4).
Save.

(*
assert (float_class result = Finite /\
           float_value result = round_float Double nearest_even 1).
apply H.
unfold no_overflow, round_float,max_gen_float, nearest_even.
admit. (*gappa succeeds*)
destruct H33.
assert (float_class result1 = Finite /\
           float_value result1 = round_float Double nearest_even 1).
apply H13.
unfold no_overflow, round_float,max_gen_float, nearest_even.
admit. (*gappa succeeds*)
destruct H36.
case (overflow_dec Double nearest_even (float_value result / float_value x)).
intro.
generalize (H7 (conj H33 (conj H28 (conj H30 H38)))).
intros (h1,h2).
assert (no_overflow  Double nearest_even (float_value result1 / float_value y)).
rewrite H37; rewrite <- H34; rewrite <- H35;exact H38. 
generalize (H22 (conj H36 (conj H31 (conj H32 H39)))).
intros (h3,h4).
left.
split;auto.
split;auto.
rewrite h4;rewrite <- H34;rewrite H37;rewrite <- H35;auto.
intro.
generalize (H8 (conj H33 (conj H28 (conj H30 H38))));intro.
unfold overflow_value in H39.
decompose [and] H39;clear H39 H40 H41 H42.
assert (~ no_overflow Double nearest_even (float_value result1 / float_value y)).
rewrite H37; rewrite <- H34; rewrite <- H35;exact H38. 
generalize (H23 (conj H36 (conj H31 (conj H32 H39))));intro.
unfold overflow_value in H40.
decompose [and] H40;clear H40 H41 H42 H43.
unfold product_sign in *.
unfold same_sign in *.
unfold diff_sign in *.

assert (float_sign result = Positive).
apply finite_sign_pos1.
split;trivial.
rewrite H35.
admit. 
(* apply pos_round_of_pos_real with (Double nearest_even 1%R).
auto with real. *)

assert (float_sign result1 = Positive).
admit. (*pareil*)

case (sign_dec x).
intro.
destruct H11.
assert (float_sign result0=Negative).
apply H43;rewrite H40,H42;discriminate.

assert (float_sign y =Negative).
generalize (sign_invariant x H28 H30); intro.
generalize (sign_invariant y H31 H32); intro.
unfold float_value in *.
rewrite H42 in H47.
rewrite H34 in H47.
unfold same_sign_real_bool in *.
case (sign_dec y);intro;auto.
rewrite H49 in H48.
admit. (*absurd H47 H48 *)
destruct H26.
assert (float_sign result2=Negative).
apply H48;rewrite H41,H47;discriminate.
right.
rewrite H45,H49.
clear -H44 H46; intuition.

intro.
destruct H11.
assert (float_sign result0=Positive).
apply H11;rewrite H40,H42;auto.


assert (float_sign y =Positive).
generalize (sign_invariant x H28 H30); intro.
generalize (sign_invariant y H31 H32); intro.
unfold float_value in *.
rewrite H42 in H47.
rewrite H34 in H47.
unfold same_sign_real_bool in *.
case (sign_dec y);intro;auto.
rewrite H49 in H48.
admit. (*absurd H47 H48 *)
destruct H26.
assert (float_sign result2=Positive).
apply H26;rewrite H41,H47;auto.
right.
rewrite H45,H49.
clear -H44 H46; intuition.
Save.
*)



(* Why obligation from file "floats1.why", line 31, characters 9-62: *)
(*Why goal*) Lemma tes2_po_1 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (HW_1: (is_gen_zero_plus x) /\ (is_gen_zero_minus y)),
  ((Rle (min_gen_float Double) (1)%R) /\ (Rle (1)%R (max_gen_float Double))).
Proof.
intros.
unfold min_gen_float,max_gen_float.
gappa.
Save.


(* Why obligation from file "floats1.why", line 32, characters 8-92: *)
(*Why goal*) Lemma tes2_po_2 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (one: gen_float),
  forall (HW_1: (is_gen_zero_plus x) /\ (is_gen_zero_minus y)),
  forall (HW_2: (Rle (min_gen_float Double) (1)%R) /\
                (Rle (1)%R (max_gen_float Double))),
  ((float_class one) = Finite /\ (float_sign one) = Positive /\
  ~(eq (float_value one) (0)%R)).
Proof.
intros.
Admitted.


(* Why obligation from file "floats1.why", line 36, characters 2-48: *)
(*Why goal*) Lemma tes2_po_3 : 
  forall (x: gen_float),
  forall (y: gen_float),
  forall (one: gen_float),
  forall (HW_1: (is_gen_zero_plus x) /\ (is_gen_zero_minus y)),
  forall (HW_2: (Rle (min_gen_float Double) (1)%R) /\
                (Rle (1)%R (max_gen_float Double))),
  forall (HW_3: (float_class one) = Finite /\ (float_sign one) = Positive /\
                ~(eq (float_value one) (0)%R)),
  forall (result: gen_float),
  forall (HW_4: (((is_NaN one) \/ (is_NaN x) -> (is_NaN result))) /\
                (((is_finite one) /\ (is_infinite x) -> (is_gen_zero result))) /\
                (((is_infinite one) /\ (is_finite x) -> (is_infinite result))) /\
                (((is_infinite one) /\ (is_infinite x) -> (is_NaN result))) /\
                (((is_finite one) /\ (is_finite x) /\
                  ~(eq (float_value x) (0)%R) /\
                  (no_overflow
                   Double nearest_even (Rdiv
                                        (float_value one) (float_value x))) ->
                  (is_finite result) /\
                  (eq (float_value result) (round_float
                                            Double nearest_even (Rdiv
                                                                 (float_value
                                                                  one) (
                                                                 float_value
                                                                 x)))))) /\
                (((is_finite one) /\ (is_finite x) /\
                  ~(eq (float_value x) (0)%R) /\
                  ~(no_overflow
                    Double nearest_even (Rdiv
                                         (float_value one) (float_value x))) ->
                  (overflow_value Double nearest_even result))) /\
                (((is_finite one) /\ (is_gen_zero x) /\
                  ~(eq (float_value one) (0)%R) -> (is_infinite result))) /\
                (((is_gen_zero one) /\ (is_gen_zero x) -> (is_NaN result))) /\
                (product_sign result one x) /\
                (eq (exact_value result) (Rdiv
                                          (exact_value one) (exact_value x))) /\
                (eq (model_value result) (Rdiv
                                          (model_value one) (model_value x)))),
  forall (t1: gen_float),
  forall (HW_5: t1 = result),
  forall (result0: gen_float),
  forall (HW_6: (((is_NaN one) \/ (is_NaN y) -> (is_NaN result0))) /\
                (((is_finite one) /\ (is_infinite y) -> (is_gen_zero result0))) /\
                (((is_infinite one) /\ (is_finite y) -> (is_infinite result0))) /\
                (((is_infinite one) /\ (is_infinite y) -> (is_NaN result0))) /\
                (((is_finite one) /\ (is_finite y) /\
                  ~(eq (float_value y) (0)%R) /\
                  (no_overflow
                   Double nearest_even (Rdiv
                                        (float_value one) (float_value y))) ->
                  (is_finite result0) /\
                  (eq (float_value result0) (round_float
                                             Double nearest_even (Rdiv
                                                                  (float_value
                                                                   one) (
                                                                  float_value
                                                                  y)))))) /\
                (((is_finite one) /\ (is_finite y) /\
                  ~(eq (float_value y) (0)%R) /\
                  ~(no_overflow
                    Double nearest_even (Rdiv
                                         (float_value one) (float_value y))) ->
                  (overflow_value Double nearest_even result0))) /\
                (((is_finite one) /\ (is_gen_zero y) /\
                  ~(eq (float_value one) (0)%R) -> (is_infinite result0))) /\
                (((is_gen_zero one) /\ (is_gen_zero y) -> (is_NaN result0))) /\
                (product_sign result0 one y) /\
                (eq (exact_value result0) (Rdiv
                                           (exact_value one) (exact_value y))) /\
                (eq (model_value result0) (Rdiv
                                           (model_value one) (model_value y)))),
  forall (t2: gen_float),
  forall (HW_7: t2 = result0),
  ((is_plus_infinity t1) /\ (is_minus_infinity t2)).
Proof.
unfold is_finite,is_infinite, is_plus_infinity, is_minus_infinity,is_gen_zero_plus, is_gen_zero_minus.
intros.
subst.
decompose [and or] HW_4;clear HW_4.
decompose [and or] HW_6;clear HW_6.
decompose [and] HW_1;clear HW_1.
decompose [and] HW_3;clear HW_3.
generalize (is_gen_zero_correct1 x H23);intro.
generalize (is_gen_zero_correct1 y H20);intro.
generalize (H5 (conj H22 (conj H23 H28)));intro.
generalize (H16 (conj H22 (conj H20 H28)));intro.
repeat split;trivial;unfold product_sign,same_sign,diff_sign in *;
rewrite H27,H24,H25 in *.
clear -H7; intuition.
clear -H18;apply (proj2 H18);discriminate.
Save.
