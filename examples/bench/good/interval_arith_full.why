

axiom help1: forall x:real. forall y:real. forall z:real. forall t:real.
   (0.0 <= x <= y and 0.0 <= z <= t) -> x*z <= y*t

axiom help3: forall x:real. forall y:real. forall a:real. forall b:real.
   (0.0 <= a <= x and y <= b and y < 0.0) -> x*y <= a*b 

axiom help5: forall x:real. forall y:real. forall a:real. forall b:real.
   (a <= x and x > 0.0 and y <= b <= 0.0 ) -> x*y <= a*b

(* help6 is help5, exchanging a and b; and x and y *)
axiom help6: forall x:real. forall y:real. forall a:real. forall b:real.
   (b <= y and y > 0.0 and x <= a <= 0.0 ) -> x*y <= a*b

axiom help7: forall x:real. forall y:real. forall a:real. forall b:real.
   (x <= a <= 0.0 and y <= b and y < 0.0) -> a*b <= x*y

axiom help8: forall x:real. forall y:real. forall a:real. forall b:real.
   (x <= a and x < 0.0 and y <= b <= 0.0 ) -> a*b <= x*y

axiom help9: forall x:real. forall y:real. forall a:real. forall b:real.
   (a <= x and x > 0.0 and 0.0 <= b <= y ) -> a*b <= x*y 



let min (x:double) (y:double) =
 { double_is_not_NaN(x) and double_is_not_NaN(y) 
}
if (lt_double x y) then x else y
 { le_double(result,x) and le_double(result,y)
} 


let max (x:double) (y:double) =
 { double_is_not_NaN(x) and double_is_not_NaN(y) 
}
if (gt_double x y) then x else y
{  le_double(x,result) and le_double(y,result)
}



predicate float_less_than_real(x:double,y:real) = 
       (double_is_finite(x) and double_value(x) <= y)  or double_is_minus_infinity(x)

predicate real_less_than_float(x:real,y:double) = 
       (double_is_finite(y) and x <= double_value(y)) or double_is_plus_infinity(y)

	
let mul_dn (x:double) (y:double) =

{
 double_is_not_NaN(x) and double_is_not_NaN(y) and
  ((double_is_infinite(x) or double_is_infinite(y)) -> double_diff_sign(x,y))
and               
  (double_is_infinite(x) and double_is_finite(y) -> double_value(y) <> 0.0) 
and
  (double_is_infinite(y) and double_is_finite(x) -> double_value(x) <> 0.0)
 }
 (mul_double down x y)
 {
  float_less_than_real(result,double_value(x)*double_value(y)) and
(double_is_infinite(x) or double_is_infinite(y) -> double_is_minus_infinity(result)) 
}



parameter a:double ref
parameter b:double ref
parameter z:double ref


let mul_up (x:double) (y:double) =
 {

 double_is_not_NaN(x) and double_is_not_NaN(y) and
  ((double_is_infinite(x) or double_is_infinite(y)) -> double_same_sign(x,y)) 
  and
  (double_is_infinite(x) and double_is_finite(y) -> double_value(y) <> 0.0 )
  and 
  (double_is_infinite(y) and double_is_finite(x) -> double_value(x) <> 0.0)
}
begin
a := (neg_double y);
(*
assert { 
  double_is_finite(y) -> double_is_finite(a) and double_value(a) = - double_value(y) };
*)
b := (mul_double down x !a);
z := (neg_double !b) ;
(*
assert { 
  double_is_finite(b) -> double_is_finite(z) and double_value(z) = - double_value(b) };
*)
!z
end
{
real_less_than_float(double_value(x)*double_value(y),result) and
((double_is_infinite(x) or double_is_infinite(y)) -> double_is_plus_infinity(result)) 

}



(*********************


  intervals


**********************)



predicate is_interval(l:double,u:double)= 
 (double_is_finite(l) or (double_is_infinite(l) and double_sign(l) = Negative))
 and 
 (double_is_finite(u) or (double_is_infinite(u) and double_sign(u) = Positive))

predicate in_interval(a:real,l:double,u:double) = 
 float_less_than_real(l,a) and real_less_than_float(a,u)


parameter zl:double ref
parameter zu:double ref

let add (xl:double) (xu:double) (yl:double) (yu:double) =
{ is_interval(xl,xu) and is_interval(yl,yu) }
begin
zl := (add_double down xl yl)
(*
zu := (neg_double (sub_double down (neg_double xu) yu))
*)
end
{

(*
 forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a+b,zl,zu)
*)

 (forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> float_less_than_real(zl,a+b)) 

(*and 
(forall a:real. forall b:real. 
         in_interval(a,xl,xu) and in_interval(b,yl,yu) -> real_less_than_float(a+b,zu))
*)
}






parameter tl:double ref
parameter tu:double ref
parameter zero:double ref

let mul (xl:double) (xu:double) (yl:double) (yu:double) =
{ is_interval(xl,xu) and is_interval(yl,yu) 
}
  zero := double_of_real down 0.0;
assert {double_value(zero)=0.0};
  begin
  if (lt_double xl !zero) then
    if (gt_double xu !zero) then
      if (lt_double yl !zero) then
        if (gt_double yu !zero) then
            begin (* xl,yl< 0 et xu,yu > 0 *)
	    tl := min (mul_dn xl yu) (mul_dn xu yl);
            tu := max (mul_up xl yl) (mul_up xu yu)
	    end
        else           
            begin (* xl,yl< 0 et xu > 0 et yu <=0 *)
	    tl := mul_dn xu yl;
	    tu := mul_up xl yl
            end
      else 
        begin
        if (gt_double yu !zero) then
            begin (* xl< 0 et yl >=0 et xu > 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xu yu
	    end
        else
            begin (* xl< 0 et yl >=0 et xu > 0 et yu <=0 *)          
            tl := !zero;
            tu := !zero 
	    end
	end
    else
      begin
      if (lt_double yl !zero) then
        begin
	if (gt_double yu !zero) then
            begin (* xl,yl< 0 et xu <= 0 et yu >0 *)
	    tl := mul_dn xl yu;
            tu := mul_up xl yl
	    end
        else           
            begin (* xl,yl< 0 et xu <= 0 et yu <=0 *)
	    tl := mul_dn xu yu;
            tu := mul_up xl yl
	    end
	end
      else 
        if (gt_double yu !zero) then
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu >0 *) 
	    tl := mul_dn xl yu;
            tu := mul_up xu yl
	    end
        else          
            begin (* xl< 0 et yl>=0 et xu <= 0 et yu <=0 *)
	    tl := !zero;
            tu := !zero
	    end
      end
  else
    if (gt_double xu !zero) then
      if (lt_double yl !zero) then
        if (gt_double yu !zero) then
            begin (* xl>=0 et yl<0 et xu > 0 et yu >0 *)
	    tl := mul_dn xu yl;
            tu := mul_up xu yu
	    end
        else           
            begin (* xl>=0 et yl<0 et xu > 0 et yu <=0*)
	    tl := mul_dn xu yl;
            tu := mul_up xl yu
	    end
      else 
        if (gt_double yu !zero) then
            begin (* xl>=0 et yl >=0 et xu > 0 et yu >0*)
     	    tl := mul_dn xl yl;
	    tu := mul_up xu yu
            end
        else           
            begin  (* xl>=0 et yl >=0 et xu > 0 et yu <=0*)
	    tl := !zero;
            tu := !zero
	    end
    else   (* xl>=0 et yl qlq et xu <= 0 et yu qlq *)             
        begin
	tl := !zero;
        tu := !zero
        end
  end;
  void       
{ is_interval(tl,tu) and 
 
  forall a:real. forall b:real. 
      in_interval(a,xl,xu) and in_interval(b,yl,yu) -> in_interval(a*b,tl,tu)

(*
         (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))


completement prouvé par Z3 sauf postconditions 55, 96 et 140 prouvés par cvc3
*)






(*  Borne inférieure: Il ne faut pas considerer la borne inf toute seule parce que 
    le calcul de tl parfois depend de xu et/ou yu

forall a:real. forall b:real. 
       float_less_than_real(xl,a) and float_less_than_real(yl,b) ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       double_is_finite(xl) and double_value(xl) <= a and 
       double_is_finite(yl) and double_value(yl) <= b ->
           float_less_than_real(tl,a*b)

completement prouvé par Z3 !

forall a:real. forall b:real. 
       double_is_minus_infinity(xl) and 
       double_is_finite(yl) and double_value(yl) <= b ->
           float_less_than_real(tl,a*b)

forall a:real. forall b:real. 
       double_is_finite(xl) and double_value(xl) <= a and 
       double_is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)
forall a:real. forall b:real. 
       double_is_minus_infinity(xl) and double_is_minus_infinity(yl) ->
           float_less_than_real(tl,a*b)

completement prouvés par Z3 !
*)







(* Les deux bornes ensembles:

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_finite(yl) and double_value(yl) <= b and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_finite(yl) and double_value(yl) <= b and
       double_is_plus_infinity(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_finite(yl) and double_value(yl) <= b and
       double_is_finite(xu) and a <= double_value(xu) and  
       double_is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition)

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_finite(yl) and double_value(yl) <= b and
       double_is_plus_infinity(xu) and  
       double_is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions)





***************aussi *******************



forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_finite(yl) and double_value(yl) <= b and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_finite(yl) and double_value(yl) <= b and 
       double_is_plus_infinity(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_finite(yl) and double_value(yl) <= b and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_finite(yl) and double_value(yl) <= b and 
       double_is_plus_infinity(xu) and 
       double_is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3





***************aussi *******************


forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_minus_infinity(yl) and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_minus_infinity(yl) and 
       double_is_plus_infinity(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))
completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_minus_infinity(yl) and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_finite(xl) and double_value(xl) <= a and 
       double_is_minus_infinity(yl) and 
       double_is_plus_infinity(xu) and 
       double_is_plus_infinity(yu)) ->  
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

completement prouvé par Z3




*******************aussi************************





forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_minus_infinity(yl) and 
       double_is_plus_infinity(xu) and  
       double_is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par tous

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_minus_infinity(yl) and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3 et ergo (pour une seule postcondition en ajoutant des assertions) 

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_minus_infinity(yl) and 
       double_is_plus_infinity(xu) and 
       double_is_finite(yu) and b <= double_value(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

forall a:real. forall b:real. 
       (double_is_minus_infinity(xl) and 
       double_is_minus_infinity(yl) and 
       double_is_finite(xu) and a <= double_value(xu) and 
       double_is_plus_infinity(yu)) ->
           (float_less_than_real(tl,a*b) and real_less_than_float(a*b,tu))

complètetement prouvé par Z3

*)

}

