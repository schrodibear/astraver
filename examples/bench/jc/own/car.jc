
# InvariantPolicy = Ownership


axiomatic Round {

  logic integer round(real x)

  logic real K

}

tag Sensor = {
  real rpm;
}

type Sensor = [Sensor]

real any_real_();

unit Sensor_read(Sensor[0] this)
  requires \mutable(this, Sensor) && this.committed == false;
  behavior default:
    assigns this.rpm;     
    ensures true;
{
  unpack(this);
  this.rpm = any_real_ ();
  pack(this);
}

tag Car = {
  integer displayedSpeed;
  rep Sensor[0..] sensor;
  invariant I(self) =     
    self.displayedSpeed == round(K * self.sensor.rpm);
}

type Car = [Car]

/*
unit Car_update_no_annot(Car[0] this)
behavior default:
  ensures true;
{
  Sensor_read(this.sensor);
  this.displayedSpeed = round(K * this.sensor.rpm);
  ()
}
*/

unit cons_Car(Car[0] this, Sensor[0] s)
  requires \mutable(this) && 
    this.committed == false &&
    \mutable(s,Sensor) && s.committed == false;
  behavior default:
    /* we should say: assigns this.committed, this.mutable; */
    ensures \mutable(this,Car) && this.committed == false;
{
  this.sensor = s;
  this.displayedSpeed = round(K * this.sensor.rpm);
  pack(this);
}
   

unit Car_update(Car[0] this)
requires \mutable(this, Car) && this.committed == false;
{
  unpack(this);
  assert (should_be_proved: \mutable(this.sensor,Sensor));
  Sensor_read(this.sensor); 
  this.displayedSpeed = round(K * this.sensor.rpm);
  pack(this);
}


unit wrong_main() 
{
  var Sensor[0] s;
  s = new Sensor[1];
  pack(s);
  var Car[0] c = new Car[1];
  c.sensor = s;
  c.displayedSpeed = round(K * c.sensor.rpm);	
  assert (should_be_true: \offset_max(c.sensor) == 0);
  assert (should_be_proved: \mutable(c.sensor,Sensor));
  pack(c);
  Sensor_read(s);
}
  