
(* this one could be accepted, but this is not easy to implement:
   indeed, l should be generalized in let l = ...
   but then during the WP computation, it must be substituted at two
   different places with the term nil, on two different types

   it means that the substitution l->nil function must look for the variable l
   as Tapp(l,[],[tau]) and then replace it by nil[alpha <- tau], but alpha can
   be anywhere in the term to be substituted *)

type 'a list
logic nil : 'a list
logic cons : 'a, 'a list -> 'a list

let p () =
  let l = nil in
  let x = cons 1 l in
  let y = cons true l in
  x
  { result = cons(1,nil) }
