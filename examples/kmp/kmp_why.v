(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Sumbool.

Require Match.
Require Next.
Require ZArithRing.
Require Omega.
Require Lex.

Tactic Definition Omega' := Abstract Omega.

Parameter A : Set.
Axiom A_eq_dec : (x,y:A) { x=y }+{ ~x=y }.
Definition A_eq_bool := [x,y:A](bool_of_sumbool (A_eq_dec x y)).

(*Why*) Parameter M : Z.
Axiom M_positive : `0 <= M`.

Lemma initnext_po_1 : 
  (next: (array M Z))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (result2: Z)
  (Post3: (store next `1` result2) = (store next `1` `0`))
  `0 <= 1` /\ `1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_2 : 
  (next: (array M Z))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (well_founded ? lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma initnext_po_3 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_4 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Pre3: `0 <= j0` /\ `j0 < M`)
  `0 <= i0` /\ `i0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_5 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  (result7: Z)
  (Post9: (store next1 i1 result7) = (store next1 i1 j1))
  `0 <= i1` /\ `i1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_6 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  (next2: (array M Z))
  (Post9: next2 = (store next1 i1 j1))
  `0 <= j1` /\ `j1 <= M` /\ (`j1 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)).
Proof.
Intuition.
Rewrite Post7; Rewrite Post8.
Apply match_right_extension.
Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H3; Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0+1-(z-1)` with `i0+1+1-z`.
  Rewrite Post7 in H7; Assumption. Omega'. Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro Hk'.  
  Rewrite Post9; Rewrite store_def_2.
  Apply H6; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`. Intro Heq.	
  Rewrite Post9; Rewrite Post7; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Rewrite Post8; Replace `i0+1-(j0+1)` with `i0-j0`.
  Apply match_right_extension; Omega' Orelse Try Assumption.
  Ring `i0-j0+j0`; Ring `0+j0`; Assumption. Omega'.
  Intros z Hz. 
  Red; Apply H3; Omega'.
  Omega'. Omega'.
Unfold lexZ lex Zwf pairZ; Left; Omega'.
Save.

Lemma initnext_po_7 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: j0 = `0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (result7: Z)
  (Post6: (store next1 i1 result7) = (store next1 i1 `0`))
  `0 <= i1` /\ `i1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_8 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: j0 = `0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (next2: (array M Z))
  (Post6: next2 = (store next1 i1 `0`))
  `0 <= j0` /\ `j0 <= M` /\ (`j0 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j0` p `0` j0) /\
  ((z:Z) (`j0 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  (lexZ (pairZ `M - i1` j0) (pairZ `M - i0` j0)).
Proof.
Intuition.
  Rewrite Test4.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_lt_ge_dec `j0+2` z); Intro.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H3; Omega'.
  Apply match_right_weakening with n := z.
  Rewrite Post5 in H7.
  Replace `i0+1-(z-1)` with `i0+1+1-z`; [ Assumption | Omega' ]. Omega'.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Idtac ].
  Decompose [match] H7.
  Replace i0 with `i0+1+1-2+j0`; [ Idtac | Omega' ].
  Replace #p[j0] with #p[`0+j0`]; [ Idtac | Ring `0+j0`; Reflexivity ].
  Cut `z = 2`; [ Intro Heq | Omega' ].
  Rewrite <- Heq. Rewrite <- Post5; Apply H11; Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro.
  Rewrite Post6; Rewrite store_def_2.
  Apply H6; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`; [ Intro Heq | Omega' ].
  Rewrite Post6; Rewrite Post5; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Apply match_empty; Omega'.
  Intros z Hz.
  Elim (Z_lt_ge_dec `1` z); Intro.
  (* 1 < z  *)
  Red; Apply H3; Omega'.
  (* z = 1 *)
  Red; Intro.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Rewrite Test4 ].
  Decompose [match] H5.
  Replace `0` with `0+0`; [ Idtac | Omega' ].
  Replace `i0` with `i0+1-z+0`; [ Idtac | Omega' ].
  Apply H11; Omega'.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma initnext_po_9 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: ~(j0 = `0`))
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_10 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: ~(j0 = `0`))
  (Pre5: `0 <= j0` /\ `j0 < M`)
  (j1: Z)
  (Post4: j1 = (access next1 j0))
  `0 <= j1` /\ `j1 <= M` /\ (`j1 < i0` /\ `i0 <= M`) /\
  (match p `i0 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
  (lexZ (pairZ `M - i0` j1) (pairZ `M - i0` j0)).
Proof.
Intuition (Cut ~`j0=0`; [ Clear Test3; Intro Test3 | Assumption ]).
  Rewrite Post4. 
  Elim (H8 j0); Omega'.
  Elim (H8 j0); Omega'.
  Elim (H8 j0); Omega'.
  Rewrite Post4.
  Apply match_trans with t2 := p i2 := `j0-(access   next1 j0)`.
  Apply match_left_weakening with n := j0.
  Replace `i0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `i0-j0` ; [ Idtac | Omega' ].
  Replace `j0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `0` ; [ Assumption | Omega' ].
  Elim (H8 j0); Omega'. Elim (H8 j0); Auto; Omega'.

  Elim (Z_lt_ge_dec `j0+1` z); Intro.
  (* j0+1 < z < i0+1 *)
  Apply (H5 z); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec z `j0+1`); Intro.
  (* z = j0+1 *)
  Absurd (#p[i0])=(#p[j0]) ; [ Assumption | Idtac ].
  Decompose [match] H9.
  Replace i0 with `i0+1-z+j0`; [ Idtac | Omega' ].
  Replace j0 with `0+j0`; [ Idtac | Omega' ].
  Apply H13; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  Absurd (match p `j0-(z-1)` p `0` `z-1`).
  Decompose [match] H9.
  Elim (H8 j0); Omega' Orelse Intros.
  Apply H16; Omega'.
  Apply match_trans with t2 := p i2 := `i0-(z-1)`.
  Apply match_sym.
  Apply match_left_weakening with n := j0.
  Replace `i0-(z-1)-(j0-(z-1))` with `i0-j0` ; [ Idtac | Omega' ].
  Ring `j0-(z-1)-(j0-(z-1))`. Assumption.
  Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0-(z-1)` with `i0+1-z` ; [ Assumption | Omega' ].
  Omega'.
Unfold lexZ lex Zwf pairZ. 
Elim (H8 j0) ; [ Intros | Omega' ].
Right. Omega'.
Save.

Lemma initnext_po_11 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (i1: Z)
  (j1: Z)
  (next2: (array M Z))
  (Inv0: `0 <= j1` /\ `j1 <= M` /\ (`j1 < i1` /\ `i1 <= M`) /\
         (match p `i1 - j1` p `0` j1) /\
         ((z:Z)
          (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
         (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)))
  (lexZ (pairZ `M - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre8; Assumption.
Save.

Lemma initnext_po_12 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (i1: Z)
  (j1: Z)
  (next2: (array M Z))
  (Inv0: `0 <= j1` /\ `j1 <= M` /\ (`j1 < i1` /\ `i1 <= M`) /\
         (match p `i1 - j1` p `0` j1) /\
         ((z:Z)
          (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
         (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)))
  `0 <= j1` /\ `j1 <= M` /\ (`j1 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))).
Proof.
Intuition.
Save.

Lemma initnext_po_13 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test2: `i0 >= M - 1`)
  `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
  (match p `i0 - j0` p `0` j0) /\
  ((z:Z) (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
  `i0 >= M - 1`.
Proof.
Intuition.
Save.

Lemma initnext_po_14 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  `0 <= result0` /\ `result0 <= M` /\ (`result0 < result` /\
  `result <= M`) /\ (match p `result - result0` p `0` result0) /\
  ((z:Z)
   (`result0 + 1 < z` /\ `z < result + 1` ->
    ~(match p `result + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= result` -> (Next p k (access next0 k)))).
Proof.
Intuition.
Rewrite Post1; Rewrite Post2.
Apply match_empty ; Omega'.
Absurd `1 < z`; Omega'.
Replace k with `1` ; [ Rewrite Post3; Rewrite store_def_1 | Omega' ].
Apply next_1_0; Omega'.
Omega'.
Save.

Lemma initnext_po_15 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `i0 >= M - 1`)
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))).
Proof.
Intuition.
Save.

Lemma initnext_po_16 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test1: `1 >= M`)
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))).
Proof.
Intuition.
Absurd `0 < j`; Omega'.
Save.




(*Why*) Parameter N : Z.
Axiom N_positive : `0 <= N`.


Lemma kmp_po_1 : 
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (well_founded ? lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma kmp_po_2 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test2: `j0 < M`)
  (result3: bool)
  (Bool2: (if result3 then `i0 < N` else `i0 >= N`))
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_3 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test1: `j0 >= M`)
  (result3: bool)
  (Post3: result3 = false)
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_4 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Discriminate H7.
Save.

Lemma kmp_po_5 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Pre2: `0 <= j0` /\ `j0 < M`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma kmp_po_6 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test7: (access a i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  `0 <= j1` /\ `j1 <= M` /\ (`j1 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))) /\
  (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H7 Orelse Auto with *.
Rewrite Post7; Rewrite Post8.
  Apply match_right_extension.
  Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Replace `i0+1-(j0+1)` with `i0-j0`. 
  Apply (H5 k); Assumption Orelse Omega'.
  Omega'.
  Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_7 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test5: j0 = `0`)
  (i1: Z)
  (Post6: i1 = `i0 + 1`)
  `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j0` p `0` j0) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j0` -> ~(match a k p `0` M))) /\
  (lexZ (pairZ `N - i1` j0) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H7 Orelse Auto with *.
  Rewrite Test5.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_le_lt_eq_dec k `i0-j0`).
  Intro. Apply (H5 k); Assumption Orelse Omega'.
  Intro. Generalize H8. Apply match_contradiction_at_first. Omega'.
  Rewrite b. Rewrite Test5. Ring `i0-0`. Rewrite <- Test5. Assumption.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_8 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: ~(j0 = `0`))
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Discriminate H7.
Save.

Lemma kmp_po_9 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: ~(j0 = `0`))
  (Pre4: `0 <= j0` /\ `j0 < M`)
  (j1: Z)
  (Post5: j1 = (access next0 j0))
  `0 <= j1` /\ `j1 <= M` /\ (`j1 <= i0` /\ `i0 <= N`) /\
  (match a `i0 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i0 - j1` -> ~(match a k p `0` M))) /\
  (lexZ (pairZ `N - i0` j1) (pairZ `N - i0` j0)).
Proof.
Intuition (Assert `j0<>0`; Auto with *).
  (* invariant *)
  Elim (Post15 j0); Intros. Omega'.
  Omega'.
  Elim (Post15 j0); Intros; Omega'.
  Elim (Post15 j0); Intros; Omega'.
  Apply next_iteration with j := j0.
  Omega'.
  Omega'.
  Assumption.
  Rewrite Post5; Apply (Post15 j0); Omega'.
  (* ~(match a k p `0` M) *)
  Elim (Z_lt_ge_dec k `i0-j0`); Intro Hck.
  (* k < i0-j0 *)
  Apply (H7 k); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec `i0-j0` k); Intro Hck'.
  (* k = i0-j0 *)
  Generalize H10. Replace k with `i0-j0`.
  Apply match_contradiction_at_i with i := j0.
  Omega'. Omega'. Ring `i0-j0+j0`. Ring `0+j0`. Assumption. Omega'. 
  (* i0-j0 < k *)
  Generalize H10.
  Apply next_is_maximal with i := i0 j := j0 n := #next0[j0]. 
  Omega'. Omega'. Omega'.
  Assumption.
  Apply (Post15 j0); Omega'.
  Unfold lexZ lex Zwf pairZ. 
  Elim (Post15 j0). Intros.
  Right. Omega'. Omega'.
Discriminate H9.
Discriminate H9.
Save.

Lemma kmp_po_10 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (i1: Z)
  (j1: Z)
  (Inv0: `0 <= j1` /\ `j1 <= M` /\ (`j1 <= i1` /\ `i1 <= N`) /\
         (match a `i1 - j1` p `0` j1) /\
         ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))) /\
         (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)))
  (lexZ (pairZ `N - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre5; Assumption.
Rewrite Pre5; Assumption.
Save.

Lemma kmp_po_11 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (i1: Z)
  (j1: Z)
  (Inv0: `0 <= j1` /\ `j1 <= M` /\ (`j1 <= i1` /\ `i1 <= N`) /\
         (match a `i1 - j1` p `0` j1) /\
         ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))) /\
         (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)))
  `0 <= j1` /\ `j1 <= M` /\ (`j1 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))).
Proof.
Intuition.
Save.

Lemma kmp_po_12 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test3: `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false)
  `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
  (match a `i0 - j0` p `0` j0) /\
  ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))) /\ (`j0 < M` /\
  `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition.
Save.

Lemma kmp_po_13 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  `0 <= result0` /\ `result0 <= M` /\ (`result0 <= result` /\
  `result <= N`) /\ (match a `result - result0` p `0` result0) /\
  ((k:Z) (`0 <= k` /\ `k < result - result0` -> ~(match a k p `0` M))).
Proof.
Intuition.
Generalize M_positive; Omega'.
Generalize N_positive; Omega'.
Rewrite Post1; Rewrite Post2.
Apply match_empty.
Generalize N_positive; Omega'. Generalize M_positive; Omega'.
Absurd `0 <= k`; Omega'.
Save.

Definition first_occur :=
  [p:(array M A)][a:(array N A)][r:Z]  
     (`0 <= r < N` -> (match a r p `0` M))
  /\ ((k:Z) `0 <= k < r` -> ~(match a k p `0` M)).

Lemma kmp_po_14 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test10: j0 = M)
  (first_occur p a `i0 - M`).
Proof.
Intros.
Decompose [and] Inv.
Unfold first_occur. 
Split. 
Intro. Rewrite <- Test10. Replace `i0-M` with `i0-j0`. Assumption. Omega'.
Replace `i0-M` with `i0-j0`. Assumption. Omega'.
Save.

Lemma kmp_po_15 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: `0 <= j0` /\ `j0 <= M` /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test9: ~(j0 = M))
  (first_occur p a i0).
Proof.
Intros. Unfold first_occur. Decompose [and] Inv.
Split. 
Intro. Absurd `i0 < N`; Omega'.
Intros k Hk. 
Elim (Z_lt_ge_dec k `i0-j0`); Intro Hk'.
Apply H3; Omega'.
Red; Intro. Decompose [match] H5.
Absurd `k <= N-M`; Omega'.
Save.






