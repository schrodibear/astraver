(* Load Programs. *)(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Import Sumbool.

Require Export Match.
Require Export Next.
Require Import ZArithRing.
Require Import Omega.
Require Export Lex.

Ltac Omega' := abstract omega.

Parameter A : Set.
Axiom A_eq_dec : forall x y:A, {x = y} + {x <> y}.
Definition A_eq_bool (x y:A) := bool_of_sumbool (A_eq_dec x y).

(*Why*) Parameter M : Z.
Axiom M_positive : (0 <= M)%Z.

(* Why obligation from file , characters 1205-1217 *)
Lemma initnext_po_1 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z),
   (0 <= 1)%Z /\ (1 < array_length next)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1225-1755 *)
Lemma initnext_po_2 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z), well_founded lexZ.
Proof.
intros; exact lexZ_well_founded.
Qed.

(* Why obligation from file , characters 1578-1583 *)
Lemma initnext_po_3 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z),
   (0 <= i1)%Z /\ (i1 < array_length p)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1584-1589 *)
Lemma initnext_po_4 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z),
   (0 <= j1)%Z /\ (j1 < array_length p)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1634-1648 *)
Lemma initnext_po_5 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test6:access p i1 = access p j1) (i2:Z) (Post2:i2 = (i1 + 1)%Z)
   (j2:Z) (Post3:j2 = (j1 + 1)%Z),
   (0 <= i2)%Z /\ (i2 < array_length next1)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1596-1660 *)
Lemma initnext_po_6 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test6:access p i1 = access p j1) (i2:Z) (Post2:i2 = (i1 + 1)%Z)
   (j2:Z) (Post3:j2 = (j1 + 1)%Z)
   (Pre10:(0 <= i2)%Z /\ (i2 < array_length next1)%Z) (next2:array Z)
   (Post4:next2 = store next1 i2 j2),
   (((0 <= j2)%Z /\ (j2 <= M)%Z) /\
    ((j2 < i2)%Z /\ (i2 <= M)%Z) /\
    match_ p (i2 - j2) p 0 j2 /\
    (forall z:Z,
       (j2 + 1 < z)%Z /\ (z < i2 + 1)%Z ->
       ~ match_ p (i2 + 1 - z) p 0 z) /\
    (forall k:Z, (0 < k)%Z /\ (k <= i2)%Z -> Next p k (access next2 k)) /\
    array_length next2 = M) /\
   lexZ (pairZ (M - i2) j2) (pairZ (M - i1) j1).
Proof.
intuition.
subst i2 j2.
apply match_right_extension.
replace (i1 + 1 - (j1 + 1))%Z with (i1 - j1)%Z.
 assumption.
 Omega'.
  Omega'.
 Omega'.
  ring (i1 + 1 - (j1 + 1) + j1)%Z.
 ring (0 + j1)%Z.
 assumption.
  absurd (match_ p (i1 + 1 - (z - 1)) p 0 (z - 1)).
  red; apply H11; Omega'.
  apply match_right_weakening with (n := z).
  replace (i1 + 1 - (z - 1))%Z with (i1 + 1 + 1 - z)%Z.
  subst i2; assumption.
 Omega'.
 Omega'.
  elim (Z_lt_ge_dec k (i1 + 1)); intro Hk'.
    subst next2; rewrite store_def_2.
  apply H13; Omega'.
 Omega'.
 Omega'.
 Omega'.
  cut ((i1 + 1)%Z = k).
 intro Heq.
   subst next2 i2; rewrite Heq.
 rewrite store_def_1.
  rewrite <- Heq.
 apply Next_cons.
 Omega'.
  subst j2; replace (i1 + 1 - (j1 + 1))%Z with (i1 - j1)%Z.
  apply match_right_extension; Omega' || (try assumption).
  ring (i1 - j1 + j1)%Z; ring (0 + j1)%Z; assumption.
 Omega'.
  intros z Hz.
   red; apply H11; Omega'.
  Omega'.
 Omega'.
  ArraySubst next2.
unfold lexZ, lex, Zwf, pairZ; left; Omega'.
Qed.

(* Why obligation from file , characters 1708-1721 *)
Lemma initnext_po_7 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test5:access p i1 <> access p j1) (Test4:j1 = 0%Z) (i2:Z)
   (Post5:i2 = (i1 + 1)%Z), (0 <= i2)%Z /\ (i2 < array_length next1)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1691-1725 *)
Lemma initnext_po_8 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test5:access p i1 <> access p j1) (Test4:j1 = 0%Z) (i2:Z)
   (Post5:i2 = (i1 + 1)%Z)
   (Pre9:(0 <= i2)%Z /\ (i2 < array_length next1)%Z) (next2:array Z)
   (Post6:next2 = store next1 i2 0%Z),
   (((0 <= j1)%Z /\ (j1 <= M)%Z) /\
    ((j1 < i2)%Z /\ (i2 <= M)%Z) /\
    match_ p (i2 - j1) p 0 j1 /\
    (forall z:Z,
       (j1 + 1 < z)%Z /\ (z < i2 + 1)%Z ->
       ~ match_ p (i2 + 1 - z) p 0 z) /\
    (forall k:Z, (0 < k)%Z /\ (k <= i2)%Z -> Next p k (access next2 k)) /\
    array_length next2 = M) /\
   lexZ (pairZ (M - i2) j1) (pairZ (M - i1) j1).
Proof.
intuition.
  rewrite Test4.
  apply match_empty.
 Omega'.
 Omega'.
  elim (Z_lt_ge_dec (j1 + 2) z); intro.
  absurd (match_ p (i1 + 1 - (z - 1)) p 0 (z - 1)).
  red; apply H11; Omega'.
  apply match_right_weakening with (n := z).
  subst i2.
  replace (i1 + 1 - (z - 1))%Z with (i1 + 1 + 1 - z)%Z;
   [ assumption | Omega' ].
 Omega'.
  absurd (access p i1 = access p j1); [ assumption | idtac ].
  decompose [match_] H18.
  replace i1 with (i1 + 1 + 1 - 2 + j1)%Z; [ idtac | Omega' ].
  replace (access p j1) with (access p (0 + j1));
   [ idtac | ring (0 + j1)%Z; reflexivity ].
  cut (z = 2%Z); [ intro Heq | Omega' ].
  rewrite <- Heq.
 rewrite <- Post5; apply H22; Omega'.
  elim (Z_lt_ge_dec k (i1 + 1)); intro.
  subst next2.
 AccessOther.
  apply H13; Omega'.
   cut ((i1 + 1)%Z = k); [ intro Heq | Omega' ].
  rewrite Post6; rewrite Post5; rewrite Heq.
 AccessSame.
  rewrite <- Heq.
 apply Next_cons.
 Omega'.
  apply match_empty; Omega'.
  intros z Hz.
  elim (Z_lt_ge_dec 1 z); intro.
  (* 1 < z  *)
  red; apply H11; Omega'.
  (* z = 1 *)
  red; intro.
  absurd (access p i1 = access p j1); [ assumption | rewrite Test4 ].
  decompose [match_] H17.
  replace 0%Z with (0 + 0)%Z; [ idtac | Omega' ].
  replace i1 with (i1 + 1 - z + 0)%Z; [ idtac | Omega' ].
  apply H22; Omega'.
  ArraySubst next2.
unfold lexZ, lex, Zwf, pairZ.
 left; Omega'.
Qed.

(* Why obligation from file , characters 1736-1744 *)
Lemma initnext_po_9 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test5:access p i1 <> access p j1) (Test3:j1 <> 0%Z),
   (0 <= j1)%Z /\ (j1 < array_length next1)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1731-1744 *)
Lemma initnext_po_10 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length p)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test5:access p i1 <> access p j1) (Test3:j1 <> 0%Z)
   (Pre8:(0 <= j1)%Z /\ (j1 < array_length next1)%Z) (j2:Z)
   (Post7:j2 = access next1 j1),
   (((0 <= j2)%Z /\ (j2 <= M)%Z) /\
    ((j2 < i1)%Z /\ (i1 <= M)%Z) /\
    match_ p (i1 - j2) p 0 j2 /\
    (forall z:Z,
       (j2 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
       ~ match_ p (i1 + 1 - z) p 0 z) /\
    (forall k:Z, (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
    array_length next1 = M) /\
   lexZ (pairZ (M - i1) j2) (pairZ (M - i1) j1).
Proof.
intuition cut (j1 <> 0%Z); [ clear Test3; intro Test3 | assumption ].
  subst j2.
  elim (H15 j1); Omega'.
  elim (H15 j1); Omega'.
  elim (H15 j1); Omega'.
  subst j2.
  apply match_trans with (t2 := p) (i2 := (j1 - access next1 j1)%Z).
  apply match_left_weakening with (n := j1).
  replace (i1 - access next1 j1 - (j1 - access next1 j1))%Z with
   (i1 - j1)%Z; [ idtac | Omega' ].
  replace (j1 - access next1 j1 - (j1 - access next1 j1))%Z with 0%Z;
   [ assumption | Omega' ].
  elim (H15 j1); Omega'.
 elim (H15 j1); auto; Omega'.

  elim (Z_lt_ge_dec (j1 + 1) z); intro.
  (* j0+1 < z < i0+1 *)
  apply (H13 z); assumption || Omega'.
  elim (Z_ge_lt_dec z (j1 + 1)); intro.
  (* z = j0+1 *)
  absurd (access p i1 = access p j1); [ assumption | idtac ].
  decompose [match_] H18.
  replace i1 with (i1 + 1 - z + j1)%Z; [ idtac | Omega' ].
  replace j1 with (0 + j1)%Z; [ idtac | Omega' ].
  apply H22; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  absurd (match_ p (j1 - (z - 1)) p 0 (z - 1)).
  decompose [match_] H18.
  elim (H15 j1); Omega' || intros.
  apply H25; Omega'.
  apply match_trans with (t2 := p) (i2 := (i1 - (z - 1))%Z).
  apply match_sym.
  apply match_left_weakening with (n := j1).
  replace (i1 - (z - 1) - (j1 - (z - 1)))%Z with (i1 - j1)%Z;
   [ idtac | Omega' ].
  ring (j1 - (z - 1) - (j1 - (z - 1)))%Z.
 assumption.
  Omega'.
  apply match_right_weakening with (n := z).
  replace (i1 - (z - 1))%Z with (i1 + 1 - z)%Z; [ assumption | Omega' ].
  Omega'.
unfold lexZ, lex, Zwf, pairZ.
 elim (H15 j1); [ intros | Omega' ].
right.
 Omega'.
Qed.

(* Why obligation from file , characters 1225-1755 *)
Lemma initnext_po_11 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (Variant1:prodZZ) (i1 j1:Z)
   (next1:array Z) (Pre13:Variant1 = pairZ (M - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
        match_ p (i1 - j1) p 0 j1 /\
        (forall z:Z,
           (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
           ~ match_ p (i1 + 1 - z) p 0 z) /\
        (forall k:Z,
           (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
        array_length next1 = M) (Test7:(i1 < M - 1)%Z) (i2 j2:Z)
   (next2:array Z)
   (Inv0:(((0 <= j2)%Z /\ (j2 <= M)%Z) /\
          ((j2 < i2)%Z /\ (i2 <= M)%Z) /\
          match_ p (i2 - j2) p 0 j2 /\
          (forall z:Z,
             (j2 + 1 < z)%Z /\ (z < i2 + 1)%Z ->
             ~ match_ p (i2 + 1 - z) p 0 z) /\
          (forall k:Z,
             (0 < k)%Z /\ (k <= i2)%Z -> Next p k (access next2 k)) /\
          array_length next2 = M) /\
         lexZ (pairZ (M - i2) j2) (pairZ (M - i1) j1)),
   lexZ (pairZ (M - i2) j2) Variant1.
Proof.
intuition.
rewrite Pre13; assumption.
Qed.

(* Why obligation from file , characters 1263-1512 *)
Lemma initnext_po_12 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z),
   ((0 <= j)%Z /\ (j <= M)%Z) /\
   ((j < i)%Z /\ (i <= M)%Z) /\
   match_ p (i - j) p 0 j /\
   (forall z:Z,
      (j + 1 < z)%Z /\ (z < i + 1)%Z -> ~ match_ p (i + 1 - z) p 0 z) /\
   (forall k:Z, (0 < k)%Z /\ (k <= i)%Z -> Next p k (access next0 k)) /\
   array_length next0 = M.
Proof.
intuition.
subst i j.
apply match_empty; Omega'.
replace k with 1%Z; [ subst next0; rewrite store_def_1 | Omega' ].
apply next_1_0; Omega'.
Omega'.
ArraySubst next0.
Qed.

(* Why obligation from file , characters 1193-1763 *)
Lemma initnext_po_13 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test8:(1 < M)%Z)
   (Pre14:(0 <= 1)%Z /\ (1 < array_length next)%Z) (next0:array Z)
   (Post1:next0 = store next 1 0%Z) (i1 j1:Z) (next1:array Z)
   (Inv:(((0 <= j1)%Z /\ (j1 <= M)%Z) /\
         ((j1 < i1)%Z /\ (i1 <= M)%Z) /\
         match_ p (i1 - j1) p 0 j1 /\
         (forall z:Z,
            (j1 + 1 < z)%Z /\ (z < i1 + 1)%Z ->
            ~ match_ p (i1 + 1 - z) p 0 z) /\
         (forall k:Z,
            (0 < k)%Z /\ (k <= i1)%Z -> Next p k (access next1 k)) /\
         array_length next1 = M) /\ (i1 >= M - 1)%Z),
   array_length next1 = M /\
   (forall j:Z, (0 < j)%Z /\ (j < M)%Z -> Next p j (access next1 j)).
Proof.
intuition.
Qed.

(* Why obligation from file , characters 1763-1763 *)
Lemma initnext_po_14 :
 forall (next:array Z) (p:array A)
   (Pre15:array_length p = M /\ array_length next = M) (i:Z)
   (Post9:i = 1%Z) (j:Z) (Post8:j = 0%Z) (Test1:(1 >= M)%Z),
   array_length next = M /\
   (forall j:Z, (0 < j)%Z /\ (j < M)%Z -> Next p j (access next j)).
Proof.
intuition.
absurd (0 < j)%Z; Omega'.
Qed.


(*Why*) Parameter N : Z.
Axiom N_positive : (0 <= N)%Z.


(* Why obligation from file , characters 2317-2332 *)
Lemma kmp_po_1 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z),
   array_length p = M /\ array_length next = M.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 2338-2714 *)
Lemma kmp_po_2 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j))),
   well_founded lexZ.
Proof.
intros; exact lexZ_well_founded.
Qed.

(* Why obligation from file , characters 2354-2360 *)
Lemma kmp_po_3 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test2:(j1 < M)%Z) (result1:bool)
   (Bool4:if result1 then (i1 < N)%Z else (i1 >= N)%Z),
   if result1
   then (j1 < M)%Z /\ (i1 < N)%Z
   else (j1 >= M)%Z \/ (j1 < M)%Z /\ (i1 >= N)%Z.
Proof.
intuition oldinduction result1; tauto.
Qed.

(* Why obligation from file , characters 2360-2360 *)
Lemma kmp_po_4 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test1:(j1 >= M)%Z) (result1:bool) (Post5:result1 = false),
   if result1
   then (j1 < M)%Z /\ (i1 < N)%Z
   else (j1 >= M)%Z \/ (j1 < M)%Z /\ (i1 >= N)%Z.
Proof.
oldinduction result1; intuition; discriminate Post5.
Qed.

(* Why obligation from file , characters 2586-2591 *)
Lemma kmp_po_5 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z),
   (0 <= i1)%Z /\ (i1 < array_length a)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 2592-2597 *)
Lemma kmp_po_6 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length a)%Z),
   (0 <= j1)%Z /\ (j1 < array_length p)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 2604-2648 *)
Lemma kmp_po_7 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length a)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test7:access a i1 = access p j1) (i2:Z) (Post1:i2 = (i1 + 1)%Z)
   (j2:Z) (Post2:j2 = (j1 + 1)%Z),
   (((0 <= j2)%Z /\ (j2 <= M)%Z) /\
    ((j2 <= i2)%Z /\ (i2 <= N)%Z) /\
    match_ a (i2 - j2) p 0 j2 /\
    (forall k:Z, (0 <= k)%Z /\ (k < i2 - j2)%Z -> ~ match_ a k p 0 M)) /\
   lexZ (pairZ (N - i2) j2) (pairZ (N - i1) j1).
Proof.
intuition discriminate H18 || auto with *.
subst j2 i2.
  apply match_right_extension.
  replace (i1 + 1 - (j1 + 1))%Z with (i1 - j1)%Z.
 assumption.
 Omega'.
  Omega'.
 Omega'.
  ring (i1 + 1 - (j1 + 1) + j1)%Z.
 ring (0 + j1)%Z.
 assumption.
  replace (i1 + 1 - (j1 + 1))%Z with (i1 - j1)%Z.
   apply (H18 k); assumption || Omega'.
  Omega'.
  unfold lexZ, lex, Zwf, pairZ.
 left; Omega'.
Qed.

(* Why obligation from file , characters 2677-2686 *)
Lemma kmp_po_8 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length a)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test6:access a i1 <> access p j1) (Test5:j1 = 0%Z) (i2:Z)
   (Post3:i2 = (i1 + 1)%Z),
   (((0 <= j1)%Z /\ (j1 <= M)%Z) /\
    ((j1 <= i2)%Z /\ (i2 <= N)%Z) /\
    match_ a (i2 - j1) p 0 j1 /\
    (forall k:Z, (0 <= k)%Z /\ (k < i2 - j1)%Z -> ~ match_ a k p 0 M)) /\
   lexZ (pairZ (N - i2) j1) (pairZ (N - i1) j1).
Proof.
intuition discriminate H18 || auto with *.
  subst j1.
  apply match_empty.
 Omega'.
 Omega'.
  elim (Z_le_lt_eq_dec k (i1 - j1)).
  intro.
 apply (H18 k); assumption || Omega'.
  intro.
 generalize H19.
 apply match_contradiction_at_first.
 Omega'.
  rewrite b.
 subst j1.
 ring (i1 - 0)%Z.
 assumption.
  Omega'.
unfold lexZ, lex, Zwf, pairZ.
 left; Omega'.
Qed.

(* Why obligation from file , characters 2697-2705 *)
Lemma kmp_po_9 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length a)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test6:access a i1 <> access p j1) (Test4:j1 <> 0%Z),
   (0 <= j1)%Z /\ (j1 < array_length next0)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 2692-2705 *)
Lemma kmp_po_10 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z)
   (Pre11:(0 <= i1)%Z /\ (i1 < array_length a)%Z)
   (Pre12:(0 <= j1)%Z /\ (j1 < array_length p)%Z)
   (Test6:access a i1 <> access p j1) (Test4:j1 <> 0%Z)
   (Pre10:(0 <= j1)%Z /\ (j1 < array_length next0)%Z) (j2:Z)
   (Post4:j2 = access next0 j1),
   (((0 <= j2)%Z /\ (j2 <= M)%Z) /\
    ((j2 <= i1)%Z /\ (i1 <= N)%Z) /\
    match_ a (i1 - j2) p 0 j2 /\
    (forall k:Z, (0 <= k)%Z /\ (k < i1 - j2)%Z -> ~ match_ a k p 0 M)) /\
   lexZ (pairZ (N - i1) j2) (pairZ (N - i1) j1).
Proof.
intuition assert (j1 <> 0%Z); auto with *.
  (* invariant *)
  elim (H5 j1); intros.
 Omega'.
  Omega'.
  elim (H5 j1); intros; Omega'.
  elim (H5 j1); intros; Omega'.
  apply next_iteration with (j := j1).
  Omega'.
  Omega'.
  assumption.
  subst j2; apply (H5 j1); Omega'.
  (* ~(match a k p `0` M) *)
  elim (Z_lt_ge_dec k (i1 - j1)); intro Hck.
  (* k < i0-j0 *)
  apply (H20 k); assumption || Omega'.
  elim (Z_ge_lt_dec (i1 - j1) k); intro Hck'.
  (* k = i0-j0 *)
  generalize H21.
 replace k with (i1 - j1)%Z.
  apply match_contradiction_at_i with (i := j1).
  Omega'.
 Omega'.
 ring (i1 - j1 + j1)%Z.
 ring (0 + j1)%Z.
 assumption.
 Omega'.
   (* i0-j0 < k *)
  generalize H21.
 rewrite <- H.
  apply next_is_maximal with (i := i1) (j := j1) (n := access next0 j1).
   Omega'.
 Omega'.
 Omega'.
  assumption.
  apply (H5 j1); Omega'.
  unfold lexZ, lex, Zwf, pairZ.
   elim (H5 j1).
 intros.
  right.
 Omega'.
 Omega'.
Qed.

(* Why obligation from file , characters 2338-2714 *)
Lemma kmp_po_11 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (Variant1:prodZZ) (i1 j1:Z) (Pre13:Variant1 = pairZ (N - i1) j1)
   (Inv:((0 <= j1)%Z /\ (j1 <= M)%Z) /\
        ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
        match_ a (i1 - j1) p 0 j1 /\
        (forall k:Z,
           (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M))
   (Test8:(j1 < M)%Z /\ (i1 < N)%Z) (i2 j2:Z)
   (Inv0:(((0 <= j2)%Z /\ (j2 <= M)%Z) /\
          ((j2 <= i2)%Z /\ (i2 <= N)%Z) /\
          match_ a (i2 - j2) p 0 j2 /\
          (forall k:Z,
             (0 <= k)%Z /\ (k < i2 - j2)%Z -> ~ match_ a k p 0 M)) /\
         lexZ (pairZ (N - i2) j2) (pairZ (N - i1) j1)),
   lexZ (pairZ (N - i2) j2) Variant1.
Proof.
intuition; rewrite Pre13; assumption.
Qed.

Definition first_occur (p a:array A) (r:Z) :=
  ((0 <= r < array_length a)%Z -> match_ a r p 0 (array_length p)) /\
  (forall k:Z, (0 <= k < r)%Z -> ~ match_ a k p 0 (array_length p)).

(* Why obligation from file , characters 2382-2524 *)
Lemma kmp_po_12 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j))),
   ((0 <= j)%Z /\ (j <= M)%Z) /\
   ((j <= i)%Z /\ (i <= N)%Z) /\
   match_ a (i - j) p 0 j /\
   (forall k:Z, (0 <= k)%Z /\ (k < i - j)%Z -> ~ match_ a k p 0 M).
Proof.
intuition.
generalize M_positive; Omega'.
generalize N_positive; Omega'.
subst i j.
apply match_empty.
generalize N_positive; Omega'.
 generalize M_positive; Omega'.
Qed.

(* Why obligation from file , characters 2736-2740 *)
Lemma kmp_po_13 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (i1 j1:Z)
   (Inv:(((0 <= j1)%Z /\ (j1 <= M)%Z) /\
         ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
         match_ a (i1 - j1) p 0 j1 /\
         (forall k:Z,
            (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M)) /\
        ((j1 >= M)%Z \/ (j1 < M)%Z /\ (i1 >= N)%Z)) (Test10:j1 = M),
   first_occur p a (i1 - M).
Proof.
intros.
decompose [and] Inv.
unfold first_occur.
 split.
 intro.
 rewrite <- Test10.
  replace (array_length p) with j1.
 assumption.
 Omega'.
replace (i1 - M)%Z with (i1 - j1)%Z.
 replace (array_length p) with M.
 assumption.
 Omega'.
Omega'.
Qed.

(* Why obligation from file , characters 2746-2748 *)
Lemma kmp_po_14 :
 forall (a:array A) (next:array Z) (p:array A)
   (Pre15:array_length p = M /\
          array_length next = M /\ array_length a = N) (i:Z)
   (Post8:i = 0%Z) (j:Z) (Post7:j = 0%Z)
   (Pre14:array_length p = M /\ array_length next = M) (next0:array Z)
   (Post15:array_length next0 = M /\
           (forall j:Z,
              (0 < j)%Z /\ (j < M)%Z -> Next p j (access next0 j)))
   (i1 j1:Z)
   (Inv:(((0 <= j1)%Z /\ (j1 <= M)%Z) /\
         ((j1 <= i1)%Z /\ (i1 <= N)%Z) /\
         match_ a (i1 - j1) p 0 j1 /\
         (forall k:Z,
            (0 <= k)%Z /\ (k < i1 - j1)%Z -> ~ match_ a k p 0 M)) /\
        ((j1 >= M)%Z \/ (j1 < M)%Z /\ (i1 >= N)%Z)) (Test9:j1 <> M),
   first_occur p a i1.
Proof.
intros.
 unfold first_occur.
 decompose [and] Inv.
split.
 intro.
 absurd (i1 < N)%Z; Omega'.
intros k Hk.
 elim (Z_lt_ge_dec k (i1 - j1)); intro Hk'.
replace (array_length p) with M.
apply H6; Omega'.
 Omega'.
red; intro.
 decompose [match_] H4.
absurd (k <= N - M)%Z; Omega'.
Qed.


