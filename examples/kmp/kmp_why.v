(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Sumbool.

Require Export Match.
Require Export Next.
Require ZArithRing.
Require Omega.
Require Export Lex.

Tactic Definition Omega' := Abstract Omega.

Parameter A : Set.
Axiom A_eq_dec : (x,y:A) { x=y }+{ ~x=y }.
Definition A_eq_bool := [x,y:A](bool_of_sumbool (A_eq_dec x y)).

(*Why*) Parameter M : Z.
Axiom M_positive : `0 <= M`.

(* Why obligation from file "kmp.mlw", characters 1205-1217 *)
Lemma initnext_po_1 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  `0 <= 1` /\ `1 < (array_length next)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1225-1755 *)
Lemma initnext_po_2 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

(* Why obligation from file "kmp.mlw", characters 1578-1583 *)
Lemma initnext_po_3 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  `0 <= i1` /\ `i1 < (array_length p)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1584-1589 *)
Lemma initnext_po_4 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  `0 <= j1` /\ `j1 < (array_length p)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1634-1648 *)
Lemma initnext_po_5 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test6: (access p i1) = (access p j1))
  (i2: Z)
  (Post2: i2 = `i1 + 1`)
  (j2: Z)
  (Post3: j2 = `j1 + 1`)
  `0 <= i2` /\ `i2 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1596-1660 *)
Lemma initnext_po_6 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test6: (access p i1) = (access p j1))
  (i2: Z)
  (Post2: i2 = `i1 + 1`)
  (j2: Z)
  (Post3: j2 = `j1 + 1`)
  (Pre10: `0 <= i2` /\ `i2 < (array_length next1)`)
  (next2: (array Z))
  (Post4: next2 = (store next1 i2 j2))
  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 < i2` /\ `i2 <= M`) /\
  (match p `i2 - j2` p `0` j2) /\
  ((z:Z) (`j2 + 1 < z` /\ `z < i2 + 1` -> ~(match p `i2 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i2` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i2` j2) (pairZ `M - i1` j1)).
Proof.
Intuition.
Subst i2 j2.
Apply match_right_extension.
Replace `i1+1-(j1+1)` with `i1-j1`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i1+1-(j1+1)+j1`. Ring `0+j1`. Assumption.
  Absurd (match p `i1+1-(z-1)` p `0` `z-1`).
  Red; Apply H11; Omega'.
  Apply match_right_weakening with n := z.
  Replace `i1+1-(z-1)` with `i1+1+1-z`.
  Subst i2; Assumption. Omega'. Omega'.
  Elim (Z_lt_ge_dec k `i1+1`); Intro Hk'.  
  Subst next2; Rewrite store_def_2.
  Apply H13; Omega'. Omega'. Omega'. Omega'.
  Cut `i1+1 = k`. Intro Heq.	
  Subst next2 i2; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Subst j2; Replace `i1+1-(j1+1)` with `i1-j1`.
  Apply match_right_extension; Omega' Orelse Try Assumption.
  Ring `i1-j1+j1`; Ring `0+j1`; Assumption. Omega'.
  Intros z Hz. 
  Red; Apply H11; Omega'.
  Omega'. Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ; Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1708-1721 *)
Lemma initnext_po_7 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test5: ~(access p i1) = (access p j1))
  (Test4: `j1 = 0`)
  (i2: Z)
  (Post5: i2 = `i1 + 1`)
  `0 <= i2` /\ `i2 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1691-1725 *)
Lemma initnext_po_8 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test5: ~(access p i1) = (access p j1))
  (Test4: `j1 = 0`)
  (i2: Z)
  (Post5: i2 = `i1 + 1`)
  (Pre9: `0 <= i2` /\ `i2 < (array_length next1)`)
  (next2: (array Z))
  (Post6: next2 = (store next1 i2 `0`))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i2` /\ `i2 <= M`) /\
  (match p `i2 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i2 + 1` -> ~(match p `i2 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i2` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i2` j1) (pairZ `M - i1` j1)).
Proof.
Intuition.
  Rewrite Test4.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_lt_ge_dec `j1+2` z); Intro.
  Absurd (match p `i1+1-(z-1)` p `0` `z-1`).
  Red; Apply H11; Omega'.
  Apply match_right_weakening with n := z.
  Subst i2.
  Replace `i1+1-(z-1)` with `i1+1+1-z`; [ Assumption | Omega' ]. Omega'.
  Absurd (#p[i1])=(#p[j1]); [ Assumption | Idtac ].
  Decompose [match] H18.
  Replace i1 with `i1+1+1-2+j1`; [ Idtac | Omega' ].
  Replace #p[j1] with #p[`0+j1`]; [ Idtac | Ring `0+j1`; Reflexivity ].
  Cut `z = 2`; [ Intro Heq | Omega' ].
  Rewrite <- Heq. Rewrite <- Post5; Apply H22; Omega'.
  Elim (Z_lt_ge_dec k `i1+1`); Intro.
  Subst next2. AccessOther.
  Apply H13; Omega'. 
  Cut `i1+1 = k`; [ Intro Heq | Omega' ].
  Rewrite Post6; Rewrite Post5; Rewrite Heq. AccessSame.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Apply match_empty; Omega'.
  Intros z Hz.
  Elim (Z_lt_ge_dec `1` z); Intro.
  (* 1 < z  *)
  Red; Apply H11; Omega'.
  (* z = 1 *)
  Red; Intro.
  Absurd (#p[i1])=(#p[j1]); [ Assumption | Rewrite Test4 ].
  Decompose [match] H17.
  Replace `0` with `0+0`; [ Idtac | Omega' ].
  Replace `i1` with `i1+1-z+0`; [ Idtac | Omega' ].
  Apply H22; Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1736-1744 *)
Lemma initnext_po_9 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test5: ~(access p i1) = (access p j1))
  (Test3: `j1 <> 0`)
  `0 <= j1` /\ `j1 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1731-1744 *)
Lemma initnext_po_10 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (Pre11: `0 <= i1` /\ `i1 < (array_length p)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test5: ~(access p i1) = (access p j1))
  (Test3: `j1 <> 0`)
  (Pre8: `0 <= j1` /\ `j1 < (array_length next1)`)
  (j2: Z)
  (Post7: j2 = (access next1 j1))
  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j2` p `0` j2) /\
  ((z:Z) (`j2 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
  `(array_length next1) = M`) /\
  (lexZ (pairZ `M - i1` j2) (pairZ `M - i1` j1)).
Proof.
Intuition (Cut ~`j1=0`; [ Clear Test3; Intro Test3 | Assumption ]).
  Subst j2.
  Elim (H15 j1); Omega'.
  Elim (H15 j1); Omega'.
  Elim (H15 j1); Omega'.
  Subst j2.
  Apply match_trans with t2 := p i2 := `j1-(access   next1 j1)`.
  Apply match_left_weakening with n := j1.
  Replace `i1-(access   next1 j1)-(j1-(access   next1 j1))` 
    with `i1-j1` ; [ Idtac | Omega' ].
  Replace `j1-(access   next1 j1)-(j1-(access   next1 j1))` 
    with `0` ; [ Assumption | Omega' ].
  Elim (H15 j1); Omega'. Elim (H15 j1); Auto; Omega'.

  Elim (Z_lt_ge_dec `j1+1` z); Intro.
  (* j0+1 < z < i0+1 *)
  Apply (H13 z); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec z `j1+1`); Intro.
  (* z = j0+1 *)
  Absurd (#p[i1])=(#p[j1]) ; [ Assumption | Idtac ].
  Decompose [match] H18.
  Replace i1 with `i1+1-z+j1`; [ Idtac | Omega' ].
  Replace j1 with `0+j1`; [ Idtac | Omega' ].
  Apply H22; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  Absurd (match p `j1-(z-1)` p `0` `z-1`).
  Decompose [match] H18.
  Elim (H15 j1); Omega' Orelse Intros.
  Apply H25; Omega'.
  Apply match_trans with t2 := p i2 := `i1-(z-1)`.
  Apply match_sym.
  Apply match_left_weakening with n := j1.
  Replace `i1-(z-1)-(j1-(z-1))` with `i1-j1` ; [ Idtac | Omega' ].
  Ring `j1-(z-1)-(j1-(z-1))`. Assumption.
  Omega'.
  Apply match_right_weakening with n := z.
  Replace `i1-(z-1)` with `i1+1-z` ; [ Assumption | Omega' ].
  Omega'.
Unfold lexZ lex Zwf pairZ. 
Elim (H15 j1) ; [ Intros | Omega' ].
Right. Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1225-1755 *)
Lemma initnext_po_11 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Pre13: Variant1 = (pairZ `M - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i1 < M - 1`)
  (i2: Z)
  (j2: Z)
  (next2: (array Z))
  (Inv0: ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 < i2` /\ `i2 <= M`) /\
         (match p `i2 - j2` p `0` j2) /\
         ((z:Z)
          (`j2 + 1 < z` /\ `z < i2 + 1` -> ~(match p `i2 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i2` -> (Next p k (access next2 k)))) /\
         `(array_length next2) = M`) /\
         (lexZ (pairZ `M - i2` j2) (pairZ `M - i1` j1)))
  (lexZ (pairZ `M - i2` j2) Variant1).
Proof.
Intuition.
Rewrite Pre13; Assumption.
Save.

(* Why obligation from file "kmp.mlw", characters 1263-1512 *)
Lemma initnext_po_12 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (`0 <= j` /\ `j <= M`) /\ (`j < i` /\ `i <= M`) /\
  (match p `i - j` p `0` j) /\
  ((z:Z) (`j + 1 < z` /\ `z < i + 1` -> ~(match p `i + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i` -> (Next p k (access next0 k)))) /\
  `(array_length next0) = M`.
Proof.
Intuition.
Subst i j .
Apply match_empty ; Omega'.
Replace k with `1` ; [ Subst next0; Rewrite store_def_1 | Omega' ].
Apply next_1_0; Omega'.
Omega'.
ArraySubst next0.
Save.

(* Why obligation from file "kmp.mlw", characters 1193-1763 *)
Lemma initnext_po_13 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test8: `1 < M`)
  (Pre14: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (i1: Z)
  (j1: Z)
  (next1: (array Z))
  (Inv: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
        (match p `i1 - j1` p `0` j1) /\
        ((z:Z)
         (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`) /\ `i1 >= M - 1`)
  `(array_length next1) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))).
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1179-1763 *)
Lemma initnext_po_14 : 
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M`)
  (i: Z)
  (Post9: i = `1`)
  (j: Z)
  (Post8: j = `0`)
  (Test1: `1 >= M`)
  `(array_length next) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))).
Proof.
Intuition.
Absurd `0 < j`; Omega'.
Save.


(*Why*) Parameter N : Z.
Axiom N_positive : `0 <= N`.


(* Why obligation from file "kmp.mlw", characters 2317-2332 *)
Lemma kmp_po_1 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  `(array_length p) = M` /\ `(array_length next) = M`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 2338-2714 *)
Lemma kmp_po_2 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

(* Why obligation from file "kmp.mlw", characters 2354-2360 *)
Lemma kmp_po_3 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test2: `j1 < M`)
  (result1: bool)
  (Bool4: (if result1 then `i1 < N` else `i1 >= N`))
  (if result1 then `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false
   else `j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false).
Proof.
Intuition Induction result1; Tauto.
Save.

(* Why obligation from file "kmp.mlw", characters 2344-2360 *)
Lemma kmp_po_4 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test1: `j1 >= M`)
  (result1: bool)
  (Post5: result1 = false)
  (if result1 then `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false
   else `j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false).
Proof.
Intuition Induction result1; Tauto.
Save.

(* Why obligation from file "kmp.mlw", characters 2586-2591 *)
Lemma kmp_po_5 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  `0 <= i1` /\ `i1 < (array_length a)`.
Proof.
Intuition.
Discriminate H14.
Save.

(* Why obligation from file "kmp.mlw", characters 2592-2597 *)
Lemma kmp_po_6 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (Pre11: `0 <= i1` /\ `i1 < (array_length a)`)
  `0 <= j1` /\ `j1 < (array_length p)`.
Proof.
Intuition.
Discriminate H16.
Save.

(* Why obligation from file "kmp.mlw", characters 2604-2648 *)
Lemma kmp_po_7 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (Pre11: `0 <= i1` /\ `i1 < (array_length a)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test7: (access a i1) = (access p j1))
  (i2: Z)
  (Post1: i2 = `i1 + 1`)
  (j2: Z)
  (Post2: j2 = `j1 + 1`)
  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
  (match a `i2 - j2` p `0` j2) /\
  ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i2` j2) (pairZ `N - i1` j1)).
Proof.
Intuition Discriminate H18 Orelse Auto with *.
Subst j2 i2.
  Apply match_right_extension.
  Replace `i1+1-(j1+1)` with `i1-j1`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i1+1-(j1+1)+j1`. Ring `0+j1`. Assumption.
  Replace `i1+1-(j1+1)` with `i1-j1`. 
  Apply (H16 k); Assumption Orelse Omega'.
  Omega'.
  Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2677-2686 *)
Lemma kmp_po_8 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (Pre11: `0 <= i1` /\ `i1 < (array_length a)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test6: ~(access a i1) = (access p j1))
  (Test5: `j1 = 0`)
  (i2: Z)
  (Post3: i2 = `i1 + 1`)
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i2` /\ `i2 <= N`) /\
  (match a `i2 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i2 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i2` j1) (pairZ `N - i1` j1)).
Proof.
Intuition Discriminate H18 Orelse Auto with *.
  Subst j1.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_le_lt_eq_dec k `i1-j1`).
  Intro. Apply (H16 k); Assumption Orelse Omega'.
  Intro. Generalize H19. Apply match_contradiction_at_first. Omega'.
  Rewrite b. Subst j1. Ring `i1-0`. Assumption.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2697-2705 *)
Lemma kmp_po_9 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (Pre11: `0 <= i1` /\ `i1 < (array_length a)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test6: ~(access a i1) = (access p j1))
  (Test4: `j1 <> 0`)
  `0 <= j1` /\ `j1 < (array_length next0)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 2692-2705 *)
Lemma kmp_po_10 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (Pre11: `0 <= i1` /\ `i1 < (array_length a)`)
  (Pre12: `0 <= j1` /\ `j1 < (array_length p)`)
  (Test6: ~(access a i1) = (access p j1))
  (Test4: `j1 <> 0`)
  (Pre10: `0 <= j1` /\ `j1 < (array_length next0)`)
  (j2: Z)
  (Post4: j2 = (access next0 j1))
  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j2` p `0` j2) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j2` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j2) (pairZ `N - i1` j1)).
Proof.
Intuition (Assert `j1<>0`; Auto with *).
  (* invariant *)
  Elim (H5 j1); Intros. Omega'.
  Omega'.
  Elim (H5 j1); Intros; Omega'.
  Elim (H5 j1); Intros; Omega'.
  Apply next_iteration with j := j1.
  Omega'.
  Omega'.
  Assumption.
  Subst j2; Apply (H5 j1); Omega'.
  (* ~(match a k p `0` M) *)
  Elim (Z_lt_ge_dec k `i1-j1`); Intro Hck.
  (* k < i0-j0 *)
  Apply (H18 k); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec `i1-j1` k); Intro Hck'.
  (* k = i0-j0 *)
  Generalize H21. Replace k with `i1-j1`.
  Apply match_contradiction_at_i with i := j1.
  Omega'. Omega'. Ring `i1-j1+j1`. Ring `0+j1`. Assumption. Omega'. 
  (* i0-j0 < k *)
  Generalize H21. Rewrite <- H.
  Apply next_is_maximal with i := i1 j := j1 n := #next0[j1]. 
  Omega'. Omega'. Omega'.
  Assumption.
  Apply (H5 j1); Omega'.
  Unfold lexZ lex Zwf pairZ. 
  Elim (H5 j1). Intros.
  Right. Omega'. Omega'.
Discriminate H20.
Discriminate H20.
Save.

(* Why obligation from file "kmp.mlw", characters 2338-2714 *)
Lemma kmp_po_11 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i1: Z)
  (j1: Z)
  (Pre13: Variant1 = (pairZ `N - i1` j1))
  (Inv: (`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M))))
  (Test8: `j1 < M` /\ `i1 < N` \/ `j1 >= M` /\ true = false)
  (i2: Z)
  (j2: Z)
  (Inv0: ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
         (match a `i2 - j2` p `0` j2) /\
         ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
         (lexZ (pairZ `N - i2` j2) (pairZ `N - i1` j1)))
  (lexZ (pairZ `N - i2` j2) Variant1).
Proof.
Intuition; Rewrite Pre13; Assumption.
Save.

Definition first_occur :=
  [p:(array A)][a:(array A)][r:Z]  
     (`0 <= r < (array_length a)` -> 
        (match a r p `0` (array_length p)))
  /\ ((k:Z) `0 <= k < r` -> ~(match a k p `0` (array_length p))).

(* Why obligation from file "kmp.mlw", characters 2382-2524 *)
Lemma kmp_po_12 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (`0 <= j` /\ `j <= M`) /\ (`j <= i` /\ `i <= N`) /\
  (match a `i - j` p `0` j) /\
  ((k:Z) (`0 <= k` /\ `k < i - j` -> ~(match a k p `0` M))).
Proof.
Intuition.
Generalize M_positive; Omega'.
Generalize N_positive; Omega'.
Subst i j .
Apply match_empty.
Generalize N_positive; Omega'. Generalize M_positive; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2736-2740 *)
Lemma kmp_po_13 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i1: Z)
  (j1: Z)
  (Inv: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
        (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false))
  (Test10: `j1 = M`)
  (first_occur p a `i1 - M`).
Proof.
Intros.
Decompose [and] Inv.
Unfold first_occur. 
Split. 
Intro. Rewrite <- Test10.  
Replace (array_length p) with j1. Assumption. Omega'.
Replace `i1-M` with `i1-j1`. 
Replace (array_length p) with M. Assumption. Omega'.
Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2746-2748 *)
Lemma kmp_po_14 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre15: `(array_length p) = M` /\ `(array_length next) = M` /\
          `(array_length a) = N`)
  (i: Z)
  (Post8: i = `0`)
  (j: Z)
  (Post7: j = `0`)
  (Pre14: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i1: Z)
  (j1: Z)
  (Inv: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
        (match a `i1 - j1` p `0` j1) /\
        ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
        (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false))
  (Test9: `j1 <> M`)
  (first_occur p a i1).
Proof.
Intros. Unfold first_occur. Decompose [and] Inv.
Split. 
Intro. Absurd `i1 < N`; Omega'.
Intros k Hk. 
Elim (Z_lt_ge_dec k `i1-j1`); Intro Hk'.
Replace (array_length p) with M.
Apply H6; Omega'. Omega'.
Red; Intro. Decompose [match] H4.
Absurd `k <= N-M`; Omega'.
Save.


