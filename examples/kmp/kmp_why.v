(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Sumbool.

Require Export Match.
Require Export Next.
Require ZArithRing.
Require Omega.
Require Export Lex.

Tactic Definition Omega' := Abstract Omega.

Parameter A : Set.
Axiom A_eq_dec : (x,y:A) { x=y }+{ ~x=y }.
Definition A_eq_bool := [x,y:A](bool_of_sumbool (A_eq_dec x y)).

(*Why*) Parameter M : Z.
Axiom M_positive : `0 <= M`.

(* Why obligation from file "kmp.mlw", characters 1205-1217 *)
Lemma initnext_po_1 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  `0 <= 1` /\ `1 < (array_length next)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1225-1755 *)
Lemma initnext_po_2 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

(* Why obligation from file "kmp.mlw", characters 1584-1589 *)
Lemma initnext_po_3 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  `0 <= j0` /\ `j0 < (array_length p)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1578-1583 *)
Lemma initnext_po_4 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Pre3: `0 <= j0` /\ `j0 < (array_length p)`)
  `0 <= i0` /\ `i0 < (array_length p)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1634-1648 *)
Lemma initnext_po_5 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post2: i1 = `i0 + 1`)
  (j1: Z)
  (Post3: j1 = `j0 + 1`)
  `0 <= i1` /\ `i1 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1596-1660 *)
Lemma initnext_po_6 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post2: i1 = `i0 + 1`)
  (j1: Z)
  (Post3: j1 = `j0 + 1`)
  (Pre6: `0 <= i1` /\ `i1 < (array_length next1)`)
  (next2: (array Z))
  (Post4: next2 = (store next1 i1 j1))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)).
Proof.
Intuition.
Subst i1 j1.
Apply match_right_extension.
Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H7; Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0+1-(z-1)` with `i0+1+1-z`.
  Subst i1; Assumption. Omega'. Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro Hk'.  
  Subst next2; Rewrite store_def_2.
  Apply H9; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`. Intro Heq.	
  Subst next2 i1; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Subst j1; Replace `i0+1-(j0+1)` with `i0-j0`.
  Apply match_right_extension; Omega' Orelse Try Assumption.
  Ring `i0-j0+j0`; Ring `0+j0`; Assumption. Omega'.
  Intros z Hz. 
  Red; Apply H7; Omega'.
  Omega'. Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ; Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1708-1721 *)
Lemma initnext_po_7 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  `0 <= i1` /\ `i1 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1691-1725 *)
Lemma initnext_po_8 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (Pre5: `0 <= i1` /\ `i1 < (array_length next1)`)
  (next2: (array Z))
  (Post6: next2 = (store next1 i1 `0`))
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j0` p `0` j0) /\
  ((z:Z) (`j0 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i1` j0) (pairZ `M - i0` j0)).
Proof.
Intuition.
  Rewrite Test4.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_lt_ge_dec `j0+2` z); Intro.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H7; Omega'.
  Apply match_right_weakening with n := z.
  Subst i1.
  Replace `i0+1-(z-1)` with `i0+1+1-z`; [ Assumption | Omega' ]. Omega'.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Idtac ].
  Decompose [match] H14.
  Replace i0 with `i0+1+1-2+j0`; [ Idtac | Omega' ].
  Replace #p[j0] with #p[`0+j0`]; [ Idtac | Ring `0+j0`; Reflexivity ].
  Cut `z = 2`; [ Intro Heq | Omega' ].
  Rewrite <- Heq. Rewrite <- Post5; Apply H18; Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro.
  Subst next2. AccessOther.
  Apply H9; Omega'. 
  Cut `i0+1 = k`; [ Intro Heq | Omega' ].
  Rewrite Post6; Rewrite Post5; Rewrite Heq. AccessSame.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Apply match_empty; Omega'.
  Intros z Hz.
  Elim (Z_lt_ge_dec `1` z); Intro.
  (* 1 < z  *)
  Red; Apply H7; Omega'.
  (* z = 1 *)
  Red; Intro.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Rewrite Test4 ].
  Decompose [match] H13.
  Replace `0` with `0+0`; [ Idtac | Omega' ].
  Replace `i0` with `i0+1-z+0`; [ Idtac | Omega' ].
  Apply H18; Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1736-1744 *)
Lemma initnext_po_9 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  `0 <= j0` /\ `j0 < (array_length next1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1731-1744 *)
Lemma initnext_po_10 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  (Pre4: `0 <= j0` /\ `j0 < (array_length next1)`)
  (j1: Z)
  (Post7: j1 = (access next1 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i0` /\ `i0 <= M`) /\
  (match p `i0 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
  `(array_length next1) = M`) /\
  (lexZ (pairZ `M - i0` j1) (pairZ `M - i0` j0)).
Proof.
Intuition (Cut ~`j0=0`; [ Clear Test3; Intro Test3 | Assumption ]).
  Subst j1.
  Elim (H11 j0); Omega'.
  Elim (H11 j0); Omega'.
  Elim (H11 j0); Omega'.
  Subst j1.
  Apply match_trans with t2 := p i2 := `j0-(access   next1 j0)`.
  Apply match_left_weakening with n := j0.
  Replace `i0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `i0-j0` ; [ Idtac | Omega' ].
  Replace `j0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `0` ; [ Assumption | Omega' ].
  Elim (H11 j0); Omega'. Elim (H11 j0); Auto; Omega'.

  Elim (Z_lt_ge_dec `j0+1` z); Intro.
  (* j0+1 < z < i0+1 *)
  Apply (H9 z); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec z `j0+1`); Intro.
  (* z = j0+1 *)
  Absurd (#p[i0])=(#p[j0]) ; [ Assumption | Idtac ].
  Decompose [match] H14.
  Replace i0 with `i0+1-z+j0`; [ Idtac | Omega' ].
  Replace j0 with `0+j0`; [ Idtac | Omega' ].
  Apply H18; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  Absurd (match p `j0-(z-1)` p `0` `z-1`).
  Decompose [match] H14.
  Elim (H11 j0); Omega' Orelse Intros.
  Apply H21; Omega'.
  Apply match_trans with t2 := p i2 := `i0-(z-1)`.
  Apply match_sym.
  Apply match_left_weakening with n := j0.
  Replace `i0-(z-1)-(j0-(z-1))` with `i0-j0` ; [ Idtac | Omega' ].
  Ring `j0-(z-1)-(j0-(z-1))`. Assumption.
  Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0-(z-1)` with `i0+1-z` ; [ Assumption | Omega' ].
  Omega'.
Unfold lexZ lex Zwf pairZ. 
Elim (H11 j0) ; [ Intros | Omega' ].
Right. Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 1225-1755 *)
Lemma initnext_po_11 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (i1: Z)
  (j1: Z)
  (next2: (array Z))
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
         (match p `i1 - j1` p `0` j1) /\
         ((z:Z)
          (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
         `(array_length next2) = M`) /\
         (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)))
  (lexZ (pairZ `M - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre7; Assumption.
Save.

(* Why obligation from file "kmp.mlw", characters 1263-1512 *)
Lemma initnext_po_12 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 < result` /\
  `result <= M`) /\ (match p `result - result0` p `0` result0) /\
  ((z:Z)
   (`result0 + 1 < z` /\ `z < result + 1` ->
    ~(match p `result + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= result` -> (Next p k (access next0 k)))) /\
  `(array_length next0) = M`.
Proof.
Intuition.
Subst result result0.
Apply match_empty ; Omega'.
Replace k with `1` ; [ Subst next0; Rewrite store_def_1 | Omega' ].
Apply next_1_0; Omega'.
Omega'.
ArraySubst next0.
Save.

(* Why obligation from file "kmp.mlw", characters 1193-1763 *)
Lemma initnext_po_13 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`) /\ `i0 >= M - 1`)
  `(array_length next1) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))).
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 1179-1763 *)
Lemma initnext_po_14 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test1: `1 >= M`)
  `(array_length next) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))).
Proof.
Intuition.
Absurd `0 < j`; Omega'.
Save.


(*Why*) Parameter N : Z.
Axiom N_positive : `0 <= N`.


(* Why obligation from file "kmp.mlw", characters 2317-2332 *)
Lemma kmp_po_1 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  `(array_length p) = M` /\ `(array_length next) = M`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 2338-2714 *)
Lemma kmp_po_2 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

(* Why obligation from file "kmp.mlw", characters 2354-2360 *)
Lemma kmp_po_3 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test2: `j0 < M`)
  (result3: bool)
  (Bool4: (if result3 then `i0 < N` else `i0 >= N`))
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

(* Why obligation from file "kmp.mlw", characters 2344-2360 *)
Lemma kmp_po_4 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test1: `j0 >= M`)
  (result3: bool)
  (Post5: result3 = false)
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

(* Why obligation from file "kmp.mlw", characters 2592-2597 *)
Lemma kmp_po_5 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  `0 <= j0` /\ `j0 < (array_length p)`.
Proof.
Intuition.
Discriminate H14.
Save.

(* Why obligation from file "kmp.mlw", characters 2586-2591 *)
Lemma kmp_po_6 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Pre5: `0 <= j0` /\ `j0 < (array_length p)`)
  `0 <= i0` /\ `i0 < (array_length a)`.
Proof.
Intuition.
Save.

(* Why obligation from file "kmp.mlw", characters 2604-2648 *)
Lemma kmp_po_7 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test7: (access a i0) = (access p j0))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (j1: Z)
  (Post2: j1 = `j0 + 1`)
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H14 Orelse Auto with *.
Subst j1 i1.
  Apply match_right_extension.
  Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Replace `i0+1-(j0+1)` with `i0-j0`. 
  Apply (H12 k); Assumption Orelse Omega'.
  Omega'.
  Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2677-2686 *)
Lemma kmp_po_8 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test5: `j0 = 0`)
  (i1: Z)
  (Post3: i1 = `i0 + 1`)
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j0` p `0` j0) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j0` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j0) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H14 Orelse Auto with *.
  Subst j0.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_le_lt_eq_dec k `i0-j0`).
  Intro. Apply (H12 k); Assumption Orelse Omega'.
  Intro. Generalize H15. Apply match_contradiction_at_first. Omega'.
  Rewrite b. Subst j0. Ring `i0-0`. Assumption.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2697-2705 *)
Lemma kmp_po_9 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  `0 <= j0` /\ `j0 < (array_length next0)`.
Proof.
Intuition.
Discriminate H14.
Save.

(* Why obligation from file "kmp.mlw", characters 2692-2705 *)
Lemma kmp_po_10 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  (Pre6: `0 <= j0` /\ `j0 < (array_length next0)`)
  (j1: Z)
  (Post4: j1 = (access next0 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i0` /\ `i0 <= N`) /\
  (match a `i0 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i0 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i0` j1) (pairZ `N - i0` j0)).
Proof.
Intuition (Assert `j0<>0`; Auto with *).
  (* invariant *)
  Elim (H5 j0); Intros. Omega'.
  Omega'.
  Elim (H5 j0); Intros; Omega'.
  Elim (H5 j0); Intros; Omega'.
  Apply next_iteration with j := j0.
  Omega'.
  Omega'.
  Assumption.
  Subst j1; Apply (H5 j0); Omega'.
  (* ~(match a k p `0` M) *)
  Elim (Z_lt_ge_dec k `i0-j0`); Intro Hck.
  (* k < i0-j0 *)
  Apply (H14 k); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec `i0-j0` k); Intro Hck'.
  (* k = i0-j0 *)
  Generalize H17. Replace k with `i0-j0`.
  Apply match_contradiction_at_i with i := j0.
  Omega'. Omega'. Ring `i0-j0+j0`. Ring `0+j0`. Assumption. Omega'. 
  (* i0-j0 < k *)
  Generalize H17. Rewrite <- H.
  Apply next_is_maximal with i := i0 j := j0 n := #next0[j0]. 
  Omega'. Omega'. Omega'.
  Assumption.
  Apply (H5 j0); Omega'.
  Unfold lexZ lex Zwf pairZ. 
  Elim (H5 j0). Intros.
  Right. Omega'. Omega'.
Discriminate H16.
Discriminate H16.
Save.

(* Why obligation from file "kmp.mlw", characters 2338-2714 *)
Lemma kmp_po_11 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (i1: Z)
  (j1: Z)
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
         (match a `i1 - j1` p `0` j1) /\
         ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
         (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)))
  (lexZ (pairZ `N - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre7; Assumption.
Rewrite Pre7; Assumption.
Save.

Definition first_occur :=
  [p:(array A)][a:(array A)][r:Z]  
     (`0 <= r < (array_length a)` -> 
        (match a r p `0` (array_length p)))
  /\ ((k:Z) `0 <= k < r` -> ~(match a k p `0` (array_length p))).

(* Why obligation from file "kmp.mlw", characters 2382-2524 *)
Lemma kmp_po_12 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 <= result` /\
  `result <= N`) /\ (match a `result - result0` p `0` result0) /\
  ((k:Z) (`0 <= k` /\ `k < result - result0` -> ~(match a k p `0` M))).
Proof.
Intuition.
Generalize M_positive; Omega'.
Generalize N_positive; Omega'.
Subst result result0.
Apply match_empty.
Generalize N_positive; Omega'. Generalize M_positive; Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2736-2740 *)
Lemma kmp_po_13 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test10: `j0 = M`)
  (first_occur p a `i0 - M`).
Proof.
Intros.
Decompose [and] Inv.
Unfold first_occur. 
Split. 
Intro. Rewrite <- Test10.  
Replace (array_length p) with j0. Assumption. Omega'.
Replace `i0-M` with `i0-j0`. 
Replace (array_length p) with M. Assumption. Omega'.
Omega'.
Save.

(* Why obligation from file "kmp.mlw", characters 2746-2748 *)
Lemma kmp_po_14 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test9: `j0 <> M`)
  (first_occur p a i0).
Proof.
Intros. Unfold first_occur. Decompose [and] Inv.
Split. 
Intro. Absurd `i0 < N`; Omega'.
Intros k Hk. 
Elim (Z_lt_ge_dec k `i0-j0`); Intro Hk'.
Replace (array_length p) with M.
Apply H6; Omega'. Omega'.
Red; Intro. Decompose [match] H4.
Absurd `k <= N-M`; Omega'.
Save.


