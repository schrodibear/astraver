(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Sumbool.

Require Match.
Require Next.
Require ZArithRing.
Require Omega.
Require Lex.

Tactic Definition Omega' := Abstract Omega.

Parameter A : Set.
Axiom A_eq_dec : (x,y:A) { x=y }+{ ~x=y }.
Definition A_eq_bool := [x,y:A](bool_of_sumbool (A_eq_dec x y)).

(*Why*) Parameter M : Z.
Axiom M_positive : `0 <= M`.

Lemma initnext_po_1 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  `0 <= 1` /\ `1 < (array_length next)`.
Proof.
Intuition.
Save.

Lemma initnext_po_2 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma initnext_po_3 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  `0 <= j0` /\ `j0 < (array_length p)`.
Proof.
Intuition.
Save.

Lemma initnext_po_4 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Pre3: `0 <= j0` /\ `j0 < (array_length p)`)
  `0 <= i0` /\ `i0 < (array_length p)`.
Proof.
Intuition.
Save.

Lemma initnext_po_5 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post2: i1 = `i0 + 1`)
  (j1: Z)
  (Post3: j1 = `j0 + 1`)
  `0 <= i1` /\ `i1 < (array_length next1)`.
Proof.
Intuition.
Save.

Lemma initnext_po_6 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post2: i1 = `i0 + 1`)
  (j1: Z)
  (Post3: j1 = `j0 + 1`)
  (Pre6: `0 <= i1` /\ `i1 < (array_length next1)`)
  (next2: (array Z))
  (Post4: next2 = (store next1 i1 j1))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)).
Proof.
Intuition.
Subst i1 j1.
Apply match_right_extension.
Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H7; Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0+1-(z-1)` with `i0+1+1-z`.
  Subst i1; Assumption. Omega'. Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro Hk'.  
  Subst next2; Rewrite store_def_2.
  Apply H9; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`. Intro Heq.	
  Subst next2 i1; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Subst j1; Replace `i0+1-(j0+1)` with `i0-j0`.
  Apply match_right_extension; Omega' Orelse Try Assumption.
  Ring `i0-j0+j0`; Ring `0+j0`; Assumption. Omega'.
  Intros z Hz. 
  Red; Apply H7; Omega'.
  Omega'. Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ; Left; Omega'.
Save.

Lemma initnext_po_7 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  `0 <= i1` /\ `i1 < (array_length next1)`.
Proof.
Intuition.
Save.

Lemma initnext_po_8 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (Pre5: `0 <= i1` /\ `i1 < (array_length next1)`)
  (next2: (array Z))
  (Post6: next2 = (store next1 i1 `0`))
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j0` p `0` j0) /\
  ((z:Z) (`j0 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
  `(array_length next2) = M`) /\
  (lexZ (pairZ `M - i1` j0) (pairZ `M - i0` j0)).
Proof.
Intuition.
  Rewrite Test4.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_lt_ge_dec `j0+2` z); Intro.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H7; Omega'.
  Apply match_right_weakening with n := z.
  Subst i1.
  Replace `i0+1-(z-1)` with `i0+1+1-z`; [ Assumption | Omega' ]. Omega'.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Idtac ].
  Decompose [match] H14.
  Replace i0 with `i0+1+1-2+j0`; [ Idtac | Omega' ].
  Replace #p[j0] with #p[`0+j0`]; [ Idtac | Ring `0+j0`; Reflexivity ].
  Cut `z = 2`; [ Intro Heq | Omega' ].
  Rewrite <- Heq. Rewrite <- Post5; Apply H18; Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro.
  Subst next2. AccessOther.
  Apply H9; Omega'. 
  Cut `i0+1 = k`; [ Intro Heq | Omega' ].
  Rewrite Post6; Rewrite Post5; Rewrite Heq. AccessSame.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Apply match_empty; Omega'.
  Intros z Hz.
  Elim (Z_lt_ge_dec `1` z); Intro.
  (* 1 < z  *)
  Red; Apply H7; Omega'.
  (* z = 1 *)
  Red; Intro.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Rewrite Test4 ].
  Decompose [match] H13.
  Replace `0` with `0+0`; [ Idtac | Omega' ].
  Replace `i0` with `i0+1-z+0`; [ Idtac | Omega' ].
  Apply H18; Omega'.
  ArraySubst next2.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma initnext_po_9 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  `0 <= j0` /\ `j0 < (array_length next1)`.
Proof.
Intuition.
Save.

Lemma initnext_po_10 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  (Pre4: `0 <= j0` /\ `j0 < (array_length next1)`)
  (j1: Z)
  (Post7: j1 = (access next1 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i0` /\ `i0 <= M`) /\
  (match p `i0 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
  `(array_length next1) = M`) /\
  (lexZ (pairZ `M - i0` j1) (pairZ `M - i0` j0)).
Proof.
Intuition (Cut ~`j0=0`; [ Clear Test3; Intro Test3 | Assumption ]).
  Subst j1.
  Elim (H11 j0); Omega'.
  Elim (H11 j0); Omega'.
  Elim (H11 j0); Omega'.
  Subst j1.
  Apply match_trans with t2 := p i2 := `j0-(access   next1 j0)`.
  Apply match_left_weakening with n := j0.
  Replace `i0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `i0-j0` ; [ Idtac | Omega' ].
  Replace `j0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `0` ; [ Assumption | Omega' ].
  Elim (H11 j0); Omega'. Elim (H11 j0); Auto; Omega'.

  Elim (Z_lt_ge_dec `j0+1` z); Intro.
  (* j0+1 < z < i0+1 *)
  Apply (H9 z); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec z `j0+1`); Intro.
  (* z = j0+1 *)
  Absurd (#p[i0])=(#p[j0]) ; [ Assumption | Idtac ].
  Decompose [match] H14.
  Replace i0 with `i0+1-z+j0`; [ Idtac | Omega' ].
  Replace j0 with `0+j0`; [ Idtac | Omega' ].
  Apply H18; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  Absurd (match p `j0-(z-1)` p `0` `z-1`).
  Decompose [match] H14.
  Elim (H11 j0); Omega' Orelse Intros.
  Apply H21; Omega'.
  Apply match_trans with t2 := p i2 := `i0-(z-1)`.
  Apply match_sym.
  Apply match_left_weakening with n := j0.
  Replace `i0-(z-1)-(j0-(z-1))` with `i0-j0` ; [ Idtac | Omega' ].
  Ring `j0-(z-1)-(j0-(z-1))`. Assumption.
  Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0-(z-1)` with `i0+1-z` ; [ Assumption | Omega' ].
  Omega'.
Unfold lexZ lex Zwf pairZ. 
Elim (H11 j0) ; [ Intros | Omega' ].
Right. Omega'.
Save.

Lemma initnext_po_11 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Pre7: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`)
  (Test7: `i0 < M - 1`)
  (i1: Z)
  (j1: Z)
  (next2: (array Z))
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
         (match p `i1 - j1` p `0` j1) /\
         ((z:Z)
          (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
         `(array_length next2) = M`) /\
         (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)))
  (lexZ (pairZ `M - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre7; Assumption.
Save.

Lemma initnext_po_12 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 < result` /\
  `result <= M`) /\ (match p `result - result0` p `0` result0) /\
  ((z:Z)
   (`result0 + 1 < z` /\ `z < result + 1` ->
    ~(match p `result + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= result` -> (Next p k (access next0 k)))) /\
  `(array_length next0) = M`.
Proof.
Intuition.
Subst result result0.
Apply match_empty ; Omega'.
Absurd `1 < z`; Omega'.
Replace k with `1` ; [ Subst next0; Rewrite store_def_1 | Omega' ].
Apply next_1_0; Omega'.
Omega'.
ArraySubst next0.
Save.

Lemma initnext_po_13 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test8: `1 < M`)
  (Pre8: `0 <= 1` /\ `1 < (array_length next)`)
  (next0: (array Z))
  (Post1: next0 = (store next `1` `0`))
  (i0: Z)
  (j0: Z)
  (next1: (array Z))
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
        `(array_length next1) = M`) /\ `i0 >= M - 1`)
  `(array_length next1) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))).
Proof.
Intuition.
Save.

Lemma initnext_po_14 : 
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M`)
  (result: Z)
  (Post9: result = `1`)
  (result0: Z)
  (Post8: result0 = `0`)
  (Test1: `1 >= M`)
  `(array_length next) = M` /\
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))).
Proof.
Intuition.
Absurd `0 < j`; Omega'.
Save.

Definition initnext := (* validation *)
  [u: unit; next: (array Z); p: (array A); Pre9: `(array_length p) = M` /\
   `(array_length next) = M`]
    let (result, Post9) = (exist_1 [result: Z]result = `1` `1`
      (refl_equal ? `1`)) in
    let (i0, next0, result0, Post13) =
      let (result0, Post8) = (exist_1 [result0: Z]result0 = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, j0, next0, result1, Post14) =
        let (result1, Bool4) =
          let (result3, Post15) = (Z_lt_ge_bool `1` M) in
          (exist_1 [result4: bool]
          (if result4 then `1 < M` else `1 >= M`) result3 Post15) in
        (Cases (btest [result1:bool](if result1 then `1 < M` else `1 >= M`)
                result1 Bool4) of
        | (left Test8) =>
            let (i0, j0, next0, result2, Post17) =
              let Pre8 =
                (initnext_po_1 next p Pre9 result Post9 result0 Post8 Test8) in
              let (next0, result2, Post1) = (exist_2 [next1: (array Z)]
                [result4: unit]
                next1 = (store next `1` `0`) (store next `1` `0`) tt
                (refl_equal ? (store next `1` `0`))) in
              let (i0, j0, next1, result3, Inv) =
                (well_founded_induction prodZZ lexZ
                  (initnext_po_2 next p Pre9 result Post9 result0 Post8 Test8
                  Pre8 next0 Post1) [Variant1: prodZZ](i0: Z)(j0: Z)
                  (next1: (array Z))(_: Variant1 = (pairZ `M - i0` j0))
                  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\
                  `i0 <= M`) /\ (match p `i0 - j0` p `0` j0) /\
                  ((z:Z)
                   (`j0 + 1 < z` /\ `z < i0 + 1` ->
                    ~(match p `i0 + 1 - z` p `0` z))) /\
                  ((k:Z)
                   (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
                  `(array_length next1) = M`)
                  (sig_4 Z Z (array Z) unit [i1: Z][j1: Z][next2: (array Z)]
                   [result3: unit](((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\
                   `i1 <= M`) /\ (match p `i1 - j1` p `0` j1) /\
                   ((z:Z)
                    (`j1 + 1 < z` /\ `z < i1 + 1` ->
                     ~(match p `i1 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
                   `(array_length next2) = M`) /\ `i1 >= M - 1`))
                  [Variant1: prodZZ; wf1: (Variant2: prodZZ)
                   (Pre1: (lexZ Variant2 Variant1))(i0: Z)(j0: Z)
                   (next1: (array Z))(_: Variant2 = (pairZ `M - i0` j0))
                   (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\
                   `i0 <= M`) /\ (match p `i0 - j0` p `0` j0) /\
                   ((z:Z)
                    (`j0 + 1 < z` /\ `z < i0 + 1` ->
                     ~(match p `i0 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
                   `(array_length next1) = M`)
                   (sig_4 Z Z (array Z) unit [i1: Z][j1: Z][next2: (array Z)]
                    [result3: unit](((`0 <= j1` /\ `j1 <= M`) /\
                    (`j1 < i1` /\ `i1 <= M`) /\
                    (match p `i1 - j1` p `0` j1) /\
                    ((z:Z)
                     (`j1 + 1 < z` /\ `z < i1 + 1` ->
                      ~(match p `i1 + 1 - z` p `0` z))) /\
                    ((k:Z)
                     (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k)))) /\
                    `(array_length next2) = M`) /\ `i1 >= M - 1`));
                   i0: Z; j0: Z; next1: (array Z);
                   Pre7: Variant1 = (pairZ `M - i0` j0); Inv: (`0 <= j0` /\
                   `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
                   (match p `i0 - j0` p `0` j0) /\
                   ((z:Z)
                    (`j0 + 1 < z` /\ `z < i0 + 1` ->
                     ~(match p `i0 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))) /\
                   `(array_length next1) = M`]
                    let (result3, Bool3) =
                      let (result5, Post18) = (Z_lt_ge_bool i0 `M - 1`) in
                      (exist_1 [result6: bool]
                      (if result6 then `i0 < M - 1` else `i0 >= M - 1`) 
                      result5 Post18) in
                    (Cases (btest
                            [result3:bool](if result3 then `i0 < M - 1`
                                           else `i0 >= M - 1`)
                            result3 Bool3) of
                    | (left Test7) =>
                        let (i1, j1, next2, result4, Inv0) =
                          let (i1, j1, next2, result4, Inv0) =
                            let (i1, j1, next2, result4, Inv0) =
                              let (result4, Bool2) =
                                let Pre3 =
                                  (initnext_po_3 next p Pre9 result Post9
                                  result0 Post8 Test8 Pre8 next0 Post1
                                  Variant1 i0 j0 next1 Pre7 Inv Test7) in
                                let result5 =
                                  let Pre2 =
                                    (initnext_po_4 next p Pre9 result Post9
                                    result0 Post8 Test8 Pre8 next0 Post1
                                    Variant1 i0 j0 next1 Pre7 Inv Test7 Pre3) in
                                  (A_eq_bool (access p i0)) in
                                let (result6, Post19) =
                                  (result5 (access p j0)) in
                                (exist_1 [result7: bool]
                                (if result7
                                 then (access p i0) = (access p j0)
                                 else ~(access p i0) = (access p j0)) 
                                result6 Post19) in
                              (Cases (btest
                                      [result4:bool](if result4
                                                     then (access p i0) = (
                                                          access p j0)
                                                     else ~(access p i0) = (
                                                           access p j0))
                                      result4 Bool2) of
                              | (left Test6) =>
                                  let (i1, j1, next2, result5, Inv0) =
                                    let (i1, result5, Post2) =
                                      let (result5, Post2) =
                                        (exist_1 [result5: Z]
                                        result5 = `i0 + 1` `i0 + 1`
                                        (refl_equal ? `i0 + 1`)) in
                                      (exist_2 [i2: Z][result6: unit]
                                      i2 = `i0 + 1` result5 tt Post2) in
                                    let (j1, result6, Post3) =
                                      let (result6, Post3) =
                                        (exist_1 [result6: Z]
                                        result6 = `j0 + 1` `j0 + 1`
                                        (refl_equal ? `j0 + 1`)) in
                                      (exist_2 [j2: Z][result7: unit]
                                      j2 = `j0 + 1` result6 tt Post3) in
                                    let Pre6 =
                                      (initnext_po_5 next p Pre9 result Post9
                                      result0 Post8 Test8 Pre8 next0 Post1
                                      Variant1 i0 j0 next1 Pre7 Inv Test7
                                      Test6 i1 Post2 j1 Post3) in
                                    let (next2, result7, Post4) =
                                      (exist_2 [next3: (array Z)]
                                      [result9: unit]
                                      next3 = (store next1 i1 j1) (store next1
                                                                   i1 j1) 
                                      tt
                                      (refl_equal ? (store next1 i1 j1))) in
                                    (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                                    [result8: unit]((`0 <= j2` /\
                                    `j2 <= M`) /\ (`j2 < i2` /\ `i2 <= M`) /\
                                    (match p `i2 - j2` p `0` j2) /\
                                    ((z:Z)
                                     (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                      ~(match p `i2 + 1 - z` p `0` z))) /\
                                    ((k:Z)
                                     (`0 < k` /\ `k <= i2` ->
                                      (Next p k (access next3 k)))) /\
                                    `(array_length next3) = M`) /\
                                    (lexZ (pairZ `M - i2` j2)
                                     (pairZ `M - i0` j0)) i1
                                    j1 next2 result7
                                    (initnext_po_6 next p Pre9 result Post9
                                    result0 Post8 Test8 Pre8 next0 Post1
                                    Variant1 i0 j0 next1 Pre7 Inv Test7 Test6
                                    i1 Post2 j1 Post3 Pre6 next2 Post4)) in
                                  (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                                  [result6: unit]((`0 <= j2` /\ `j2 <= M`) /\
                                  (`j2 < i2` /\ `i2 <= M`) /\
                                  (match p `i2 - j2` p `0` j2) /\
                                  ((z:Z)
                                   (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                    ~(match p `i2 + 1 - z` p `0` z))) /\
                                  ((k:Z)
                                   (`0 < k` /\ `k <= i2` ->
                                    (Next p k (access next3 k)))) /\
                                  `(array_length next3) = M`) /\
                                  (lexZ (pairZ `M - i2` j2)
                                   (pairZ `M - i0` j0)) i1
                                  j1 next2 result5 Inv0)
                              | (right Test5) =>
                                  let (i1, j1, next2, result5, Inv0) =
                                    let (result5, Bool1) =
                                      let (result7, Post20) =
                                        (Z_eq_bool j0 `0`) in
                                      (exist_1 [result8: bool]
                                      (if result8 then `j0 = 0`
                                       else `j0 <> 0`) result7
                                      Post20) in
                                    (Cases (btest
                                            [result5:bool](if result5
                                                           then `j0 = 0`
                                                           else `j0 <> 0`)
                                            result5 Bool1) of
                                    | (left Test4) =>
                                        let (i1, next2, result6, Inv0) =
                                          let (i1, result6, Post5) =
                                            let (result6, Post5) =
                                              (exist_1 [result6: Z]
                                              result6 = `i0 + 1` `i0 + 1`
                                              (refl_equal ? `i0 + 1`)) in
                                            (exist_2 [i2: Z][result7: unit]
                                            i2 = `i0 + 1` result6 tt Post5) in
                                          let Pre5 =
                                            (initnext_po_7 next p Pre9 result
                                            Post9 result0 Post8 Test8 Pre8
                                            next0 Post1 Variant1 i0 j0 next1
                                            Pre7 Inv Test7 Test5 Test4 i1
                                            Post5) in
                                          let (next2, result7, Post6) =
                                            (exist_2 [next3: (array Z)]
                                            [result9: unit]
                                            next3 = (store next1 i1 `0`) 
                                            (store next1 i1 `0`) tt
                                            (refl_equal ? (store next1 i1 `0`))) in
                                          (exist_3 [i2: Z][next3: (array Z)]
                                          [result8: unit]((`0 <= j0` /\
                                          `j0 <= M`) /\ (`j0 < i2` /\
                                          `i2 <= M`) /\
                                          (match p `i2 - j0` p `0` j0) /\
                                          ((z:Z)
                                           (`j0 + 1 < z` /\ `z < i2 + 1` ->
                                            ~(match p `i2 + 1 - z` p `0` z))) /\
                                          ((k:Z)
                                           (`0 < k` /\ `k <= i2` ->
                                            (Next p k (access next3 k)))) /\
                                          `(array_length next3) = M`) /\
                                          (lexZ (pairZ `M - i2` j0)
                                           (pairZ `M - i0` j0)) i1
                                          next2 result7
                                          (initnext_po_8 next p Pre9 result
                                          Post9 result0 Post8 Test8 Pre8
                                          next0 Post1 Variant1 i0 j0 next1
                                          Pre7 Inv Test7 Test5 Test4 i1 Post5
                                          Pre5 next2 Post6)) in
                                        (exist_4 [i2: Z][j1: Z]
                                        [next3: (array Z)][result7: unit]
                                        ((`0 <= j1` /\ `j1 <= M`) /\
                                        (`j1 < i2` /\ `i2 <= M`) /\
                                        (match p `i2 - j1` p `0` j1) /\
                                        ((z:Z)
                                         (`j1 + 1 < z` /\ `z < i2 + 1` ->
                                          ~(match p `i2 + 1 - z` p `0` z))) /\
                                        ((k:Z)
                                         (`0 < k` /\ `k <= i2` ->
                                          (Next p k (access next3 k)))) /\
                                        `(array_length next3) = M`) /\
                                        (lexZ (pairZ `M - i2` j1)
                                         (pairZ `M - i0` j0)) i1
                                        j0 next2 result6 Inv0)
                                    | (right Test3) =>
                                        let Pre4 =
                                          (initnext_po_9 next p Pre9 result
                                          Post9 result0 Post8 Test8 Pre8
                                          next0 Post1 Variant1 i0 j0 next1
                                          Pre7 Inv Test7 Test5 Test3) in
                                        let (j1, result6, Post7) =
                                          let (result6, Post7) =
                                            (exist_1 [result6: Z]
                                            result6 = (access next1 j0) 
                                            (access next1 j0)
                                            (refl_equal ? (access next1 j0))) in
                                          (exist_2 [j2: Z][result7: unit]
                                          j2 = (access next1 j0) result6 
                                          tt Post7) in
                                        (exist_4 [i1: Z][j2: Z]
                                        [next2: (array Z)][result7: unit]
                                        ((`0 <= j2` /\ `j2 <= M`) /\
                                        (`j2 < i1` /\ `i1 <= M`) /\
                                        (match p `i1 - j2` p `0` j2) /\
                                        ((z:Z)
                                         (`j2 + 1 < z` /\ `z < i1 + 1` ->
                                          ~(match p `i1 + 1 - z` p `0` z))) /\
                                        ((k:Z)
                                         (`0 < k` /\ `k <= i1` ->
                                          (Next p k (access next2 k)))) /\
                                        `(array_length next2) = M`) /\
                                        (lexZ (pairZ `M - i1` j2)
                                         (pairZ `M - i0` j0)) i0
                                        j1 next1 result6
                                        (initnext_po_10 next p Pre9 result
                                        Post9 result0 Post8 Test8 Pre8 next0
                                        Post1 Variant1 i0 j0 next1 Pre7 Inv
                                        Test7 Test5 Test3 Pre4 j1 Post7)) end) in
                                  (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                                  [result6: unit]((`0 <= j2` /\ `j2 <= M`) /\
                                  (`j2 < i2` /\ `i2 <= M`) /\
                                  (match p `i2 - j2` p `0` j2) /\
                                  ((z:Z)
                                   (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                    ~(match p `i2 + 1 - z` p `0` z))) /\
                                  ((k:Z)
                                   (`0 < k` /\ `k <= i2` ->
                                    (Next p k (access next3 k)))) /\
                                  `(array_length next3) = M`) /\
                                  (lexZ (pairZ `M - i2` j2)
                                   (pairZ `M - i0` j0)) i1
                                  j1 next2 result5 Inv0) end) in
                            (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                            [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                            (`j2 < i2` /\ `i2 <= M`) /\
                            (match p `i2 - j2` p `0` j2) /\
                            ((z:Z)
                             (`j2 + 1 < z` /\ `z < i2 + 1` ->
                              ~(match p `i2 + 1 - z` p `0` z))) /\
                            ((k:Z)
                             (`0 < k` /\ `k <= i2` ->
                              (Next p k (access next3 k)))) /\
                            `(array_length next3) = M`) /\
                            (lexZ (pairZ `M - i2` j2) (pairZ `M - i0` j0)) 
                            i1 j1 next2 result4 Inv0) in
                          ((wf1 (pairZ `M - i1` j1))
                            (initnext_po_11 next p Pre9 result Post9 result0
                            Post8 Test8 Pre8 next0 Post1 Variant1 i0 j0 next1
                            Pre7 Inv Test7 i1 j1 next2 Inv0) i1 j1 next2
                            (refl_equal ? (pairZ `M - i1` j1))
                            (proj1 ? ? Inv0)) in
                        (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                        [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                        (`j2 < i2` /\ `i2 <= M`) /\
                        (match p `i2 - j2` p `0` j2) /\
                        ((z:Z)
                         (`j2 + 1 < z` /\ `z < i2 + 1` ->
                          ~(match p `i2 + 1 - z` p `0` z))) /\
                        ((k:Z)
                         (`0 < k` /\ `k <= i2` -> (Next p k (access next3 k)))) /\
                        `(array_length next3) = M`) /\ `i2 >= M - 1` 
                        i1 j1 next2 result4 Inv0)
                    | (right Test2) =>
                        let (i1, j1, next2, result4, Inv0) = (exist_4 [i1: Z]
                          [j1: Z][next2: (array Z)][result4: unit]
                          ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\
                          `i1 <= M`) /\ (match p `i1 - j1` p `0` j1) /\
                          ((z:Z)
                           (`j1 + 1 < z` /\ `z < i1 + 1` ->
                            ~(match p `i1 + 1 - z` p `0` z))) /\
                          ((k:Z)
                           (`0 < k` /\ `k <= i1` ->
                            (Next p k (access next2 k)))) /\
                          `(array_length next2) = M`) /\ `i1 >= M - 1` 
                          i0 j0 next1 tt (conj ? ? Inv Test2)) in
                        (exist_4 [i2: Z][j2: Z][next3: (array Z)]
                        [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                        (`j2 < i2` /\ `i2 <= M`) /\
                        (match p `i2 - j2` p `0` j2) /\
                        ((z:Z)
                         (`j2 + 1 < z` /\ `z < i2 + 1` ->
                          ~(match p `i2 + 1 - z` p `0` z))) /\
                        ((k:Z)
                         (`0 < k` /\ `k <= i2` -> (Next p k (access next3 k)))) /\
                        `(array_length next3) = M`) /\ `i2 >= M - 1` 
                        i1 j1 next2 result4 Inv0) end)
                  (pairZ `M - result` result0) result result0 next0
                  (refl_equal ? (pairZ `M - result` result0))
                  (initnext_po_12 next p Pre9 result Post9 result0 Post8
                  Test8 Pre8 next0 Post1)) in
              (exist_4 [i1: Z][j1: Z][next2: (array Z)][result4: unit]
              `(array_length next2) = M` /\
              ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next2 j)))) 
              i0 j0 next1 result3
              (initnext_po_13 next p Pre9 result Post9 result0 Post8 Test8
              Pre8 next0 Post1 i0 j0 next1 Inv)) in
            (exist_4 [i1: Z][j1: Z][next1: (array Z)][result3: unit]
            `(array_length next1) = M` /\
            ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) 
            i0 j0 next0 result2 Post17)
        | (right Test1) =>
            let (result2, Post16) = (exist_1 [result2: unit]
              `(array_length next) = M` /\
              ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))) 
              tt
              (initnext_po_14 next p Pre9 result Post9 result0 Post8 Test1)) in
            (exist_4 [i0: Z][j0: Z][next0: (array Z)][result3: unit]
            `(array_length next0) = M` /\
            ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))) 
            result result0 next result2 Post16) end) in
      (exist_3 [i1: Z][next1: (array Z)][result2: unit]
      `(array_length next1) = M` /\
      ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) i0 
      next0 result1 Post14) in
    (exist_2 [next1: (array Z)][result1: unit]`(array_length next1) = M` /\
    ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) next0 
    result0 Post13).

(*Why*) Parameter N : Z.
Axiom N_positive : `0 <= N`.


Lemma kmp_po_1 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  `(array_length p) = M` /\ `(array_length next) = M`.
Proof.
Intuition.
Save.

Lemma kmp_po_2 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (well_founded lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma kmp_po_3 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test2: `j0 < M`)
  (result3: bool)
  (Bool4: (if result3 then `i0 < N` else `i0 >= N`))
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_4 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test1: `j0 >= M`)
  (result3: bool)
  (Post5: result3 = false)
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_5 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  `0 <= j0` /\ `j0 < (array_length p)`.
Proof.
Intuition.
Discriminate H14.
Save.

Lemma kmp_po_6 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Pre5: `0 <= j0` /\ `j0 < (array_length p)`)
  `0 <= i0` /\ `i0 < (array_length a)`.
Proof.
Intuition.
Save.

Lemma kmp_po_7 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test7: (access a i0) = (access p j0))
  (i1: Z)
  (Post1: i1 = `i0 + 1`)
  (j1: Z)
  (Post2: j1 = `j0 + 1`)
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H14 Orelse Auto with *.
Subst j1 i1.
  Apply match_right_extension.
  Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Replace `i0+1-(j0+1)` with `i0-j0`. 
  Apply (H12 k); Assumption Orelse Omega'.
  Omega'.
  Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_8 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test5: `j0 = 0`)
  (i1: Z)
  (Post3: i1 = `i0 + 1`)
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j0` p `0` j0) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j0` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j0) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H14 Orelse Auto with *.
  Subst j0.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_le_lt_eq_dec k `i0-j0`).
  Intro. Apply (H12 k); Assumption Orelse Omega'.
  Intro. Generalize H15. Apply match_contradiction_at_first. Omega'.
  Rewrite b. Subst j0. Ring `i0-0`. Assumption.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_9 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  `0 <= j0` /\ `j0 < (array_length next0)`.
Proof.
Intuition.
Discriminate H14.
Save.

Lemma kmp_po_10 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  (Pre6: `0 <= j0` /\ `j0 < (array_length next0)`)
  (j1: Z)
  (Post4: j1 = (access next0 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i0` /\ `i0 <= N`) /\
  (match a `i0 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i0 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i0` j1) (pairZ `N - i0` j0)).
Proof.
Intuition (Assert `j0<>0`; Auto with *).
  (* invariant *)
  Elim (H5 j0); Intros. Omega'.
  Omega'.
  Elim (H5 j0); Intros; Omega'.
  Elim (H5 j0); Intros; Omega'.
  Apply next_iteration with j := j0.
  Omega'.
  Omega'.
  Assumption.
  Subst j1; Apply (H5 j0); Omega'.
  (* ~(match a k p `0` M) *)
  Elim (Z_lt_ge_dec k `i0-j0`); Intro Hck.
  (* k < i0-j0 *)
  Apply (H14 k); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec `i0-j0` k); Intro Hck'.
  (* k = i0-j0 *)
  Generalize H17. Replace k with `i0-j0`.
  Apply match_contradiction_at_i with i := j0.
  Omega'. Omega'. Ring `i0-j0+j0`. Ring `0+j0`. Assumption. Omega'. 
  (* i0-j0 < k *)
  Generalize H17. Rewrite <- H.
  Apply next_is_maximal with i := i0 j := j0 n := #next0[j0]. 
  Omega'. Omega'. Omega'.
  Assumption.
  Apply (H5 j0); Omega'.
  Unfold lexZ lex Zwf pairZ. 
  Elim (H5 j0). Intros.
  Right. Omega'. Omega'.
Discriminate H16.
Discriminate H16.
Save.

Lemma kmp_po_11 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre7: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (i1: Z)
  (j1: Z)
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
         (match a `i1 - j1` p `0` j1) /\
         ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
         (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)))
  (lexZ (pairZ `N - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre7; Assumption.
Rewrite Pre7; Assumption.
Save.

Definition first_occur :=
  [p:(array A)][a:(array A)][r:Z]  
     (`0 <= r < (array_length a)` -> 
        (match a r p `0` (array_length p)))
  /\ ((k:Z) `0 <= k < r` -> ~(match a k p `0` (array_length p))).

Lemma kmp_po_12 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 <= result` /\
  `result <= N`) /\ (match a `result - result0` p `0` result0) /\
  ((k:Z) (`0 <= k` /\ `k < result - result0` -> ~(match a k p `0` M))).
Proof.
Intuition.
Generalize M_positive; Omega'.
Generalize N_positive; Omega'.
Subst result result0.
Apply match_empty.
Generalize N_positive; Omega'. Generalize M_positive; Omega'.
Absurd `0 <= k`; Omega'.
Save.

Lemma kmp_po_13 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test10: `j0 = M`)
  (first_occur p a `i0 - M`).
Proof.
Intros.
Decompose [and] Inv.
Unfold first_occur. 
Split. 
Intro. Rewrite <- Test10.  
Replace (array_length p) with j0. Assumption. Omega'.
Replace `i0-M` with `i0-j0`. 
Replace (array_length p) with M. Assumption. Omega'.
Omega'.
Save.

Lemma kmp_po_14 : 
  (a: (array A))
  (next: (array Z))
  (p: (array A))
  (Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
         `(array_length a) = N`)
  (result: Z)
  (Post8: result = `0`)
  (result0: Z)
  (Post7: result0 = `0`)
  (Pre8: `(array_length p) = M` /\ `(array_length next) = M`)
  (next0: (array Z))
  (Post15: `(array_length next0) = M` /\
           ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test9: `j0 <> M`)
  (first_occur p a i0).
Proof.
Intros. Unfold first_occur. Decompose [and] Inv.
Split. 
Intro. Absurd `i0 < N`; Omega'.
Intros k Hk. 
Elim (Z_lt_ge_dec k `i0-j0`); Intro Hk'.
Replace (array_length p) with M.
Apply H6; Omega'. Omega'.
Red; Intro. Decompose [match] H4.
Absurd `k <= N-M`; Omega'.
Save.

Definition kmp := (* validation *)
  [a: (array A); next: (array Z); p: (array A);
   Pre9: `(array_length p) = M` /\ `(array_length next) = M` /\
   `(array_length a) = N`]
    let (result, Post8) = (exist_1 [result: Z]result = `0` `0`
      (refl_equal ? `0`)) in
    let (i0, next0, result0, Post13) =
      let (result0, Post7) = (exist_1 [result0: Z]result0 = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, j0, next0, result1, Post14) =
        let Pre8 = (kmp_po_1 a next p Pre9 result Post8 result0 Post7) in
        let (next0, result1, Post15) =
          let Pre1 = Pre8 in
          let Pre2 = Pre1 in
          let (next0, result3, Post16) = (initnext tt next p Pre1) in
          (exist_2 [next1: (array Z)][result4: unit]
          `(array_length next1) = M` /\
          ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) 
          next0 result3 Post16) in
        let (i0, j0, result2, Inv) =
          (well_founded_induction prodZZ lexZ
            (kmp_po_2 a next p Pre9 result Post8 result0 Post7 Pre8 next0
            Post15) [Variant1: prodZZ](i0: Z)(j0: Z)
            (_: Variant1 = (pairZ `N - i0` j0))(Inv: (`0 <= j0` /\
            `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
            (match a `i0 - j0` p `0` j0) /\
            ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
            (sig_3 Z Z unit [i1: Z][j1: Z][result2: unit](((`0 <= j1` /\
             `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
             (match a `i1 - j1` p `0` j1) /\
             ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
             (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false)))
            [Variant1: prodZZ; wf1: (Variant2: prodZZ)
             (Pre3: (lexZ Variant2 Variant1))(i0: Z)(j0: Z)
             (_: Variant2 = (pairZ `N - i0` j0))(Inv: (`0 <= j0` /\
             `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
             (match a `i0 - j0` p `0` j0) /\
             ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
             (sig_3 Z Z unit [i1: Z][j1: Z][result2: unit](((`0 <= j1` /\
              `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
              (match a `i1 - j1` p `0` j1) /\
              ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
              (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false)));
             i0: Z; j0: Z; Pre7: Variant1 = (pairZ `N - i0` j0);
             Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
             (match a `i0 - j0` p `0` j0) /\
             ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))]
              let (result2, Post6) =
                let (result2, Bool1) =
                  let (result4, Post17) = (Z_lt_ge_bool j0 M) in
                  (exist_1 [result5: bool]
                  (if result5 then `j0 < M` else `j0 >= M`) result4 Post17) in
                (Cases (btest
                        [result2:bool](if result2 then `j0 < M`
                                       else `j0 >= M`)
                        result2 Bool1) of
                | (left Test2) =>
                    let (result3, Bool4) =
                      let (result5, Post18) = (Z_lt_ge_bool i0 N) in
                      (exist_1 [result6: bool]
                      (if result6 then `i0 < N` else `i0 >= N`) result5
                      Post18) in
                    (exist_1 [result4: bool]
                    (if result4 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\
                     true = false else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\
                     false = false) result3
                    (kmp_po_3 a next p Pre9 result Post8 result0 Post7 Pre8
                    next0 Post15 Variant1 i0 j0 Pre7 Inv Test2 result3 Bool4))
                | (right Test1) =>
                    let (result3, Post5) = (exist_1 [result3: bool]
                      result3 = false false (refl_equal ? false)) in
                    (exist_1 [result4: bool]
                    (if result4 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\
                     true = false else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\
                     false = false) result3
                    (kmp_po_4 a next p Pre9 result Post8 result0 Post7 Pre8
                    next0 Post15 Variant1 i0 j0 Pre7 Inv Test1 result3 Post5)) end) in
              (Cases (btest
                      [result2:bool](if result2 then `j0 < M` /\ `i0 < N` \/
                                     `j0 >= M` /\ true = false
                                     else `j0 < M` /\ `i0 >= N` \/
                                     `j0 >= M` /\ false = false)
                      result2 Post6) of
              | (left Test8) =>
                  let (i1, j1, result3, Inv0) =
                    let (i1, j1, result3, Inv0) =
                      let (i1, j1, result3, Inv0) =
                        let (result3, Bool3) =
                          let Pre5 =
                            (kmp_po_5 a next p Pre9 result Post8 result0
                            Post7 Pre8 next0 Post15 Variant1 i0 j0 Pre7 Inv
                            Test8) in
                          let result4 =
                            let Pre4 =
                              (kmp_po_6 a next p Pre9 result Post8 result0
                              Post7 Pre8 next0 Post15 Variant1 i0 j0 Pre7 Inv
                              Test8 Pre5) in
                            (A_eq_bool (access a i0)) in
                          let (result5, Post19) = (result4 (access p j0)) in
                          (exist_1 [result6: bool]
                          (if result6 then (access a i0) = (access p j0)
                           else ~(access a i0) = (access p j0)) result5
                          Post19) in
                        (Cases (btest
                                [result3:bool](if result3
                                               then (access a i0) = (
                                                    access p j0)
                                               else ~(access a i0) = (
                                                     access p j0))
                                result3 Bool3) of
                        | (left Test7) =>
                            let (i1, j1, result4, Inv0) =
                              let (i1, result4, Post1) =
                                let (result4, Post1) = (exist_1 [result4: Z]
                                  result4 = `i0 + 1` `i0 + 1`
                                  (refl_equal ? `i0 + 1`)) in
                                (exist_2 [i2: Z][result5: unit]
                                i2 = `i0 + 1` result4 tt Post1) in
                              let (j1, result5, Post2) =
                                let (result5, Post2) = (exist_1 [result5: Z]
                                  result5 = `j0 + 1` `j0 + 1`
                                  (refl_equal ? `j0 + 1`)) in
                                (exist_2 [j2: Z][result6: unit]
                                j2 = `j0 + 1` result5 tt Post2) in
                              (exist_3 [i2: Z][j2: Z][result6: unit]
                              ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                              `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                              ((k:Z)
                               (`0 <= k` /\ `k < i2 - j2` ->
                                ~(match a k p `0` M)))) /\
                              (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                              i1 j1 result5
                              (kmp_po_7 a next p Pre9 result Post8 result0
                              Post7 Pre8 next0 Post15 Variant1 i0 j0 Pre7 Inv
                              Test8 Test7 i1 Post1 j1 Post2)) in
                            (exist_3 [i2: Z][j2: Z][result5: unit]
                            ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                            `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                            ((k:Z)
                             (`0 <= k` /\ `k < i2 - j2` ->
                              ~(match a k p `0` M)))) /\
                            (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                            i1 j1 result4 Inv0)
                        | (right Test6) =>
                            let (i1, j1, result4, Inv0) =
                              let (result4, Bool2) =
                                let (result6, Post20) = (Z_eq_bool j0 `0`) in
                                (exist_1 [result7: bool]
                                (if result7 then `j0 = 0` else `j0 <> 0`) 
                                result6 Post20) in
                              (Cases (btest
                                      [result4:bool](if result4 then `
                                                     j0 = 0` else `j0 <> 0`)
                                      result4 Bool2) of
                              | (left Test5) =>
                                  let (i1, result5, Post3) =
                                    let (result5, Post3) =
                                      (exist_1 [result5: Z]
                                      result5 = `i0 + 1` `i0 + 1`
                                      (refl_equal ? `i0 + 1`)) in
                                    (exist_2 [i2: Z][result6: unit]
                                    i2 = `i0 + 1` result5 tt Post3) in
                                  (exist_3 [i2: Z][j1: Z][result6: unit]
                                  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i2` /\
                                  `i2 <= N`) /\
                                  (match a `i2 - j1` p `0` j1) /\
                                  ((k:Z)
                                   (`0 <= k` /\ `k < i2 - j1` ->
                                    ~(match a k p `0` M)))) /\
                                  (lexZ (pairZ `N - i2` j1)
                                   (pairZ `N - i0` j0)) i1
                                  j0 result5
                                  (kmp_po_8 a next p Pre9 result Post8
                                  result0 Post7 Pre8 next0 Post15 Variant1 i0
                                  j0 Pre7 Inv Test8 Test6 Test5 i1 Post3))
                              | (right Test4) =>
                                  let Pre6 =
                                    (kmp_po_9 a next p Pre9 result Post8
                                    result0 Post7 Pre8 next0 Post15 Variant1
                                    i0 j0 Pre7 Inv Test8 Test6 Test4) in
                                  let (j1, result5, Post4) =
                                    let (result5, Post4) =
                                      (exist_1 [result5: Z]
                                      result5 = (access next0 j0) (access next0
                                                                   j0)
                                      (refl_equal ? (access next0 j0))) in
                                    (exist_2 [j2: Z][result6: unit]
                                    j2 = (access next0 j0) result5 tt Post4) in
                                  (exist_3 [i1: Z][j2: Z][result6: unit]
                                  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i1` /\
                                  `i1 <= N`) /\
                                  (match a `i1 - j2` p `0` j2) /\
                                  ((k:Z)
                                   (`0 <= k` /\ `k < i1 - j2` ->
                                    ~(match a k p `0` M)))) /\
                                  (lexZ (pairZ `N - i1` j2)
                                   (pairZ `N - i0` j0)) i0
                                  j1 result5
                                  (kmp_po_10 a next p Pre9 result Post8
                                  result0 Post7 Pre8 next0 Post15 Variant1 i0
                                  j0 Pre7 Inv Test8 Test6 Test4 Pre6 j1
                                  Post4)) end) in
                            (exist_3 [i2: Z][j2: Z][result5: unit]
                            ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                            `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                            ((k:Z)
                             (`0 <= k` /\ `k < i2 - j2` ->
                              ~(match a k p `0` M)))) /\
                            (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                            i1 j1 result4 Inv0) end) in
                      (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                      `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                      (match a `i2 - j2` p `0` j2) /\
                      ((k:Z)
                       (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                      (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                      i1 j1 result3 Inv0) in
                    ((wf1 (pairZ `N - i1` j1))
                      (kmp_po_11 a next p Pre9 result Post8 result0 Post7
                      Pre8 next0 Post15 Variant1 i0 j0 Pre7 Inv Test8 i1 j1
                      Inv0) i1 j1 (refl_equal ? (pairZ `N - i1` j1))
                      (proj1 ? ? Inv0)) in
                  (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                  `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                  (match a `i2 - j2` p `0` j2) /\
                  ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                  (`j2 < M` /\ `i2 >= N` \/ `j2 >= M` /\ false = false) 
                  i1 j1 result3 Inv0)
              | (right Test3) =>
                  let (i1, j1, result3, Inv0) = (exist_3 [i1: Z][j1: Z]
                    [result3: unit]((`0 <= j1` /\ `j1 <= M`) /\
                    (`j1 <= i1` /\ `i1 <= N`) /\
                    (match a `i1 - j1` p `0` j1) /\
                    ((k:Z)
                     (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
                    (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false) 
                    i0 j0 tt (conj ? ? Inv Test3)) in
                  (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                  `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                  (match a `i2 - j2` p `0` j2) /\
                  ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                  (`j2 < M` /\ `i2 >= N` \/ `j2 >= M` /\ false = false) 
                  i1 j1 result3 Inv0) end) (pairZ `N - result` result0)
            result result0 (refl_equal ? (pairZ `N - result` result0))
            (kmp_po_12 a next p Pre9 result Post8 result0 Post7 Pre8 next0
            Post15)) in
        let (result3, Post21) =
          let (result3, Bool5) =
            let (result5, Post22) = (Z_eq_bool j0 M) in
            (exist_1 [result6: bool]
            (if result6 then `j0 = M` else `j0 <> M`) result5 Post22) in
          (Cases (btest
                  [result3:bool](if result3 then `j0 = M` else `j0 <> M`)
                  result3 Bool5) of
          | (left Test10) =>
              let (result4, Post24) = (exist_1 [result4: Z]
                (first_occur p a result4) `i0 - M`
                (kmp_po_13 a next p Pre9 result Post8 result0 Post7 Pre8
                next0 Post15 i0 j0 Inv Test10)) in
              (exist_1 [result5: Z](first_occur p a result5) result4 Post24)
          | (right Test9) =>
              let (result4, Post23) = (exist_1 [result4: Z]
                (first_occur p a result4) i0
                (kmp_po_14 a next p Pre9 result Post8 result0 Post7 Pre8
                next0 Post15 i0 j0 Inv Test9)) in
              (exist_1 [result5: Z](first_occur p a result5) result4 Post23) end) in
        (exist_4 [i1: Z][j1: Z][next1: (array Z)][result4: Z]
        (first_occur p a result4) i0 j0 next0 result3 Post21) in
      (exist_3 [i1: Z][next1: (array Z)][result2: Z]
      (first_occur p a result2) i0 next0 result1 Post14) in
    (exist_2 [next1: (array Z)][result1: Z](first_occur p a result1) 
    next0 result0 Post13).

