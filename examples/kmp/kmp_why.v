(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Sumbool.

Require Match.
Require Next.
Require ZArithRing.
Require Omega.
Require Lex.

Tactic Definition Omega' := Abstract Omega.

Parameter A : Set.
Axiom A_eq_dec : (x,y:A) { x=y }+{ ~x=y }.
Definition A_eq_bool := [x,y:A](bool_of_sumbool (A_eq_dec x y)).

(*Why*) Parameter M : Z.
Axiom M_positive : `0 <= M`.

Lemma initnext_po_1 : 
  (next: (array M Z))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (result2: Z)
  (Post3: (store next `1` result2) = (store next `1` `0`))
  `0 <= 1` /\ `1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_2 : 
  (next: (array M Z))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (well_founded ? lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma initnext_po_3 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_4 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Pre3: `0 <= j0` /\ `j0 < M`)
  `0 <= i0` /\ `i0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_5 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  (result7: Z)
  (Post9: (store next1 i1 result7) = (store next1 i1 j1))
  `0 <= i1` /\ `i1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_6 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test6: (access p i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  (next2: (array M Z))
  (Post9: next2 = (store next1 i1 j1))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k))))) /\
  (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)).
Proof.
Intuition.
Rewrite Post7; Rewrite Post8.
Apply match_right_extension.
Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H3; Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0+1-(z-1)` with `i0+1+1-z`.
  Rewrite Post7 in H7; Assumption. Omega'. Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro Hk'.  
  Rewrite Post9; Rewrite store_def_2.
  Apply H6; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`. Intro Heq.	
  Rewrite Post9; Rewrite Post7; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Rewrite Post8; Replace `i0+1-(j0+1)` with `i0-j0`.
  Apply match_right_extension; Omega' Orelse Try Assumption.
  Ring `i0-j0+j0`; Ring `0+j0`; Assumption. Omega'.
  Intros z Hz. 
  Red; Apply H3; Omega'.
  Omega'. Omega'.
Unfold lexZ lex Zwf pairZ; Left; Omega'.
Save.

Lemma initnext_po_7 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (result7: Z)
  (Post6: (store next1 i1 result7) = (store next1 i1 `0`))
  `0 <= i1` /\ `i1 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_8 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test4: `j0 = 0`)
  (i1: Z)
  (Post5: i1 = `i0 + 1`)
  (next2: (array M Z))
  (Post6: next2 = (store next1 i1 `0`))
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i1` /\ `i1 <= M`) /\
  (match p `i1 - j0` p `0` j0) /\
  ((z:Z) (`j0 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k))))) /\
  (lexZ (pairZ `M - i1` j0) (pairZ `M - i0` j0)).
Proof.
Intuition.
  Rewrite Test4.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_lt_ge_dec `j0+2` z); Intro.
  Absurd (match p `i0+1-(z-1)` p `0` `z-1`).
  Red; Apply H3; Omega'.
  Apply match_right_weakening with n := z.
  Rewrite Post5 in H7.
  Replace `i0+1-(z-1)` with `i0+1+1-z`; [ Assumption | Omega' ]. Omega'.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Idtac ].
  Decompose [match] H7.
  Replace i0 with `i0+1+1-2+j0`; [ Idtac | Omega' ].
  Replace #p[j0] with #p[`0+j0`]; [ Idtac | Ring `0+j0`; Reflexivity ].
  Cut `z = 2`; [ Intro Heq | Omega' ].
  Rewrite <- Heq. Rewrite <- Post5; Apply H11; Omega'.
  Elim (Z_lt_ge_dec k `i0+1`); Intro.
  Rewrite Post6; Rewrite store_def_2.
  Apply H6; Omega'. Omega'. Omega'. Omega'.
  Cut `i0+1 = k`; [ Intro Heq | Omega' ].
  Rewrite Post6; Rewrite Post5; Rewrite Heq. Rewrite store_def_1.
  Rewrite <- Heq. Apply Next_cons. Omega'.
  Apply match_empty; Omega'.
  Intros z Hz.
  Elim (Z_lt_ge_dec `1` z); Intro.
  (* 1 < z  *)
  Red; Apply H3; Omega'.
  (* z = 1 *)
  Red; Intro.
  Absurd (#p[i0])=(#p[j0]); [ Assumption | Rewrite Test4 ].
  Decompose [match] H5.
  Replace `0` with `0+0`; [ Idtac | Omega' ].
  Replace `i0` with `i0+1-z+0`; [ Idtac | Omega' ].
  Apply H11; Omega'.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma initnext_po_9 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Save.

Lemma initnext_po_10 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (Test5: ~(access p i0) = (access p j0))
  (Test3: `j0 <> 0`)
  (Pre5: `0 <= j0` /\ `j0 < M`)
  (j1: Z)
  (Post4: j1 = (access next1 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i0` /\ `i0 <= M`) /\
  (match p `i0 - j1` p `0` j1) /\
  ((z:Z) (`j1 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k))))) /\
  (lexZ (pairZ `M - i0` j1) (pairZ `M - i0` j0)).
Proof.
Intuition (Cut ~`j0=0`; [ Clear Test3; Intro Test3 | Assumption ]).
  Rewrite Post4. 
  Elim (H8 j0); Omega'.
  Elim (H8 j0); Omega'.
  Elim (H8 j0); Omega'.
  Rewrite Post4.
  Apply match_trans with t2 := p i2 := `j0-(access   next1 j0)`.
  Apply match_left_weakening with n := j0.
  Replace `i0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `i0-j0` ; [ Idtac | Omega' ].
  Replace `j0-(access   next1 j0)-(j0-(access   next1 j0))` 
    with `0` ; [ Assumption | Omega' ].
  Elim (H8 j0); Omega'. Elim (H8 j0); Auto; Omega'.

  Elim (Z_lt_ge_dec `j0+1` z); Intro.
  (* j0+1 < z < i0+1 *)
  Apply (H5 z); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec z `j0+1`); Intro.
  (* z = j0+1 *)
  Absurd (#p[i0])=(#p[j0]) ; [ Assumption | Idtac ].
  Decompose [match] H9.
  Replace i0 with `i0+1-z+j0`; [ Idtac | Omega' ].
  Replace j0 with `0+j0`; [ Idtac | Omega' ].
  Apply H13; Omega'.
  (* next[j0]+1 < z < j0+1 *)
  Absurd (match p `j0-(z-1)` p `0` `z-1`).
  Decompose [match] H9.
  Elim (H8 j0); Omega' Orelse Intros.
  Apply H16; Omega'.
  Apply match_trans with t2 := p i2 := `i0-(z-1)`.
  Apply match_sym.
  Apply match_left_weakening with n := j0.
  Replace `i0-(z-1)-(j0-(z-1))` with `i0-j0` ; [ Idtac | Omega' ].
  Ring `j0-(z-1)-(j0-(z-1))`. Assumption.
  Omega'.
  Apply match_right_weakening with n := z.
  Replace `i0-(z-1)` with `i0+1-z` ; [ Assumption | Omega' ].
  Omega'.
Unfold lexZ lex Zwf pairZ. 
Elim (H8 j0) ; [ Intros | Omega' ].
Right. Omega'.
Save.

Lemma initnext_po_11 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Pre8: Variant1 = (pairZ `M - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
  (Test7: `i0 < M - 1`)
  (i1: Z)
  (j1: Z)
  (next2: (array M Z))
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
         (match p `i1 - j1` p `0` j1) /\
         ((z:Z)
          (`j1 + 1 < z` /\ `z < i1 + 1` -> ~(match p `i1 + 1 - z` p `0` z))) /\
         ((k:Z) (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k))))) /\
         (lexZ (pairZ `M - i1` j1) (pairZ `M - i0` j0)))
  (lexZ (pairZ `M - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre8; Assumption.
Save.

Lemma initnext_po_12 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 < result` /\
  `result <= M`) /\ (match p `result - result0` p `0` result0) /\
  ((z:Z)
   (`result0 + 1 < z` /\ `z < result + 1` ->
    ~(match p `result + 1 - z` p `0` z))) /\
  ((k:Z) (`0 < k` /\ `k <= result` -> (Next p k (access next0 k)))).
Proof.
Intuition.
Rewrite Post1; Rewrite Post2.
Apply match_empty ; Omega'.
Absurd `1 < z`; Omega'.
Replace k with `1` ; [ Rewrite Post3; Rewrite store_def_1 | Omega' ].
Apply next_1_0; Omega'.
Omega'.
Save.

Lemma initnext_po_13 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test8: `1 < M`)
  (next0: (array M Z))
  (Post3: next0 = (store next `1` `0`))
  (i0: Z)
  (j0: Z)
  (next1: (array M Z))
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
        (match p `i0 - j0` p `0` j0) /\
        ((z:Z)
         (`j0 + 1 < z` /\ `z < i0 + 1` -> ~(match p `i0 + 1 - z` p `0` z))) /\
        ((k:Z) (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k))))) /\
        `i0 >= M - 1`)
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))).
Proof.
Intuition.
Save.

Lemma initnext_po_14 : 
  (next: (array M Z))
  (p: (array M A))
  (result: Z)
  (Post1: result = `1`)
  (result0: Z)
  (Post2: result0 = `0`)
  (Test1: `1 >= M`)
  ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))).
Proof.
Intuition.
Absurd `0 < j`; Omega'.
Save.

Definition initnext := (* validation *)
  [u: unit; next: (array M Z); p: (array M A)]
    let (result, Post1) = (exist_1 [result: Z]result = `1` `1`
      (refl_equal ? `1`)) in
    let (i0, next0, result0, Post13) =
      let (result0, Post2) = (exist_1 [result0: Z]result0 = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, j0, next0, result1, Post14) =
        let (result1, Bool4) =
          let (result3, Post15) = (Z_lt_ge_bool `1` M) in
          (exist_1 [result4: bool]
          (if result4 then `1 < M` else `1 >= M`) result3 Post15) in
        (Cases (btest [result1:bool](if result1 then `1 < M` else `1 >= M`)
                result1 Bool4) of
        | (left Test8) =>
            let (i0, j0, next0, result2, Post17) =
              let (next0, result2, Post3) =
                let (result2, Post3) = (exist_1 [result2: Z]
                  (store next `1` result2) = (store next `1` `0`) `0`
                  (refl_equal ? (store next `1` `0`))) in
                let Pre1 =
                  (initnext_po_1 next result Post1 result0 Post2 Test8
                  result2 Post3) in
                (exist_2 [next1: (array M Z)][result4: unit]
                next1 = (store next `1` `0`) (store next `1` result2) 
                tt Post3) in
              let (i0, j0, next1, result3, Inv) =
                (well_founded_induction prodZZ lexZ
                  (initnext_po_2 next result Post1 result0 Post2 Test8 next0
                  Post3) [Variant1: prodZZ](i0: Z)(j0: Z)(next1: (array M Z))
                  (_: Variant1 = (pairZ `M - i0` j0))(Inv: (`0 <= j0` /\
                  `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
                  (match p `i0 - j0` p `0` j0) /\
                  ((z:Z)
                   (`j0 + 1 < z` /\ `z < i0 + 1` ->
                    ~(match p `i0 + 1 - z` p `0` z))) /\
                  ((k:Z)
                   (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
                  (sig_4 Z Z (array M Z) unit [i1: Z][j1: Z]
                   [next2: (array M Z)][result3: unit](((`0 <= j1` /\
                   `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
                   (match p `i1 - j1` p `0` j1) /\
                   ((z:Z)
                    (`j1 + 1 < z` /\ `z < i1 + 1` ->
                     ~(match p `i1 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k))))) /\
                   `i1 >= M - 1`))
                  [Variant1: prodZZ; wf1: (Variant2: prodZZ)
                   (Pre2: (lexZ Variant2 Variant1))(i0: Z)(j0: Z)
                   (next1: (array M Z))(_: Variant2 = (pairZ `M - i0` j0))
                   (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 < i0` /\
                   `i0 <= M`) /\ (match p `i0 - j0` p `0` j0) /\
                   ((z:Z)
                    (`j0 + 1 < z` /\ `z < i0 + 1` ->
                     ~(match p `i0 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k)))))
                   (sig_4 Z Z (array M Z) unit [i1: Z][j1: Z]
                    [next2: (array M Z)][result3: unit](((`0 <= j1` /\
                    `j1 <= M`) /\ (`j1 < i1` /\ `i1 <= M`) /\
                    (match p `i1 - j1` p `0` j1) /\
                    ((z:Z)
                     (`j1 + 1 < z` /\ `z < i1 + 1` ->
                      ~(match p `i1 + 1 - z` p `0` z))) /\
                    ((k:Z)
                     (`0 < k` /\ `k <= i1` -> (Next p k (access next2 k))))) /\
                    `i1 >= M - 1`));
                   i0: Z; j0: Z; next1: (array M Z);
                   Pre8: Variant1 = (pairZ `M - i0` j0); Inv: (`0 <= j0` /\
                   `j0 <= M`) /\ (`j0 < i0` /\ `i0 <= M`) /\
                   (match p `i0 - j0` p `0` j0) /\
                   ((z:Z)
                    (`j0 + 1 < z` /\ `z < i0 + 1` ->
                     ~(match p `i0 + 1 - z` p `0` z))) /\
                   ((k:Z)
                    (`0 < k` /\ `k <= i0` -> (Next p k (access next1 k))))]
                    let (result3, Bool1) =
                      let (result5, Post18) = (Z_lt_ge_bool i0 `M - 1`) in
                      (exist_1 [result6: bool]
                      (if result6 then `i0 < M - 1` else `i0 >= M - 1`) 
                      result5 Post18) in
                    (Cases (btest
                            [result3:bool](if result3 then `i0 < M - 1`
                                           else `i0 >= M - 1`)
                            result3 Bool1) of
                    | (left Test7) =>
                        let (i1, j1, next2, result4, Inv0) =
                          let (i1, j1, next2, result4, Inv0) =
                            let (i1, j1, next2, result4, Inv0) =
                              let (result4, Bool3) =
                                let Pre3 =
                                  (initnext_po_3 next p result Post1 result0
                                  Post2 Test8 next0 Post3 Variant1 i0 j0
                                  next1 Pre8 Inv Test7) in
                                let result5 =
                                  let Pre4 =
                                    (initnext_po_4 next p result Post1
                                    result0 Post2 Test8 next0 Post3 Variant1
                                    i0 j0 next1 Pre8 Inv Test7 Pre3) in
                                  (A_eq_bool (access p i0)) in
                                let (result6, Post19) =
                                  (result5 (access p j0)) in
                                (exist_1 [result7: bool]
                                (if result7
                                 then (access p i0) = (access p j0)
                                 else ~(access p i0) = (access p j0)) 
                                result6 Post19) in
                              (Cases (btest
                                      [result4:bool](if result4
                                                     then (access p i0) =
                                                          (access p j0)
                                                     else ~(access p i0) =
                                                           (access p j0))
                                      result4 Bool3) of
                              | (left Test6) =>
                                  let (i1, j1, next2, result5, Inv0) =
                                    let (i1, result5, Post7) =
                                      let (result5, Post7) =
                                        (exist_1 [result5: Z]
                                        result5 = `i0 + 1` `i0 + 1`
                                        (refl_equal ? `i0 + 1`)) in
                                      (exist_2 [i2: Z][result6: unit]
                                      i2 = `i0 + 1` result5 tt Post7) in
                                    let (j1, result6, Post8) =
                                      let (result6, Post8) =
                                        (exist_1 [result6: Z]
                                        result6 = `j0 + 1` `j0 + 1`
                                        (refl_equal ? `j0 + 1`)) in
                                      (exist_2 [j2: Z][result7: unit]
                                      j2 = `j0 + 1` result6 tt Post8) in
                                    let (next2, result7, Post9) =
                                      let (result7, Post9) =
                                        (exist_1 [result7: Z]
                                        (store next1 i1 result7) =
                                        (store next1 i1 j1) j1
                                        (refl_equal ? (store next1 i1 j1))) in
                                      let Pre7 =
                                        (initnext_po_5 next p result Post1
                                        result0 Post2 Test8 next0 Post3
                                        Variant1 i0 j0 next1 Pre8 Inv Test7
                                        Test6 i1 Post7 j1 Post8 result7
                                        Post9) in
                                      (exist_2 [next3: (array M Z)]
                                      [result9: unit]
                                      next3 = (store next1 i1 j1) (store next1
                                                                   i1 result7)
                                      tt Post9) in
                                    (exist_4 [i2: Z][j2: Z]
                                    [next3: (array M Z)][result8: unit]
                                    ((`0 <= j2` /\ `j2 <= M`) /\
                                    (`j2 < i2` /\ `i2 <= M`) /\
                                    (match p `i2 - j2` p `0` j2) /\
                                    ((z:Z)
                                     (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                      ~(match p `i2 + 1 - z` p `0` z))) /\
                                    ((k:Z)
                                     (`0 < k` /\ `k <= i2` ->
                                      (Next p k (access next3 k))))) /\
                                    (lexZ (pairZ `M - i2` j2)
                                     (pairZ `M - i0` j0)) i1
                                    j1 next2 result7
                                    (initnext_po_6 next p result Post1
                                    result0 Post2 Test8 next0 Post3 Variant1
                                    i0 j0 next1 Pre8 Inv Test7 Test6 i1 Post7
                                    j1 Post8 next2 Post9)) in
                                  (exist_4 [i2: Z][j2: Z][next3: (array M Z)]
                                  [result6: unit]((`0 <= j2` /\ `j2 <= M`) /\
                                  (`j2 < i2` /\ `i2 <= M`) /\
                                  (match p `i2 - j2` p `0` j2) /\
                                  ((z:Z)
                                   (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                    ~(match p `i2 + 1 - z` p `0` z))) /\
                                  ((k:Z)
                                   (`0 < k` /\ `k <= i2` ->
                                    (Next p k (access next3 k))))) /\
                                  (lexZ (pairZ `M - i2` j2)
                                   (pairZ `M - i0` j0)) i1
                                  j1 next2 result5 Inv0)
                              | (right Test5) =>
                                  let (i1, j1, next2, result5, Inv0) =
                                    let (result5, Bool2) =
                                      let (result7, Post20) =
                                        (Z_eq_bool j0 `0`) in
                                      (exist_1 [result8: bool]
                                      (if result8 then `j0 = 0`
                                       else `j0 <> 0`) result7
                                      Post20) in
                                    (Cases (btest
                                            [result5:bool](if result5
                                                           then `j0 = 0`
                                                           else `j0 <> 0`)
                                            result5 Bool2) of
                                    | (left Test4) =>
                                        let (i1, next2, result6, Inv0) =
                                          let (i1, result6, Post5) =
                                            let (result6, Post5) =
                                              (exist_1 [result6: Z]
                                              result6 = `i0 + 1` `i0 + 1`
                                              (refl_equal ? `i0 + 1`)) in
                                            (exist_2 [i2: Z][result7: unit]
                                            i2 = `i0 + 1` result6 tt Post5) in
                                          let (next2, result7, Post6) =
                                            let (result7, Post6) =
                                              (exist_1 [result7: Z]
                                              (store next1 i1 result7) =
                                              (store next1 i1 `0`) `0`
                                              (refl_equal ? (store next1 i1
                                                             `0`))) in
                                            let Pre6 =
                                              (initnext_po_7 next p result
                                              Post1 result0 Post2 Test8 next0
                                              Post3 Variant1 i0 j0 next1 Pre8
                                              Inv Test7 Test5 Test4 i1 Post5
                                              result7 Post6) in
                                            (exist_2 [next3: (array M Z)]
                                            [result9: unit]
                                            next3 = (store next1 i1 `0`) 
                                            (store next1 i1 result7) 
                                            tt Post6) in
                                          (exist_3 [i2: Z]
                                          [next3: (array M Z)][result8: unit]
                                          ((`0 <= j0` /\ `j0 <= M`) /\
                                          (`j0 < i2` /\ `i2 <= M`) /\
                                          (match p `i2 - j0` p `0` j0) /\
                                          ((z:Z)
                                           (`j0 + 1 < z` /\ `z < i2 + 1` ->
                                            ~(match p `i2 + 1 - z` p `0` z))) /\
                                          ((k:Z)
                                           (`0 < k` /\ `k <= i2` ->
                                            (Next p k (access next3 k))))) /\
                                          (lexZ (pairZ `M - i2` j0)
                                           (pairZ `M - i0` j0)) i1
                                          next2 result7
                                          (initnext_po_8 next p result Post1
                                          result0 Post2 Test8 next0 Post3
                                          Variant1 i0 j0 next1 Pre8 Inv Test7
                                          Test5 Test4 i1 Post5 next2 Post6)) in
                                        (exist_4 [i2: Z][j1: Z]
                                        [next3: (array M Z)][result7: unit]
                                        ((`0 <= j1` /\ `j1 <= M`) /\
                                        (`j1 < i2` /\ `i2 <= M`) /\
                                        (match p `i2 - j1` p `0` j1) /\
                                        ((z:Z)
                                         (`j1 + 1 < z` /\ `z < i2 + 1` ->
                                          ~(match p `i2 + 1 - z` p `0` z))) /\
                                        ((k:Z)
                                         (`0 < k` /\ `k <= i2` ->
                                          (Next p k (access next3 k))))) /\
                                        (lexZ (pairZ `M - i2` j1)
                                         (pairZ `M - i0` j0)) i1
                                        j0 next2 result6 Inv0)
                                    | (right Test3) =>
                                        let Pre5 =
                                          (initnext_po_9 next p result Post1
                                          result0 Post2 Test8 next0 Post3
                                          Variant1 i0 j0 next1 Pre8 Inv Test7
                                          Test5 Test3) in
                                        let (j1, result6, Post4) =
                                          let (result6, Post4) =
                                            (exist_1 [result6: Z]
                                            result6 = (access next1 j0) 
                                            (access next1 j0)
                                            (refl_equal ? (access next1 j0))) in
                                          (exist_2 [j2: Z][result7: unit]
                                          j2 = (access next1 j0) result6 
                                          tt Post4) in
                                        (exist_4 [i1: Z][j2: Z]
                                        [next2: (array M Z)][result7: unit]
                                        ((`0 <= j2` /\ `j2 <= M`) /\
                                        (`j2 < i1` /\ `i1 <= M`) /\
                                        (match p `i1 - j2` p `0` j2) /\
                                        ((z:Z)
                                         (`j2 + 1 < z` /\ `z < i1 + 1` ->
                                          ~(match p `i1 + 1 - z` p `0` z))) /\
                                        ((k:Z)
                                         (`0 < k` /\ `k <= i1` ->
                                          (Next p k (access next2 k))))) /\
                                        (lexZ (pairZ `M - i1` j2)
                                         (pairZ `M - i0` j0)) i0
                                        j1 next1 result6
                                        (initnext_po_10 next p result Post1
                                        result0 Post2 Test8 next0 Post3
                                        Variant1 i0 j0 next1 Pre8 Inv Test7
                                        Test5 Test3 Pre5 j1 Post4)) end) in
                                  (exist_4 [i2: Z][j2: Z][next3: (array M Z)]
                                  [result6: unit]((`0 <= j2` /\ `j2 <= M`) /\
                                  (`j2 < i2` /\ `i2 <= M`) /\
                                  (match p `i2 - j2` p `0` j2) /\
                                  ((z:Z)
                                   (`j2 + 1 < z` /\ `z < i2 + 1` ->
                                    ~(match p `i2 + 1 - z` p `0` z))) /\
                                  ((k:Z)
                                   (`0 < k` /\ `k <= i2` ->
                                    (Next p k (access next3 k))))) /\
                                  (lexZ (pairZ `M - i2` j2)
                                   (pairZ `M - i0` j0)) i1
                                  j1 next2 result5 Inv0) end) in
                            (exist_4 [i2: Z][j2: Z][next3: (array M Z)]
                            [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                            (`j2 < i2` /\ `i2 <= M`) /\
                            (match p `i2 - j2` p `0` j2) /\
                            ((z:Z)
                             (`j2 + 1 < z` /\ `z < i2 + 1` ->
                              ~(match p `i2 + 1 - z` p `0` z))) /\
                            ((k:Z)
                             (`0 < k` /\ `k <= i2` ->
                              (Next p k (access next3 k))))) /\
                            (lexZ (pairZ `M - i2` j2) (pairZ `M - i0` j0)) 
                            i1 j1 next2 result4 Inv0) in
                          ((wf1 (pairZ `M - i1` j1))
                            (initnext_po_11 next p result Post1 result0 Post2
                            Test8 next0 Post3 Variant1 i0 j0 next1 Pre8 Inv
                            Test7 i1 j1 next2 Inv0) i1 j1 next2
                            (refl_equal ? (pairZ `M - i1` j1))
                            (proj1 ? ? Inv0)) in
                        (exist_4 [i2: Z][j2: Z][next3: (array M Z)]
                        [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                        (`j2 < i2` /\ `i2 <= M`) /\
                        (match p `i2 - j2` p `0` j2) /\
                        ((z:Z)
                         (`j2 + 1 < z` /\ `z < i2 + 1` ->
                          ~(match p `i2 + 1 - z` p `0` z))) /\
                        ((k:Z)
                         (`0 < k` /\ `k <= i2` -> (Next p k (access next3 k))))) /\
                        `i2 >= M - 1` i1 j1 next2 result4 Inv0)
                    | (right Test2) =>
                        let (i1, j1, next2, result4, Inv0) = (exist_4 [i1: Z]
                          [j1: Z][next2: (array M Z)][result4: unit]
                          ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 < i1` /\
                          `i1 <= M`) /\ (match p `i1 - j1` p `0` j1) /\
                          ((z:Z)
                           (`j1 + 1 < z` /\ `z < i1 + 1` ->
                            ~(match p `i1 + 1 - z` p `0` z))) /\
                          ((k:Z)
                           (`0 < k` /\ `k <= i1` ->
                            (Next p k (access next2 k))))) /\
                          `i1 >= M - 1` i0 j0 next1 tt
                          (conj ? ? Inv Test2)) in
                        (exist_4 [i2: Z][j2: Z][next3: (array M Z)]
                        [result5: unit]((`0 <= j2` /\ `j2 <= M`) /\
                        (`j2 < i2` /\ `i2 <= M`) /\
                        (match p `i2 - j2` p `0` j2) /\
                        ((z:Z)
                         (`j2 + 1 < z` /\ `z < i2 + 1` ->
                          ~(match p `i2 + 1 - z` p `0` z))) /\
                        ((k:Z)
                         (`0 < k` /\ `k <= i2` -> (Next p k (access next3 k))))) /\
                        `i2 >= M - 1` i1 j1 next2 result4 Inv0) end)
                  (pairZ `M - result` result0) result result0 next0
                  (refl_equal ? (pairZ `M - result` result0))
                  (initnext_po_12 next p result Post1 result0 Post2 Test8
                  next0 Post3)) in
              (exist_4 [i1: Z][j1: Z][next2: (array M Z)][result4: unit]
              ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next2 j)))) 
              i0 j0 next1 result3
              (initnext_po_13 next p result Post1 result0 Post2 Test8 next0
              Post3 i0 j0 next1 Inv)) in
            (exist_4 [i1: Z][j1: Z][next1: (array M Z)][result3: unit]
            ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) 
            i0 j0 next0 result2 Post17)
        | (right Test1) =>
            let (result2, Post16) = (exist_1 [result2: unit]
              ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next j)))) 
              tt (initnext_po_14 next p result Post1 result0 Post2 Test1)) in
            (exist_4 [i0: Z][j0: Z][next0: (array M Z)][result3: unit]
            ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))) 
            result result0 next result2 Post16) end) in
      (exist_3 [i1: Z][next1: (array M Z)][result2: unit]
      ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) i0 
      next0 result1 Post14) in
    (exist_2 [next1: (array M Z)][result1: unit]
    ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) next0 
    result0 Post13).

(*Why*) Parameter N : Z.
Axiom N_positive : `0 <= N`.


Lemma kmp_po_1 : 
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (well_founded ? lexZ).
Proof.
Intros; Exact lexZ_well_founded.
Save.

Lemma kmp_po_2 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test2: `j0 < M`)
  (result3: bool)
  (Bool2: (if result3 then `i0 < N` else `i0 >= N`))
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_3 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test1: `j0 >= M`)
  (result3: bool)
  (Post3: result3 = false)
  (if result3 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false
   else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false).
Proof.
Intuition Induction result3; Tauto.
Save.

Lemma kmp_po_4 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Discriminate H7.
Save.

Lemma kmp_po_5 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Pre2: `0 <= j0` /\ `j0 < M`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma kmp_po_6 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test7: (access a i0) = (access p j0))
  (i1: Z)
  (Post7: i1 = `i0 + 1`)
  (j1: Z)
  (Post8: j1 = `j0 + 1`)
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H7 Orelse Auto with *.
Rewrite Post7; Rewrite Post8.
  Apply match_right_extension.
  Replace `i0+1-(j0+1)` with `i0-j0`. Assumption. Omega'.
  Omega'. Omega'.
  Ring `i0+1-(j0+1)+j0`. Ring `0+j0`. Assumption.
  Replace `i0+1-(j0+1)` with `i0-j0`. 
  Apply (H5 k); Assumption Orelse Omega'.
  Omega'.
  Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_7 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test5: `j0 = 0`)
  (i1: Z)
  (Post6: i1 = `i0 + 1`)
  ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i1` /\ `i1 <= N`) /\
  (match a `i1 - j0` p `0` j0) /\
  ((k:Z) (`0 <= k` /\ `k < i1 - j0` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i1` j0) (pairZ `N - i0` j0)).
Proof.
Intuition Discriminate H7 Orelse Auto with *.
  Rewrite Test5.
  Apply match_empty. Omega'. Omega'.
  Elim (Z_le_lt_eq_dec k `i0-j0`).
  Intro. Apply (H5 k); Assumption Orelse Omega'.
  Intro. Generalize H8. Apply match_contradiction_at_first. Omega'.
  Rewrite b. Rewrite Test5. Ring `i0-0`. Rewrite <- Test5. Assumption.
  Omega'.
Unfold lexZ lex Zwf pairZ. Left; Omega'.
Save.

Lemma kmp_po_8 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  `0 <= j0` /\ `j0 < M`.
Proof.
Intuition.
Discriminate H7.
Save.

Lemma kmp_po_9 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (Test6: ~(access a i0) = (access p j0))
  (Test4: `j0 <> 0`)
  (Pre4: `0 <= j0` /\ `j0 < M`)
  (j1: Z)
  (Post5: j1 = (access next0 j0))
  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i0` /\ `i0 <= N`) /\
  (match a `i0 - j1` p `0` j1) /\
  ((k:Z) (`0 <= k` /\ `k < i0 - j1` -> ~(match a k p `0` M)))) /\
  (lexZ (pairZ `N - i0` j1) (pairZ `N - i0` j0)).
Proof.
Intuition (Assert `j0<>0`; Auto with *).
  (* invariant *)
  Elim (Post15 j0); Intros. Omega'.
  Omega'.
  Elim (Post15 j0); Intros; Omega'.
  Elim (Post15 j0); Intros; Omega'.
  Apply next_iteration with j := j0.
  Omega'.
  Omega'.
  Assumption.
  Rewrite Post5; Apply (Post15 j0); Omega'.
  (* ~(match a k p `0` M) *)
  Elim (Z_lt_ge_dec k `i0-j0`); Intro Hck.
  (* k < i0-j0 *)
  Apply (H7 k); Assumption Orelse Omega'.
  Elim (Z_ge_lt_dec `i0-j0` k); Intro Hck'.
  (* k = i0-j0 *)
  Generalize H10. Replace k with `i0-j0`.
  Apply match_contradiction_at_i with i := j0.
  Omega'. Omega'. Ring `i0-j0+j0`. Ring `0+j0`. Assumption. Omega'. 
  (* i0-j0 < k *)
  Generalize H10.
  Apply next_is_maximal with i := i0 j := j0 n := #next0[j0]. 
  Omega'. Omega'. Omega'.
  Assumption.
  Apply (Post15 j0); Omega'.
  Unfold lexZ lex Zwf pairZ. 
  Elim (Post15 j0). Intros.
  Right. Omega'. Omega'.
Discriminate H9.
Discriminate H9.
Save.

Lemma kmp_po_10 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (Variant1: prodZZ)
  (i0: Z)
  (j0: Z)
  (Pre5: Variant1 = (pairZ `N - i0` j0))
  (Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
  (Test8: `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\ true = false)
  (i1: Z)
  (j1: Z)
  (Inv0: ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
         (match a `i1 - j1` p `0` j1) /\
         ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
         (lexZ (pairZ `N - i1` j1) (pairZ `N - i0` j0)))
  (lexZ (pairZ `N - i1` j1) Variant1).
Proof.
Intuition.
Rewrite Pre5; Assumption.
Rewrite Pre5; Assumption.
Save.

Lemma kmp_po_11 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (`0 <= result0` /\ `result0 <= M`) /\ (`result0 <= result` /\
  `result <= N`) /\ (match a `result - result0` p `0` result0) /\
  ((k:Z) (`0 <= k` /\ `k < result - result0` -> ~(match a k p `0` M))).
Proof.
Intuition.
Generalize M_positive; Omega'.
Generalize N_positive; Omega'.
Rewrite Post1; Rewrite Post2.
Apply match_empty.
Generalize N_positive; Omega'. Generalize M_positive; Omega'.
Absurd `0 <= k`; Omega'.
Save.

Definition first_occur :=
  [p:(array M A)][a:(array N A)][r:Z]  
     (`0 <= r < N` -> (match a r p `0` M))
  /\ ((k:Z) `0 <= k < r` -> ~(match a k p `0` M)).

Lemma kmp_po_12 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test10: `j0 = M`)
  (first_occur p a `i0 - M`).
Proof.
Intros.
Decompose [and] Inv.
Unfold first_occur. 
Split. 
Intro. Rewrite <- Test10. Replace `i0-M` with `i0-j0`. Assumption. Omega'.
Replace `i0-M` with `i0-j0`. Assumption. Omega'.
Save.

Lemma kmp_po_13 : 
  (a: (array N A))
  (p: (array M A))
  (result: Z)
  (Post1: result = `0`)
  (result0: Z)
  (Post2: result0 = `0`)
  (next0: (array M Z))
  (Post15: ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next0 j)))))
  (i0: Z)
  (j0: Z)
  (Inv: ((`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
        (match a `i0 - j0` p `0` j0) /\
        ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))) /\
        (`j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\ false = false))
  (Test9: `j0 <> M`)
  (first_occur p a i0).
Proof.
Intros. Unfold first_occur. Decompose [and] Inv.
Split. 
Intro. Absurd `i0 < N`; Omega'.
Intros k Hk. 
Elim (Z_lt_ge_dec k `i0-j0`); Intro Hk'.
Apply H6; Omega'.
Red; Intro. Decompose [match] H4.
Absurd `k <= N-M`; Omega'.
Save.

Definition kmp := (* validation *)
  [a: (array N A); next: (array M Z); p: (array M A)]
    let (result, Post1) = (exist_1 [result: Z]result = `0` `0`
      (refl_equal ? `0`)) in
    let (i0, next0, result0, Post13) =
      let (result0, Post2) = (exist_1 [result0: Z]result0 = `0` `0`
        (refl_equal ? `0`)) in
      let (i0, j0, next0, result1, Post14) =
        let (next0, result1, Post15) =
          let (next0, result3, Post16) = (initnext tt next p) in
          (exist_2 [next1: (array M Z)][result4: unit]
          ((j:Z) (`0 < j` /\ `j < M` -> (Next p j (access next1 j)))) 
          next0 result3 Post16) in
        let (i0, j0, result2, Inv) =
          (well_founded_induction prodZZ lexZ
            (kmp_po_1 p result Post1 result0 Post2 next0 Post15)
            [Variant1: prodZZ](i0: Z)(j0: Z)
            (_: Variant1 = (pairZ `N - i0` j0))(Inv: (`0 <= j0` /\
            `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
            (match a `i0 - j0` p `0` j0) /\
            ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
            (sig_3 Z Z unit [i1: Z][j1: Z][result2: unit](((`0 <= j1` /\
             `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
             (match a `i1 - j1` p `0` j1) /\
             ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
             (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false)))
            [Variant1: prodZZ; wf1: (Variant2: prodZZ)
             (Pre1: (lexZ Variant2 Variant1))(i0: Z)(j0: Z)
             (_: Variant2 = (pairZ `N - i0` j0))(Inv: (`0 <= j0` /\
             `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
             (match a `i0 - j0` p `0` j0) /\
             ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M))))
             (sig_3 Z Z unit [i1: Z][j1: Z][result2: unit](((`0 <= j1` /\
              `j1 <= M`) /\ (`j1 <= i1` /\ `i1 <= N`) /\
              (match a `i1 - j1` p `0` j1) /\
              ((k:Z) (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
              (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false)));
             i0: Z; j0: Z; Pre5: Variant1 = (pairZ `N - i0` j0);
             Inv: (`0 <= j0` /\ `j0 <= M`) /\ (`j0 <= i0` /\ `i0 <= N`) /\
             (match a `i0 - j0` p `0` j0) /\
             ((k:Z) (`0 <= k` /\ `k < i0 - j0` -> ~(match a k p `0` M)))]
              let (result2, Post4) =
                let (result2, Bool1) =
                  let (result4, Post17) = (Z_lt_ge_bool j0 M) in
                  (exist_1 [result5: bool]
                  (if result5 then `j0 < M` else `j0 >= M`) result4 Post17) in
                (Cases (btest
                        [result2:bool](if result2 then `j0 < M`
                                       else `j0 >= M`)
                        result2 Bool1) of
                | (left Test2) =>
                    let (result3, Bool2) =
                      let (result5, Post18) = (Z_lt_ge_bool i0 N) in
                      (exist_1 [result6: bool]
                      (if result6 then `i0 < N` else `i0 >= N`) result5
                      Post18) in
                    (exist_1 [result4: bool]
                    (if result4 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\
                     true = false else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\
                     false = false) result3
                    (kmp_po_2 a p result Post1 result0 Post2 next0 Post15
                    Variant1 i0 j0 Pre5 Inv Test2 result3 Bool2))
                | (right Test1) =>
                    let (result3, Post3) = (exist_1 [result3: bool]
                      result3 = false false (refl_equal ? false)) in
                    (exist_1 [result4: bool]
                    (if result4 then `j0 < M` /\ `i0 < N` \/ `j0 >= M` /\
                     true = false else `j0 < M` /\ `i0 >= N` \/ `j0 >= M` /\
                     false = false) result3
                    (kmp_po_3 a p result Post1 result0 Post2 next0 Post15
                    Variant1 i0 j0 Pre5 Inv Test1 result3 Post3)) end) in
              (Cases (btest
                      [result2:bool](if result2 then `j0 < M` /\ `i0 < N` \/
                                     `j0 >= M` /\ true = false
                                     else `j0 < M` /\ `i0 >= N` \/
                                     `j0 >= M` /\ false = false)
                      result2 Post4) of
              | (left Test8) =>
                  let (i1, j1, result3, Inv0) =
                    let (i1, j1, result3, Inv0) =
                      let (i1, j1, result3, Inv0) =
                        let (result3, Bool4) =
                          let Pre2 =
                            (kmp_po_4 a p result Post1 result0 Post2 next0
                            Post15 Variant1 i0 j0 Pre5 Inv Test8) in
                          let result4 =
                            let Pre3 =
                              (kmp_po_5 a p result Post1 result0 Post2 next0
                              Post15 Variant1 i0 j0 Pre5 Inv Test8 Pre2) in
                            (A_eq_bool (access a i0)) in
                          let (result5, Post19) = (result4 (access p j0)) in
                          (exist_1 [result6: bool]
                          (if result6 then (access a i0) = (access p j0)
                           else ~(access a i0) = (access p j0)) result5
                          Post19) in
                        (Cases (btest
                                [result3:bool](if result3
                                               then (access a i0) =
                                                    (access p j0)
                                               else ~(access a i0) =
                                                     (access p j0))
                                result3 Bool4) of
                        | (left Test7) =>
                            let (i1, j1, result4, Inv0) =
                              let (i1, result4, Post7) =
                                let (result4, Post7) = (exist_1 [result4: Z]
                                  result4 = `i0 + 1` `i0 + 1`
                                  (refl_equal ? `i0 + 1`)) in
                                (exist_2 [i2: Z][result5: unit]
                                i2 = `i0 + 1` result4 tt Post7) in
                              let (j1, result5, Post8) =
                                let (result5, Post8) = (exist_1 [result5: Z]
                                  result5 = `j0 + 1` `j0 + 1`
                                  (refl_equal ? `j0 + 1`)) in
                                (exist_2 [j2: Z][result6: unit]
                                j2 = `j0 + 1` result5 tt Post8) in
                              (exist_3 [i2: Z][j2: Z][result6: unit]
                              ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                              `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                              ((k:Z)
                               (`0 <= k` /\ `k < i2 - j2` ->
                                ~(match a k p `0` M)))) /\
                              (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                              i1 j1 result5
                              (kmp_po_6 a p result Post1 result0 Post2 next0
                              Post15 Variant1 i0 j0 Pre5 Inv Test8 Test7 i1
                              Post7 j1 Post8)) in
                            (exist_3 [i2: Z][j2: Z][result5: unit]
                            ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                            `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                            ((k:Z)
                             (`0 <= k` /\ `k < i2 - j2` ->
                              ~(match a k p `0` M)))) /\
                            (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                            i1 j1 result4 Inv0)
                        | (right Test6) =>
                            let (i1, j1, result4, Inv0) =
                              let (result4, Bool3) =
                                let (result6, Post20) = (Z_eq_bool j0 `0`) in
                                (exist_1 [result7: bool]
                                (if result7 then `j0 = 0` else `j0 <> 0`) 
                                result6 Post20) in
                              (Cases (btest
                                      [result4:bool](if result4 then `
                                                     j0 = 0` else `j0 <> 0`)
                                      result4 Bool3) of
                              | (left Test5) =>
                                  let (i1, result5, Post6) =
                                    let (result5, Post6) =
                                      (exist_1 [result5: Z]
                                      result5 = `i0 + 1` `i0 + 1`
                                      (refl_equal ? `i0 + 1`)) in
                                    (exist_2 [i2: Z][result6: unit]
                                    i2 = `i0 + 1` result5 tt Post6) in
                                  (exist_3 [i2: Z][j1: Z][result6: unit]
                                  ((`0 <= j1` /\ `j1 <= M`) /\ (`j1 <= i2` /\
                                  `i2 <= N`) /\
                                  (match a `i2 - j1` p `0` j1) /\
                                  ((k:Z)
                                   (`0 <= k` /\ `k < i2 - j1` ->
                                    ~(match a k p `0` M)))) /\
                                  (lexZ (pairZ `N - i2` j1)
                                   (pairZ `N - i0` j0)) i1
                                  j0 result5
                                  (kmp_po_7 a p result Post1 result0 Post2
                                  next0 Post15 Variant1 i0 j0 Pre5 Inv Test8
                                  Test6 Test5 i1 Post6))
                              | (right Test4) =>
                                  let Pre4 =
                                    (kmp_po_8 a p result Post1 result0 Post2
                                    next0 Post15 Variant1 i0 j0 Pre5 Inv
                                    Test8 Test6 Test4) in
                                  let (j1, result5, Post5) =
                                    let (result5, Post5) =
                                      (exist_1 [result5: Z]
                                      result5 = (access next0 j0) (access next0
                                                                   j0)
                                      (refl_equal ? (access next0 j0))) in
                                    (exist_2 [j2: Z][result6: unit]
                                    j2 = (access next0 j0) result5 tt Post5) in
                                  (exist_3 [i1: Z][j2: Z][result6: unit]
                                  ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i1` /\
                                  `i1 <= N`) /\
                                  (match a `i1 - j2` p `0` j2) /\
                                  ((k:Z)
                                   (`0 <= k` /\ `k < i1 - j2` ->
                                    ~(match a k p `0` M)))) /\
                                  (lexZ (pairZ `N - i1` j2)
                                   (pairZ `N - i0` j0)) i0
                                  j1 result5
                                  (kmp_po_9 a p result Post1 result0 Post2
                                  next0 Post15 Variant1 i0 j0 Pre5 Inv Test8
                                  Test6 Test4 Pre4 j1 Post5)) end) in
                            (exist_3 [i2: Z][j2: Z][result5: unit]
                            ((`0 <= j2` /\ `j2 <= M`) /\ (`j2 <= i2` /\
                            `i2 <= N`) /\ (match a `i2 - j2` p `0` j2) /\
                            ((k:Z)
                             (`0 <= k` /\ `k < i2 - j2` ->
                              ~(match a k p `0` M)))) /\
                            (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                            i1 j1 result4 Inv0) end) in
                      (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                      `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                      (match a `i2 - j2` p `0` j2) /\
                      ((k:Z)
                       (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                      (lexZ (pairZ `N - i2` j2) (pairZ `N - i0` j0)) 
                      i1 j1 result3 Inv0) in
                    ((wf1 (pairZ `N - i1` j1))
                      (kmp_po_10 a p result Post1 result0 Post2 next0 Post15
                      Variant1 i0 j0 Pre5 Inv Test8 i1 j1 Inv0) i1 j1
                      (refl_equal ? (pairZ `N - i1` j1)) (proj1 ? ? Inv0)) in
                  (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                  `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                  (match a `i2 - j2` p `0` j2) /\
                  ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                  (`j2 < M` /\ `i2 >= N` \/ `j2 >= M` /\ false = false) 
                  i1 j1 result3 Inv0)
              | (right Test3) =>
                  let (i1, j1, result3, Inv0) = (exist_3 [i1: Z][j1: Z]
                    [result3: unit]((`0 <= j1` /\ `j1 <= M`) /\
                    (`j1 <= i1` /\ `i1 <= N`) /\
                    (match a `i1 - j1` p `0` j1) /\
                    ((k:Z)
                     (`0 <= k` /\ `k < i1 - j1` -> ~(match a k p `0` M)))) /\
                    (`j1 < M` /\ `i1 >= N` \/ `j1 >= M` /\ false = false) 
                    i0 j0 tt (conj ? ? Inv Test3)) in
                  (exist_3 [i2: Z][j2: Z][result4: unit]((`0 <= j2` /\
                  `j2 <= M`) /\ (`j2 <= i2` /\ `i2 <= N`) /\
                  (match a `i2 - j2` p `0` j2) /\
                  ((k:Z) (`0 <= k` /\ `k < i2 - j2` -> ~(match a k p `0` M)))) /\
                  (`j2 < M` /\ `i2 >= N` \/ `j2 >= M` /\ false = false) 
                  i1 j1 result3 Inv0) end) (pairZ `N - result` result0)
            result result0 (refl_equal ? (pairZ `N - result` result0))
            (kmp_po_11 a p result Post1 result0 Post2 next0 Post15)) in
        let (result3, Post21) =
          let (result3, Bool5) =
            let (result5, Post22) = (Z_eq_bool j0 M) in
            (exist_1 [result6: bool]
            (if result6 then `j0 = M` else `j0 <> M`) result5 Post22) in
          (Cases (btest
                  [result3:bool](if result3 then `j0 = M` else `j0 <> M`)
                  result3 Bool5) of
          | (left Test10) =>
              let (result4, Post24) = (exist_1 [result4: Z]
                (first_occur p a result4) `i0 - M`
                (kmp_po_12 a p result Post1 result0 Post2 next0 Post15 i0 j0
                Inv Test10)) in
              (exist_1 [result5: Z](first_occur p a result5) result4 Post24)
          | (right Test9) =>
              let (result4, Post23) = (exist_1 [result4: Z]
                (first_occur p a result4) i0
                (kmp_po_13 a p result Post1 result0 Post2 next0 Post15 i0 j0
                Inv Test9)) in
              (exist_1 [result5: Z](first_occur p a result5) result4 Post23) end) in
        (exist_4 [i1: Z][j1: Z][next1: (array M Z)][result4: Z]
        (first_occur p a result4) i0 j0 next0 result3 Post21) in
      (exist_3 [i1: Z][next1: (array M Z)][result2: Z]
      (first_occur p a result2) i0 next0 result1 Post14) in
    (exist_2 [next1: (array M Z)][result1: Z](first_occur p a result1) 
    next0 result0 Post13).

