(* Load Programs. *)(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Export Match.

(*Why*) Parameter OUTPUT : forall j:Z, unit.

(*Why*) Parameter
          memcmp :
            forall (i j n:Z) (x y:array Z),
              sig_1 Z
                (fun result:Z =>
                   (result = 0%Z -> match_ x i y j n) /\
                   (result <> 0%Z -> ~ match_ x i y j n)).

(* Why obligation from file , characters 520-524 *)
Lemma NSN_po_1 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z),
   (0 <= 0)%Z /\ (0 < array_length x)%Z.
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 528-532 *)
Lemma NSN_po_2 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z)
   (Pre2:(0 <= 0)%Z /\ (0 < array_length x)%Z) (c_aux_1:Z)
   (Post2:c_aux_1 = access x 0), (0 <= 1)%Z /\ (1 < array_length x)%Z.
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 520-532 *)
Lemma NSN_po_3 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z)
   (Pre2:(0 <= 0)%Z /\ (0 < array_length x)%Z) (c_aux_1:Z)
   (Post2:c_aux_1 = access x 0)
   (Pre1:(0 <= 1)%Z /\ (1 < array_length x)%Z) (c_aux_2:Z)
   (Post1:c_aux_2 = access x 1) (result:bool)
   (Post27:if result then c_aux_1 = c_aux_2 else c_aux_1 <> c_aux_2),
   if result
   then
    forall k:Z,
      k = 2%Z ->
      forall ell:Z,
        ell = 1%Z ->
        (forall j:Z, j = 0%Z -> (0 <= j)%Z) /\ (k > 0)%Z /\ (ell > 0)%Z
   else
    forall k:Z,
      k = 1%Z ->
      forall ell:Z,
        ell = 2%Z ->
        (forall j:Z, j = 0%Z -> (0 <= j)%Z) /\ (k > 0)%Z /\ (ell > 0)%Z.
Proof.
olddestruct result; intuition.
Qed.

(* Why obligation from file , characters 757-761 *)
Lemma NSN_po_4 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z) (ell1 k1:Z)
   (Pre11:(k1 > 0)%Z /\ (ell1 > 0)%Z) (j1:Z) (Post7:j1 = 0%Z)
   (Variant1 j2:Z) (Pre10:Variant1 = (n - m - j2)%Z) (Pre9:(0 <= j2)%Z)
   (Test2:(j2 <= n - m)%Z), (0 <= 1)%Z /\ (1 < array_length x)%Z.
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 765-773 *)
Lemma NSN_po_5 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z) (ell1 k1:Z)
   (Pre11:(k1 > 0)%Z /\ (ell1 > 0)%Z) (j1:Z) (Post7:j1 = 0%Z)
   (Variant1 j2:Z) (Pre10:Variant1 = (n - m - j2)%Z) (Pre9:(0 <= j2)%Z)
   (Test2:(j2 <= n - m)%Z) (Pre5:(0 <= 1)%Z /\ (1 < array_length x)%Z)
   (c_aux_7:Z) (Post9:c_aux_7 = access x 1),
   (0 <= j2 + 1)%Z /\ (j2 + 1 < array_length y)%Z.
Proof.
intuition.
Qed.

(* Why obligation from file , characters 757-773 *)
Lemma NSN_po_6 :
 forall (m n:Z) (x y:array Z)
   (Pre12:array_length x = m /\
          array_length y = n /\ (0 <= n)%Z /\ (2 <= m)%Z) (ell1 k1:Z)
   (Pre11:(k1 > 0)%Z /\ (ell1 > 0)%Z) (j1:Z) (Post7:j1 = 0%Z)
   (Variant1 j2:Z) (Pre10:Variant1 = (n - m - j2)%Z) (Pre9:(0 <= j2)%Z)
   (Test2:(j2 <= n - m)%Z) (Pre5:(0 <= 1)%Z /\ (1 < array_length x)%Z)
   (c_aux_7:Z) (Post9:c_aux_7 = access x 1)
   (Pre4:(0 <= j2 + 1)%Z /\ (j2 + 1 < array_length y)%Z) (c_aux_8:Z)
   (Post8:c_aux_8 = access y (j2 + 1)) (result3:bool)
   (Post30:if result3 then c_aux_7 <> c_aux_8 else c_aux_7 = c_aux_8),
   if result3
   then
    forall j:Z,
      j = (j2 + k1)%Z -> (0 <= j)%Z /\ Zwf 0 (n - m - j) (n - m - j2)
   else
    forall result:Z,
      result = (j2 + 2)%Z ->
      forall result0:Z,
        (result0 = 0%Z -> match_ x 2 y result (m - 2)) /\
        (result0 <> 0%Z -> ~ match_ x 2 y result (m - 2)) ->
        (result0 = 0%Z ->
         (forall result:Z,
            result = access x 0 ->
            (forall result0:Z,
               result0 = access y j2 ->
               (result = result0 ->
                (forall j:Z,
                   j = (j2 + ell1)%Z ->
                   (0 <= j)%Z /\ Zwf 0 (n - m - j) (n - m - j2)) /\
                match_ x 0 y j2 (array_length x)) /\
               (result <> result0 ->
                forall j:Z,
                  j = (j2 + ell1)%Z ->
                  (0 <= j)%Z /\ Zwf 0 (n - m - j) (n - m - j2))) /\
            (0 <= j2)%Z /\ (j2 < array_length y)%Z) /\
         (0 <= 0)%Z /\ (0 < array_length x)%Z) /\
        (result0 <> 0%Z ->
         forall j:Z,
           j = (j2 + ell1)%Z ->
           (0 <= j)%Z /\ Zwf 0 (n - m - j) (n - m - j2)).
Proof.
olddestruct result3; unfold Zwf; intuition.
subst.
apply match_left_extension; try omega.
apply match_left_extension; try omega.
assumption.
replace (j2 + 1 + 1)%Z with (j2 + 2)%Z; try omega.
replace (array_length x - 1 - 1)%Z with (m - 2)%Z; try omega.
assumption.
Qed.

