(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Export Match.

(*Why*) Parameter OUTPUT : (j: Z)unit.

(*Why*) Parameter memcmp :
  (i: Z)(j: Z)(n: Z)(x: (array Z))(y: (array Z))
  (sig_1 Z [result: Z](((`result = 0` -> (match x i y j n))) /\
   ((`result <> 0` -> ~(match x i y j n))))).

(* Why obligation from file "not_so_naive.c", characters 520-524 *)
Lemma NSN_po_1 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  `0 <= 0` /\ `0 < (array_length x)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "not_so_naive.c", characters 528-532 *)
Lemma NSN_po_2 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  (Pre2: `0 <= 0` /\ `0 < (array_length x)`)
  (c_aux_1: Z)
  (Post2: c_aux_1 = (access x `0`))
  `0 <= 1` /\ `1 < (array_length x)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "not_so_naive.c", characters 520-532 *)
Lemma NSN_po_3 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  (Pre2: `0 <= 0` /\ `0 < (array_length x)`)
  (c_aux_1: Z)
  (Post2: c_aux_1 = (access x `0`))
  (Pre1: `0 <= 1` /\ `1 < (array_length x)`)
  (c_aux_2: Z)
  (Post1: c_aux_2 = (access x `1`))
  (result2: bool)
  (Post28: (if result2 then `c_aux_1 = c_aux_2` else `c_aux_1 <> c_aux_2`))
  (if result2
   then ((k:Z)
         (k = `2` ->
          ((ell:Z)
           (ell = `1` -> ((j:Z) (j = `0` -> `0 <= j`)) /\ `k > 0` /\
            `ell > 0`))))
   else ((k:Z)
         (k = `1` ->
          ((ell:Z)
           (ell = `2` -> ((j:Z) (j = `0` -> `0 <= j`)) /\ `k > 0` /\
            `ell > 0`))))).
Proof.
Destruct result2; Intuition.
Save.

(* Why obligation from file "not_so_naive.c", characters 757-761 *)
Lemma NSN_po_4 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  (ell0: Z)
  (k0: Z)
  (Pre11: `k0 > 0` /\ `ell0 > 0`)
  (j0: Z)
  (Post7: j0 = `0`)
  (Variant1: Z)
  (j1: Z)
  (Pre10: Variant1 = `n - m - j1`)
  (Pre9: `0 <= j1`)
  (Test2: `j1 <= n - m`)
  `0 <= 1` /\ `1 < (array_length x)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "not_so_naive.c", characters 765-773 *)
Lemma NSN_po_5 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  (ell0: Z)
  (k0: Z)
  (Pre11: `k0 > 0` /\ `ell0 > 0`)
  (j0: Z)
  (Post7: j0 = `0`)
  (Variant1: Z)
  (j1: Z)
  (Pre10: Variant1 = `n - m - j1`)
  (Pre9: `0 <= j1`)
  (Test2: `j1 <= n - m`)
  (Pre5: `0 <= 1` /\ `1 < (array_length x)`)
  (c_aux_8: Z)
  (Post9: c_aux_8 = (access x `1`))
  `0 <= j1 + 1` /\ `j1 + 1 < (array_length y)`.
Proof.
Intuition.
Save.

(* Why obligation from file "not_so_naive.c", characters 757-773 *)
Lemma NSN_po_6 : 
  (m: Z)
  (n: Z)
  (x: (array Z))
  (y: (array Z))
  (Pre12: `(array_length x) = m` /\ `(array_length y) = n` /\ `0 <= n` /\
          `2 <= m`)
  (ell0: Z)
  (k0: Z)
  (Pre11: `k0 > 0` /\ `ell0 > 0`)
  (j0: Z)
  (Post7: j0 = `0`)
  (Variant1: Z)
  (j1: Z)
  (Pre10: Variant1 = `n - m - j1`)
  (Pre9: `0 <= j1`)
  (Test2: `j1 <= n - m`)
  (Pre5: `0 <= 1` /\ `1 < (array_length x)`)
  (c_aux_8: Z)
  (Post9: c_aux_8 = (access x `1`))
  (Pre4: `0 <= j1 + 1` /\ `j1 + 1 < (array_length y)`)
  (c_aux_9: Z)
  (Post8: c_aux_9 = (access y `j1 + 1`))
  (result6: bool)
  (Post31: (if result6 then `c_aux_8 <> c_aux_9` else `c_aux_8 = c_aux_9`))
  (if result6
   then ((j:Z)
         (j = `j1 + k0` -> `0 <= j` /\ (Zwf `0` `n - m - j` `n - m - j1`)))
   else ((result:Z)
         (result = `j1 + 2` ->
          ((result0:Z)
           (((`result0 = 0` -> (match x `2` y result `m - 2`))) /\
            ((`result0 <> 0` -> ~(match x `2` y result `m - 2`))) ->
            ((`result0 = 0` ->
              ((result:Z)
               (result = (access x `0`) ->
                ((result0:Z)
                 (result0 = (access y j1) ->
                  ((`result = result0` ->
                    ((result:Z)
                     (result = j1 ->
                      ((j:Z)
                       (j = `j1 + ell0` -> `0 <= j` /\
                        (Zwf `0` `n - m - j` `n - m - j1`))) /\
                      (match x `0` y j1 (array_length x)))))) /\
                  ((`result <> result0` ->
                    ((j:Z)
                     (j = `j1 + ell0` -> `0 <= j` /\
                      (Zwf `0` `n - m - j` `n - m - j1`))))))) /\
                `0 <= j1` /\ `j1 < (array_length y)`)) /\
              `0 <= 0` /\ `0 < (array_length x)`)) /\
            ((`result0 <> 0` ->
              ((j:Z)
               (j = `j1 + ell0` -> `0 <= j` /\
                (Zwf `0` `n - m - j` `n - m - j1`)))))))))).
Proof.
Destruct result6; Unfold Zwf; Intuition.
Subst.
Apply match_left_extension; Try Omega.
Apply match_left_extension; Try Omega.
Assumption.
Replace `j1+1+1` with `j1+2`; Try Omega.
Replace `(array_length x)-1-1` with `m-2`; Try Omega.
Assumption.
Save.

