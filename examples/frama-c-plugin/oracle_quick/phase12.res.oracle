rm -f phase12.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only phase12.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat phase12.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag enum___anonenum_T_RESULTAT_1_P = {
  __anonenum_T_RESULTAT_1 enum___anonenum_T_RESULTAT_1_M;
}

type enum___anonenum_T_RESULTAT_1_P = [enum___anonenum_T_RESULTAT_1_P]

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag void_P = {
}

type void_P = [void_P]

type __anonenum_T_RESULTAT_1 = 0..1

type __anonenum_T_ID_TEST_2 = 0..1

logic int32 strlen{L}(char_P[..] s) reads (s + [0..]).char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      ((((0 <= k) && (k <= i)) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

uint32 __ConsignerPanne_cpt;

enum___anonenum_T_RESULTAT_1_P[..] __ConsignerPanne_v0;

uint32 __TT0_cpt;

enum___anonenum_T_RESULTAT_1_P[..] __TT0_v0;

uint32 __TT1_cpt;

enum___anonenum_T_RESULTAT_1_P[..] __TT1_v0;

logic f_cond0{L}(enum___anonenum_T_RESULTAT_1_P[..] testv0, integer cpt) =
((testv0 + cpt).enum___anonenum_T_RESULTAT_1_M == 1)

logic f_cond1{L}(enum___anonenum_T_RESULTAT_1_P[..] testv0, integer cpt) =
((testv0 + cpt).enum___anonenum_T_RESULTAT_1_M == 0)

logic f_cond_OK{L}(enum___anonenum_T_RESULTAT_1_P[..] testv0, integer cpt,
                   integer cpt_panne) reads (testv0 + cpt).enum___anonenum_T_RESULTAT_1_M,
(__ConsignerPanne_v0 + cpt_panne).enum___anonenum_T_RESULTAT_1_M;

__anonenum_T_RESULTAT_1 TesterOK(enum___anonenum_T_RESULTAT_1_P[..] status,
                                 __anonenum_T_ID_TEST_2 id_test)
  requires (C_1 : ((C_2 : (\offset_min(status) <= 0)) &&
                    (C_3 : (\offset_max(status) >= 0))));
behavior default_1:
  assumes true;
  assigns status.enum___anonenum_T_RESULTAT_1_M,
  __ConsignerPanne_cpt,
  __TT0_cpt,
  __TT1_cpt;
  ensures (C_4 : ((C_5 : (\old(__ConsignerPanne_cpt) <= __ConsignerPanne_cpt)) &&
                   (C_6 : (__ConsignerPanne_cpt <=
                            (\old(__ConsignerPanne_cpt) + 1)))));
behavior T0:
  assumes ((id_test == 0) && (status.enum___anonenum_T_RESULTAT_1_M == 1));
  assigns status.enum___anonenum_T_RESULTAT_1_M,
  __ConsignerPanne_cpt,
  __TT0_cpt;
  ensures (C_7 : (f_cond_OK{Here}(__TT0_v0, \old(__TT0_cpt),
                                  \old(__ConsignerPanne_cpt)) ==>
                   (status.enum___anonenum_T_RESULTAT_1_M == 1)));
behavior T1:
  assumes ((id_test == 1) && (status.enum___anonenum_T_RESULTAT_1_M == 1));
  assigns status.enum___anonenum_T_RESULTAT_1_M,
  __ConsignerPanne_cpt,
  __TT1_cpt;
  ensures (C_8 : (f_cond_OK{Here}(__TT1_v0, \old(__TT1_cpt),
                                  \old(__ConsignerPanne_cpt)) ==>
                   (status.enum___anonenum_T_RESULTAT_1_M == 1)));
;

uint32 __ConsignerPanne_cpt_t0;

uint32 __ConsignerPanne_cpt_t1;

__anonenum_T_RESULTAT_1 phase1()
  requires (C_20 : ((C_21 : (\offset_min(__TT0_v0) <= __TT0_cpt)) &&
                     (C_22 : (\offset_max(__TT0_v0) >= (__TT0_cpt + 1)))));
  requires (C_23 : ((C_24 : (\offset_min(__TT1_v0) <= __TT1_cpt)) &&
                     (C_25 : (\offset_max(__TT1_v0) >= (__TT1_cpt + 1)))));
  requires (C_26 : ((C_27 : (\offset_min(__ConsignerPanne_v0) <=
                              __ConsignerPanne_cpt)) &&
                     (C_28 : (\offset_max(__ConsignerPanne_v0) >=
                               (__ConsignerPanne_cpt + 1)))));
behavior default_2:
  assumes true;
  ensures (C_29 : ((f_cond_OK{Here}(__TT0_v0, \old(__TT0_cpt),
                                    __ConsignerPanne_cpt_t0) &&
                     f_cond_OK{Here}(__TT1_v0, \old(__TT1_cpt),
                                     __ConsignerPanne_cpt_t1)) ==>
                    (\result == 1)));
{  
   (var enum___anonenum_T_RESULTAT_1_P[0] Rl_Status);
   
   {  (C_10 : (Rl_Status = (C_9 : (new enum___anonenum_T_RESULTAT_1_P[1]))));
      (C_12 : ((C_11 : Rl_Status.enum___anonenum_T_RESULTAT_1_M) = 1));
      (C_13 : (__ConsignerPanne_cpt_t0 = __ConsignerPanne_cpt));
      (C_14 : TesterOK(Rl_Status, 0));
      
      {  
         (assert (C_15 : (f_cond_OK{Here}(__TT0_v0, \at(__TT0_cpt,Pre),
                                          __ConsignerPanne_cpt_t0) ==>
                           (Rl_Status.enum___anonenum_T_RESULTAT_1_M == 1))));
         ()
      };
      (C_16 : (__ConsignerPanne_cpt_t1 = __ConsignerPanne_cpt));
      (C_17 : TesterOK(Rl_Status, 1));
      
      {  (C_18 : (free(Rl_Status)));
         
         (return (C_19 : Rl_Status.enum___anonenum_T_RESULTAT_1_M))
      }
   }
}
