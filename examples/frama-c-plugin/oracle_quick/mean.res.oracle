rm -f mean.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only mean.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat mean.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

axiom mean_1 :
(\forall int32 x;
  ((0 <= x) ==> ((0 <= (x / 2)) && ((x / 2) <= x))))

int32 mean(int32 l, int32 r)
  requires (C_8 : ((C_9 : (0 <= l)) && (C_10 : (l <= r))));
{  
   (var int32 __retres);
   
   {  (C_7 : (__retres = (C_6 : ((C_5 : (l +
                                          (C_4 : ((C_3 : ((C_2 : ((C_1 : 
                                                                  (r -
                                                                    l)) :> int32)) /
                                                           2)) :> int32)))) :> int32))));
      
      (return __retres)
   }
}

uint32 umean(uint32 l, uint32 r)
  requires (C_21 : (l <= r));
{  
   (var uint32 __retres);
   
   {  
      {  
         (assert (C_11 : ((C_12 : (0 <= ((r - l) / 2))) &&
                           (C_13 : (((r - l) / 2) <= (r - l))))));
         ()
      };
      (C_20 : (__retres = (C_19 : ((C_18 : (l +
                                             (C_17 : ((C_16 : ((C_15 : (
                                                               (C_14 : 
                                                               (r -
                                                                 l)) :> uint32)) /
                                                                2)) :> uint32)))) :> uint32))));
      
      (return __retres)
   }
}

int32 min_int(int32 x, int32 y)
behavior default:
  assumes true;
  ensures (C_22 : (((\result == x) && (x <= y)) ||
                    ((\result == y) && (y <= x))));
;

int32 max_int(int32 x, int32 y)
behavior default_1:
  assumes true;
  ensures (C_23 : (((\result == x) && (x >= y)) ||
                    ((\result == y) && (y >= x))));
;

int32 mean2(int32 x, int32 y)
  requires (C_35 : ((C_36 : (0 <= x)) && (C_37 : (0 <= y))));
{  
   (var int32 min);
   
   (var int32 max);
   
   (var int32 __retres);
   
   {  (C_25 : (min = (C_24 : min_int(x, y))));
      (C_27 : (max = (C_26 : max_int(x, y))));
      (C_34 : (__retres = (C_33 : ((C_32 : (min +
                                             (C_31 : ((C_30 : ((C_29 : (
                                                               (C_28 : 
                                                               (max -
                                                                 min)) :> int32)) /
                                                                2)) :> int32)))) :> int32))));
      
      (return __retres)
   }
}
