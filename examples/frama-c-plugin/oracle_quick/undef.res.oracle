rm -f undef.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only undef.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat undef.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag int_P = {
  int32 int_M;
}

type int_P = [int_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

invariant valid_a :
((\offset_min(a) <= 0) && (\offset_max(a) >= 1))

invariant valid___string_abc :
((\offset_min(__string_abc) <= 0) && (\offset_max(__string_abc) >= 3))

char_P[0..3] __string_abc;

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

int32 div0_wrong(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  (C_3 : (__retres = (C_2 : ((C_1 : (x / 0)) :> int32))));
      
      (return __retres)
   }
}

int32 div0_unsafe(int32 x, int32 y)
  requires (C_7 : (y != 0));
{  
   (var int32 __retres);
   
   {  (C_6 : (__retres = (C_5 : ((C_4 : (x / y)) :> int32))));
      
      (return __retres)
   }
}

int32 div0_unsafe_pos(int32 x, int32 y)
  requires (C_11 : (y > 0));
{  
   (var int32 __retres);
   
   {  (C_10 : (__retres = (C_9 : ((C_8 : (x / y)) :> int32))));
      
      (return __retres)
   }
}

int32 div0_safe(int32 x, int32 y)
  requires (C_16 : true);
{  
   (var int32 __retres);
   
   {  (if (y == 0) then 
      {  (C_15 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_14 : (__retres = (C_13 : ((C_12 : (x / y)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 div0_safe_pos(int32 x, int32 y)
  requires (C_21 : true);
{  
   (var int32 __retres);
   
   {  (if (y <= 0) then 
      {  (C_20 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_19 : (__retres = (C_18 : ((C_17 : (x / y)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

uint32 udiv0_wrong(uint32 x, uint32 y)
{  
   (var uint32 __retres);
   
   {  (C_24 : (__retres = (C_23 : ((C_22 : (x / 0)) :> uint32))));
      
      (return __retres)
   }
}

uint32 udiv0_unsafe(uint32 x, uint32 y)
  requires (C_28 : (y != 0));
{  
   (var uint32 __retres);
   
   {  (C_27 : (__retres = (C_26 : ((C_25 : (x / y)) :> uint32))));
      
      (return __retres)
   }
}

uint32 udiv0_safe(uint32 x, uint32 y)
  requires (C_33 : true);
{  
   (var uint32 __retres);
   
   {  (if (y == 0) then 
      {  (C_32 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_31 : (__retres = (C_30 : ((C_29 : (x / y)) :> uint32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 mod0_wrong(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  (C_36 : (__retres = (C_35 : ((C_34 : (x % 0)) :> int32))));
      
      (return __retres)
   }
}

int32 mod0_unsafe(int32 x, int32 y)
  requires (C_40 : (y != 0));
{  
   (var int32 __retres);
   
   {  (C_39 : (__retres = (C_38 : ((C_37 : (x % y)) :> int32))));
      
      (return __retres)
   }
}

int32 mod0_safe(int32 x, int32 y)
  requires (C_45 : true);
{  
   (var int32 __retres);
   
   {  (if (y == 0) then 
      {  (C_44 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_43 : (__retres = (C_42 : ((C_41 : (x % y)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 shift_left_signed_wrong_1(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_46 : (32 < 32)));
         
         (assert (C_47 : (x >= 0)));
         
         (assert (C_48 : (x <= 0)));
         (C_51 : (__retres = (C_50 : ((C_49 : (x * 4294967296)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_left_signed_wrong_2(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_52 : (-1 >= 0)));
         
         (assert (C_53 : (x >= 0)));
         
         (assert (C_54 : (x <= (2147483647 >>> -1))));
         (C_57 : (__retres = (C_56 : ((C_55 : (x << -1)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_left_signed_wrong_3(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  (C_58 : (__retres = -64));
      
      (return __retres)
   }
}

int32 shift_left_signed_unsafe(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_59 : (y >= 0)));
         
         (assert (C_60 : (y < 32)));
         
         (assert (C_61 : (x >= 0)));
         
         (assert (C_62 : (x <= (2147483647 >>> y))));
         (C_65 : (__retres = (C_64 : ((C_63 : (x << y)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_left_signed_safe(int32 x, int32 y)
  requires (C_86 : true);
{  
   (var int32 __retres);
   
   {  (if (x < 0) then 
      {  (C_81 : (__retres = 0));
         
         (goto return_label)
      } else (if (y < 0) then 
             {  (C_80 : (__retres = 0));
                
                (goto return_label)
             } else (if ((C_79 : (y :> uint32)) >= 32) then 
                    {  (C_78 : (__retres = 0));
                       
                       (goto return_label)
                    } else 
                    {  
                       (assert (C_66 : (y >= 0)));
                       
                       (assert (C_67 : (y < 32)));
                       (if (x >
                             (C_77 : ((C_76 : (2147483647 >>> y)) :> int32))) then 
                       {  (C_75 : (__retres = 0));
                          
                          (goto return_label)
                       } else 
                       {  
                          {  
                             (assert (C_68 : (y >= 0)));
                             
                             (assert (C_69 : (y < 32)));
                             
                             (assert (C_70 : (x >= 0)));
                             
                             (assert (C_71 : (x <= (2147483647 >>> y))));
                             (C_74 : (__retres = (C_73 : ((C_72 : (x << y)) :> int32))))
                          };
                          
                          (goto return_label)
                       })
                    })));
      
      (goto _L_1);
      (C_82 : (__retres = 0));
      
      (goto return_label);
      (_L_1 : ());
      
      (goto _L_0);
      (C_83 : (__retres = 0));
      
      (goto return_label);
      (_L_0 : ());
      
      (goto _L);
      (C_84 : (__retres = 0));
      
      (goto return_label);
      (_L : ());
      (C_85 : (__retres = 0));
      (return_label : 
      (return __retres))
   }
}

uint32 shift_left_unsigned_wrong(uint32 x, uint32 y)
{  
   (var uint32 __retres);
   
   {  
      {  
         (assert (C_87 : (32 < 32)));
         (C_90 : (__retres = (C_89 : ((C_88 : (x * 4294967296)) :> uint32))))
      };
      
      (return __retres)
   }
}

uint32 shift_left_unsigned_unsafe(uint32 x, uint32 y)
{  
   (var uint32 __retres);
   
   {  
      {  
         (assert (C_91 : (y < 32)));
         (C_94 : (__retres = (C_93 : ((C_92 : (x << y)) :> uint32))))
      };
      
      (return __retres)
   }
}

uint32 shift_left_unsigned_safe(uint32 x, uint32 y)
  requires (C_100 : true);
{  
   (var uint32 __retres);
   
   {  (if (y >= 32) then 
      {  (C_99 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  
         {  
            (assert (C_95 : (y < 32)));
            (C_98 : (__retres = (C_97 : ((C_96 : (x << y)) :> uint32))))
         };
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 shift_right_signed_wrong_1(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_101 : (-1 >= 0)));
         (C_104 : (__retres = (C_103 : ((C_102 : (x >>> -1)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_right_signed_wrong_2(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_105 : (32 < 32)));
         (C_108 : (__retres = (C_107 : ((C_106 : (x / 4294967296)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_right_signed_unsafe(int32 x, int32 y)
{  
   (var int32 __retres);
   
   {  
      {  
         (assert (C_109 : (y >= 0)));
         
         (assert (C_110 : (y < 32)));
         (C_113 : (__retres = (C_112 : ((C_111 : (x >>> y)) :> int32))))
      };
      
      (return __retres)
   }
}

int32 shift_right_signed_safe(int32 x, int32 y)
  requires (C_124 : true);
{  
   (var int32 __retres);
   
   {  (if (y < 0) then 
      {  (C_121 : (__retres = 0));
         
         (goto return_label)
      } else (if ((C_120 : (y :> uint32)) >= 32) then 
             {  (C_119 : (__retres = 0));
                
                (goto return_label)
             } else 
             {  
                {  
                   (assert (C_114 : (y >= 0)));
                   
                   (assert (C_115 : (y < 32)));
                   (C_118 : (__retres = (C_117 : ((C_116 : (x >>> y)) :> int32))))
                };
                
                (goto return_label)
             }));
      
      (goto _L);
      (C_122 : (__retres = 0));
      
      (goto return_label);
      (_L : ());
      (C_123 : (__retres = 0));
      (return_label : 
      (return __retres))
   }
}

uint32 shift_right_unsigned_wrong(uint32 x, uint32 y)
{  
   (var uint32 __retres);
   
   {  
      {  
         (assert (C_125 : (32 < 32)));
         (C_128 : (__retres = (C_127 : ((C_126 : (x / 4294967296)) :> uint32))))
      };
      
      (return __retres)
   }
}

uint32 shift_right_unsigned_unsafe(uint32 x, uint32 y)
{  
   (var uint32 __retres);
   
   {  
      {  
         (assert (C_129 : (y < 32)));
         (C_132 : (__retres = (C_131 : ((C_130 : (x >> y)) :> uint32))))
      };
      
      (return __retres)
   }
}

uint32 shift_right_unsigned_safe(uint32 x, uint32 y)
  requires (C_138 : true);
{  
   (var uint32 __retres);
   
   {  (if (y >= 32) then 
      {  (C_137 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  
         {  
            (assert (C_133 : (y < 32)));
            (C_136 : (__retres = (C_135 : ((C_134 : (x >> y)) :> uint32))))
         };
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 null_ptr_wrong(int_P[..] x)
{  
   (var int32 __retres);
   
   {  (C_139 : (x = null));
      (C_141 : (__retres = (C_140 : x.int_M)));
      
      (return __retres)
   }
}

int32 null_ptr_unsafe(int_P[..] x)
  requires (C_144 : ((C_145 : (\offset_min(x) <= 0)) &&
                      (C_146 : (\offset_max(x) >= 0))));
{  
   (var int32 __retres);
   
   {  (C_143 : (__retres = (C_142 : x.int_M)));
      
      (return __retres)
   }
}

int32 null_ptr_safe(int_P[..] x)
  requires (C_150 : (((\offset_min(x) <= 0) && (\offset_max(x) >= 0)) ||
                      (x == null)));
{  
   (var int32 __retres);
   
   {  (if (x == null) then 
      {  (C_149 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_148 : (__retres = (C_147 : x.int_M)));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int_P[..] bad_local_pointer()
behavior default:
  assumes true;
  ensures (C_155 : ((C_156 : (\offset_min(\result) <= 0)) &&
                     (C_157 : (\offset_max(\result) >= 0))));
{  
   (var int_P[0] x);
   
   (var int_P[..] __retres);
   
   {  (C_152 : (x = (C_151 : (new int_P[1]))));
      (C_153 : (__retres = x));
      
      {  (C_154 : (free(x)));
         
         (return __retres)
      }
   }
}

int32 stack_access_wrong()
{  
   (var int_P[..] x);
   
   (var int32 __retres);
   
   {  (C_159 : (x = (C_158 : bad_local_pointer())));
      (C_161 : (__retres = (C_160 : x.int_M)));
      
      (return __retres)
   }
}

int32 ptr_sub_wrong()
{  
   (var int_P[0..19] a_0);
   
   (var int_P[0..9] b);
   
   (var int_P[..] x);
   
   (var int_P[..] y);
   
   (var int32 __retres);
   
   (var int32 __jc_off_x);
   
   (var int32 __jc_off_y);
   
   {  (C_163 : (a_0 = (C_162 : (new int_P[20]))));
      (C_165 : (b = (C_164 : (new int_P[10]))));
      (C_166 : (__jc_off_x = 2));
      (C_167 : (__jc_off_y = 0));
      (C_172 : (__retres = (C_171 : ((C_170 : ((C_169 : (a_0 + __jc_off_x)) -
                                                (C_168 : (b + __jc_off_y)))) :> int32))));
      
      {  (C_173 : (free(a_0)));
         (C_174 : (free(b)));
         
         (return __retres)
      }
   }
}

int32 ptr_sub_unsafe(int_P[..] x, int_P[..] y)
  requires (C_181 : (((C_183 : (\offset_min(x) <= 0)) &&
                       (C_184 : (\offset_max(x) >= 0))) &&
                      ((C_186 : (\offset_min(y) <= 0)) &&
                        (C_187 : (\offset_max(y) >= 0)))));
{  
   (var int32 __retres);
   
   (var int32 __jc_off_y_1);
   
   {  (C_177 : (__jc_off_y_1 = (C_176 : ((C_175 : (y - x)) :> int32))));
      (C_180 : (__retres = (C_179 : ((C_178 : (- __jc_off_y_1)) :> int32))));
      
      (return __retres)
   }
}

int32 ptr_sub_safe()
  requires (C_196 : true);
{  
   (var int_P[0..2] a_0);
   
   (var int_P[..] x);
   
   (var int_P[..] y);
   
   (var int32 __retres);
   
   (var int32 __jc_off_x_1);
   
   (var int32 __jc_off_y_2);
   
   {  (C_189 : (a_0 = (C_188 : (new int_P[3]))));
      (C_190 : (__jc_off_x_1 = 2));
      (C_191 : (__jc_off_y_2 = 0));
      (C_194 : (__retres = (C_193 : ((C_192 : (__jc_off_x_1 - __jc_off_y_2)) :> int32))));
      
      {  (C_195 : (free(a_0)));
         
         (return __retres)
      }
   }
}

int_P[0..1] a;

int32 oob_pointer_wrong(uint32 x)
{  
   (var int_P[..] i);
   
   (var int32 __retres);
   
   {  (C_199 : (i = (C_198 : ((C_197 : (a + x)) + 2))));
      (C_201 : (__retres = (C_200 : i.int_M)));
      
      (return __retres)
   }
}

int32 oob_pointer_unsafe(uint32 x)
  requires (C_206 : ((C_207 : (0 <= x)) && (C_208 : (x < 2))));
{  
   (var int_P[..] i);
   
   (var int32 __retres);
   
   {  (C_203 : (i = (C_202 : (a + x))));
      (C_205 : (__retres = (C_204 : i.int_M)));
      
      (return __retres)
   }
}

int32 oob_pointer_safe(uint32 x)
{  
   (var int_P[..] i);
   
   (var int32 __retres);
   
   {  (if (x < 2) then 
      {  (C_211 : (i = (C_210 : (a + x))));
         (C_213 : (__retres = (C_212 : i.int_M)));
         
         (goto return_label)
      } else 
      {  (C_209 : (__retres = 0));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 array_bounds_wrong(uint32 i)
{  
   (var int32 __retres);
   
   {  (C_217 : (__retres = (C_216 : (a +
                                      (C_215 : ((C_214 : (2 + i)) :> uint32))).int_M)));
      
      (return __retres)
   }
}

int32 array_bounds_unsafe(uint32 i)
  requires (C_220 : (i < 2));
{  
   (var int32 __retres);
   
   {  (C_219 : (__retres = (C_218 : (a + i).int_M)));
      
      (return __retres)
   }
}

int32 array_bounds_safe(uint32 i)
  requires (C_225 : true);
{  
   (var int32 __retres);
   
   {  (if (i < 2) then 
      {  (C_224 : (__retres = (C_223 : (a + i).int_M)));
         
         (goto return_label)
      } else 
      {  (C_222 : (__retres = (C_221 : (a + 0).int_M)));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 initialization_wrong()
{  
   (var int32 x);
   
   {  
      (return x)
   }
}

int32 initialization_unsafe(int32 i)
  requires (C_227 : (i != 0));
{  
   (var int32 x);
   
   {  (if (i != 0) then (C_226 : (x = 1)) else ());
      
      (return x)
   }
}

int32 initialization_safe(int32 i)
  requires (C_230 : true);
{  
   (var int32 x);
   
   {  (if (i != 0) then (C_229 : (x = 1)) else (C_228 : (x = 2)));
      
      (return x)
   }
}

int32 signed_overflow_wrong(int32 x)
{  
   (var int32 __retres);
   
   {  (if (x > 0) then 
      {  (C_238 : (__retres = (C_237 : ((C_236 : (x + 2147483647)) :> int32))));
         
         (goto return_label)
      } else 
      {  (C_235 : (__retres = (C_234 : ((C_233 : ((C_232 : ((C_231 : (x - 1)) :> int32)) -
                                                   2147483647)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 signed_overflow_unsafe(int32 x)
  requires (C_242 : (x <= (2147483647 - 10)));
{  
   (var int32 __retres);
   
   {  (C_241 : (__retres = (C_240 : ((C_239 : (x + 10)) :> int32))));
      
      (return __retres)
   }
}

int32 signed_overflow_safe(int32 x)
  requires (C_249 : true);
{  
   (var int32 __retres);
   
   {  (if (x < 0) then 
      {  (C_248 : (__retres = (C_247 : ((C_246 : (x + 2147483647)) :> int32))));
         
         (goto return_label)
      } else 
      {  (C_245 : (__retres = (C_244 : ((C_243 : (x - 2147483647)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 missing_return_wrong(int32 x)
{  
   (var int32 __retres);
   
   {  (C_250 : (__retres = 0));
      
      (return __retres)
   }
}

int32 missing_return_unsafe(int32 x)
  requires (C_253 : (x < 0));
{  
   (var int32 __retres);
   
   {  (if (x < 0) then 
      {  (C_251 : (__retres = 0));
         
         (goto return_label)
      } else ());
      (C_252 : (__retres = 0));
      (return_label : 
      (return __retres))
   }
}

int32 missing_return_safe(int32 x)
  requires (C_256 : true);
{  
   (var int32 __retres);
   
   {  (if (x < 0) then 
      {  (C_255 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_254 : (__retres = 1));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 multiple_update_wrong_1(int_P[..] x, int_P[..] y)
{  
   (var int32 tmp);
   
   (var int32 tmp_0);
   
   (var int32 __retres);
   
   {  (C_257 : (tmp = 0));
      (C_259 : ((C_258 : x.int_M) = tmp));
      (C_260 : (tmp_0 = 0));
      (C_262 : ((C_261 : x.int_M) = tmp_0));
      (C_265 : (__retres = (C_264 : ((C_263 : (tmp + tmp_0)) :> int32))));
      
      (return __retres)
   }
}

int32 multiple_update_wrong_2(int32 i)
{  
   {  (C_268 : (i = (C_267 : ((C_266 : (i + 1)) :> int32))));
      (C_271 : (i = (C_270 : ((C_269 : (i + 1)) :> int32))));
      
      (return i)
   }
}

int32 multiple_update_wrong_3(int32 i)
{  
   (var int32 tmp);
   
   {  (C_272 : (tmp = i));
      (C_275 : (i = (C_274 : ((C_273 : (i + 1)) :> int32))));
      (C_277 : ((C_276 : (a + tmp).int_M) = i));
      
      (return i)
   }
}

int32 multiple_update_unsafe(int_P[..] x, int_P[..] y)
  requires (C_291 : ((x - y) != 0));
{  
   (var int32 tmp);
   
   (var int32 tmp_0);
   
   (var int32 __retres);
   
   (var int32 __jc_off_y_3);
   
   {  (C_280 : (__jc_off_y_3 = (C_279 : ((C_278 : (y - x)) :> int32))));
      (C_281 : (tmp = 0));
      (C_283 : ((C_282 : x.int_M) = tmp));
      (C_284 : (tmp_0 = 0));
      (C_287 : ((C_286 : (C_285 : (x + __jc_off_y_3)).int_M) = tmp_0));
      (C_290 : (__retres = (C_289 : ((C_288 : (tmp + tmp_0)) :> int32))));
      
      (return __retres)
   }
}

int32 multiple_update_safe(int_P[..] x, int_P[..] y)
  requires (C_308 : true);
{  
   (var int32 tmp);
   
   (var int32 tmp_0);
   
   (var int32 __retres);
   
   (var int32 __jc_off_y_4);
   
   {  (C_294 : (__jc_off_y_4 = (C_293 : ((C_292 : (y - x)) :> int32))));
      (if ((C_307 : ((C_306 : (- __jc_off_y_4)) :> int32)) == 0) then 
      {  (C_305 : (__retres = 0));
         
         (goto return_label)
      } else 
      {  (C_295 : (tmp = 0));
         (C_297 : ((C_296 : x.int_M) = tmp));
         (C_298 : (tmp_0 = 0));
         (C_301 : ((C_300 : (C_299 : (x + __jc_off_y_4)).int_M) = tmp_0));
         (C_304 : (__retres = (C_303 : ((C_302 : (tmp + tmp_0)) :> int32))));
         
         (goto return_label)
      });
      (return_label : 
      (return __retres))
   }
}

int32 foo(int32 unnamed, int32 unnamed_1)
behavior generated:
  assumes true;
  ensures (C_309 : true);
;

int32 bar()
behavior generated_1:
  assumes true;
  ensures (C_310 : true);
;

int32 baz()
behavior generated_2:
  assumes true;
  ensures (C_311 : true);
;

int32 order_of_arg_eval()
{  
   (var int32 tmp);
   
   (var int32 tmp_0);
   
   (var int32 tmp_1);
   
   {  (C_313 : (tmp = (C_312 : baz())));
      (C_315 : (tmp_0 = (C_314 : bar())));
      (C_317 : (tmp_1 = (C_316 : foo(tmp_0, tmp))));
      
      (return tmp_1)
   }
}

int32 volatile_cast_wrong(int_P[..] ip)
{  
   (var int_P[..] x);
   
   (var int32 __retres);
   
   (var int32 __jc_off_x_2);
   
   {  (C_318 : (__jc_off_x_2 = 0));
      (C_321 : (__retres = (C_320 : (C_319 : (ip + __jc_off_x_2)).int_M)));
      
      (return __retres)
   }
}

int32 const_cast_wrong(int_P[..] ip)
{  
   (var int_P[..] x);
   
   (var int32 __retres);
   
   (var int32 __jc_off_x_3);
   
   {  (C_322 : (__jc_off_x_3 = 0));
      (C_325 : ((C_324 : (C_323 : (ip + __jc_off_x_3)).int_M) = 1));
      (C_326 : (__retres = 1));
      
      (return __retres)
   }
}

unit mod_string()
{  
   (var char_P[..] str);
   
   {  (C_327 : (str = __string_abc));
      (C_330 : ((C_329 : (C_328 : (str + 2)).char_M) = 122));
      
      (return ())
   }
}
