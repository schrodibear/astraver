rm -f heap.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only heap.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat heap.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag int_P = {
  int32 int_M;
}

type int_P = [int_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

invariant valid_heap :
((\offset_min(heap) <= 0) && (\offset_max(heap) >= 99))

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

axiom div2_1 :
(\forall int32 x;
  ((0 <= x) ==> ((0 <= (x / 2)) && ((x / 2) <= x))))

logic type bag

logic bag singleton_bag(integer x) reads \nothing;

logic bag union_bag(bag b1, bag b2) reads \nothing;

logic bag add_bag(integer x, bag b) =
union_bag(b, singleton_bag(x))

logic integer occ_bag(integer x, bag b) reads \nothing;

logic is_max_bag(bag b, integer m) =
((occ_bag(m, b) >= 1) &&
  (\forall integer x;
    ((occ_bag(x, b) >= 1) ==> (x <= m))))

logic type tree

logic tree Node(tree l, integer x, tree r) reads \nothing;

logic bag bag_of_tree(tree t) reads \nothing;

axiom bag_of_tree_def_2 :
(\forall tree l;
  (\forall int32 x;
    (\forall tree r;
      (bag_of_tree(Node(l, x, r)) ==
        add_bag(x, union_bag(bag_of_tree(l), bag_of_tree(r)))))))

logic is_heap(tree t) reads \nothing;

axiom is_heap_def_5 :
(\forall tree ll;
  (\forall int32 lx;
    (\forall tree lr;
      (\forall int32 x;
        (\forall tree rl;
          (\forall int32 rx;
            (\forall tree rr;
              ((x >= lx) ==>
                (is_heap(Node(ll, lx, lr)) ==>
                  ((x >= rx) ==>
                    (is_heap(Node(rl, rx, rr)) ==>
                      is_heap(Node(Node(ll, lx, lr), x, Node(rl, rx, rr))))))))))))))

logic tree tree_of_array{L}(int_P[..] t, integer root, integer bound) reads 
(t +
  [..]).int_M;

axiom tree_of_array_def_2{L} :
(\forall int_P[..] t;
  (\forall integer root;
    (\forall integer bound;
      (((0 <= root) && (root < bound)) ==>
        (tree_of_array{L}(t, root, bound) ==
          Node(tree_of_array{L}(t, ((2 * root) + 1), bound),
               (t + root).int_M, tree_of_array{L}(t, ((2 * root) + 2), bound)))))))

int_P[0..99] heap;

int32 size;

invariant size_inv :
((0 <= size) && (size < 100))

unit clear()
{  
   {  (C_1 : (size = 0));
      
      (return ())
   }
}

unit push(int32 x)
{  
   (var int32 i);
   
   (var int32 parent);
   
   (var int32 p);
   
   {  (C_2 : (i = size));
      
      {  
         invariant (C_3 : true);
         while (true)
         {  
            {  (if (i > 0) then () else 
               (goto while_0_break));
               (C_8 : (parent = (C_7 : ((C_6 : ((C_5 : ((C_4 : (i - 1)) :> int32)) /
                                                 2)) :> int32))));
               (C_10 : (p = (C_9 : (heap + parent).int_M)));
               (if (p >= x) then 
               (goto while_0_break) else ());
               (C_12 : ((C_11 : (heap + i).int_M) = p));
               (C_13 : (i = parent))
            }
         };
         (while_0_break : ())
      };
      (C_15 : ((C_14 : (heap + i).int_M) = x));
      (C_18 : (size = (C_17 : ((C_16 : (size + 1)) :> int32))));
      
      (return ())
   }
}

int32 max()
{  
   (var int32 __retres);
   
   {  (C_20 : (__retres = (C_19 : (heap + 0).int_M)));
      
      (return __retres)
   }
}

int32 pop()
{  
   (var int32 res);
   
   (var int32 v);
   
   (var int32 i);
   
   (var int32 j);
   
   {  (C_22 : (res = (C_21 : (heap + 0).int_M)));
      (C_25 : (size = (C_24 : ((C_23 : (size - 1)) :> int32))));
      (if (size != 0) then 
      {  (C_27 : (v = (C_26 : (heap + size).int_M)));
         (C_28 : (i = 0));
         
         {  
            invariant (C_29 : ((C_30 : (0 <= i)) && (C_31 : (i <= size))));
            variant (C_32 : (size - i));
            while (true)
            {  
               {  (if (i < size) then () else 
                  (goto while_1_break));
                  (C_37 : (j = (C_36 : ((C_35 : ((C_34 : ((C_33 : (2 * i)) :> int32)) +
                                                  1)) :> int32))));
                  (if (j < (C_46 : ((C_45 : (size - 1)) :> int32))) then 
                  (if ((C_44 : (heap + j).int_M) <
                        (C_43 : (heap + (C_42 : ((C_41 : (j + 1)) :> int32))).int_M)) then 
                  (C_40 : (j = (C_39 : ((C_38 : (j + 1)) :> int32)))) else ()) else ());
                  
                  (goto _L);
                  (_L : ());
                  (if (v >= (C_47 : (heap + j).int_M)) then 
                  (goto while_1_break) else ());
                  (C_50 : ((C_49 : (heap + i).int_M) = (C_48 : (heap + j).int_M)));
                  (C_51 : (i = j))
               }
            };
            (while_1_break : ())
         };
         (C_53 : ((C_52 : (heap + i).int_M) = v))
      } else ());
      
      (return res)
   }
}
