(* Load Programs. *)(********************************************************************

  A simple algorithm for computing the square root of a non-negative
  integer.

  Proofs of obligations generated by Why.

  (c) Claude MarchÃ©, may 2002

**********************************************************************)

(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)


Require Import ZArith.
Require Import Zcomplements.
Require Import ZArithRing.
Require Import Zdiv.
Require Import Omega.
Require Import Why.

(* some basic arithmetic lemmas *)

Lemma sqr_gt :
 forall x y:Z, (x > y)%Z -> (y > 0)%Z -> (x * x > y * y)%Z.
Proof.
intros.
assert (x * y > y * y)%Z.
apply Zgt_Zmult_right; omega.
assert (x * x > x * y)%Z.
apply Zgt_Zmult_left; omega.
omega.
Qed.

Lemma Z_mod_same : forall a:Z, (a > 0)%Z -> (a mod a)%Z = 0%Z.
Proof.
intros a aPos.
generalize (Z_mod_plus 0 1 a aPos).
replace (0 + 1 * a)%Z with a.
intros.
rewrite H.
compute.
trivial.
ring.
Qed.

Lemma Z_div_same : forall a:Z, (a > 0)%Z -> (a / a)%Z = 1%Z.
Proof.
intros a aPos.
generalize (Z_div_plus 0 1 a aPos).
replace (0 + 1 * a)%Z with a.
intros.
rewrite H.
compute.
trivial.
ring.
Qed.

(* some general lemmas for invariants *)

Lemma iter_sqrt_pos :
 forall x z:Z, (x > 0)%Z -> (z > 0)%Z -> ((x / z + z) / 2 > 0)%Z.
Proof.
intros x z xPos zPos.
assert (x / z + z >= 2)%Z.
assert (x + z * z >= z + z)%Z.
assert (x + (z - 1) * (z - 1) >= 1)%Z.
generalize (sqr_pos (z - 1)).
intros.
omega.
replace (z * z)%Z with ((z - 1) * (z - 1) + z + z - 1)%Z.
omega.
ring.
generalize (Z_div_ge (x + z * z) (z + z) z zPos H).
intro.
generalize (Z_div_plus x z z zPos).
intro H1.
rewrite H1 in H0.
clear H1.
generalize (Z_div_plus z 1 z zPos).
replace (1 * z)%Z with z.
intro H2.
rewrite H2 in H0.
clear H2.
generalize (Z_div_plus 0 1 z zPos).
replace (1 * z)%Z with z.
replace (0 + z)%Z with z.
intro.
rewrite H1 in H0.
simpl in H0.
trivial.
trivial.
ring.
ring.
assert (2 > 0)%Z.
omega.
generalize (Z_div_ge (x / z + z) 2 2 H0 H).
replace (2 / 2)%Z with 1%Z.
intro; omega.
compute.
trivial.
Qed.

Lemma iter_sqrt_pos2 : forall x:Z, (x > 0)%Z -> ((x + 1) / 2 > 0)%Z.
Proof.
intros.
assert (x + 1 >= 2)%Z.
 omega.
assert ((x + 1) / 2 >= 2 / 2)%Z.
apply Z_div_ge; try omega.
assert (2 / 2 > 0)%Z; try omega.
compute; trivial.
Qed.

Lemma iter_sqrt_invar1 :
 forall x y z:Z,
   (x > 0)%Z ->
   (y > 0)%Z -> z = ((x / y + y) / 2)%Z -> (2 * y * z <= x + y * y)%Z.
Proof.
intros x y z xPos yPos zVal.
assert (2 * z <= x / y + y)%Z.
rewrite zVal.
apply Z_mult_div_ge; omega.
assert (2 * y * z <= y * (x / y + y))%Z.
replace (2 * y * z)%Z with (y * (2 * z))%Z; try ring.
apply Zle_Zmult_pos_left; trivial || omega.
assert (y * (x / y + y) <= x + y * y)%Z.
assert ((y * (x / y + y))%Z = (y * (x / y) + y * y)%Z); try ring.
 assert (y * (x / y) <= x)%Z.
apply Z_mult_div_ge; omega.
omega.
omega.
Qed.

Lemma iter_sqrt_invar2 :
 forall x y z:Z,
   (x > 0)%Z ->
   (y > 0)%Z ->
   z = ((x / y + y) / 2)%Z -> (2 * y * (z + 1) > x + y * y)%Z.
Proof.
intros x y z xPos yPos zVal.
assert TwoPos: (2 > 0)%Z; try omega.
generalize (Z_div_mod_eq x y yPos).
generalize (Z_mod_lt x y yPos).
generalize (Z_div_mod_eq (x / y + y) 2 TwoPos).
generalize (Z_mod_lt (x / y + y) 2 TwoPos).
intros.
rewrite zVal.
replace (2 * y * ((x / y + y) / 2 + 1))%Z with
 (y * (2 * ((x / y + y) / 2)) + y + y)%Z; try ring.
replace (2 * ((x / y + y) / 2))%Z with
 (x / y + y - (x / y + y) mod 2)%Z.
replace (y * (x / y + y - (x / y + y) mod 2))%Z with
 (y * (x / y) + y * y - y * ((x / y + y) mod 2))%Z.
replace (y * (x / y))%Z with (x - x mod y)%Z.
assert (y >= y * ((x / y + y) mod 2))%Z.
pattern y 1; replace y with (y * 1)%Z.
apply Zge_Zmult_pos_left.
omega.
omega.
ring.
omega.
omega.
ring.
omega.
Qed.

Lemma iter_sqrt_invar3 :
 forall x y z:Z,
   (x > 0)%Z ->
   (y > 0)%Z -> z = ((x / y + y) / 2)%Z -> (x < (z + 1) * (z + 1))%Z.
Proof.
intros x y z xPos yPos zVal.
cut ((z + 1) * (z + 1) - x > 0)%Z; try omega.
assert (4 * y * y * ((z + 1) * (z + 1) - x) >= 1)%Z.
replace (4 * y * y * ((z + 1) * (z + 1) - x))%Z with
 (2 * y * (z + 1) * (2 * y * (z + 1)) - 4 * y * y * x)%Z; try ring.
generalize (iter_sqrt_invar2 x y z xPos yPos zVal).
intro.
assert
 (2 * y * (z + 1) * (2 * y * (z + 1)) > (x + y * y) * (x + y * y))%Z.
assert (2 * y * (z + 1) * (x + y * y) > (x + y * y) * (x + y * y))%Z.
apply Zgt_Zmult_right.
generalize (sqr_pos y).
omega.
assumption.
assert
 (2 * y * (z + 1) * (2 * y * (z + 1)) > 2 * y * (z + 1) * (x + y * y))%Z;
 try omega.
apply Zgt_Zmult_left; try assumption.
apply Zgt_ZERO_mult; try omega.
assert (z >= 0)%Z; try omega.
rewrite zVal.
apply Z_div_ge0; try omega.
assert (x / y >= 0)%Z; try omega.
apply Z_div_ge0; try omega.
assert ((x + y * y) * (x + y * y) - 4 * y * y * x >= 0)%Z; try omega.
replace ((x + y * y) * (x + y * y) - 4 * y * y * x)%Z with
 ((x - y * y) * (x - y * y))%Z; try ring.
apply sqr_pos.
apply (Zmult_gt (4 * y * y)).
apply Zgt_ZERO_mult; try omega.
omega.
Qed.




Lemma iter_sqrt_invar4 :
 forall x y z:Z,
   (x > 0)%Z ->
   (y > 0)%Z -> z = ((x / y + y) / 2)%Z -> (z >= y)%Z -> (y * y <= x)%Z.
Proof.
intros x y z xPos yPos zVal zGey.
generalize (iter_sqrt_invar1 x y z xPos yPos zVal); intros.
assert (y * y <= y * z)%Z.
apply Zle_Zmult_pos_left; try omega.
assert ((2 * y * z)%Z = (y * z + y * z)%Z); try ring.
omega.
Qed.




(* beginning of proof obligations *)

(* Why obligation from file , characters 391-392 *)
Lemma sqrt_po_1 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test6:x = 0%Z),
   (0 * 0 <= x)%Z /\ (x < (0 + 1) * (0 + 1))%Z.
 (* sqrt_po_1 *)
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 417-418 *)
Lemma sqrt_po_2 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test4:(x <= 3)%Z),
   (1 * 1 <= x)%Z /\ (x < (1 + 1) * (1 + 1))%Z.
 (* sqrt_po_2 *)
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 460-467 *)
Lemma sqrt_po_3 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test3:(x > 3)%Z)
   (y:Z) (Post5:y = x), 2%Z <> 0%Z.
 (* sqrt_po_3 *)
Proof.
auto with *.
Qed.

(* Why obligation from file , characters 654-660 *)
Lemma sqrt_po_4 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test3:(x > 3)%Z)
   (y:Z) (Post5:y = x) (Pre6:2%Z <> 0%Z) (z:Z)
   (Post4:z = ((x + 1) / 2)%Z) (Variant1 y1 z1:Z) (Pre5:Variant1 = y1)
   (Pre4:(z1 > 0)%Z /\
         (y1 > 0)%Z /\
         z1 = ((x / y1 + y1) / 2)%Z /\
         (x < (y1 + 1) * (y1 + 1))%Z /\ (x < (z1 + 1) * (z1 + 1))%Z)
   (Test2:(z1 < y1)%Z) (y2:Z) (Post1:y2 = z1) (Pre2:2%Z <> 0%Z),
   z1 <> 0%Z.
 Proof.
 intuition.
Qed.


(* Why obligation from file , characters 636-670 *)
Lemma sqrt_po_5 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test3:(x > 3)%Z)
   (y:Z) (Post5:y = x) (Pre6:2%Z <> 0%Z) (z:Z)
   (Post4:z = ((x + 1) / 2)%Z) (Variant1 y1 z1:Z) (Pre5:Variant1 = y1)
   (Pre4:(z1 > 0)%Z /\
         (y1 > 0)%Z /\
         z1 = ((x / y1 + y1) / 2)%Z /\
         (x < (y1 + 1) * (y1 + 1))%Z /\ (x < (z1 + 1) * (z1 + 1))%Z)
   (Test2:(z1 < y1)%Z) (y2:Z) (Post1:y2 = z1) (Pre2:2%Z <> 0%Z)
   (Pre3:z1 <> 0%Z) (z2:Z) (Post2:z2 = ((x / z1 + z1) / 2)%Z),
   ((z2 > 0)%Z /\
    (y2 > 0)%Z /\
    z2 = ((x / y2 + y2) / 2)%Z /\
    (x < (y2 + 1) * (y2 + 1))%Z /\ (x < (z2 + 1) * (z2 + 1))%Z) /\
   Zwf 0 y2 y1.
 Proof.
 unfold Zwf; intuition.
subst z2.
apply iter_sqrt_pos; omega.
subst y2; assumption.
subst y2; assumption.
apply (iter_sqrt_invar3 x z1); auto.
omega.
Qed.

(* Why obligation from file , characters 525-613 *)
Lemma sqrt_po_6 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test3:(x > 3)%Z)
   (y:Z) (Post5:y = x) (Pre6:2%Z <> 0%Z) (z:Z)
   (Post4:z = ((x + 1) / 2)%Z),
   (z > 0)%Z /\
   (y > 0)%Z /\
   z = ((x / y + y) / 2)%Z /\
   (x < (y + 1) * (y + 1))%Z /\ (x < (z + 1) * (z + 1))%Z.
 (* sqrt_po_6 *)
Proof.
intuition.
subst z.
assert ((x + 1) / 2 >= 1)%Z.
pattern 1%Z 2; replace 1%Z with (2 / 2)%Z; trivial.
apply Z_div_ge; try omega.
omega.
subst y.
assert ((x / x + x)%Z = (x + 1)%Z).
assert xPos: (x > 0)%Z; try omega.
generalize (Z_div_same x xPos).
 intro.
rewrite H; omega.
rewrite H; trivial.

subst y.
assert ((x + 1) * (x + 1) >= (x + 1) * 1)%Z.
apply Zge_Zmult_pos_left; try omega.
assert (((x + 1) * 1)%Z = (x + 1)%Z); try ring.
omega.

subst z.
apply (iter_sqrt_invar3 x x); try omega.
assert ((x / x + x)%Z = (x + 1)%Z).
assert xPos: (x > 0)%Z; try omega.
generalize (Z_div_same x xPos).
 intro.
rewrite H; omega.
rewrite H; trivial.
Qed.

(* Why obligation from file , characters 679-681 *)
Lemma sqrt_po_7 :
 forall (x:Z) (Pre7:(x >= 0)%Z) (Test5:x <> 0%Z) (Test3:(x > 3)%Z)
   (y:Z) (Post5:y = x) (Pre6:2%Z <> 0%Z) (z:Z)
   (Post4:z = ((x + 1) / 2)%Z) (y1 z1:Z)
   (Post3:((z1 > 0)%Z /\
           (y1 > 0)%Z /\
           z1 = ((x / y1 + y1) / 2)%Z /\
           (x < (y1 + 1) * (y1 + 1))%Z /\ (x < (z1 + 1) * (z1 + 1))%Z) /\
          (z1 >= y1)%Z),
   (y1 * y1 <= x)%Z /\ (x < (y1 + 1) * (y1 + 1))%Z.
Proof.
intuition.
apply (iter_sqrt_invar4 x y1 z1); try omega.
Qed.

