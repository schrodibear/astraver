(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require Omega.


(* Why obligation from file "selection.mlw", characters 812-819 *)
Lemma selection_po_1 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (Variant3: Z)
  (j0: Z)
  (min0: Z)
  (Pre6: Variant3 = `(array_length t0) - j0`)
  (Pre5: (`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
         `min0 < (array_length t0)`) /\
         ((k:Z)
          (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`)))
  (Test5: `j0 < (array_length t0)`)
  `0 <= min0` /\ `min0 < (array_length t0)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "selection.mlw", characters 804-809 *)
Lemma selection_po_2 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (Variant3: Z)
  (j0: Z)
  (min0: Z)
  (Pre6: Variant3 = `(array_length t0) - j0`)
  (Pre5: (`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
         `min0 < (array_length t0)`) /\
         ((k:Z)
          (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`)))
  (Test5: `j0 < (array_length t0)`)
  (Pre4: `0 <= min0` /\ `min0 < (array_length t0)`)
  `0 <= j0` /\ `j0 < (array_length t0)`.
Proof.
Intuition.
Save.

(* Why obligation from file "selection.mlw", characters 825-834 *)
Lemma selection_po_3 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (Variant3: Z)
  (j0: Z)
  (min0: Z)
  (Pre6: Variant3 = `(array_length t0) - j0`)
  (Pre5: (`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
         `min0 < (array_length t0)`) /\
         ((k:Z)
          (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`)))
  (Test5: `j0 < (array_length t0)`)
  (Test4: `(access t0 j0) < (access t0 min0)`)
  (min1: Z)
  (Post1: min1 = j0)
  ((j:Z)
   (j = `j0 + 1` -> ((`i0 + 1 <= j` /\ `j <= (array_length t0)`) /\
    (`i0 <= min1` /\ `min1 < (array_length t0)`) /\
    ((k:Z) (`i0 <= k` /\ `k < j` -> `(access t0 min1) <= (access t0 k)`))) /\
    (Zwf `0` `(array_length t0) - j` `(array_length t0) - j0`))).
Proof.
Intuition.
Assert h: `k<j0` \/ `k=j0`. Omega. Intuition.
Apply Zle_trans with (access t0 min0).
Subst min1; Omega.
Apply H8; Omega.
Subst min1 k; Omega.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "selection.mlw", characters 801-834 *)
Lemma selection_po_4 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (Variant3: Z)
  (j0: Z)
  (min0: Z)
  (Pre6: Variant3 = `(array_length t0) - j0`)
  (Pre5: (`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
         `min0 < (array_length t0)`) /\
         ((k:Z)
          (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`)))
  (Test5: `j0 < (array_length t0)`)
  (Test3: `(access t0 j0) >= (access t0 min0)`)
  ((j:Z)
   (j = `j0 + 1` -> ((`i0 + 1 <= j` /\ `j <= (array_length t0)`) /\
    (`i0 <= min0` /\ `min0 < (array_length t0)`) /\
    ((k:Z) (`i0 <= k` /\ `k < j` -> `(access t0 min0) <= (access t0 k)`))) /\
    (Zwf `0` `(array_length t0) - j` `(array_length t0) - j0`))).
Proof.
Intuition.
Assert h: `k<j0` \/ `k=j0`. Omega. Intuition.
Subst k; Omega.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "selection.mlw", characters 619-755 *)
Lemma selection_po_5 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (`i0 + 1 <= result2` /\ `result2 <= (array_length t0)`) /\
  (`i0 <= result1` /\ `result1 < (array_length t0)`) /\
  ((k:Z)
   (`i0 <= k` /\ `k < result2` -> `(access t0 result1) <= (access t0 k)`)).
Proof.
Intuition.
Assert h:`k=i0`. Omega.
Subst result1 k; Omega.
Save.

(* Why obligation from file "selection.mlw", characters 898-905 *)
Lemma selection_po_6 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (j0: Z)
  (min0: Z)
  (Post3: ((`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
          `min0 < (array_length t0)`) /\
          ((k:Z)
           (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`))) /\
          `j0 >= (array_length t0)`)
  `0 <= min0` /\ `min0 < (array_length t0)`.
Proof.
Intuition.
Save.

(* Why obligation from file "selection.mlw", characters 926-931 *)
Lemma selection_po_7 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (j0: Z)
  (min0: Z)
  (Post3: ((`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
          `min0 < (array_length t0)`) /\
          ((k:Z)
           (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`))) /\
          `j0 >= (array_length t0)`)
  (Pre10: `0 <= min0` /\ `min0 < (array_length t0)`)
  (w: Z)
  (Post6: w = (access t0 min0))
  (Pre8: `0 <= min0` /\ `min0 < (array_length t0)`)
  `0 <= i0` /\ `i0 < (array_length t0)`.
Proof.
Intuition.
Save.

(* Why obligation from file "selection.mlw", characters 933-943 *)
Lemma selection_po_8 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (j0: Z)
  (min0: Z)
  (Post3: ((`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
          `min0 < (array_length t0)`) /\
          ((k:Z)
           (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`))) /\
          `j0 >= (array_length t0)`)
  (Pre10: `0 <= min0` /\ `min0 < (array_length t0)`)
  (w: Z)
  (Post6: w = (access t0 min0))
  (Pre8: `0 <= min0` /\ `min0 < (array_length t0)`)
  (Pre9: `0 <= i0` /\ `i0 < (array_length t0)`)
  (t1: (array Z))
  (Post4: t1 = (store t0 min0 (access t0 i0)))
  `0 <= i0` /\ `i0 < (array_length t1)`.
Proof.
Intuition.
ArraySubst t1.
Save.

(* Why obligation from file "selection.mlw", characters 909-947 *)
Lemma selection_po_9 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (Variant1: Z)
  (i0: Z)
  (t0: (array Z))
  (Pre12: Variant1 = `(array_length t0) - i0`)
  (Pre11: (`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
          (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
          ((k:Z)
           (`0 <= k` /\ `k < i0` ->
            ((l:Z)
             (`i0 <= l` /\ `l < (array_length t0)` ->
              `(access t0 k) <= (access t0 l)`)))))
  (Test6: `i0 < (array_length t0) - 1`)
  (result1: Z)
  (Post8: result1 = i0)
  (result2: Z)
  (Post7: result2 = `i0 + 1`)
  (j0: Z)
  (min0: Z)
  (Post3: ((`i0 + 1 <= j0` /\ `j0 <= (array_length t0)`) /\ (`i0 <= min0` /\
          `min0 < (array_length t0)`) /\
          ((k:Z)
           (`i0 <= k` /\ `k < j0` -> `(access t0 min0) <= (access t0 k)`))) /\
          `j0 >= (array_length t0)`)
  (Pre10: `0 <= min0` /\ `min0 < (array_length t0)`)
  (w: Z)
  (Post6: w = (access t0 min0))
  (Pre8: `0 <= min0` /\ `min0 < (array_length t0)`)
  (Pre9: `0 <= i0` /\ `i0 < (array_length t0)`)
  (t1: (array Z))
  (Post4: t1 = (store t0 min0 (access t0 i0)))
  (Pre7: `0 <= i0` /\ `i0 < (array_length t1)`)
  (t2: (array Z))
  (Post5: t2 = (store t1 i0 w))
  ((i:Z)
   (i = `i0 + 1` -> ((`0 <= i` /\ `i <= (array_length t2) - 1`) /\
    (sorted_array t2 `0` `i - 1`) /\ (permut t2 t) /\
    ((k:Z)
     (`0 <= k` /\ `k < i` ->
      ((l:Z)
       (`i <= l` /\ `l < (array_length t2)` ->
        `(access t2 k) <= (access t2 l)`))))) /\
    (Zwf `0` `(array_length t2) - i` `(array_length t0) - i0`))).
Proof.
Intuition.
ArraySubst t2.
ArraySubst t1.
Assert h: `i0=0` \/ `0<i0`. Omega. Intuition.
Replace `i-1` with `0`.
Unfold sorted_array; Intros; Omega.
Omega.
Replace `i-1` with `(i0-1)+1`.
Apply right_extension.
Omega.
ArraySubst t2.
ArraySubst t1.
Apply sorted_array_id with t0.
Assumption.
Unfold array_id; Intros.
Subst t2; Do 2 AccessOther.
Replace `i0-1+1` with i0.
Subst t2 t1; Do 2 AccessOther.
Subst w.
Apply H4; Omega.
Omega.
Omega.
Apply permut_trans with t0.
Subst t2; Subst t1; Subst w.
Apply exchange_is_permut with min0 i0; Auto with *.
Assumption.
Assert h:`k=i0` \/ `k<i0`. Omega. Intuition.
Subst k.
Subst t2; Simpl in H23.
AccessSame.
AccessOther.
Subst t1; Simpl in H23.
Assert h:`l=min0` \/ `min0<>l`. Omega. Intuition.
Subst l; AccessSame.
Subst w; Apply H11; Omega.
AccessOther.
Subst w; Apply H11; Try Omega.
Subst t2; Simpl in H23. AccessOther.
AccessOther.
Subst t1; Simpl in H23.
Assert h:`l=min0` \/ `min0<>l`. Omega. Intuition.
Subst l; AccessSame.
AccessOther.
Apply H4; Omega.
AccessOther.
AccessOther.
Apply H4; Omega.
Subst t2 t1; Simpl; Unfold Zwf; Omega.
Save.

(* Why obligation from file "selection.mlw", characters 232-424 *)
Lemma selection_po_10 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (`0 <= result` /\ `result <= (array_length t) - 1`) /\
  (sorted_array t `0` `result - 1`) /\ (permut t t) /\
  ((k:Z)
   (`0 <= k` /\ `k < result` ->
    ((l:Z)
     (`result <= l` /\ `l < (array_length t)` ->
      `(access t k) <= (access t l)`)))).
Proof.
Intuition.
Unfold sorted_array; Intros; Omega.
Save.

(* Why obligation from file "selection.mlw", characters 120-985 *)
Lemma selection_po_11 : 
  (t: (array Z))
  (Pre13: `(array_length t) >= 1`)
  (result: Z)
  (Post11: result = `0`)
  (i0: Z)
  (t0: (array Z))
  (Post10: ((`0 <= i0` /\ `i0 <= (array_length t0) - 1`) /\
           (sorted_array t0 `0` `i0 - 1`) /\ (permut t0 t) /\
           ((k:Z)
            (`0 <= k` /\ `k < i0` ->
             ((l:Z)
              (`i0 <= l` /\ `l < (array_length t0)` ->
               `(access t0 k) <= (access t0 l)`))))) /\
           `i0 >= (array_length t0) - 1`)
  (sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t).
Proof.
Intuition.
Assert h:`i0=0` \/ `0<i0`. Omega. Intuition.
Unfold sorted_array; Intros; Omega.
Replace `(array_length t0)-1` with `(i0-1)+1`.
Apply right_extension; Try Omega. 
Assumption.
Apply H5; Omega.
Omega.
Save.


