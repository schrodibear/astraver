(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Import Omega.

Proof.
unfold sorted_array; intuition.
Save.

Proof.
intuition.
assert (h: k = i).
 omega.
subst result k; omega.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
assert (h: (k < j) \/ k = j).
 omega.
 intuition.
apply Zle_trans with (access t0 min).
subst min0; omega.
auto with *.
subst min0 k; omega.
Save.

Proof.
intuition.
assert (h: (k < j) \/ k = j).
 omega.
 intuition.
subst k; omega.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
Save.

Proof.
intuition.
ArraySubst t1.
Save.

Proof.
intuition.
ArraySubst t2.
ArraySubst t1.
assert (h: i = 0%Z \/ (0 < i)).
 omega.
 intuition.
replace (i0 - 1)%Z with 0%Z.
unfold sorted_array; intros; omega.
omega.
replace (i0 - 1)%Z with (i - 1 + 1)%Z.
apply right_extension.
omega.
ArraySubst t2.
ArraySubst t1.
apply sorted_array_id with t0.
assumption.
unfold array_id; intros.
subst t2; do 2 AccessOther.
replace (i - 1 + 1)%Z with i.
subst t2 t1; do 2 AccessOther.
subst result1.
auto with *.
omega.
omega.
apply permut_trans with t0.
subst t2; subst t1; subst result1 result2.
apply exchange_is_permut with min i; auto with *.
assumption.
assert (h: k = i \/ (k < i)).
 omega.
 intuition.
subst k.
subst t2.
AccessSame.
AccessOther.
subst t1.
assert (h: l = min \/ min <> l).
 omega.
 intuition.
subst l; AccessSame.
subst result1 result2; auto with *.
assert (h: l < array_length (update (update t0 min result2) i result1)).
assumption.
do 2 rewrite array_length_update in h.
AccessOther.
subst.
auto with *.
ArraySubst t1.
assert (h: i < array_length (update t0 min result2)). assumption.
rewrite array_length_update in h.
assert (h': l < array_length (update (update t0 min result2) i result1)). assumption.
do 2 rewrite array_length_update in h'.
omega.
subst.
AccessOther.
AccessOther.
AccessOther.
assert (h: l < array_length (update (update t0 min (access t0 i)) i (access t0 min))). assumption.
do 2 rewrite array_length_update in h.
assert (l = min \/ min <> l).
 omega.
 intuition.
subst l; AccessSame.
auto with *.
AccessOther.
auto with *.
assert (h: l < array_length (update (update t0 min (access t0 i)) i (access t0 min))). assumption.
do 2 rewrite array_length_update in h.
omega.
subst t2 t1; simpl; unfold Zwf; omega.
Save.

Proof.
intuition.
assert (i=0 \/ 0<i). omega. intuition.
unfold sorted_array; intros; omega.
replace (array_length t0 - 1)%Z with (i - 1 + 1)%Z.
apply right_extension; try omega.
 assumption.
auto with *.
omega.
Qed.



