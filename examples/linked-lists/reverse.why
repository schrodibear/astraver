
(* in-place list reversal revisited with algebraic types *)


(* logical polymorphic lists *)

type 'a list = Nil | Cons('a, 'a list)

logic rev : 'a list -> 'a list

logic app : 'a list, 'a list -> 'a list

logic disjoint : 'a list, 'a list -> prop

(* modelisation of pointers *)

type pointer

logic null : pointer

parameter eq_pointer : 
  p1:pointer -> p2:pointer -> {} bool { if result then p1=p2 else p1<>p2 }

parameter ne_pointer : 
  p1:pointer -> p2:pointer -> {} bool { if result then p1<>p2 else p1=p2 }

parameter is_null : p:pointer -> {} bool { if result then p=null else p<>null }



(* modelisation of the memory heap *)

type pointer_store

logic pget : pointer_store, pointer -> pointer
logic pset : pointer_store, pointer, pointer -> pointer_store

logic is_valid_pointer : pointer_store, pointer -> prop

parameter Ltl : pointer_store ref


(* null-terminated program lists *)
 
(*
inductive lpath : pointer_store, pointer, pointer list, pointer -> prop =
| lpath_nil: lpath(tl, p, Nil, p)
| lpath_cons: is_valid_pointer(tl,p) and lpath(tl, pget(tl,p), l, q) 
      -> lpath(tl, p, Cons(p,l), q)
*)

(* llist(tl,p,l) is true whenever p is a null-terminated list of pointers,
   and l is the list of pointers met on the path from p to null *)
inductive llist : pointer_store, pointer, pointer list -> prop =
| llist_nil: forall tl:pointer_store. llist(tl, null, Nil)
| llist_cons: forall tl:pointer_store. forall p:pointer. 
  forall l:pointer list. 
  is_valid_pointer(tl,p) and llist(tl, pget(tl,p), l) 
      -> llist(tl, p, Cons(p,l))

(*
logic llist : pointer_store, pointer, pointer list -> prop
*)

predicate is_list(tl:pointer_store, p:pointer) = 
  exists l:pointer list. llist(tl,p,l)



(* for termination *)

type StorePointerPair

logic store_pointer_pair : pointer_store, pointer -> StorePointerPair

(* in-place list reversal *)

let reverse (p0:pointer) =
  { is_list(Ltl, p0) }
  init:
  let p = ref p0 in
  let r = ref !p in
  begin
    p := null;
    while (ne_pointer !r null) do
      { invariant exists lp:pointer list. exists lr:pointer list.
                  llist(Ltl, p, lp) and llist(Ltl, r, lr) and
	          disjoint(lp, lr) and 
	           forall l:pointer list. 
	           llist(Ltl@init, p0, l) -> app(rev(lr), lp) = rev(l)
        variant store_pointer_pair(Ltl, r) for ll_order }
      let q = ref !r in
      begin
      r := (pget !Ltl !r);
      Ltl := (pset !Ltl !q !p);
      p := !q
      end
    done;
    !p
  end
  { exists l:pointer list. 
      llist(Ltl, result, l) and
      forall l0:pointer list. llist(Ltl@, p0, l0) -> l = rev(l0) }

