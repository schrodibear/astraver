
external null : pointer
external eq_pointer : 
  p1:pointer -> p2:pointer -> {} bool { if result then p1=p2 else p1<>p2 }
external ne_pointer : 
  p1:pointer -> p2:pointer -> {} bool { if result then p1<>p2 else p1=p2 }
external is_null : p:pointer -> {} bool { if result then p=null else p<>null }

external access_int : int_store -> pointer -> int
external update_int : int_store -> pointer -> int -> int_store

external access_pointer : pointer_store -> pointer -> pointer
external update_pointer : pointer_store -> pointer -> pointer -> pointer_store

logic is_valid_int : int_store, pointer -> prop
logic is_valid_pointer : pointer_store, pointer -> prop

logic list_of : pointer_store, pointer, plist -> prop

logic is_list : int_store, pointer_store, pointer -> prop
logic triple : int_store, pointer_store, pointer -> Triple

(* global state = stores for fields hd and tl *)

parameter Lhd : int_store ref
parameter Ltl : pointer_store ref

(* list length *)

let length (p0:pointer) =
  { is_list(Lhd, Ltl, p0) }
  let p = ref p0 in
  let n = ref 0 in
  begin
  while not (is_null !p) do
    { invariant is_list(Lhd, Ltl, p)
      variant triple(Lhd, Ltl, p) for tl_order }
    n := !n + 1;
    p := (access_pointer !Ltl !p)
  done;
  !n
  end
  {} 

 