(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Why.
Require Export words.
Require Import Omega.
Require Import Sumbool.

(*Why*) Parameter n1 : Z.
Axiom n1_non_negative : (0 <= n1)%Z.

(*Why*) Parameter n2 : Z.
Axiom n2_non_negative : (0 <= n2)%Z.

Ltac Omega' :=
  generalize n1_non_negative; generalize n2_non_negative;
   abstract omega.

Definition min_suffix (w1 w2:array A) (i j n:Z) :=
  min_dist (suffix n1 w1 i) (suffix n2 w2 j) n.

Definition test_char (a b:A) := bool_of_sumbool (A_eq_dec a b).

(* Why obligation from file "distance.mlw", characters 1780-1796 *)
Lemma distance_po_1 : 
  forall (t: (array Z)),
  forall (w1: (array A)),
  forall (w2: (array A)),
  forall (Pre28: (array_length w1) = n1 /\ (array_length w2) = n2 /\
                 (array_length t) = (n2 + 1)),
  forall (i0: Z),
  forall (Post1: i0 = 0),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre4: Variant1 = (n2 + 1 - i1)),
  forall (Pre3: (0 <= i1 /\ i1 <= (n2 + 1)) /\ (array_length t0) =
                (n2 + 1) /\
                (forall (j:Z), (0 <= j /\ j < i1 -> (access t0 j) = (n2 - j)))),
  forall (Test2: i1 <= n2),
  0 <= i1 /\ i1 < (array_length t0).
Proof.
simpl; intuition.
Qed.

(* Why obligation from file "distance.mlw", characters 1780-1817 *)
Lemma distance_po_2 : 
  forall (t: (array Z)),
  forall (w1: (array A)),
  forall (w2: (array A)),
  forall (Pre28: (array_length w1) = n1 /\ (array_length w2) = n2 /\
                 (array_length t) = (n2 + 1)),
  forall (i0: Z),
  forall (Post1: i0 = 0),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre4: Variant1 = (n2 + 1 - i1)),
  forall (Pre3: (0 <= i1 /\ i1 <= (n2 + 1)) /\ (array_length t0) =
                (n2 + 1) /\
                (forall (j:Z), (0 <= j /\ j < i1 -> (access t0 j) = (n2 - j)))),
  forall (Test2: i1 <= n2),
  forall (Pre2: 0 <= i1 /\ i1 < (array_length t0)),
  forall (t1: (array Z)),
  forall (Post2: t1 = (store t0 i1 (n2 - i1))),
  forall (i2: Z),
  forall (Post3: i2 = (i1 + 1)),
  ((0 <= i2 /\ i2 <= (n2 + 1)) /\ (array_length t1) = (n2 + 1) /\
  (forall (j:Z), (0 <= j /\ j < i2 -> (access t1 j) = (n2 - j)))) /\
  (Zwf 0 (n2 + 1 - i2) (n2 + 1 - i1)).
Proof.
intuition.
ArraySubst t1.
subst t1.
 AccessStore i1 j Hij; try Omega'.
apply H8; Omega'.
Qed.

(* Why obligation from file "distance.mlw", characters 1607-1828 *)
Lemma distance_po_3 : 
  forall (t: (array Z)),
  forall (w1: (array A)),
  forall (w2: (array A)),
  forall (Pre28: (array_length w1) = n1 /\ (array_length w2) = n2 /\
                 (array_length t) = (n2 + 1)),
  forall (i0: Z),
  forall (Post1: i0 = 0),
  forall (Variant1: Z),
  forall (i1: Z),
  forall (t0: (array Z)),
  forall (Pre4: Variant1 = (n2 + 1 - i1)),
  forall (Pre3: (0 <= i1 /\ i1 <= (n2 + 1)) /\ (array_length t0) =
                (n2 + 1) /\
                (forall (j:Z), (0 <= j /\ j < i1 -> (access t0 j) = (n2 - j)))),
  forall (Test1: i1 > n2),
  (forall (i:Z),
   (i = (n1 - 1) -> (((Zopp 1) <= i /\ i <= (n1 - 1)) /\ (array_length t0) =
    (n2 + 1) /\
    (forall (j:Z),
     (0 <= j /\ j <= n2 -> (min_suffix w1 w2 (i + 1) j (access t0 j))))) /\
    (forall (i:Z),
     (forall (t:(array Z)),
      (((Zopp 1) <= i /\ i <= (n1 - 1)) /\ (array_length t) = (n2 + 1) /\
       (forall (j:Z),
        (0 <= j /\ j <= n2 -> (min_suffix w1 w2 (i + 1) j (access t j)))) ->
       ((i >= 0 ->
         (forall (old:Z),
          (old = (access t n2) ->
           ((forall (t0:(array Z)),
             (t0 = (store t n2 ((access t n2) + 1)) ->
              (forall (j:Z),
               (j = (n2 - 1) -> (((Zopp 1) <= j /\ j <= (n2 - 1)) /\
                (array_length t0) = (n2 + 1) /\
                (forall (k:Z),
                 (j < k /\ k <= n2 -> (min_suffix w1 w2 i k (access t0 k)))) /\
                (forall (k:Z),
                 (0 <= k /\ k <= j ->
                  (min_suffix w1 w2 (i + 1) k (access t0 k)))) /\
                (min_suffix w1 w2 (i + 1) (j + 1) old)) /\
                (forall (j:Z),
                 (forall (old:Z),
                  (forall (t:(array Z)),
                   (((Zopp 1) <= j /\ j <= (n2 - 1)) /\ (array_length t) =
                    (n2 + 1) /\
                    (forall (k:Z),
                     (j < k /\ k <= n2 -> (min_suffix w1 w2 i k (access t k)))) /\
                    (forall (k:Z),
                     (0 <= k /\ k <= j ->
                      (min_suffix w1 w2 (i + 1) k (access t k)))) /\
                    (min_suffix w1 w2 (i + 1) (j + 1) old) ->
                    ((j >= 0 ->
                      (forall (result:Z),
                       (result = old ->
                        (forall (old:Z),
                         (old = (access t j) ->
                          (((((access w1 i) = (access w2 j) ->
                              (forall (t0:(array Z)),
                               (t0 = (store t j result) ->
                                (forall (j0:Z),
                                 (j0 = (j - 1) -> (((Zopp 1) <= j0 /\ j0 <=
                                  (n2 - 1)) /\ (array_length t0) =
                                  (n2 + 1) /\
                                  (forall (k:Z),
                                   (j0 < k /\ k <= n2 ->
                                    (min_suffix w1 w2 i k (access t0 k)))) /\
                                  (forall (k:Z),
                                   (0 <= k /\ k <= j0 ->
                                    (min_suffix w1 w2 (i + 1) k (access t0 k)))) /\
                                  (min_suffix w1 w2 (i + 1) (j0 + 1) old)) /\
                                  (Zwf 0 (j0 + 1) (j + 1)))))) /\
                              0 <= j /\ j < (array_length t))) /\
                          ((~(access w1 i) = (access w2 j) ->
                            (((forall (t0:(array Z)),
                               (t0 = (store t j
                                      ((Zmin (access t j) (access t (j + 1))) +
                                      1)) ->
                                (forall (j0:Z),
                                 (j0 = (j - 1) -> (((Zopp 1) <= j0 /\ j0 <=
                                  (n2 - 1)) /\ (array_length t0) =
                                  (n2 + 1) /\
                                  (forall (k:Z),
                                   (j0 < k /\ k <= n2 ->
                                    (min_suffix w1 w2 i k (access t0 k)))) /\
                                  (forall (k:Z),
                                   (0 <= k /\ k <= j0 ->
                                    (min_suffix w1 w2 (i + 1) k (access t0 k)))) /\
                                  (min_suffix w1 w2 (i + 1) (j0 + 1) old)) /\
                                  (Zwf 0 (j0 + 1) (j + 1)))))) /\
                            0 <= j /\ j < (array_length t)) /\ 0 <=
                            (j + 1) /\ (j + 1) < (array_length t)) /\ 0 <=
                            j /\ j < (array_length t)))) /\
                          0 <= i /\ i < (array_length w1)) /\ 0 <= j /\ j <
                          (array_length w2))) /\
                        0 <= j /\ j < (array_length t))))) /\
                    ((j < 0 ->
                      (forall (i0:Z),
                       (i0 = (i - 1) -> (((Zopp 1) <= i0 /\ i0 <=
                        (n1 - 1)) /\ (array_length t) = (n2 + 1) /\
                        (forall (j:Z),
                         (0 <= j /\ j <= n2 ->
                          (min_suffix w1 w2 (i0 + 1) j (access t j))))) /\
                        (Zwf 0 (i0 + 1) (i + 1)))))))))))))) /\
           0 <= n2 /\ n2 < (array_length t)) /\ 0 <= n2 /\ n2 <
           (array_length t))) /\
         0 <= n2 /\ n2 < (array_length t))) /\
       ((i < 0 ->
         (min_dist (word_of_array n1 w1) (word_of_array n2 w2) (access t 0)) /\
         0 <= 0 /\ 0 < (array_length t)))))))).
Proof.
intuition.
Omega'.
Qed.

(* Why obligation from file "distance.mlw", characters 1645-1744 *)
Lemma distance_po_4 : 
  forall (t: (array Z)),
  forall (w1: (array A)),
  forall (w2: (array A)),
  forall (Pre28: (array_length w1) = n1 /\ (array_length w2) = n2 /\
                 (array_length t) = (n2 + 1)),
  forall (i0: Z),
  forall (Post1: i0 = 0),
  (0 <= i0 /\ i0 <= (n2 + 1)) /\ (array_length t) = (n2 + 1) /\
  (forall (j:Z), (0 <= j /\ j < i0 -> (access t j) = (n2 - j))).
Proof.
intuition.
Omega'.
Qed.

Proof.
intuition.
ArraySubst t4.
unfold min_suffix.
subst t4.
AccessStore j2 k Hj2k.
  (* j2=k *)
  rewrite (suffix_is_cons n1 w1 i3); [ idtac | Omega' ].
  rewrite (suffix_is_cons n2 w2 k); [ idtac | Omega' ].
  rewrite Test6.
 rewrite <- Hj2k.
  apply min_dist_equal.
  subst temp; assumption.
  Omega'.
  (* j2<>k *)
  unfold min_suffix in H16.
  apply H18; Omega'.
  Omega'.
  Omega'.
unfold min_suffix.
subst t4.
AccessOther.
unfold min_suffix in H21; apply H21; Omega'.
replace (j + 1)%Z with j2; [ idtac | Omega' ].
subst old3.
unfold min_suffix; unfold min_suffix in H21; apply H21; Omega'.
Qed.

Proof.
intuition.
Qed.

Proof.
intuition.
ArraySubst t4.
unfold min_suffix.
rewrite Post11; clear Post11.
AccessStore j2 k Hj2k.
  (* j2=k *)
  rewrite <- Hj2k.
    rewrite (suffix_is_cons n1 w1 i3); [ idtac | Omega' ].
  rewrite (suffix_is_cons n2 w2 j2); [ idtac | Omega' ].
  apply min_dist_diff.
   assumption.
  rewrite <- (suffix_is_cons n1 w1 i3); [ idtac | Omega' ].
  apply H18; Omega'.
  rewrite <- (suffix_is_cons n2 w2 j2); [ idtac | Omega' ].
  apply H21; Omega'.
  Omega'.
  (* j2<> k *)
  apply H18; Omega'.
  Omega'.
  Omega'.
rewrite Post11; clear Post11.
unfold min_suffix.
AccessOther.
apply H21; Omega'.
replace (j + 1)%Z with j2; [ idtac | Omega' ].
subst old3; apply H21; Omega'.
Qed.

Proof.
intuition.
ArraySubst t2.
rewrite Post7; clear Post7.
replace k with n2; [ idtac | Omega' ].
unfold min_suffix.
rewrite (suffix_is_cons n1 w1 i3).
rewrite suffix_n_is_eps.
AccessSame.
apply min_dist_eps.
rewrite <- suffix_n_is_eps with (n := n2) (t := w2).
apply H13; Omega'.
Omega'.
rewrite Post7.
AccessOther.
apply H13; Omega'.
rewrite Post6.
replace n2 with (j1 + 1)%Z; [ idtac | Omega' ].
apply H13; Omega'.
Qed.

Proof.
intuition.
replace (i4 + 1)%Z with i3; [ idtac | Omega' ].
apply H20; Omega'.
Qed.

Proof.
intuition.
Omega'.
replace (i2 + 1)%Z with n1; [ idtac | Omega' ].
unfold min_suffix.
rewrite suffix_n_is_eps.
replace (access t0 j) with (Zlength (suffix n2 w2 j)).
exact (min_dist_eps_length (suffix n2 w2 j)).
rewrite H7.
apply suffix_length; Omega'.
Omega'.
Qed.

Proof.
intuition.
Omega'.
Qed.


Proof.
intuition.
cut ((i3 + 1)%Z = 0%Z); [ intro Hi3 | Omega' ].
rewrite Hi3 in H14.
unfold word_of_array.
unfold min_suffix in H14.
apply (H14 0%Z); Omega'.
Qed.

