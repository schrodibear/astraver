(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.
Require words.
Require Omega.
Require Sumbool.

(*Why*) Parameter n1 : Z.
Axiom n1_non_negative : `0 <= n1`.

(*Why*) Parameter n2 : Z.
Axiom n2_non_negative : `0 <= n2`.

Tactic Definition Omega' := 
  Generalize n1_non_negative; 
  Generalize n2_non_negative; 
  Abstract Omega.

Definition min_suffix :=
  [w1:(array A)][w2:(array A)][i,j,n:Z]
  (min_dist (suffix n1 w1 i) (suffix n2 w2 j) n).

Definition test_char := [a,b:A](bool_of_sumbool (A_eq_dec a b)).

(* Why obligation from file "distance.mlw", characters 1733-1749 *)
Lemma distance_po_1 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (Variant1: Z)
  (i1: Z)
  (t0: (array Z))
  (Pre4: Variant1 = `n2 + 1 - i1`)
  (Pre3: (`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
         ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`)))
  (Test2: `i1 <= n2`)
  `0 <= i1` /\ `i1 < (array_length t0)`.
Proof.
Simpl; Intuition.
Save.

(* Why obligation from file "distance.mlw", characters 1560-1781 *)
Lemma distance_po_2 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (Variant1: Z)
  (i1: Z)
  (t0: (array Z))
  (Pre4: Variant1 = `n2 + 1 - i1`)
  (Pre3: (`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
         ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`)))
  (Test2: `i1 <= n2`)
  (Pre2: `0 <= i1` /\ `i1 < (array_length t0)`)
  (t1: (array Z))
  (Post2: t1 = (store t0 i1 `n2 - i1`))
  (i2: Z)
  (Post3: i2 = `i1 + 1`)
  ((`0 <= i2` /\ `i2 <= n2 + 1`) /\ `(array_length t1) = n2 + 1` /\
  ((j:Z) (`0 <= j` /\ `j < i2` -> `(access t1 j) = n2 - j`))) /\
  (Zwf `0` `n2 + 1 - i2` `n2 + 1 - i1`).
Proof.
Intuition.
ArraySubst t1.
Subst t1. AccessStore i1 j Hij; Try Omega'.
Apply H8; Omega'.
Unfold Zwf; Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 1598-1697 *)
Lemma distance_po_3 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (`0 <= i0` /\ `i0 <= n2 + 1`) /\ `(array_length t) = n2 + 1` /\
  ((j:Z) (`0 <= j` /\ `j < i0` -> `(access t j) = n2 - j`)).
Proof.
Intuition.
Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2027-2032 *)
Lemma distance_po_4 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  `0 <= n2` /\ `n2 < (array_length t1)`.
Proof.
Intuition.
Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2480-2485 *)
Lemma distance_po_5 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (temp: Z)
  (Post12: temp = old2)
  `0 <= j2` /\ `j2 < (array_length t3)`.
Proof.
Intuition.
Save.

(* Why obligation from file "distance.mlw", characters 2513-2519 *)
Lemma distance_po_6 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (temp: Z)
  (Post12: temp = old2)
  (Pre11: `0 <= j2` /\ `j2 < (array_length t3)`)
  (old3: Z)
  (Post9: old3 = (access t3 j2))
  `0 <= j2` /\ `j2 < (array_length w2)`.
Proof.
Intuition.
Save.

(* Why obligation from file "distance.mlw", characters 2506-2512 *)
Lemma distance_po_7 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (temp: Z)
  (Post12: temp = old2)
  (Pre11: `0 <= j2` /\ `j2 < (array_length t3)`)
  (old3: Z)
  (Post9: old3 = (access t3 j2))
  (Pre8: `0 <= j2` /\ `j2 < (array_length w2)`)
  `0 <= i3` /\ `i3 < (array_length w1)`.
Proof.
Intuition.
Save.

(* Why obligation from file "distance.mlw", characters 2533-2546 *)
Lemma distance_po_8 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (temp: Z)
  (Post12: temp = old2)
  (Pre11: `0 <= j2` /\ `j2 < (array_length t3)`)
  (old3: Z)
  (Post9: old3 = (access t3 j2))
  (Test6: (access w1 i3) = (access w2 j2))
  (Pre10: `0 <= j2` /\ `j2 < (array_length t3)`)
  (t4: (array Z))
  (Post10: t4 = (store t3 j2 temp))
  ((j:Z)
   (j = `j2 - 1` -> ((`(-1) <= j` /\ `j <= n2 - 1`) /\
    `(array_length t4) = n2 + 1` /\
    ((k:Z) (`j < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t4 k)))) /\
    ((k:Z)
     (`0 <= k` /\ `k <= j` -> (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
    (min_suffix w1 w2 `i3 + 1` `j + 1` old3)) /\ (Zwf `0` `j + 1` `j2 + 1`))).
Proof.
Intuition.
ArraySubst t4.
Unfold min_suffix.
Subst t4.
AccessStore j2 k Hj2k.
  (* j2=k *)
  Rewrite (suffix_is_cons n1 w1 i3); [ Idtac | Omega' ].
  Rewrite (suffix_is_cons n2 w2 k); [ Idtac | Omega' ].
  Rewrite Test6. Rewrite <- Hj2k.
  Apply min_dist_equal.
  Subst temp; Assumption.
  Omega'.
  (* j2<>k *)
  Unfold min_suffix in H16.
  Apply H16; Omega'.
  Omega'.
  Omega'.
Unfold min_suffix.
Subst t4.
AccessOther.
Unfold min_suffix in H19; Apply H19; Omega'.
Replace `j+1` with j2; [ Idtac | Omega' ].
Subst old3.
Unfold min_suffix; Unfold min_suffix in H19; Apply H19; Omega'.
Unfold Zwf; Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2564-2597 *)
Lemma distance_po_9 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (temp: Z)
  (Post12: temp = old2)
  (Pre11: `0 <= j2` /\ `j2 < (array_length t3)`)
  (old3: Z)
  (Post9: old3 = (access t3 j2))
  (Test5: ~(access w1 i3) = (access w2 j2))
  (Pre9: `0 <= j2` /\ `j2 < (array_length t3)`)
  (t4: (array Z))
  (Post11: t4 = (store t3 j2 `(Zmin (access t3 j2) (access t3 j2 + 1)) + 1`))
  ((j:Z)
   (j = `j2 - 1` -> ((`(-1) <= j` /\ `j <= n2 - 1`) /\
    `(array_length t4) = n2 + 1` /\
    ((k:Z) (`j < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t4 k)))) /\
    ((k:Z)
     (`0 <= k` /\ `k <= j` -> (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
    (min_suffix w1 w2 `i3 + 1` `j + 1` old3)) /\ (Zwf `0` `j + 1` `j2 + 1`))).
Proof.
Intuition.
ArraySubst t4.
Unfold min_suffix.
Rewrite Post11; Clear Post11.
AccessStore j2 k Hj2k.
  (* j2=k *)
  Rewrite <- Hj2k.  
  Rewrite (suffix_is_cons n1 w1 i3); [ Idtac | Omega' ].
  Rewrite (suffix_is_cons n2 w2 j2); [ Idtac | Omega' ].
  Apply min_dist_diff. 
  Assumption.
  Rewrite <- (suffix_is_cons n1 w1 i3); [ Idtac | Omega' ].
  Apply H16; Omega'.
  Rewrite <- (suffix_is_cons n2 w2 j2); [ Idtac | Omega' ].
  Apply H19; Omega'.
  Omega'.
  (* j2<> k *)
  Apply H16; Omega'.
  Omega'.
  Omega'.
Rewrite Post11; Clear Post11.
Unfold min_suffix.
AccessOther.
Apply H19; Omega'.
Replace `j+1` with j2; [ Idtac | Omega' ].
Subst old3; Apply H19; Omega'.
Unfold Zwf; Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2116-2648 *)
Lemma distance_po_10 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (Variant5: Z)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Pre13: Variant5 = `j2 + 1`)
  (Pre12: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
          ((k:Z)
           (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
          ((k:Z)
           (`0 <= k` /\ `k <= j2` ->
            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
  (Test7: `j2 >= 0`)
  (old3: Z)
  (t4: (array Z))
  (Post24: ((j:Z)
            (j = `j2 - 1` -> ((`(-1) <= j` /\ `j <= n2 - 1`) /\
             `(array_length t4) = n2 + 1` /\
             ((k:Z)
              (`j < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t4 k)))) /\
             ((k:Z)
              (`0 <= k` /\ `k <= j` ->
               (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
             (min_suffix w1 w2 `i3 + 1` `j + 1` old3)) /\
             (Zwf `0` `j + 1` `j2 + 1`))))
  (j3: Z)
  (Post13: j3 = `j2 - 1`)
  ((`(-1) <= j3` /\ `j3 <= n2 - 1`) /\ `(array_length t4) = n2 + 1` /\
  ((k:Z) (`j3 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t4 k)))) /\
  ((k:Z)
   (`0 <= k` /\ `k <= j3` -> (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
  (min_suffix w1 w2 `i3 + 1` `j3 + 1` old3)) /\ (Zwf `0` `j3 + 1` `j2 + 1`).
Proof.
Intuition.
Save.

(* Why obligation from file "distance.mlw", characters 2155-2403 *)
Lemma distance_po_11 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (`(-1) <= j1` /\ `j1 <= n2 - 1`) /\ `(array_length t2) = n2 + 1` /\
  ((k:Z) (`j1 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t2 k)))) /\
  ((k:Z)
   (`0 <= k` /\ `k <= j1` -> (min_suffix w1 w2 `i3 + 1` k (access t2 k)))) /\
  (min_suffix w1 w2 `i3 + 1` `j1 + 1` old1).
Proof.
Intuition.
ArraySubst t2.
Rewrite Post7; Clear Post7.
Replace k with n2; [ Idtac | Omega' ].
Unfold min_suffix.
Rewrite (suffix_is_cons n1 w1 i3).
Rewrite suffix_n_is_eps.
AccessSame.
Apply min_dist_eps.
Rewrite <- suffix_n_is_eps with n:=n2 t:=w2.
Apply H13; Omega'.
Omega'.
Rewrite Post7.
AccessOther.
Apply H13; Omega'.
Rewrite Post6.
Replace `n2` with `(j1+1)`; [ Idtac | Omega' ].
Apply H13; Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 1831-2673 *)
Lemma distance_po_12 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (Variant3: Z)
  (i3: Z)
  (t1: (array Z))
  (Pre17: Variant3 = `i3 + 1`)
  (Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
          ((j:Z)
           (`0 <= j` /\ `j <= n2` ->
            (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
  (Test8: `i3 >= 0`)
  (Pre15: `0 <= n2` /\ `n2 < (array_length t1)`)
  (old1: Z)
  (Post6: old1 = (access t1 n2))
  (Pre14: `0 <= n2` /\ `n2 < (array_length t1)`)
  (t2: (array Z))
  (Post7: t2 = (store t1 n2 `(access t1 n2) + 1`))
  (j1: Z)
  (Post8: j1 = `n2 - 1`)
  (j2: Z)
  (old2: Z)
  (t3: (array Z))
  (Post14: ((`(-1) <= j2` /\ `j2 <= n2 - 1`) /\
           `(array_length t3) = n2 + 1` /\
           ((k:Z)
            (`j2 < k` /\ `k <= n2` -> (min_suffix w1 w2 i3 k (access t3 k)))) /\
           ((k:Z)
            (`0 <= k` /\ `k <= j2` ->
             (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
           (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2)) /\ `j2 < 0`)
  (i4: Z)
  (Post15: i4 = `i3 - 1`)
  ((`(-1) <= i4` /\ `i4 <= n1 - 1`) /\ `(array_length t3) = n2 + 1` /\
  ((j:Z)
   (`0 <= j` /\ `j <= n2` -> (min_suffix w1 w2 `i4 + 1` j (access t3 j))))) /\
  (Zwf `0` `i4 + 1` `i3 + 1`).
Proof.
Intuition.
Replace `i4+1` with i3; [ Idtac | Omega' ].
Apply H18; Omega'.
Unfold Zwf; Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 1868-1987 *)
Lemma distance_po_13 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (`(-1) <= i2` /\ `i2 <= n1 - 1`) /\ `(array_length t0) = n2 + 1` /\
  ((j:Z)
   (`0 <= j` /\ `j <= n2` -> (min_suffix w1 w2 `i2 + 1` j (access t0 j)))).
Proof.
Intuition.
Omega'.
Replace `i2+1` with n1; [ Idtac | Omega' ].
Unfold min_suffix.
Rewrite suffix_n_is_eps.
Replace (access t0 j) with (Zlength (suffix n2 w2 j)).
Exact (min_dist_eps_length (suffix n2 w2 j)).
Rewrite H7.
Apply suffix_length; Omega'.
Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2681-2685 *)
Lemma distance_po_14 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (i3: Z)
  (t1: (array Z))
  (Post16: ((`(-1) <= i3` /\ `i3 <= n1 - 1`) /\
           `(array_length t1) = n2 + 1` /\
           ((j:Z)
            (`0 <= j` /\ `j <= n2` ->
             (min_suffix w1 w2 `i3 + 1` j (access t1 j))))) /\
           `i3 < 0`)
  `0 <= 0` /\ `0 < (array_length t1)`.
Proof.
Intuition.
Omega'.
Save.

(* Why obligation from file "distance.mlw", characters 2681-2685 *)
Lemma distance_po_15 : 
  (t: (array Z))
  (w1: (array A))
  (w2: (array A))
  (Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
          `(array_length t) = n2 + 1`)
  (i0: Z)
  (Post1: i0 = `0`)
  (i1: Z)
  (t0: (array Z))
  (Post4: ((`0 <= i1` /\ `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
          ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))) /\
          `i1 > n2`)
  (i2: Z)
  (Post5: i2 = `n1 - 1`)
  (i3: Z)
  (t1: (array Z))
  (Post16: ((`(-1) <= i3` /\ `i3 <= n1 - 1`) /\
           `(array_length t1) = n2 + 1` /\
           ((j:Z)
            (`0 <= j` /\ `j <= n2` ->
             (min_suffix w1 w2 `i3 + 1` j (access t1 j))))) /\
           `i3 < 0`)
  (Pre18: `0 <= 0` /\ `0 < (array_length t1)`)
  (min_dist (word_of_array n1 w1) (word_of_array n2 w2) (access t1 `0`)).
Proof.
Intuition.
Cut `i3+1=0`; [ Intro Hi3 | Omega' ].
Rewrite Hi3 in H14.
Unfold word_of_array.
Unfold min_suffix in H14.
Apply (H14 `0`); Omega'.
Save.

Definition distance (* validation *)
  : (i: Z)(j: Z)(old: Z)(t: (array Z))(w1: (array A))(w2: (array A))
    (_: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
    `(array_length t) = n2 + 1`)
    (sig_5 Z Z Z (array Z) Z [i0: Z][j0: Z][old0: Z][t0: (array Z)]
     [result: Z]
     ((min_dist (word_of_array n1 w1) (word_of_array n2 w2) result)))
  := [i: Z; j: Z; old: Z; t: (array Z); w1: (array A); w2: (array A);
      Pre19: `(array_length w1) = n1` /\ `(array_length w2) = n2` /\
      `(array_length t) = n2 + 1`]
       let (i0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = `0` `0`
           (refl_equal ? `0`)) in
         (exist_2 [i1: Z][result0: unit]i1 = `0` result tt Post1) in
       let (i1, t0, result0, Post4) =
         (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
           [Variant1: Z](i1: Z)(t0: (array Z))(_: Variant1 = `n2 + 1 - i1`)
           (_0: (`0 <= i1` /\ `i1 <= n2 + 1`) /\
           `(array_length t0) = n2 + 1` /\
           ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`)))
           (sig_3 Z (array Z) unit [i2: Z][t1: (array Z)][result0: unit]
            (((`0 <= i2` /\ `i2 <= n2 + 1`) /\
            `(array_length t1) = n2 + 1` /\
            ((j:Z) (`0 <= j` /\ `j < i2` -> `(access t1 j) = n2 - j`))) /\
            `i2 > n2`))
           [Variant1: Z; wf1: (Variant2: Z)
            (Pre1: (Zwf `0` Variant2 Variant1))(i1: Z)(t0: (array Z))
            (_: Variant2 = `n2 + 1 - i1`)(_0: (`0 <= i1` /\
            `i1 <= n2 + 1`) /\ `(array_length t0) = n2 + 1` /\
            ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`)))
            (sig_3 Z (array Z) unit [i2: Z][t1: (array Z)][result0: unit]
             (((`0 <= i2` /\ `i2 <= n2 + 1`) /\
             `(array_length t1) = n2 + 1` /\
             ((j:Z) (`0 <= j` /\ `j < i2` -> `(access t1 j) = n2 - j`))) /\
             `i2 > n2`));
            i1: Z; t0: (array Z); Pre4: Variant1 = `n2 + 1 - i1`;
            Pre3: (`0 <= i1` /\ `i1 <= n2 + 1`) /\
            `(array_length t0) = n2 + 1` /\
            ((j:Z) (`0 <= j` /\ `j < i1` -> `(access t0 j) = n2 - j`))]
             let (result0, Bool1) =
               let (result2, Post21) = (Z_le_gt_bool i1 n2) in
               (exist_1 [result3: bool]
               (if result3 then `i1 <= n2` else `i1 > n2`) result2 Post21) in
             (Cases (btest
                     [result0:bool](if result0 then `i1 <= n2` else `i1 > n2`)
                     result0 Bool1) of
             | (left Test2) =>
                 let (i2, t1, result1, Post4) =
                   let (i2, t1, result1, Post20) =
                     let Pre2 =
                       (distance_po_1 t w1 w2 Pre19 i0 Post1 Variant1 i1 t0
                       Pre4 Pre3 Test2) in
                     let (t1, result1, Post2) = (exist_2 [t2: (array Z)]
                       [result3: unit]
                       t2 = (store t0 i1 `n2 - i1`) (store t0 i1 `n2 - i1`)
                       tt (refl_equal ? (store t0 i1 `n2 - i1`))) in
                     let (i2, result2, Post3) =
                       let (result2, Post3) = (exist_1 [result2: Z]
                         result2 = `i1 + 1` `i1 + 1`
                         (refl_equal ? `i1 + 1`)) in
                       (exist_2 [i3: Z][result3: unit]i3 = `i1 + 1` result2
                       tt Post3) in
                     (exist_3 [i3: Z][t2: (array Z)][result3: unit]
                     ((`0 <= i3` /\ `i3 <= n2 + 1`) /\
                     `(array_length t2) = n2 + 1` /\
                     ((j:Z)
                      (`0 <= j` /\ `j < i3` -> `(access t2 j) = n2 - j`))) /\
                     (Zwf `0` `n2 + 1 - i3` `n2 + 1 - i1`) i2 t1 result2
                     (distance_po_2 t w1 w2 Pre19 i0 Post1 Variant1 i1 t0
                     Pre4 Pre3 Test2 Pre2 t1 Post2 i2 Post3)) in
                   ((wf1 `n2 + 1 - i2`) (loop_variant_1 Pre4 Post20) 
                     i2 t1 (refl_equal ? `n2 + 1 - i2`) (proj1 ? ? Post20)) in
                 (exist_3 [i3: Z][t2: (array Z)][result2: unit]((`0 <= i3` /\
                 `i3 <= n2 + 1`) /\ `(array_length t2) = n2 + 1` /\
                 ((j:Z) (`0 <= j` /\ `j < i3` -> `(access t2 j) = n2 - j`))) /\
                 `i3 > n2` i2 t1 result1 Post4)
             | (right Test1) =>
                 let (i2, t1, result1, Post4) = (exist_3 [i2: Z]
                   [t1: (array Z)][result1: unit]((`0 <= i2` /\
                   `i2 <= n2 + 1`) /\ `(array_length t1) = n2 + 1` /\
                   ((j:Z) (`0 <= j` /\ `j < i2` -> `(access t1 j) = n2 - j`))) /\
                   `i2 > n2` i1 t0 tt (conj ? ? Pre3 Test1)) in
                 (exist_3 [i3: Z][t2: (array Z)][result2: unit]((`0 <= i3` /\
                 `i3 <= n2 + 1`) /\ `(array_length t2) = n2 + 1` /\
                 ((j:Z) (`0 <= j` /\ `j < i3` -> `(access t2 j) = n2 - j`))) /\
                 `i3 > n2` i2 t1 result1 Post4) end) `n2 + 1 - i0` i0 
           t (refl_equal ? `n2 + 1 - i0`)
           (distance_po_3 t w1 w2 Pre19 i0 Post1)) in
       let (i2, result1, Post5) =
         let (result1, Post5) = (exist_1 [result1: Z]
           result1 = `n1 - 1` `n1 - 1` (refl_equal ? `n1 - 1`)) in
         (exist_2 [i3: Z][result2: unit]i3 = `n1 - 1` result1 tt Post5) in
       let (i3, j0, old0, t1, result2, Post16) =
         (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
           [Variant3: Z](i3: Z)(j0: Z)(old0: Z)(t1: (array Z))
           (_: Variant3 = `i3 + 1`)(_0: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\
           `(array_length t1) = n2 + 1` /\
           ((j:Z)
            (`0 <= j` /\ `j <= n2` ->
             (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
           (sig_5 Z Z Z (array Z) unit [i4: Z][j1: Z][old1: Z][t2: (array Z)]
            [result2: unit](((`(-1) <= i4` /\ `i4 <= n1 - 1`) /\
            `(array_length t2) = n2 + 1` /\
            ((j:Z)
             (`0 <= j` /\ `j <= n2` ->
              (min_suffix w1 w2 `i4 + 1` j (access t2 j))))) /\
            `i4 < 0`))
           [Variant3: Z; wf2: (Variant4: Z)
            (Pre5: (Zwf `0` Variant4 Variant3))(i3: Z)(j0: Z)(old0: Z)
            (t1: (array Z))(_: Variant4 = `i3 + 1`)(_0: (`(-1) <= i3` /\
            `i3 <= n1 - 1`) /\ `(array_length t1) = n2 + 1` /\
            ((j:Z)
             (`0 <= j` /\ `j <= n2` ->
              (min_suffix w1 w2 `i3 + 1` j (access t1 j)))))
            (sig_5 Z Z Z (array Z) unit [i4: Z][j1: Z][old1: Z]
             [t2: (array Z)][result2: unit](((`(-1) <= i4` /\
             `i4 <= n1 - 1`) /\ `(array_length t2) = n2 + 1` /\
             ((j:Z)
              (`0 <= j` /\ `j <= n2` ->
               (min_suffix w1 w2 `i4 + 1` j (access t2 j))))) /\
             `i4 < 0`));
            i3: Z; j0: Z; old0: Z; t1: (array Z); Pre17: Variant3 = `i3 + 1`;
            Pre16: (`(-1) <= i3` /\ `i3 <= n1 - 1`) /\
            `(array_length t1) = n2 + 1` /\
            ((j:Z)
             (`0 <= j` /\ `j <= n2` ->
              (min_suffix w1 w2 `i3 + 1` j (access t1 j))))]
             let (result2, Bool4) =
               let (result4, Post22) = (Z_ge_lt_bool i3 `0`) in
               (exist_1 [result5: bool]
               (if result5 then `i3 >= 0` else `i3 < 0`) result4 Post22) in
             (Cases (btest
                     [result2:bool](if result2 then `i3 >= 0` else `i3 < 0`)
                     result2 Bool4) of
             | (left Test8) =>
                 let (i4, j1, old1, t2, result3, Post16) =
                   let (i4, j1, old1, t2, result3, Post17) =
                     let Pre15 =
                       (distance_po_4 t w1 w2 Pre19 i0 Post1 i1 t0 Post4 i2
                       Post5 Variant3 i3 t1 Pre17 Pre16 Test8) in
                     let (old1, result3, Post6) =
                       let (result3, Post6) = (exist_1 [result3: Z]
                         result3 = (access t1 n2) (access t1 n2)
                         (refl_equal ? (access t1 n2))) in
                       (exist_2 [old2: Z][result4: unit]
                       old2 = (access t1 n2) result3 tt Post6) in
                     let Pre14 = Pre15 in
                     let (t2, result4, Post7) = (exist_2 [t3: (array Z)]
                       [result6: unit]
                       t3 = (store t1 n2 `(access t1 n2) + 1`) (store t1 n2
                                                                `(access t1
                                                                  n2) +
                                                                 1`) 
                       tt
                       (refl_equal ? (store t1 n2 `(access t1 n2) + 1`))) in
                     let (j1, result5, Post8) =
                       let (result5, Post8) = (exist_1 [result5: Z]
                         result5 = `n2 - 1` `n2 - 1`
                         (refl_equal ? `n2 - 1`)) in
                       (exist_2 [j2: Z][result6: unit]j2 = `n2 - 1` result5
                       tt Post8) in
                     let (j2, old2, t3, result6, Post14) =
                       (well_founded_induction Z (Zwf ZERO)
                         (Zwf_well_founded `0`) [Variant5: Z](j2: Z)(old2: Z)
                         (t3: (array Z))(_: Variant5 = `j2 + 1`)
                         (_0: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\
                         `(array_length t3) = n2 + 1` /\
                         ((k:Z)
                          (`j2 < k` /\ `k <= n2` ->
                           (min_suffix w1 w2 i3 k (access t3 k)))) /\
                         ((k:Z)
                          (`0 <= k` /\ `k <= j2` ->
                           (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
                         (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
                         (sig_4 Z Z (array Z) unit [j3: Z][old3: Z]
                          [t4: (array Z)][result6: unit](((`(-1) <= j3` /\
                          `j3 <= n2 - 1`) /\ `(array_length t4) = n2 + 1` /\
                          ((k:Z)
                           (`j3 < k` /\ `k <= n2` ->
                            (min_suffix w1 w2 i3 k (access t4 k)))) /\
                          ((k:Z)
                           (`0 <= k` /\ `k <= j3` ->
                            (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
                          (min_suffix w1 w2 `i3 + 1` `j3 + 1` old3)) /\
                          `j3 < 0`))
                         [Variant5: Z; wf3: (Variant6: Z)
                          (Pre6: (Zwf `0` Variant6 Variant5))(j2: Z)(old2: Z)
                          (t3: (array Z))(_: Variant6 = `j2 + 1`)
                          (_0: (`(-1) <= j2` /\ `j2 <= n2 - 1`) /\
                          `(array_length t3) = n2 + 1` /\
                          ((k:Z)
                           (`j2 < k` /\ `k <= n2` ->
                            (min_suffix w1 w2 i3 k (access t3 k)))) /\
                          ((k:Z)
                           (`0 <= k` /\ `k <= j2` ->
                            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
                          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2))
                          (sig_4 Z Z (array Z) unit [j3: Z][old3: Z]
                           [t4: (array Z)][result6: unit](((`(-1) <= j3` /\
                           `j3 <= n2 - 1`) /\ `(array_length t4) = n2 + 1` /\
                           ((k:Z)
                            (`j3 < k` /\ `k <= n2` ->
                             (min_suffix w1 w2 i3 k (access t4 k)))) /\
                           ((k:Z)
                            (`0 <= k` /\ `k <= j3` ->
                             (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
                           (min_suffix w1 w2 `i3 + 1` `j3 + 1` old3)) /\
                           `j3 < 0`));
                          j2: Z; old2: Z; t3: (array Z);
                          Pre13: Variant5 = `j2 + 1`; Pre12: (`(-1) <= j2` /\
                          `j2 <= n2 - 1`) /\ `(array_length t3) = n2 + 1` /\
                          ((k:Z)
                           (`j2 < k` /\ `k <= n2` ->
                            (min_suffix w1 w2 i3 k (access t3 k)))) /\
                          ((k:Z)
                           (`0 <= k` /\ `k <= j2` ->
                            (min_suffix w1 w2 `i3 + 1` k (access t3 k)))) /\
                          (min_suffix w1 w2 `i3 + 1` `j2 + 1` old2)]
                           let (result6, Bool3) =
                             let (result8, Post23) = (Z_ge_lt_bool j2 `0`) in
                             (exist_1 [result9: bool]
                             (if result9 then `j2 >= 0` else `j2 < 0`) 
                             result8 Post23) in
                           (Cases (btest
                                   [result6:bool](if result6 then `j2 >= 0`
                                                  else `j2 < 0`)
                                   result6 Bool3) of
                           | (left Test7) =>
                               let (j3, old3, t4, result7, Post14) =
                                 let (j3, old3, t4, result7, Post18) =
                                   let (old3, t4, result7, Post24) =
                                     let (temp, Post12) =
                                       (exist_1 [result7: Z]
                                       result7 = old2 old2
                                       (refl_equal ? old2)) in
                                     let (old3, t4, result7, Post25) =
                                       let Pre11 =
                                         (distance_po_5 t w1 w2 Pre19 i0
                                         Post1 i1 t0 Post4 i2 Post5 Variant3
                                         i3 t1 Pre17 Pre16 Test8 Pre15 old1
                                         Post6 Pre14 t2 Post7 j1 Post8
                                         Variant5 j2 old2 t3 Pre13 Pre12
                                         Test7 temp Post12) in
                                       let (old3, result7, Post9) =
                                         let (result7, Post9) =
                                           (exist_1 [result7: Z]
                                           result7 = (access t3 j2) (
                                                                    access t3
                                                                    j2)
                                           (refl_equal ? (access t3 j2))) in
                                         (exist_2 [old4: Z][result8: unit]
                                         old4 = (access t3 j2) result7 
                                         tt Post9) in
                                       let (t4, result8, Post26) =
                                         let (result8, Bool2) =
                                           let Pre8 =
                                             (distance_po_6 t w1 w2 Pre19 i0
                                             Post1 i1 t0 Post4 i2 Post5
                                             Variant3 i3 t1 Pre17 Pre16 Test8
                                             Pre15 old1 Post6 Pre14 t2 Post7
                                             j1 Post8 Variant5 j2 old2 t3
                                             Pre13 Pre12 Test7 temp Post12
                                             Pre11 old3 Post9) in
                                           let result9 =
                                             let Pre7 =
                                               (distance_po_7 t w1 w2 Pre19
                                               i0 Post1 i1 t0 Post4 i2 Post5
                                               Variant3 i3 t1 Pre17 Pre16
                                               Test8 Pre15 old1 Post6 Pre14
                                               t2 Post7 j1 Post8 Variant5 j2
                                               old2 t3 Pre13 Pre12 Test7 temp
                                               Post12 Pre11 old3 Post9 Pre8) in
                                             (test_char (access w1 i3)) in
                                           let (result10, Post27) =
                                             (result9 (access w2 j2)) in
                                           (exist_1 [result11: bool]
                                           (if result11
                                            then (access w1 i3) = (access w2
                                                                   j2)
                                            else ~(access w1 i3) = (access w2
                                                                    j2)) 
                                           result10 Post27) in
                                         (Cases (btest
                                                 [result8:bool](if result8
                                                                then 
                                                                (access w1 i3) = (
                                                                access w2 j2)
                                                                else ~
                                                                (access w1 i3) = (
                                                                access w2 j2))
                                                 result8 Bool2) of
                                         | (left Test6) =>
                                             let Pre10 = Pre11 in
                                             let (t4, result9, Post10) =
                                               (exist_2 [t5: (array Z)]
                                               [result11: unit]
                                               t5 = (store t3 j2 temp) 
                                               (store t3 j2 temp) tt
                                               (refl_equal ? (store t3 j2
                                                              temp))) in
                                             (exist_2 [t5: (array Z)]
                                             [result10: unit]
                                             ((j:Z)
                                              (j = `j2 - 1` ->
                                               ((`(-1) <= j` /\
                                               `j <= n2 - 1`) /\
                                               `(array_length t5) = n2 + 1` /\
                                               ((k:Z)
                                                (`j < k` /\ `k <= n2` ->
                                                 (min_suffix w1 w2 i3 k
                                                  (access t5 k)))) /\
                                               ((k:Z)
                                                (`0 <= k` /\ `k <= j` ->
                                                 (min_suffix w1 w2 `i3 + 1` k
                                                  (access t5 k)))) /\
                                               (min_suffix w1 w2 `i3 + 1`
                                                `j + 1` old3)) /\
                                               (Zwf `0` `j + 1` `j2 + 1`))) 
                                             t4 result9
                                             (distance_po_8 t w1 w2 Pre19 i0
                                             Post1 i1 t0 Post4 i2 Post5
                                             Variant3 i3 t1 Pre17 Pre16 Test8
                                             Pre15 old1 Post6 Pre14 t2 Post7
                                             j1 Post8 Variant5 j2 old2 t3
                                             Pre13 Pre12 Test7 temp Post12
                                             Pre11 old3 Post9 Test6 Pre10 t4
                                             Post10))
                                         | (right Test5) =>
                                             let Pre9 = Pre11 in
                                             let (t4, result9, Post11) =
                                               (exist_2 [t5: (array Z)]
                                               [result11: unit]
                                               t5 = (store t3 j2
                                                     `(Zmin (access t3 j2)
                                                       (access t3 j2 + 1)) +
                                                      1`) (store t3 j2
                                                           `(Zmin (access t3
                                                                   j2)
                                                             (access t3 j2 +
                                                              1)) +
                                                            1`) tt
                                               (refl_equal ? (store t3 j2
                                                              `(Zmin (
                                                                access t3 j2)
                                                                (access t3
                                                                 j2 + 1)) +
                                                               1`))) in
                                             (exist_2 [t5: (array Z)]
                                             [result10: unit]
                                             ((j:Z)
                                              (j = `j2 - 1` ->
                                               ((`(-1) <= j` /\
                                               `j <= n2 - 1`) /\
                                               `(array_length t5) = n2 + 1` /\
                                               ((k:Z)
                                                (`j < k` /\ `k <= n2` ->
                                                 (min_suffix w1 w2 i3 k
                                                  (access t5 k)))) /\
                                               ((k:Z)
                                                (`0 <= k` /\ `k <= j` ->
                                                 (min_suffix w1 w2 `i3 + 1` k
                                                  (access t5 k)))) /\
                                               (min_suffix w1 w2 `i3 + 1`
                                                `j + 1` old3)) /\
                                               (Zwf `0` `j + 1` `j2 + 1`))) 
                                             t4 result9
                                             (distance_po_9 t w1 w2 Pre19 i0
                                             Post1 i1 t0 Post4 i2 Post5
                                             Variant3 i3 t1 Pre17 Pre16 Test8
                                             Pre15 old1 Post6 Pre14 t2 Post7
                                             j1 Post8 Variant5 j2 old2 t3
                                             Pre13 Pre12 Test7 temp Post12
                                             Pre11 old3 Post9 Test5 Pre9 t4
                                             Post11)) end) in
                                       (exist_3 [old4: Z][t5: (array Z)]
                                       [result9: unit]
                                       ((j:Z)
                                        (j = `j2 - 1` -> ((`(-1) <= j` /\
                                         `j <= n2 - 1`) /\
                                         `(array_length t5) = n2 + 1` /\
                                         ((k:Z)
                                          (`j < k` /\ `k <= n2` ->
                                           (min_suffix w1 w2 i3 k
                                            (access t5 k)))) /\
                                         ((k:Z)
                                          (`0 <= k` /\ `k <= j` ->
                                           (min_suffix w1 w2 `i3 + 1` k
                                            (access t5 k)))) /\
                                         (min_suffix w1 w2 `i3 + 1` `
                                          j + 1` old4)) /\
                                         (Zwf `0` `j + 1` `j2 + 1`))) 
                                       old3 t4 result8 Post26) in
                                     (exist_3 [old4: Z][t5: (array Z)]
                                     [result8: unit]
                                     ((j:Z)
                                      (j = `j2 - 1` -> ((`(-1) <= j` /\
                                       `j <= n2 - 1`) /\
                                       `(array_length t5) = n2 + 1` /\
                                       ((k:Z)
                                        (`j < k` /\ `k <= n2` ->
                                         (min_suffix w1 w2 i3 k (access t5 k)))) /\
                                       ((k:Z)
                                        (`0 <= k` /\ `k <= j` ->
                                         (min_suffix w1 w2 `i3 + 1` k
                                          (access t5 k)))) /\
                                       (min_suffix w1 w2 `i3 + 1` `j + 1`
                                        old4)) /\
                                       (Zwf `0` `j + 1` `j2 + 1`))) old3
                                     t4 result7 Post25) in
                                   let (j3, result8, Post13) =
                                     let (result8, Post13) =
                                       (exist_1 [result8: Z]
                                       result8 = `j2 - 1` `j2 - 1`
                                       (refl_equal ? `j2 - 1`)) in
                                     (exist_2 [j4: Z][result9: unit]
                                     j4 = `j2 - 1` result8 tt Post13) in
                                   (exist_4 [j4: Z][old4: Z][t5: (array Z)]
                                   [result9: unit]((`(-1) <= j4` /\
                                   `j4 <= n2 - 1`) /\
                                   `(array_length t5) = n2 + 1` /\
                                   ((k:Z)
                                    (`j4 < k` /\ `k <= n2` ->
                                     (min_suffix w1 w2 i3 k (access t5 k)))) /\
                                   ((k:Z)
                                    (`0 <= k` /\ `k <= j4` ->
                                     (min_suffix w1 w2 `i3 + 1` k
                                      (access t5 k)))) /\
                                   (min_suffix w1 w2 `i3 + 1` `j4 + 1` old4)) /\
                                   (Zwf `0` `j4 + 1` `j2 + 1`) j3 old3 
                                   t4 result8
                                   (distance_po_10 t w1 w2 Pre19 i0 Post1 i1
                                   t0 Post4 i2 Post5 Variant3 i3 t1 Pre17
                                   Pre16 Test8 Pre15 old1 Post6 Pre14 t2
                                   Post7 j1 Post8 Variant5 j2 old2 t3 Pre13
                                   Pre12 Test7 old3 t4 Post24 j3 Post13)) in
                                 ((wf3 `j3 + 1`)
                                   (loop_variant_1 Pre13 Post18) j3 old3 
                                   t4 (refl_equal ? `j3 + 1`)
                                   (proj1 ? ? Post18)) in
                               (exist_4 [j4: Z][old4: Z][t5: (array Z)]
                               [result8: unit]((`(-1) <= j4` /\
                               `j4 <= n2 - 1`) /\
                               `(array_length t5) = n2 + 1` /\
                               ((k:Z)
                                (`j4 < k` /\ `k <= n2` ->
                                 (min_suffix w1 w2 i3 k (access t5 k)))) /\
                               ((k:Z)
                                (`0 <= k` /\ `k <= j4` ->
                                 (min_suffix w1 w2 `i3 + 1` k (access t5 k)))) /\
                               (min_suffix w1 w2 `i3 + 1` `j4 + 1` old4)) /\
                               `j4 < 0` j3 old3 t4 result7 Post14)
                           | (right Test4) =>
                               let (j3, old3, t4, result7, Post14) =
                                 (exist_4 [j3: Z][old3: Z][t4: (array Z)]
                                 [result7: unit]((`(-1) <= j3` /\
                                 `j3 <= n2 - 1`) /\
                                 `(array_length t4) = n2 + 1` /\
                                 ((k:Z)
                                  (`j3 < k` /\ `k <= n2` ->
                                   (min_suffix w1 w2 i3 k (access t4 k)))) /\
                                 ((k:Z)
                                  (`0 <= k` /\ `k <= j3` ->
                                   (min_suffix w1 w2 `i3 + 1` k (access t4 k)))) /\
                                 (min_suffix w1 w2 `i3 + 1` `j3 + 1` old3)) /\
                                 `j3 < 0` j2 old2 t3 tt
                                 (conj ? ? Pre12 Test4)) in
                               (exist_4 [j4: Z][old4: Z][t5: (array Z)]
                               [result8: unit]((`(-1) <= j4` /\
                               `j4 <= n2 - 1`) /\
                               `(array_length t5) = n2 + 1` /\
                               ((k:Z)
                                (`j4 < k` /\ `k <= n2` ->
                                 (min_suffix w1 w2 i3 k (access t5 k)))) /\
                               ((k:Z)
                                (`0 <= k` /\ `k <= j4` ->
                                 (min_suffix w1 w2 `i3 + 1` k (access t5 k)))) /\
                               (min_suffix w1 w2 `i3 + 1` `j4 + 1` old4)) /\
                               `j4 < 0` j3 old3 t4 result7 Post14) end)
                         `j1 + 1` j1 old1 t2 (refl_equal ? `j1 + 1`)
                         (distance_po_11 t w1 w2 Pre19 i0 Post1 i1 t0 Post4
                         i2 Post5 Variant3 i3 t1 Pre17 Pre16 Test8 Pre15 old1
                         Post6 Pre14 t2 Post7 j1 Post8)) in
                     let (i4, result7, Post15) =
                       let (result7, Post15) = (exist_1 [result7: Z]
                         result7 = `i3 - 1` `i3 - 1`
                         (refl_equal ? `i3 - 1`)) in
                       (exist_2 [i5: Z][result8: unit]i5 = `i3 - 1` result7
                       tt Post15) in
                     (exist_5 [i5: Z][j3: Z][old3: Z][t4: (array Z)]
                     [result8: unit]((`(-1) <= i5` /\ `i5 <= n1 - 1`) /\
                     `(array_length t4) = n2 + 1` /\
                     ((j:Z)
                      (`0 <= j` /\ `j <= n2` ->
                       (min_suffix w1 w2 `i5 + 1` j (access t4 j))))) /\
                     (Zwf `0` `i5 + 1` `i3 + 1`) i4 j2 old2 t3 result7
                     (distance_po_12 t w1 w2 Pre19 i0 Post1 i1 t0 Post4 i2
                     Post5 Variant3 i3 t1 Pre17 Pre16 Test8 Pre15 old1 Post6
                     Pre14 t2 Post7 j1 Post8 j2 old2 t3 Post14 i4 Post15)) in
                   ((wf2 `i4 + 1`) (loop_variant_1 Pre17 Post17) i4 j1 
                     old1 t2 (refl_equal ? `i4 + 1`) (proj1 ? ? Post17)) in
                 (exist_5 [i5: Z][j2: Z][old2: Z][t3: (array Z)]
                 [result4: unit]((`(-1) <= i5` /\ `i5 <= n1 - 1`) /\
                 `(array_length t3) = n2 + 1` /\
                 ((j:Z)
                  (`0 <= j` /\ `j <= n2` ->
                   (min_suffix w1 w2 `i5 + 1` j (access t3 j))))) /\
                 `i5 < 0` i4 j1 old1 t2 result3 Post16)
             | (right Test3) =>
                 let (i4, j1, old1, t2, result3, Post16) = (exist_5 [i4: Z]
                   [j1: Z][old1: Z][t2: (array Z)][result3: unit]
                   ((`(-1) <= i4` /\ `i4 <= n1 - 1`) /\
                   `(array_length t2) = n2 + 1` /\
                   ((j:Z)
                    (`0 <= j` /\ `j <= n2` ->
                     (min_suffix w1 w2 `i4 + 1` j (access t2 j))))) /\
                   `i4 < 0` i3 j0 old0 t1 tt (conj ? ? Pre16 Test3)) in
                 (exist_5 [i5: Z][j2: Z][old2: Z][t3: (array Z)]
                 [result4: unit]((`(-1) <= i5` /\ `i5 <= n1 - 1`) /\
                 `(array_length t3) = n2 + 1` /\
                 ((j:Z)
                  (`0 <= j` /\ `j <= n2` ->
                   (min_suffix w1 w2 `i5 + 1` j (access t3 j))))) /\
                 `i5 < 0` i4 j1 old1 t2 result3 Post16) end) `i2 + 1` 
           i2 j old t0 (refl_equal ? `i2 + 1`)
           (distance_po_13 t w1 w2 Pre19 i0 Post1 i1 t0 Post4 i2 Post5)) in
       let Pre18 =
         (distance_po_14 t w1 w2 Pre19 i0 Post1 i1 t0 Post4 i2 Post5 i3 t1
         Post16) in
       let (result3, Post28) = (exist_1 [result3: Z]
         (min_dist (word_of_array n1 w1) (word_of_array n2 w2) result3) 
         (access t1 `0`)
         (distance_po_15 t w1 w2 Pre19 i0 Post1 i1 t0 Post4 i2 Post5 i3 t1
         Post16 Pre18)) in
       (exist_5 [i4: Z][j1: Z][old1: Z][t2: (array Z)][result4: Z]
       (min_dist (word_of_array n1 w1) (word_of_array n2 w2) result4) 
       i3 j0 old0 t1 result3 Post28).

