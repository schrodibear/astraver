(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export Why.

(* Why obligation from file "quicksort2.mlw", line 11, characters 4-13: *)
(*Why goal*) Lemma swap_po_1 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  (0 <= j /\ j < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 13, characters 4-25: *)
(*Why goal*) Lemma swap_po_2 : 
  forall (i: Z),
  forall (j: Z),
  forall (t: (array Z)),
  forall (HW_1: (0 <= i /\ i < (array_length t)) /\ 0 <= j /\ j <
                (array_length t)),
  forall (HW_2: 0 <= i /\ i < (array_length t)),
  forall (result: Z),
  forall (HW_3: result = (access t i)),
  forall (HW_4: 0 <= j /\ j < (array_length t)),
  forall (result0: Z),
  forall (HW_5: result0 = (access t j)),
  forall (HW_6: 0 <= i /\ i < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_7: t0 = (update t i result0)),
  forall (HW_8: 0 <= j /\ j < (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_9: t1 = (update t0 j result)),
  (exchange t1 t i j).
Proof.
(* FILL PROOF HERE *)
Save.


Definition swap_functional (* validation *)
  : forall (i: Z), forall (j: Z), forall (t: (array Z)), forall (_: (0 <=
    i /\ i < (array_length t)) /\ 0 <= j /\ j < (array_length t)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  => ((exchange t0 t i j))))
  := (fun (i: Z) (j: Z) (t: (array Z)) (H_1: (0 <= i /\ i <
          (array_length t)) /\ 0 <= j /\ j < (array_length t)) =>
        let v :=
          let Pre1 := 0 <= i /\ i < (array_length t) in
          let (result0, Post1) := (array_get i t) in
          (exist_1 (fun (result1: Z) => result1 = (access t i)) (result0) (
          result0 = (access t i))) in
        let (t0, result) :=
          let (t0, result) :=
            let aux_1 :=
              let Pre2 := 0 <= j /\ j < (array_length t) in
              let (result0, Post2) := (array_get j t) in
              (exist_1 (fun (result1: Z) => result1 = (access t j)) (
              result0) (result0 = (access t j))) in
            let (t0, result) :=
              let Pre3 := 0 <= i /\ i < (array_length t) in
              let (t0, result0, Post3) := (array_set i aux_1 t) in
              (exist_2 (fun (t1: (array Z)) =>
                        (fun (result1: unit) => t1 = (update t i aux_1))) (
              t0) (result0) (t0 = (update t i aux_1))) in
            (Build_tuple_2 (t0) (result)) in
          let (t1, result0) :=
            let Pre4 := 0 <= j /\ j < (array_length t0) in
            let (t1, result1, Post4) := (array_set j v t0) in
            (exist_2 (fun (t2: (array Z)) =>
                      (fun (result2: unit) => t2 = (update t0 j v))) (
            t1) (result1) (t1 = (update t0 j v))) in
          (Build_tuple_2 (t1) (result0)) in
        (Build_tuple_2 (t0) (result))).


(* Why obligation from file "quicksort2.mlw", line 21, characters 12-16: *)
(*Why goal*) Lemma quick_rec_po_1 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  (0 <= l /\ l < (array_length t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 27, characters 13-215: *)
(*Why goal*) Lemma quick_rec_po_2 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  ((forall (j:Z), (l < j /\ j <= l -> (access t j) < result)) /\
  (forall (j:Z), (l < j /\ j < (l + 1) -> (access t j) >= result)) /\
  (sub_permut l r t t) /\ (access t l) = result /\ (l <= l /\ l < (l + 1)) /\
  (l + 1) <= (r + 1)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 32, characters 11-16: *)
(*Why goal*) Lemma quick_rec_po_3 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  (0 <= i /\ i < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 32, characters 46-58: *)
(*Why goal*) Lemma quick_rec_po_4 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  forall (HW_7: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i)),
  forall (HW_9: result0 < result),
  forall (m0: Z),
  forall (HW_10: m0 = (m + 1)),
  ((0 <= i /\ i < (array_length t0)) /\ 0 <= m0 /\ m0 < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 27, characters 13-215: *)
(*Why goal*) Lemma quick_rec_po_5 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  forall (HW_7: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i)),
  forall (HW_9: result0 < result),
  forall (m0: Z),
  forall (HW_10: m0 = (m + 1)),
  forall (HW_11: (0 <= i /\ i < (array_length t0)) /\ 0 <= m0 /\ m0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_12: (exchange t1 t0 i m0)),
  forall (i0: Z),
  forall (HW_13: i0 = (i + 1)),
  ((forall (j:Z), (l < j /\ j <= m0 -> (access t1 j) < result)) /\
  (forall (j:Z), (m0 < j /\ j < i0 -> (access t1 j) >= result)) /\
  (sub_permut l r t1 t) /\ (access t1 l) = result /\ (l <= m0 /\ m0 < i0) /\
  i0 <= (r + 1)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 31, characters 18-27: *)
(*Why goal*) Lemma quick_rec_po_6 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  forall (HW_7: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i)),
  forall (HW_9: result0 < result),
  forall (m0: Z),
  forall (HW_10: m0 = (m + 1)),
  forall (HW_11: (0 <= i /\ i < (array_length t0)) /\ 0 <= m0 /\ m0 <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_12: (exchange t1 t0 i m0)),
  forall (i0: Z),
  forall (HW_13: i0 = (i + 1)),
  (Zwf 0 (1 + r - i0) (1 + r - i)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 27, characters 13-215: *)
(*Why goal*) Lemma quick_rec_po_7 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  forall (HW_7: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i)),
  forall (HW_14: result0 >= result),
  forall (i0: Z),
  forall (HW_15: i0 = (i + 1)),
  ((forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
  (forall (j:Z), (m < j /\ j < i0 -> (access t0 j) >= result)) /\
  (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\ m < i0) /\
  i0 <= (r + 1)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 31, characters 18-27: *)
(*Why goal*) Lemma quick_rec_po_8 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_6: i <= r),
  forall (HW_7: 0 <= i /\ i < (array_length t0)),
  forall (result0: Z),
  forall (HW_8: result0 = (access t0 i)),
  forall (HW_14: result0 >= result),
  forall (i0: Z),
  forall (HW_15: i0 = (i + 1)),
  (Zwf 0 (1 + r - i0) (1 + r - i)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 35, characters 7-18: *)
(*Why goal*) Lemma quick_rec_po_9 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  ((0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m < (array_length t0)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 36, characters 7-29: *)
(*Why goal*) Lemma quick_rec_po_10 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  forall (HW_17: (0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_18: (exchange t1 t0 l m)),
  (Zwf 0 (1 + (m - 1) - l) (1 + r - l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 36, characters 7-29: *)
(*Why goal*) Lemma quick_rec_po_11 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  forall (HW_17: (0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_18: (exchange t1 t0 l m)),
  forall (HW_19: (Zwf 0 (1 + (m - 1) - l) (1 + r - l))),
  (0 <= l /\ (m - 1) < (array_length t1)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 37, characters 7-29: *)
(*Why goal*) Lemma quick_rec_po_12 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  forall (HW_17: (0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_18: (exchange t1 t0 l m)),
  forall (HW_19: (Zwf 0 (1 + (m - 1) - l) (1 + r - l))),
  forall (HW_20: 0 <= l /\ (m - 1) < (array_length t1)),
  forall (t2: (array Z)),
  forall (HW_21: (sorted_array t2 l (m - 1)) /\ (sub_permut l (m - 1) t2 t1)),
  (Zwf 0 (1 + r - (m + 1)) (1 + r - l)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 37, characters 7-29: *)
(*Why goal*) Lemma quick_rec_po_13 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  forall (HW_17: (0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_18: (exchange t1 t0 l m)),
  forall (HW_19: (Zwf 0 (1 + (m - 1) - l) (1 + r - l))),
  forall (HW_20: 0 <= l /\ (m - 1) < (array_length t1)),
  forall (t2: (array Z)),
  forall (HW_21: (sorted_array t2 l (m - 1)) /\ (sub_permut l (m - 1) t2 t1)),
  forall (HW_22: (Zwf 0 (1 + r - (m + 1)) (1 + r - l))),
  (0 <= (m + 1) /\ r < (array_length t2)).
Proof.
(* FILL PROOF HERE *)
Save.


(* Why obligation from file "quicksort2.mlw", line 39, characters 4-53: *)
(*Why goal*) Lemma quick_rec_po_14 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_2: l < r),
  forall (HW_3: 0 <= l /\ l < (array_length t)),
  forall (result: Z),
  forall (HW_4: result = (access t l)),
  forall (i: Z),
  forall (m: Z),
  forall (t0: (array Z)),
  forall (HW_5: (forall (j:Z), (l < j /\ j <= m -> (access t0 j) < result)) /\
                (forall (j:Z), (m < j /\ j < i -> (access t0 j) >= result)) /\
                (sub_permut l r t0 t) /\ (access t0 l) = result /\ (l <= m /\
                m < i) /\ i <= (r + 1)),
  forall (HW_16: i > r),
  forall (HW_17: (0 <= l /\ l < (array_length t0)) /\ 0 <= m /\ m <
                 (array_length t0)),
  forall (t1: (array Z)),
  forall (HW_18: (exchange t1 t0 l m)),
  forall (HW_19: (Zwf 0 (1 + (m - 1) - l) (1 + r - l))),
  forall (HW_20: 0 <= l /\ (m - 1) < (array_length t1)),
  forall (t2: (array Z)),
  forall (HW_21: (sorted_array t2 l (m - 1)) /\ (sub_permut l (m - 1) t2 t1)),
  forall (HW_22: (Zwf 0 (1 + r - (m + 1)) (1 + r - l))),
  forall (HW_23: 0 <= (m + 1) /\ r < (array_length t2)),
  forall (t3: (array Z)),
  forall (HW_24: (sorted_array t3 (m + 1) r) /\ (sub_permut (m + 1) r t3 t2)),
  ((sorted_array t3 l r) /\ (sub_permut l r t3 t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 39, characters 4-53: *)
(*Why goal*) Lemma quick_rec_po_15 : 
  forall (l: Z),
  forall (r: Z),
  forall (t: (array Z)),
  forall (HW_1: 0 <= l /\ r < (array_length t)),
  forall (HW_25: l >= r),
  ((sorted_array t l r) /\ (sub_permut l r t t)).
Proof.
(* FILL PROOF HERE *)
Save.

Definition quick_rec_functional (* validation *)
  : forall (l: Z), forall (r: Z), forall (t: (array Z)), forall (_: 0 <= l /\
    r < (array_length t)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  => ((sorted_array t0 l r) /\
      (sub_permut l r t0 t))))
  := (fun (l: Z) (r: Z) (t: (array Z)) (H_1: 0 <= l /\ r < (array_length t)) =>
        ((well_founded_induction) (Z) ((Zwf Z0)) ((well_founded (Zwf Z0))) ((
          fun (variant2: Z) => forall (l0: Z), forall (r0: Z),
          forall (t0: (array Z)), forall (_: 0 <= l0 /\ r0 <
          (array_length t0)), (tuple_2 (array Z) unit))) ((fun (variant2: Z) (wf1: forall (variant3: Z),
                                                               forall (Pre26: (Zwf 0 variant3 variant2)),
                                                               forall (l0: Z),
                                                               forall (r0: Z),
                                                               forall (t0: (array Z)),
                                                               forall (_: 0 <=
                                                               l0 /\ r0 <
                                                               (array_length
                                                                t0)),
                                                               (tuple_2
                                                                (array Z) unit)) (l0: Z) (r0: Z) (t0: (array Z)) (H_1_0: 0 <=
                                                               l0 /\ r0 <
                                                               (array_length
                                                                t0)) =>
                                                             let (t1, result,
                                                               H_7) :=
                                                               let result :=
                                                                 let (result0,
                                                                   Post23) :=
                                                                   (lt_int_
                                                                    l0 r0) in
                                                                 (exist_1 (
                                                                 fun (result1: bool) =>
                                                                 (if result1
                                                                  then l0 <
                                                                  r0
                                                                  else l0 >=
                                                                  r0)) (
                                                                 result0) ((
                                                                 if result0
                                                                 then l0 < r0
                                                                 else l0 >=
                                                                 r0))) in
                                                               if result then
                                                                 let (t1,
                                                                   result0) :=
                                                                   let v :=
                                                                    let Pre17 :=
                                                                    0 <=
                                                                    l0 /\
                                                                    l0 <
                                                                    (array_length
                                                                    t0) in
                                                                    let (result1,
                                                                    Post24) :=
                                                                    (
                                                                    array_get
                                                                    l0 t0) in
                                                                    (exist_1 (
                                                                    fun (result2: Z) =>
                                                                    result2 =
                                                                    (
                                                                    access
                                                                    t0 l0)) (
                                                                    result1) (
                                                                    result1 =
                                                                    (
                                                                    access
                                                                    t0 l0))) in
                                                                   let (t1,
                                                                    result0) :=
                                                                    let (m1,
                                                                    t1,
                                                                    result0) :=
                                                                    let (i1,
                                                                    m1, t1,
                                                                    result0) :=
                                                                    let (i1,
                                                                    m1, t1,
                                                                    result0) :=
                                                                    let (i1,
                                                                    m1, t1,
                                                                    result0) :=
                                                                    ((well_founded_induction) (Z) (
                                                                    (Zwf Z0)) (
                                                                    (well_founded (Zwf Z0))) ((
                                                                    fun (variant4: Z) =>
                                                                    forall (i1: Z),
                                                                    forall (m1: Z),
                                                                    forall (t1: (array Z)),
                                                                    forall (_: (
                                                                    forall (j:Z),
                                                                    (
                                                                    l0 < j /\
                                                                    j <=
                                                                    m1 ->
                                                                    (
                                                                    access
                                                                    t1 j) < v)) /\
                                                                    (
                                                                    forall (j:Z),
                                                                    (
                                                                    m1 < j /\
                                                                    j < i1 ->
                                                                    (
                                                                    access
                                                                    t1 j) >=
                                                                    v)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 r0 t1 t0) /\
                                                                    (
                                                                    access
                                                                    t1 l0) =
                                                                    v /\
                                                                    (l0 <=
                                                                    m1 /\
                                                                    m1 <
                                                                    i1) /\
                                                                    i1 <=
                                                                    (r0 + 1)),
                                                                    (
                                                                    tuple_4
                                                                    Z Z (array Z) (
                                                                    EM
                                                                    unit unit)))) ((
                                                                    fun 
                                                                    (variant4: Z) (wf2: forall (variant5: Z),
                                                                    forall (Pre27: (Zwf 0 variant5 variant4)),
                                                                    forall (i1: Z),
                                                                    forall (m1: Z),
                                                                    forall (t1: (array Z)),
                                                                    forall (_: (
                                                                    forall (j:Z),
                                                                    (
                                                                    l0 < j /\
                                                                    j <=
                                                                    m1 ->
                                                                    (
                                                                    access
                                                                    t1 j) < v)) /\
                                                                    (
                                                                    forall (j:Z),
                                                                    (
                                                                    m1 < j /\
                                                                    j < i1 ->
                                                                    (
                                                                    access
                                                                    t1 j) >=
                                                                    v)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 r0 t1 t0) /\
                                                                    (
                                                                    access
                                                                    t1 l0) =
                                                                    v /\
                                                                    (l0 <=
                                                                    m1 /\
                                                                    m1 <
                                                                    i1) /\
                                                                    i1 <=
                                                                    (r0 + 1)),
                                                                    (
                                                                    tuple_4
                                                                    Z Z (array Z) (
                                                                    EM
                                                                    unit unit))) (i1: Z) (m1: Z) (t1: (array Z)) (H_6: (
                                                                    forall (j:Z),
                                                                    (
                                                                    l0 < j /\
                                                                    j <=
                                                                    m1 ->
                                                                    (
                                                                    access
                                                                    t1 j) < v)) /\
                                                                    (
                                                                    forall (j:Z),
                                                                    (
                                                                    m1 < j /\
                                                                    j < i1 ->
                                                                    (
                                                                    access
                                                                    t1 j) >=
                                                                    v)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 r0 t1 t0) /\
                                                                    (
                                                                    access
                                                                    t1 l0) =
                                                                    v /\
                                                                    (l0 <=
                                                                    m1 /\
                                                                    m1 <
                                                                    i1) /\
                                                                    i1 <=
                                                                    (r0 + 1)) =>
                                                                    let (i2,
                                                                    m2, t2,
                                                                    result0) :=
                                                                    let result0 :=
                                                                    let (result1,
                                                                    Post25) :=
                                                                    (
                                                                    le_int_
                                                                    i1 r0) in
                                                                    (exist_1 (
                                                                    fun (result2: bool) =>
                                                                    (
                                                                    if result2
                                                                    then i1 <=
                                                                    r0
                                                                    else i1 >
                                                                    r0)) (
                                                                    result1) ((
                                                                    if result1
                                                                    then i1 <=
                                                                    r0
                                                                    else i1 >
                                                                    r0))) in
                                                                    if 
                                                                    result0 then
                                                                      
                                                                    let (i2,
                                                                    m2, t2,
                                                                    result1) :=
                                                                    let (m2,
                                                                    t2,
                                                                    result1) :=
                                                                    let result1 :=
                                                                    let aux_3 :=
                                                                    let Pre19 :=
                                                                    0 <=
                                                                    i1 /\
                                                                    i1 <
                                                                    (array_length
                                                                    t1) in
                                                                    let (result2,
                                                                    Post27) :=
                                                                    (
                                                                    array_get
                                                                    i1 t1) in
                                                                    (exist_1 (
                                                                    fun (result3: Z) =>
                                                                    result3 =
                                                                    (
                                                                    access
                                                                    t1 i1)) (
                                                                    result2) (
                                                                    result2 =
                                                                    (
                                                                    access
                                                                    t1 i1))) in
                                                                    let result1 :=
                                                                    let (result2,
                                                                    Post28) :=
                                                                    (
                                                                    lt_int_
                                                                    aux_3 v) in
                                                                    (exist_1 (
                                                                    fun (result3: bool) =>
                                                                    (
                                                                    if result3
                                                                    then aux_3 <
                                                                    v
                                                                    else aux_3 >=
                                                                    v)) (
                                                                    result2) ((
                                                                    if result2
                                                                    then aux_3 <
                                                                    v
                                                                    else aux_3 >=
                                                                    v))) in
                                                                    result1 in
                                                                    if 
                                                                    result1 then
                                                                      
                                                                    let (m2,
                                                                    t2,
                                                                    result2) :=
                                                                    let (m2,
                                                                    result2) :=
                                                                    let (m2,
                                                                    result3,
                                                                    Post29) :=
                                                                    (
                                                                    ref_set
                                                                    (m1 + 1) m1) in
                                                                    (exist_2 (
                                                                    fun (m3: Z) =>
                                                                    (
                                                                    fun (result4: unit) =>
                                                                    m3 =
                                                                    (m1 + 1))) (
                                                                    m2) (
                                                                    result3) (
                                                                    m2 =
                                                                    (m1 + 1))) in
                                                                    let (t2,
                                                                    result3) :=
                                                                    let Pre20 :=
                                                                    (0 <=
                                                                    i1 /\
                                                                    i1 <
                                                                    (array_length
                                                                    t1)) /\
                                                                    0 <=
                                                                    m2 /\
                                                                    m2 <
                                                                    (array_length
                                                                    t1) in
                                                                    let (t2,
                                                                    result4,
                                                                    Post30) :=
                                                                    (
                                                                    swap
                                                                    i1 m2 t1) in
                                                                    (exist_2 (
                                                                    fun (t3: (array Z)) =>
                                                                    (
                                                                    fun (result5: unit) =>
                                                                    (
                                                                    exchange
                                                                    t3 t1 i1 m2))) (
                                                                    t2) (
                                                                    result4) ((
                                                                    exchange
                                                                    t2 t1 i1 m2))) in
                                                                    (Build_tuple_3 (
                                                                    m2) (
                                                                    t2) (
                                                                    result3)) in
                                                                    (Build_tuple_3 (
                                                                    m2) (
                                                                    t2) (
                                                                    result2))
                                                                    else
                                                                      
                                                                    (Build_tuple_3 (
                                                                    m1) (
                                                                    t1) (
                                                                    tt)) in
                                                                    let (i2,
                                                                    result2) :=
                                                                    let (i2,
                                                                    result3,
                                                                    Post31) :=
                                                                    (
                                                                    ref_set
                                                                    (i1 + 1) i1) in
                                                                    (exist_2 (
                                                                    fun (i3: Z) =>
                                                                    (
                                                                    fun (result4: unit) =>
                                                                    i3 =
                                                                    (i1 + 1))) (
                                                                    i2) (
                                                                    result3) (
                                                                    i2 =
                                                                    (i1 + 1))) in
                                                                    (Build_tuple_4 (
                                                                    i2) (
                                                                    m2) (
                                                                    t2) (
                                                                    result2)) in
                                                                    (Build_tuple_4 (
                                                                    i2) (
                                                                    m2) (
                                                                    t2) (
                                                                    ((Val) (unit) (
                                                                    result1))))
                                                                    else
                                                                      
                                                                    let result1 :=
                                                                    ((Exn) (unit) (
                                                                    tt)) in
                                                                    match 
                                                                    result1 with
                                                                    | (Val result1_0) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    m1) (
                                                                    t1) (
                                                                    ((Val) (unit) (
                                                                    result1_0))))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    m1) (
                                                                    t1) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end in
                                                                    match 
                                                                    result0 with
                                                                    | (Val result0_0) =>
                                                                    (((
                                                                    wf2
                                                                    (1 + r0 -
                                                                    i2))) ((Zwf 0 
                                                                    (1 + r0 -
                                                                    i2) variant4)) (
                                                                    i2) (
                                                                    m2) (
                                                                    t2) (
                                                                    (1 + r0 -
                                                                    i2) =
                                                                    (1 + r0 -
                                                                    i2)) ((
                                                                    forall (j:Z),
                                                                    (
                                                                    l0 < j /\
                                                                    j <=
                                                                    m2 ->
                                                                    (
                                                                    access
                                                                    t2 j) < v)) /\
                                                                    (forall (j:Z),
                                                                    (m2 <
                                                                    j /\ j <
                                                                    i2 ->
                                                                    (access
                                                                    t2 j) >=
                                                                    v)) /\
                                                                    (sub_permut
                                                                    l0 r0 t2 t0) /\
                                                                    (access
                                                                    t2 l0) =
                                                                    v /\
                                                                    (l0 <=
                                                                    m2 /\
                                                                    m2 <
                                                                    i2) /\
                                                                    i2 <=
                                                                    (r0 + 1)))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_4 (
                                                                    i2) (
                                                                    m2) (
                                                                    t2) (
                                                                    ((Exn) (unit) (
                                                                    tt))))
                                                                    end)) (
                                                                    (1 + r0 -
                                                                    (l0 + 1))) (
                                                                    (l0 + 1)) (
                                                                    l0) (
                                                                    t0) (
                                                                    (1 + r0 -
                                                                    (l0 + 1)) =
                                                                    (1 + r0 -
                                                                    (l0 + 1))) ((
                                                                    forall (j:Z),
                                                                    (
                                                                    l0 < j /\
                                                                    j <=
                                                                    l0 ->
                                                                    (
                                                                    access
                                                                    t0 j) < v)) /\
                                                                    (forall (j:Z),
                                                                    (l0 <
                                                                    j /\ j <
                                                                    (l0 + 1) ->
                                                                    (access
                                                                    t0 j) >=
                                                                    v)) /\
                                                                    (sub_permut
                                                                    l0 r0 t0 t0) /\
                                                                    (access
                                                                    t0 l0) =
                                                                    v /\
                                                                    (l0 <=
                                                                    l0 /\
                                                                    l0 <
                                                                    (l0 + 1)) /\
                                                                    (l0 + 1) <=
                                                                    (r0 + 1))) in
                                                                    match 
                                                                    result0 with
                                                                    | (Val result0_0) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    m1) (
                                                                    t1) (
                                                                    result0_0))
                                                                    | (Exn _) =>
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    m1) (
                                                                    t1) (
                                                                    tt))
                                                                    end in
                                                                    let (t2,
                                                                    result1) :=
                                                                    let (t2,
                                                                    result1) :=
                                                                    let Pre21 :=
                                                                    (0 <=
                                                                    l0 /\
                                                                    l0 <
                                                                    (array_length
                                                                    t1)) /\
                                                                    0 <=
                                                                    m1 /\
                                                                    m1 <
                                                                    (array_length
                                                                    t1) in
                                                                    let (t2,
                                                                    result2,
                                                                    Post32) :=
                                                                    (
                                                                    swap
                                                                    l0 m1 t1) in
                                                                    (exist_2 (
                                                                    fun (t3: (array Z)) =>
                                                                    (
                                                                    fun (result3: unit) =>
                                                                    (
                                                                    exchange
                                                                    t3 t1 l0 m1))) (
                                                                    t2) (
                                                                    result2) ((
                                                                    exchange
                                                                    t2 t1 l0 m1))) in
                                                                    let (t3,
                                                                    result2) :=
                                                                    let (t3,
                                                                    result2) :=
                                                                    let Pre23 :=
                                                                    0 <=
                                                                    l0 /\
                                                                    (m1 - 1) <
                                                                    (array_length
                                                                    t2) in
                                                                    let Pre22 :=
                                                                    (Zwf 0 
                                                                    (1 +
                                                                    (m1 - 1) -
                                                                    l0) 
                                                                    (1 + r0 -
                                                                    l0)) in
                                                                    let (t3,
                                                                    result3,
                                                                    Post33) :=
                                                                    (fun 
                                                                    (H_1_1: 0 <=
                                                                    l0 /\
                                                                    (m1 - 1) <
                                                                    (
                                                                    array_length
                                                                    t2)) =>
                                                                    (((
                                                                    wf1
                                                                    (1 +
                                                                    (m1 - 1) -
                                                                    l0))) ((Zwf 0 
                                                                    (1 +
                                                                    (m1 - 1) -
                                                                    l0) variant2)) (
                                                                    l0) (
                                                                    (m1 - 1)) (
                                                                    t2) (
                                                                    (1 +
                                                                    (m1 - 1) -
                                                                    l0) =
                                                                    (1 +
                                                                    (m1 - 1) -
                                                                    l0)) (0 <=
                                                                    l0 /\
                                                                    (m1 - 1) <
                                                                    (array_length
                                                                    t2)))) in
                                                                    (exist_2 (
                                                                    fun (t4: (array Z)) =>
                                                                    (
                                                                    fun (result4: unit) =>
                                                                    (
                                                                    sorted_array
                                                                    t4 l0 
                                                                    (m1 - 1)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 
                                                                    (m1 - 1) t4 t2))) (
                                                                    t3) (
                                                                    result3) ((
                                                                    sorted_array
                                                                    t3 l0 
                                                                    (m1 - 1)) /\
                                                                    (
                                                                    sub_permut
                                                                    l0 
                                                                    (m1 - 1) t3 t2))) in
                                                                    let (t4,
                                                                    result3) :=
                                                                    let Pre25 :=
                                                                    0 <=
                                                                    (m1 + 1) /\
                                                                    r0 <
                                                                    (array_length
                                                                    t3) in
                                                                    let Pre24 :=
                                                                    (Zwf 0 
                                                                    (1 + r0 -
                                                                    (m1 + 1)) 
                                                                    (1 + r0 -
                                                                    l0)) in
                                                                    let (t4,
                                                                    result4,
                                                                    Post34) :=
                                                                    (fun 
                                                                    (H_1_1: 0 <=
                                                                    (m1 + 1) /\
                                                                    r0 <
                                                                    (
                                                                    array_length
                                                                    t3)) =>
                                                                    (((
                                                                    wf1
                                                                    (1 + r0 -
                                                                    (m1 + 1)))) ((Zwf 0 
                                                                    (1 + r0 -
                                                                    (m1 + 1)) variant2)) (
                                                                    (m1 + 1)) (
                                                                    r0) (
                                                                    t3) (
                                                                    (1 + r0 -
                                                                    (m1 + 1)) =
                                                                    (1 + r0 -
                                                                    (m1 + 1))) (0 <=
                                                                    (m1 + 1) /\
                                                                    r0 <
                                                                    (array_length
                                                                    t3)))) in
                                                                    (exist_2 (
                                                                    fun (t5: (array Z)) =>
                                                                    (
                                                                    fun (result5: unit) =>
                                                                    (
                                                                    sorted_array
                                                                    t5 
                                                                    (m1 + 1) r0) /\
                                                                    (
                                                                    sub_permut
                                                                    (m1 + 1) r0 t5 t3))) (
                                                                    t4) (
                                                                    result4) ((
                                                                    sorted_array
                                                                    t4 
                                                                    (m1 + 1) r0) /\
                                                                    (
                                                                    sub_permut
                                                                    (m1 + 1) r0 t4 t3))) in
                                                                    (Build_tuple_2 (
                                                                    t4) (
                                                                    result3)) in
                                                                    (Build_tuple_2 (
                                                                    t3) (
                                                                    result2)) in
                                                                    (Build_tuple_4 (
                                                                    i1) (
                                                                    m1) (
                                                                    t2) (
                                                                    result1)) in
                                                                    (Build_tuple_3 (
                                                                    m1) (
                                                                    t1) (
                                                                    result0)) in
                                                                    (Build_tuple_2 (
                                                                    t1) (
                                                                    result0)) in
                                                                   (Build_tuple_2 (
                                                                   t1) (
                                                                   result0)) in
                                                                 (Build_tuple_2 (
                                                                 t1) (
                                                                 result0))
                                                               else
                                                                 (Build_tuple_2 (
                                                                 t0) (
                                                                 tt)) in
                                                             (Build_tuple_2 (
                                                             t1) (result)))) (
          (1 + r - l)) (l) (r) (t) ((1 + r - l) = (1 + r - l)) (0 <= l /\ r <
          (array_length t)))).


(* Why obligation from file "quicksort2.mlw", line 45, characters 3-38: *)
(*Why goal*) Lemma quicksort_po_1 : 
  forall (t: (array Z)),
  forall (result: Z),
  forall (HW_1: result = (array_length t)),
  (0 <= 0 /\ (result - 1) < (array_length t)).
Proof.
(* FILL PROOF HERE *)
Save.

(* Why obligation from file "quicksort2.mlw", line 46, characters 4-59: *)
(*Why goal*) Lemma quicksort_po_2 : 
  forall (t: (array Z)),
  forall (result: Z),
  forall (HW_1: result = (array_length t)),
  forall (HW_2: 0 <= 0 /\ (result - 1) < (array_length t)),
  forall (t0: (array Z)),
  forall (HW_3: (sorted_array t0 0 (result - 1)) /\
                (sub_permut 0 (result - 1) t0 t)),
  ((sorted_array t0 0 ((array_length t0) - 1)) /\ (permut t0 t)).
Proof.
(* FILL PROOF HERE *)
Save.


Definition quicksort_functional (* validation *)
  : forall (t: (array Z)),
    (sig_2 (array Z) unit
     (fun (t0: (array Z)) (result: unit)  =>
      ((sorted_array t0 0 ((array_length t0) - 1)) /\ (permut t0 t))))
  := (fun (t: (array Z)) =>
        let aux_2 :=
          let aux_1 :=
            let (result0, Post2) := (array_length_ t) in
            (exist_1 (fun (result1: Z) => result1 = (array_length t)) (
            result0) (result0 = (array_length t))) in
          (aux_1 - 1) in
        let (t0, result) :=
          let Pre1 := 0 <= 0 /\ aux_2 < (array_length t) in
          let (t0, result0, Post3) := (quick_rec 0 aux_2 t) in
          (exist_2 (fun (t1: (array Z)) =>
                    (fun (result1: unit) => (sorted_array t1 0 aux_2) /\
                     (sub_permut 0 aux_2 t1 t))) (t0) (result0) ((sorted_array
                                                                  t0 0 aux_2) /\
          (sub_permut 0 aux_2 t0 t))) in
        (Build_tuple_2 (t0) (result))).


