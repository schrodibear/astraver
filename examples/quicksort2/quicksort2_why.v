(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.


(* Why obligation from file "quicksort2.mlw", characters 241-250 *)
Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  `0 <= j` /\ `j < (array_length t0)`.
Proof.
Intros; ArraySubst t0.
Save.

(* Why obligation from file "quicksort2.mlw", characters 211-257 *)
Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array Z))
  (Pre5: (`0 <= i` /\ `i < (array_length t)`) /\ `0 <= j` /\
         `j < (array_length t)`)
  (Pre4: `0 <= i` /\ `i < (array_length t)`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= i` /\ `i < (array_length t)`)
  (Pre3: `0 <= j` /\ `j < (array_length t)`)
  (t0: (array Z))
  (Post1: t0 = (store t i (access t j)))
  (Pre1: `0 <= j` /\ `j < (array_length t0)`)
  (t1: (array Z))
  (Post2: t1 = (store t0 j v))
  (exchange t1 t i j).
Proof.
Intros; Subst t1; Subst t0; Subst v.
Auto with datatypes.
Save.

Definition swap (* validation *)
  : (i: Z)(j: Z)(t: (array Z))(_: (`0 <= i` /\ `i < (array_length t)`) /\
    `0 <= j` /\ `j < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]((exchange t0 t i j)))
  := [i: Z; j: Z; t: (array Z); Pre5: (`0 <= i` /\ `i < (array_length t)`) /\
      `0 <= j` /\ `j < (array_length t)`]
       let Pre4 = (proj1 ? ? Pre5) in
       let (v, Post3) = (exist_1 [result: Z]
         result = (access t i) (access t i) (refl_equal ? (access t i))) in
       let (t0, result, Post4) =
         let Pre2 = Pre4 in
         let Pre3 =
           let (HW_1, HW_2) = Pre5 in
           let (HW_3, HW_4) = HW_1 in
           HW_2 in
         let (t0, result, Post1) = (exist_2 [t1: (array Z)][result1: unit]
           t1 = (store t i (access t j)) (store t i (access t j)) tt
           (refl_equal ? (store t i (access t j)))) in
         let Pre1 = (swap_po_1 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1) in
         let (t1, result0, Post2) = (exist_2 [t2: (array Z)][result2: unit]
           t2 = (store t0 j v) (store t0 j v) tt
           (refl_equal ? (store t0 j v))) in
         (exist_2 [t2: (array Z)][result1: unit](exchange t2 t i j) t1
         result0
         (swap_po_2 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1 Pre1 t1 Post2)) in
       (exist_2 [t1: (array Z)][result0: unit](exchange t1 t i j) t0 
       result Post4).

(* Why obligation from file "quicksort2.mlw", characters 531-535 *)
Lemma quick_rec_po_1 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  `0 <= l0` /\ `l0 < (array_length t0)`.
Proof.
Auto with *.
Save.

(* Why obligation from file "quicksort2.mlw", characters 903-908 *)
Lemma quick_rec_po_2 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Pre8: Variant3 = `1 + r0 - i0`)
  (Pre7: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  `0 <= i0` /\ `i0 < (array_length t1)`.
Proof.
Intuition.
ArrayLength.
Save.

(* Why obligation from file "quicksort2.mlw", characters 937-951 *)
Lemma quick_rec_po_3 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Pre8: Variant3 = `1 + r0 - i0`)
  (Pre7: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test4: `(access t1 i0) < v`)
  (m1: Z)
  (Post13: m1 = `m0 + 1`)
  (`0 <= i0` /\ `i0 < (array_length t1)`) /\ `0 <= m1` /\
  `m1 < (array_length t1)`.
Proof.
Intuition ArrayLength; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 918-955 *)
Lemma quick_rec_po_4 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Pre8: Variant3 = `1 + r0 - i0`)
  (Pre7: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test4: `(access t1 i0) < v`)
  (m1: Z)
  (Post13: m1 = `m0 + 1`)
  (Pre6: (`0 <= i0` /\ `i0 < (array_length t1)`) /\ `0 <= m1` /\
         `m1 < (array_length t1)`)
  (t2: (array Z))
  (Post33: (exchange t2 t1 i0 m1))
  ((i:Z)
   (i = `i0 + 1` ->
    (((j:Z) (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
    ((j:Z) (`m1 < j` /\ `j < i` -> `(access t2 j) >= v`)) /\
    (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\ (`l0 <= m1` /\
    `m1 < i`) /\ `i <= r0 + 1`) /\ (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))).
Proof.
Intuition.
Assert hj : `j < m1` \/ j = m1. Omega. 
Decompose [exchange] Post33. Intuition.
Rewrite H24; Try Omega.
Apply H5; Omega.
Subst j; Rewrite H23; Assumption.
Assert hj : `j < i0` \/ j = i0. Omega. 
Decompose [exchange] Post33. Intuition.
Rewrite H24; Try Omega.
Apply H7; Omega.
Subst j; Rewrite H22. Apply H7; Omega.
Apply sub_permut_trans with t1.
Apply exchange_is_sub_permut with i0 m1; Assumption Orelse Omega.
Assumption.
Decompose [exchange] Post33. Intuition.
Rewrite H22; Omega.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 900-955 *)
Lemma quick_rec_po_5 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Pre8: Variant3 = `1 + r0 - i0`)
  (Pre7: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test3: `(access t1 i0) >= v`)
  ((i:Z)
   (i = `i0 + 1` ->
    (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
    ((j:Z) (`m0 < j` /\ `j < i` -> `(access t1 j) >= v`)) /\
    (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
    `m0 < i`) /\ `i <= r0 + 1`) /\ (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))).
Proof.
Intuition.
Assert hj : `j < i0` \/ `j = i0`. Omega. Intuition.
Rewrite H13; Assumption.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 654-859 *)
Lemma quick_rec_po_6 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  ((j:Z) (`l0 < j` /\ `j <= result0` -> `(access t0 j) < v`)) /\
  ((j:Z) (`result0 < j` /\ `j < result1` -> `(access t0 j) >= v`)) /\
  (sub_permut l0 r0 t0 t0) /\ `(access t0 l0) = v` /\ (`l0 <= result0` /\
  `result0 < result1`) /\ `result1 <= r0 + 1`.
Proof.
Intuition.
Save.

(* Why obligation from file "quicksort2.mlw", characters 998-1011 *)
Lemma quick_rec_po_7 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
  `m0 < (array_length t1)`.
Proof.
Intuition ArrayLength; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 1020-1044 *)
Lemma quick_rec_po_8 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (Pre19: (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
          `m0 < (array_length t1)`)
  (t2: (array Z))
  (Post35: (exchange t2 t1 l0 m0))
  `0 <= l0` /\ `m0 - 1 < (array_length t2)`.
Proof.
Intuition ArrayLength.
Save.

(* Why obligation from file "quicksort2.mlw", characters 465-1143 *)
Lemma quick_rec_po_9 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (Pre19: (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
          `m0 < (array_length t1)`)
  (t2: (array Z))
  (Post35: (exchange t2 t1 l0 m0))
  (Pre18: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (Pre12: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (Pre13: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (Zwf `0` `1 + (m0 - 1) - l0` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 1053-1077 *)
Lemma quick_rec_po_10 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (Pre19: (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
          `m0 < (array_length t1)`)
  (t2: (array Z))
  (Post35: (exchange t2 t1 l0 m0))
  (Pre18: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (t3: (array Z))
  (Post37: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  `0 <= m0 + 1` /\ `r0 < (array_length t3)`.
Proof.
Intuition.
Generalize (sub_permut_length H20);
Generalize (exchange_length Post35); 
Generalize (sub_permut_length H10);
Intros; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 465-1143 *)
Lemma quick_rec_po_11 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (Pre19: (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
          `m0 < (array_length t1)`)
  (t2: (array Z))
  (Post35: (exchange t2 t1 l0 m0))
  (Pre18: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (t3: (array Z))
  (Post37: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  (Pre17: `0 <= m0 + 1` /\ `r0 < (array_length t3)`)
  (Pre15: `0 <= m0 + 1` /\ `r0 < (array_length t3)`)
  (Pre16: `0 <= m0 + 1` /\ `r0 < (array_length t3)`)
  (Zwf `0` `1 + r0 - (m0 + 1)` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 594-1086 *)
Lemma quick_rec_po_12 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test6: `l0 < r0`)
  (Pre20: `0 <= l0` /\ `l0 < (array_length t0)`)
  (v: Z)
  (Post18: v = (access t0 l0))
  (result0: Z)
  (Post17: result0 = l0)
  (result1: Z)
  (Post16: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array Z))
  (Post15: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
           ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
           (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
           `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (Pre19: (`0 <= l0` /\ `l0 < (array_length t1)`) /\ `0 <= m0` /\
          `m0 < (array_length t1)`)
  (t2: (array Z))
  (Post35: (exchange t2 t1 l0 m0))
  (Pre18: `0 <= l0` /\ `m0 - 1 < (array_length t2)`)
  (t3: (array Z))
  (Post37: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  (Pre17: `0 <= m0 + 1` /\ `r0 < (array_length t3)`)
  (t4: (array Z))
  (Post39: (sorted_array t4 `m0 + 1` r0) /\ (sub_permut `m0 + 1` r0 t4 t3))
  (sorted_array t4 l0 r0) /\ (sub_permut l0 r0 t4 t0).
Proof.
Intuition.
Unfold sorted_array; Intros.
Assert hx: `x < m0-1` \/ `x = m0-1` \/ x = m0 \/ `m0 < x`. 
Omega. Intuition.
(* x < m0-1 *)
Elim (sub_permut_id H24); Intros.
Unfold array_id in H29.
Rewrite (H29 x). Rewrite (H29 `x+1`). 
Apply H19; Omega. Omega. Omega.
(* x = m0-1 *)
Elim (sub_permut_id H24); Intros.
Unfold array_id in H28.
Rewrite (H28 x). Rewrite (H28 `x+1`). 
Clear H28 H30. Elim (sub_permut_id H20); Intros.
Unfold array_id in H30. Replace `x+1` with m0.
Rewrite (H30 m0). Elim Post35; Intros.
Rewrite H35. Rewrite H13. Clear H34 H35 H36.
Assert hm0 : `m0-1 < (array_length t2)`. Omega.
Rewrite <- (sub_permut_length H20) in hm0.
Generalize (sub_permut_function H20 H1 hm0); Intros.
Elim (H34 x). Clear H34. Intuition.
Elim H34; Intros j [ H1j H2j].
Rewrite H2j.
Assert j = l0 \/ `l0 < j`. Omega. Intuition.
Elim Post35; Intros.
Subst j. Rewrite H44.
Assert `(access t1 m0) < v`.
Apply H9; Omega. Omega.
Elim Post35; Intros.
Rewrite H46; Try Omega.
Assert `(access t1 j) < v`.
Apply H9; Omega. Omega.
Omega. Omega. Omega. Omega. Omega.
(* x = m0 *)
Subst x.
Elim (sub_permut_id H24); Intros.
Unfold array_id in H28.
Rewrite (H28 m0). Clear H28 H29.
Assert hm0 : `0 <= m0+1`. Omega.
Assert hl:(array_length t4)=(array_length t0).
  ArrayLength; Clear H24.
  ArrayLength; Clear H20.
  ArrayLength; Clear Post35.
  ArrayLength.
Rewrite <- hl in H2.
Generalize (sub_permut_function H24 hm0 H2); Intros.
Elim (H28 `m0+1`). Clear H28. Intuition.
Elim H28; Intros j [H1j H2j]. Rewrite H2j.
Clear H28 H29 H2j.
Elim (sub_permut_id H20); Intros.
Unfold array_id in H29.
Rewrite (H29 m0); Try Omega. Rewrite (H29 j); Try Omega.
Elim Post35; Intros.
Rewrite H34.
Rewrite (H35 j); Try Omega.
Rewrite H13.
Apply Zge_le.
Apply H8; Omega. ArrayLength; Clear Post35; ArrayLength. 
Omega. Omega.
(* sub_permut *)
Apply sub_permut_trans with t3.
Apply sub_permut_extension with `m0+1` r0.
Omega. Omega. Assumption.
Apply sub_permut_trans with t2.
Apply sub_permut_extension with l0 `m0-1`.
Omega. Omega. Assumption.
Apply sub_permut_trans with t1.
Apply exchange_is_sub_permut with l0 m0.
Omega. Omega. Assumption.
Assumption.
Save.

(* Why obligation from file "quicksort2.mlw", characters 503-1086 *)
Lemma quick_rec_po_13 : 
  (l: Z)
  (r: Z)
  (t: (array Z))
  (Pre23: `0 <= l` /\ `r < (array_length t)`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array Z))
  (Pre22: Variant1 = `1 + r0 - l0`)
  (Pre21: `0 <= l0` /\ `r0 < (array_length t0)`)
  (Test1: `l0 >= r0`)
  (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0).
Proof.
Intuition.
Unfold sorted_array; Intros; Omega.
Save.

Definition quick_rec (* validation *)
  : (l: Z)(r: Z)(t: (array Z))(_: `0 <= l` /\ `r < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 l r) /\ (sub_permut l r t0 t)))
  := [l: Z; r: Z; t: (array Z); Pre23: `0 <= l` /\ `r < (array_length t)`]
       (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
         [Variant1: Z](l0: Z)(r0: Z)(t0: (array Z))
         (_: Variant1 = `1 + r0 - l0`)(_0: `0 <= l0` /\
         `r0 < (array_length t0)`)
         (sig_2 (array Z) unit [t1: (array Z)][result: unit]
          ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)))
         [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
          (l0: Z)(r0: Z)(t0: (array Z))(_: Variant2 = `1 + r0 - l0`)
          (_0: `0 <= l0` /\ `r0 < (array_length t0)`)
          (sig_2 (array Z) unit [t1: (array Z)][result: unit]
           ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)));
          l0: Z; r0: Z; t0: (array Z); Pre22: Variant1 = `1 + r0 - l0`;
          Pre21: `0 <= l0` /\ `r0 < (array_length t0)`]
           let (result, Bool9) =
             let (result1, Post22) = (Z_lt_ge_bool l0 r0) in
             (exist_1 [result2: bool]
             (if result2 then `l0 < r0` else `l0 >= r0`) result1 Post22) in
           (Cases (btest
                   [result:bool](if result then `l0 < r0` else `l0 >= r0`)
                   result Bool9) of
           | (left Test6) =>
               let (t1, result0, Post24) =
                 let Pre20 =
                   (quick_rec_po_1 l r t Pre23 Variant1 l0 r0 t0 Pre22 Pre21
                   Test6) in
                 let (v, Post18) = (exist_1 [result0: Z]
                   result0 = (access t0 l0) (access t0 l0)
                   (refl_equal ? (access t0 l0))) in
                 let (t1, result0, Post25) =
                   let (result0, Post17) = (exist_1 [result0: Z]
                     result0 = l0 l0 (refl_equal ? l0)) in
                   let (m0, t1, result1, Post26) =
                     let (result1, Post16) = (exist_1 [result1: Z]
                       result1 = `l0 + 1` `l0 + 1`
                       (refl_equal ? `l0 + 1`)) in
                     let (i0, m0, t1, result2, Post27) =
                       let (i0, m0, t1, result2, Post15) =
                         (well_founded_induction Z (Zwf ZERO)
                           (Zwf_well_founded `0`) [Variant3: Z](i0: Z)(m0: Z)
                           (t1: (array Z))(_: Variant3 = `1 + r0 - i0`)
                           (_0: ((j:Z)
                                 (`l0 < j` /\ `j <= m0` ->
                                  `(access t1 j) < v`)) /\
                           ((j:Z)
                            (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                           (sub_permut l0 r0 t1 t0) /\
                           `(access t1 l0) = v` /\ (`l0 <= m0` /\
                           `m0 < i0`) /\ `i0 <= r0 + 1`)
                           (sig_4 Z Z (array Z) unit [i1: Z][m1: Z]
                            [t2: (array Z)][result2: unit]
                            ((((j:Z)
                               (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                            ((j:Z)
                             (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                            (sub_permut l0 r0 t2 t0) /\
                            `(access t2 l0) = v` /\ (`l0 <= m1` /\
                            `m1 < i1`) /\ `i1 <= r0 + 1`) /\ `i1 > r0`))
                           [Variant3: Z; wf2: (Variant4: Z)
                            (Pre2: (Zwf `0` Variant4 Variant3))(i0: Z)(m0: Z)
                            (t1: (array Z))(_: Variant4 = `1 + r0 - i0`)
                            (_0: ((j:Z)
                                  (`l0 < j` /\ `j <= m0` ->
                                   `(access t1 j) < v`)) /\
                            ((j:Z)
                             (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                            (sub_permut l0 r0 t1 t0) /\
                            `(access t1 l0) = v` /\ (`l0 <= m0` /\
                            `m0 < i0`) /\ `i0 <= r0 + 1`)
                            (sig_4 Z Z (array Z) unit [i1: Z][m1: Z]
                             [t2: (array Z)][result2: unit]
                             ((((j:Z)
                                (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                             ((j:Z)
                              (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                             (sub_permut l0 r0 t2 t0) /\
                             `(access t2 l0) = v` /\ (`l0 <= m1` /\
                             `m1 < i1`) /\ `i1 <= r0 + 1`) /\ `i1 > r0`));
                            i0: Z; m0: Z; t1: (array Z);
                            Pre8: Variant3 = `1 + r0 - i0`;
                            Pre7: ((j:Z)
                                   (`l0 < j` /\ `j <= m0` ->
                                    `(access t1 j) < v`)) /\
                            ((j:Z)
                             (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                            (sub_permut l0 r0 t1 t0) /\
                            `(access t1 l0) = v` /\ (`l0 <= m0` /\
                            `m0 < i0`) /\ `i0 <= r0 + 1`]
                             let (result2, Bool8) =
                               let (result4, Post28) =
                                 (Z_le_gt_bool i0 r0) in
                               (exist_1 [result5: bool]
                               (if result5 then `i0 <= r0` else `i0 > r0`) 
                               result4 Post28) in
                             (Cases (btest
                                     [result2:bool](if result2
                                                    then `i0 <= r0`
                                                    else `i0 > r0`)
                                     result2 Bool8) of
                             | (left Test5) =>
                                 let (i1, m1, t2, result3, Post15) =
                                   let (i1, m1, t2, result3, Post19) =
                                     let (m1, t2, result3, Post29) =
                                       let (result3, Bool7) =
                                         let result4 =
                                           let Pre3 =
                                             (quick_rec_po_2 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5) in
                                           (Z_lt_ge_bool (access t1 i0)) in
                                         let (result5, Post30) =
                                           (result4 v) in
                                         (exist_1 [result6: bool]
                                         (if result6
                                          then `(access t1 i0) < v`
                                          else `(access t1 i0) >= v`) 
                                         result5 Post30) in
                                       (Cases (btest
                                               [result3:bool](if result3
                                                              then `(
                                                                    access t1
                                                                    i0) < v`
                                                              else `(
                                                                    access t1
                                                                    i0) >= v`)
                                               result3 Bool7) of
                                       | (left Test4) =>
                                           let (m1, t2, result4, Post32) =
                                             let (m1, result4, Post13) =
                                               let (result4, Post13) =
                                                 (exist_1 [result4: Z]
                                                 result4 = `m0 + 1` `m0 + 1`
                                                 (refl_equal ? `m0 + 1`)) in
                                               (exist_2 [m2: Z]
                                               [result5: unit]
                                               m2 = `m0 + 1` result4 
                                               tt Post13) in
                                             let Pre6 =
                                               (quick_rec_po_3 l r t Pre23
                                               Variant1 l0 r0 t0 Pre22 Pre21
                                               Test6 Pre20 v Post18 result0
                                               Post17 result1 Post16 Variant3
                                               i0 m0 t1 Pre8 Pre7 Test5 Test4
                                               m1 Post13) in
                                             let (t2, result5, Post33) =
                                               let Pre4 = Pre6 in
                                               let Pre5 = Pre4 in
                                               let (t2, result7, Post34) =
                                                 (swap i0 m1 t1 Pre4) in
                                               (exist_2 [t3: (array Z)]
                                               [result8: unit]
                                               (exchange t3 t1 i0 m1) 
                                               t2 result7 Post34) in
                                             (exist_3 [m2: Z][t3: (array Z)]
                                             [result6: unit]
                                             ((i:Z)
                                              (i = `i0 + 1` ->
                                               (((j:Z)
                                                 (`l0 < j` /\ `j <= m2` ->
                                                  `(access t3 j) < v`)) /\
                                               ((j:Z)
                                                (`m2 < j` /\ `j < i` ->
                                                 `(access t3 j) >= v`)) /\
                                               (sub_permut l0 r0 t3 t0) /\
                                               `(access t3 l0) = v` /\
                                               (`l0 <= m2` /\ `m2 < i`) /\
                                               `i <= r0 + 1`) /\
                                               (Zwf `0` `1 + r0 - i` `
                                               1 + r0 - i0`))) m1
                                             t2 result5
                                             (quick_rec_po_4 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5 Test4
                                             m1 Post13 Pre6 t2 Post33)) in
                                           (exist_3 [m2: Z][t3: (array Z)]
                                           [result5: unit]
                                           ((i:Z)
                                            (i = `i0 + 1` ->
                                             (((j:Z)
                                               (`l0 < j` /\ `j <= m2` ->
                                                `(access t3 j) < v`)) /\
                                             ((j:Z)
                                              (`m2 < j` /\ `j < i` ->
                                               `(access t3 j) >= v`)) /\
                                             (sub_permut l0 r0 t3 t0) /\
                                             `(access t3 l0) = v` /\
                                             (`l0 <= m2` /\ `m2 < i`) /\
                                             `i <= r0 + 1`) /\
                                             (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                    i0`))) 
                                           m1 t2 result4 Post32)
                                       | (right Test3) =>
                                           let (result4, Post31) =
                                             (exist_1 [result4: unit]
                                             ((i:Z)
                                              (i = `i0 + 1` ->
                                               (((j:Z)
                                                 (`l0 < j` /\ `j <= m0` ->
                                                  `(access t1 j) < v`)) /\
                                               ((j:Z)
                                                (`m0 < j` /\ `j < i` ->
                                                 `(access t1 j) >= v`)) /\
                                               (sub_permut l0 r0 t1 t0) /\
                                               `(access t1 l0) = v` /\
                                               (`l0 <= m0` /\ `m0 < i`) /\
                                               `i <= r0 + 1`) /\
                                               (Zwf `0` `1 + r0 - i` `
                                               1 + r0 - i0`))) tt
                                             (quick_rec_po_5 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5 Test3)) in
                                           (exist_3 [m1: Z][t2: (array Z)]
                                           [result5: unit]
                                           ((i:Z)
                                            (i = `i0 + 1` ->
                                             (((j:Z)
                                               (`l0 < j` /\ `j <= m1` ->
                                                `(access t2 j) < v`)) /\
                                             ((j:Z)
                                              (`m1 < j` /\ `j < i` ->
                                               `(access t2 j) >= v`)) /\
                                             (sub_permut l0 r0 t2 t0) /\
                                             `(access t2 l0) = v` /\
                                             (`l0 <= m1` /\ `m1 < i`) /\
                                             `i <= r0 + 1`) /\
                                             (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                    i0`))) 
                                           m0 t1 result4 Post31) end) in
                                     let (i1, result4, Post14) =
                                       let (result4, Post14) =
                                         (exist_1 [result4: Z]
                                         result4 = `i0 + 1` `i0 + 1`
                                         (refl_equal ? `i0 + 1`)) in
                                       (exist_2 [i2: Z][result5: unit]
                                       i2 = `i0 + 1` result4 tt Post14) in
                                     (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                     [result5: unit]
                                     (((j:Z)
                                       (`l0 < j` /\ `j <= m2` ->
                                        `(access t3 j) < v`)) /\
                                     ((j:Z)
                                      (`m2 < j` /\ `j < i2` ->
                                       `(access t3 j) >= v`)) /\
                                     (sub_permut l0 r0 t3 t0) /\
                                     `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                     `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                     (Zwf `0` `1 + r0 - i2` `1 + r0 - i0`) 
                                     i1 m1 t2 result4
                                     let (HW_83, HW_84) = Pre23 in
                                     let (HW_85, HW_86) = Pre21 in
                                     let (HW_87, HW_88) = Pre20 in
                                     let (HW_89, HW_90) = Pre7 in
                                     let (HW_91, HW_92) = HW_90 in
                                     let (HW_93, HW_94) = HW_92 in
                                     let (HW_95, HW_96) = HW_94 in
                                     let (HW_97, HW_98) = HW_96 in
                                     let (HW_99, HW_100) = HW_97 in
                                     let HW_101 = (Post29 i1 Post14) in
                                     HW_101) in
                                   ((wf2 `1 + r0 - i1`)
                                     (loop_variant_1 Pre8 Post19) i1 
                                     m1 t2 (refl_equal ? `1 + r0 - i1`)
                                     (proj1 ? ? Post19)) in
                                 (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                 [result4: unit]
                                 (((j:Z)
                                   (`l0 < j` /\ `j <= m2` ->
                                    `(access t3 j) < v`)) /\
                                 ((j:Z)
                                  (`m2 < j` /\ `j < i2` ->
                                   `(access t3 j) >= v`)) /\
                                 (sub_permut l0 r0 t3 t0) /\
                                 `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                 `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                 `i2 > r0` i1 m1 t2 result3 Post15)
                             | (right Test2) =>
                                 let (i1, m1, t2, result3, Post15) =
                                   (exist_4 [i1: Z][m1: Z][t2: (array Z)]
                                   [result3: unit]
                                   (((j:Z)
                                     (`l0 < j` /\ `j <= m1` ->
                                      `(access t2 j) < v`)) /\
                                   ((j:Z)
                                    (`m1 < j` /\ `j < i1` ->
                                     `(access t2 j) >= v`)) /\
                                   (sub_permut l0 r0 t2 t0) /\
                                   `(access t2 l0) = v` /\ (`l0 <= m1` /\
                                   `m1 < i1`) /\ `i1 <= r0 + 1`) /\
                                   `i1 > r0` i0 m0 t1 tt
                                   (conj ? ? Pre7 Test2)) in
                                 (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                 [result4: unit]
                                 (((j:Z)
                                   (`l0 < j` /\ `j <= m2` ->
                                    `(access t3 j) < v`)) /\
                                 ((j:Z)
                                  (`m2 < j` /\ `j < i2` ->
                                   `(access t3 j) >= v`)) /\
                                 (sub_permut l0 r0 t3 t0) /\
                                 `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                 `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                 `i2 > r0` i1 m1 t2 result3 Post15) end)
                           `1 + r0 - result1` result1 result0 t0
                           (refl_equal ? `1 + r0 - result1`)
                           (quick_rec_po_6 l r t Pre23 Variant1 l0 r0 t0
                           Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                           result1 Post16)) in
                       let Pre19 =
                         (quick_rec_po_7 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15) in
                       let (t2, result3, Post35) =
                         let Pre9 = Pre19 in
                         let Pre10 = Pre9 in
                         let (t2, result5, Post36) = (swap l0 m0 t1 Pre9) in
                         (exist_2 [t3: (array Z)][result6: unit]
                         (exchange t3 t1 l0 m0) t2 result5 Post36) in
                       let Pre18 =
                         (quick_rec_po_8 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15 Pre19 t2 Post35) in
                       let (t3, result4, Post37) =
                         let Pre12 = Pre18 in
                         let Pre13 = Pre12 in
                         let (t3, result6, Post38) =
                           ((wf1 `1 + (m0 - 1) - l0`)
                             (quick_rec_po_9 l r t Pre23 Variant1 l0 r0 t0
                             Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                             result1 Post16 i0 m0 t1 Post15 Pre19 t2 Post35
                             Pre18 Pre12 Pre13) l0 `m0 - 1` t2
                             (refl_equal ? `1 + (m0 - 1) - l0`) Pre13) in
                         (exist_2 [t4: (array Z)][result7: unit]
                         (sorted_array t4 l0 `m0 - 1`) /\
                         (sub_permut l0 `m0 - 1` t4 t2) t3 result6 Post38) in
                       let Pre17 =
                         (quick_rec_po_10 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15 Pre19 t2 Post35 Pre18 t3
                         Post37) in
                       let (t4, result5, Post39) =
                         let Pre15 = Pre17 in
                         let Pre16 = Pre15 in
                         let (t4, result7, Post40) =
                           ((wf1 `1 + r0 - (m0 + 1)`)
                             (quick_rec_po_11 l r t Pre23 Variant1 l0 r0 t0
                             Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                             result1 Post16 i0 m0 t1 Post15 Pre19 t2 Post35
                             Pre18 t3 Post37 Pre17 Pre15 Pre16) `m0 + 1` 
                             r0 t3 (refl_equal ? `1 + r0 - (m0 + 1)`) Pre16) in
                         (exist_2 [t5: (array Z)][result8: unit]
                         (sorted_array t5 `m0 + 1` r0) /\
                         (sub_permut `m0 + 1` r0 t5 t3) t4 result7 Post40) in
                       (exist_4 [i1: Z][m1: Z][t5: (array Z)][result6: unit]
                       (sorted_array t5 l0 r0) /\ (sub_permut l0 r0 t5 t0) 
                       i0 m0 t4 result5
                       (quick_rec_po_12 l r t Pre23 Variant1 l0 r0 t0 Pre22
                       Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                       Post16 i0 m0 t1 Post15 Pre19 t2 Post35 Pre18 t3 Post37
                       Pre17 t4 Post39)) in
                     (exist_3 [m1: Z][t2: (array Z)][result3: unit]
                     (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                     m0 t1 result2 Post27) in
                   (exist_2 [t2: (array Z)][result2: unit]
                   (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                   t1 result1 Post26) in
                 (exist_2 [t2: (array Z)][result1: unit]
                 (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                 t1 result0 Post25) in
               (exist_2 [t2: (array Z)][result1: unit]
               (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1 
               result0 Post24)
           | (right Test1) =>
               let (result0, Post23) = (exist_1 [result0: unit]
                 (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0) 
                 tt
                 (quick_rec_po_13 l r t Pre23 Variant1 l0 r0 t0 Pre22 Pre21
                 Test1)) in
               (exist_2 [t1: (array Z)][result1: unit]
               (sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0) t0 
               result0 Post23) end) `1 + r - l` l r t
         (refl_equal ? `1 + r - l`) Pre23).

(* Why obligation from file "quicksort2.mlw", characters 1247-1351 *)
Lemma quicksort_po_1 : 
  (t: (array Z))
  `0 <= 0` /\ `(array_length t) - 1 < (array_length t)`.
Proof.
Intuition Omega.
Save.

(* Why obligation from file "quicksort2.mlw", characters 1247-1351 *)
Lemma quicksort_po_2 : 
  (t: (array Z))
  (Pre1: `0 <= 0` /\ `(array_length t) - 1 < (array_length t)`)
  (t0: (array Z))
  (Post1: (sorted_array t0 `0` `(array_length t) - 1`) /\
          (sub_permut `0` `(array_length t) - 1` t0 t))
  (sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t).
Proof.
Intuition.
ArrayLength; Assumption.
EAuto.
Save.

Definition quicksort (* validation *)
  : (t: (array Z))
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t)))
  := [t: (array Z)]
       let Pre1 = (quicksort_po_1 t) in
       let (t0, result1, Post1) =
         (quick_rec `0` `(array_length t) - 1` t Pre1) in
       (exist_2 [t1: (array Z)][result2: unit]
       (sorted_array t1 `0` `(array_length t1) - 1`) /\ (permut t1 t) 
       t0 result1 (quicksort_po_2 t Pre1 t0 Post1)).

