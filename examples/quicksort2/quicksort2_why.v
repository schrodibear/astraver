(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Why.

(*Why*) Parameter N : Z.

Lemma swap_po_1 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: (`0 <= i` /\ `i < N`) /\ `0 <= j` /\ `j < N`)
  (Pre1: `0 <= i` /\ `i < N`)
  (v: Z)
  (Post3: v = (access t i))
  `0 <= j` /\ `j < N`.
Proof.
Intuition.
Save.

Lemma swap_po_2 : 
  (i: Z)
  (j: Z)
  (t: (array N Z))
  (Pre5: (`0 <= i` /\ `i < N`) /\ `0 <= j` /\ `j < N`)
  (Pre1: `0 <= i` /\ `i < N`)
  (v: Z)
  (Post3: v = (access t i))
  (Pre2: `0 <= j` /\ `j < N`)
  (t0: (array N Z))
  (Post1: t0 = (store t i (access t j)))
  (t1: (array N Z))
  (Post2: t1 = (store t0 j v))
  (exchange t1 t i j).
Proof.
Intros; Subst t1; Subst t0; Subst v.
Auto with datatypes.
Save.

Definition swap := (* validation *)
  [i: Z; j: Z; t: (array N Z); Pre5: (`0 <= i` /\ `i < N`) /\ `0 <= j` /\
   `j < N`]
    let Pre1 = (proj1 ? ? Pre5) in
    let (v, Post3) = (exist_1 [result: Z]result = (access t i) (access t i)
      (refl_equal ? (access t i))) in
    let (t0, result, Post4) =
      let Pre2 = (swap_po_1 i j t Pre5 Pre1 v Post3) in
      let (t0, result, Post1) =
        let (result, Post1) = (exist_1 [result: Z]
          (store t i result) = (store t i (access t j)) (access t j)
          (refl_equal ? (store t i (access t j)))) in
        let Pre3 = Pre1 in
        (exist_2 [t1: (array N Z)][result1: unit]
        t1 = (store t i (access t j)) (store t i result) tt Post1) in
      let (t1, result0, Post2) =
        let (result0, Post2) = (exist_1 [result0: Z]
          (store t0 j result0) = (store t0 j v) v
          (refl_equal ? (store t0 j v))) in
        let Pre4 = Pre2 in
        (exist_2 [t2: (array N Z)][result2: unit]
        t2 = (store t0 j v) (store t0 j result0) tt Post2) in
      (exist_2 [t2: (array N Z)][result1: unit](exchange t2 t i j) t1 
      result0 (swap_po_2 i j t Pre5 Pre1 v Post3 Pre2 t0 Post1 t1 Post2)) in
    (exist_2 [t1: (array N Z)][result0: unit](exchange t1 t i j) t0 result
    Post4).

Lemma quick_rec_po_1 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  `0 <= l0` /\ `l0 < N`.
Proof.
Auto with *.
Save.

Lemma quick_rec_po_2 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  `0 <= i0` /\ `i0 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_3 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test4: `(access t1 i0) < v`)
  (m1: Z)
  (Post7: m1 = `m0 + 1`)
  (`0 <= i0` /\ `i0 < N`) /\ `0 <= m1` /\ `m1 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_4 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test4: `(access t1 i0) < v`)
  (m1: Z)
  (Post7: m1 = `m0 + 1`)
  (t2: (array N Z))
  (Post27: (exchange t2 t1 i0 m1))
  ((i:Z)
   (i = `i0 + 1` ->
    (((j:Z) (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
    ((j:Z) (`m1 < j` /\ `j < i` -> `(access t2 j) >= v`)) /\
    (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\ (`l0 <= m1` /\
    `m1 < i`) /\ `i <= r0 + 1`) /\ (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))).
Proof.
Intuition.
Assert hj : `j < m1` \/ j = m1. Omega. 
Decompose [exchange] Post27. Intuition.
Rewrite H19; Try Omega.
Apply H5; Omega.
Subst j; Rewrite H18; Assumption.
Assert hj : `j < i0` \/ j = i0. Omega. 
Decompose [exchange] Post27. Intuition.
Rewrite H19; Try Omega.
Apply H7; Omega.
Subst j; Rewrite H17. Apply H7; Omega.
Apply sub_permut_trans with t1.
Apply exchange_is_sub_permut with i0 m1; Assumption Orelse Omega.
Assumption.
Decompose [exchange] Post27. Intuition.
Rewrite H17; Omega.
Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_5 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (Test3: `(access t1 i0) >= v`)
  ((i:Z)
   (i = `i0 + 1` ->
    (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
    ((j:Z) (`m0 < j` /\ `j < i` -> `(access t1 j) >= v`)) /\
    (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
    `m0 < i`) /\ `i <= r0 + 1`) /\ (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))).
Proof.
Intuition.
Assert hj : `j < i0` \/ `j = i0`. Omega. Intuition.
Rewrite H13; Assumption.
Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_6 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (m1: Z)
  (t2: (array N Z))
  (Post23: ((i:Z)
            (i = `i0 + 1` ->
             (((j:Z) (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
             ((j:Z) (`m1 < j` /\ `j < i` -> `(access t2 j) >= v`)) /\
             (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\
             (`l0 <= m1` /\ `m1 < i`) /\ `i <= r0 + 1`) /\
             (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))))
  (i1: Z)
  (Post8: i1 = `i0 + 1`)
  (((j:Z) (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
  ((j:Z) (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
  (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\ (`l0 <= m1` /\
  `m1 < i1`) /\ `i1 <= r0 + 1`) /\ (Zwf `0` `1 + r0 - i1` `1 + r0 - i0`).
Proof.
Intuition.
Save.

Lemma quick_rec_po_7 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (Variant3: Z)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Pre7: Variant3 = `1 + r0 - i0`)
  (Pre6: ((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
         ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
         `m0 < i0`) /\ `i0 <= r0 + 1`)
  (Test5: `i0 <= r0`)
  (i1: Z)
  (m1: Z)
  (t2: (array N Z))
  (Post13: (((j:Z) (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
           ((j:Z) (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
           (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\ (`l0 <= m1` /\
           `m1 < i1`) /\ `i1 <= r0 + 1`) /\
           (Zwf `0` `1 + r0 - i1` `1 + r0 - i0`))
  (Zwf `0` `1 + r0 - i1` Variant3).
Proof.
Intros; Subst Variant3; Intuition.
Save.

Lemma quick_rec_po_8 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  ((j:Z) (`l0 < j` /\ `j <= result0` -> `(access t0 j) < v`)) /\
  ((j:Z) (`result0 < j` /\ `j < result1` -> `(access t0 j) >= v`)) /\
  (sub_permut l0 r0 t0 t0) /\ `(access t0 l0) = v` /\ (`l0 <= result0` /\
  `result0 < result1`) /\ `result1 <= r0 + 1`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_9 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (`0 <= l0` /\ `l0 < N`) /\ `0 <= m0` /\ `m0 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_10 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (t2: (array N Z))
  (Post29: (exchange t2 t1 l0 m0))
  `0 <= l0` /\ `m0 - 1 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_11 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (t2: (array N Z))
  (Post29: (exchange t2 t1 l0 m0))
  (Pre10: `0 <= l0` /\ `m0 - 1 < N`)
  (Zwf `0` `1 + (m0 - 1) - l0` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_12 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (t2: (array N Z))
  (Post29: (exchange t2 t1 l0 m0))
  (t3: (array N Z))
  (Post31: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  `0 <= m0 + 1` /\ `r0 < N`.
Proof.
Intuition.
Save.

Lemma quick_rec_po_13 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (t2: (array N Z))
  (Post29: (exchange t2 t1 l0 m0))
  (t3: (array N Z))
  (Post31: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  (Pre12: `0 <= m0 + 1` /\ `r0 < N`)
  (Zwf `0` `1 + r0 - (m0 + 1)` Variant1).
Proof.
Intuition.
Unfold Zwf; Omega.
Save.

Lemma quick_rec_po_14 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test6: `l0 < r0`)
  (Pre2: `0 <= l0` /\ `l0 < N`)
  (v: Z)
  (Post12: v = (access t0 l0))
  (result0: Z)
  (Post11: result0 = l0)
  (result1: Z)
  (Post10: result1 = `l0 + 1`)
  (i0: Z)
  (m0: Z)
  (t1: (array N Z))
  (Post9: (((j:Z) (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
          ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
          (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\ (`l0 <= m0` /\
          `m0 < i0`) /\ `i0 <= r0 + 1`) /\ `i0 > r0`)
  (t2: (array N Z))
  (Post29: (exchange t2 t1 l0 m0))
  (t3: (array N Z))
  (Post31: (sorted_array t3 l0 `m0 - 1`) /\ (sub_permut l0 `m0 - 1` t3 t2))
  (t4: (array N Z))
  (Post33: (sorted_array t4 `m0 + 1` r0) /\ (sub_permut `m0 + 1` r0 t4 t3))
  (sorted_array t4 l0 r0) /\ (sub_permut l0 r0 t4 t0).
Proof.
Intuition.
Unfold sorted_array; Intros.
Assert hx: `x < m0-1` \/ `x = m0-1` \/ x = m0 \/ `m0 < x`. 
Omega. Intuition.
(* x < m0-1 *)
Elim (sub_permut_id H16); Intros.
Unfold array_id in H21.
Rewrite (H21 x). Rewrite (H21 `x+1`). 
Apply H10; Omega. Omega. Omega.
(* x = m0-1 *)
Elim (sub_permut_id H16); Intros.
Unfold array_id in H20.
Rewrite (H20 x). Rewrite (H20 `x+1`). 
Clear H20 H22. Elim (sub_permut_id H14); Intros.
Unfold array_id in H22. Replace `x+1` with m0.
Rewrite (H22 m0). Elim Post29; Intros.
Rewrite H26. Rewrite H9. Clear H25 H26 H27.
Assert hm0 : `m0-1 < N`. Omega.
Generalize (sub_permut_function H1 hm0 H14); Intros.
Elim (H25 x). Clear H25. Intuition.
Elim H25; Intros j [ H1j H2j].
Rewrite H2j.
Assert j = l0 \/ `l0 < j`. Omega. Intuition.
Elim Post29; Intros.
Subst j. Rewrite H34.
Assert `(access t1 m0) < v`.
Apply H7; Omega. Omega.
Elim Post29; Intros.
Rewrite H36; Try Omega.
Assert `(access t1 j) < v`.
Apply H7; Omega. Omega.
Omega. Omega. Omega. Omega. Omega.
(* x = m0 *)
Subst x.
Elim (sub_permut_id H16); Intros.
Unfold array_id in H20.
Rewrite (H20 m0). Clear H20 H21.
Assert hm0 : `0 <= m0+1`. Omega.
Generalize (sub_permut_function hm0 H2 H16); Intros.
Elim (H20 `m0+1`). Clear H20. Intuition.
Elim H20; Intros j [H1j H2j]. Rewrite H2j.
Clear H20 H21 H2j.
Elim (sub_permut_id H14); Intros.
Unfold array_id in H21.
Rewrite (H21 m0); Try Omega. Rewrite (H21 j); Try Omega.
Elim Post29; Intros.
Rewrite H25.
Rewrite (H26 j); Try Omega.
Rewrite H9.
Apply Zge_le.
Apply H5; Omega. Omega. Omega.
(* sub_permut *)
Apply sub_permut_trans with t3.
Apply sub_permut_extension with `m0+1` r0.
Omega. Omega. Assumption.
Apply sub_permut_trans with t2.
Apply sub_permut_extension with l0 `m0-1`.
Omega. Omega. Assumption.
Apply sub_permut_trans with t1.
Apply exchange_is_sub_permut with l0 m0.
Omega. Omega. Assumption.
Assumption.
Save.

Lemma quick_rec_po_15 : 
  (l: Z)
  (r: Z)
  (Pre15: `0 <= l` /\ `r < N`)
  (Variant1: Z)
  (l0: Z)
  (r0: Z)
  (t0: (array N Z))
  (Pre14: Variant1 = `1 + r0 - l0`)
  (Pre13: `0 <= l0` /\ `r0 < N`)
  (Test1: `l0 >= r0`)
  (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0).
Proof.
Intuition.
Unfold sorted_array; Intros; Omega.
Save.

Definition quick_rec := (* validation *)
  [l: Z; r: Z; t: (array N Z); Pre15: `0 <= l` /\ `r < N`]
    (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`) [Variant1: Z]
      (l0: Z)(r0: Z)(t0: (array N Z))(_: Variant1 = `1 + r0 - l0`)
      (_0: `0 <= l0` /\ `r0 < N`)
      (sig_2 (array N Z) unit [t1: (array N Z)][result: unit]
       ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)))
      [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
       (l0: Z)(r0: Z)(t0: (array N Z))(_: Variant2 = `1 + r0 - l0`)
       (_0: `0 <= l0` /\ `r0 < N`)
       (sig_2 (array N Z) unit [t1: (array N Z)][result: unit]
        ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)));
       l0: Z; r0: Z; t0: (array N Z); Pre14: Variant1 = `1 + r0 - l0`;
       Pre13: `0 <= l0` /\ `r0 < N`]
        let (result, Bool6) =
          let (result1, Post16) = (Z_lt_ge_bool l0 r0) in
          (exist_1 [result2: bool]
          (if result2 then `l0 < r0` else `l0 >= r0`) result1 Post16) in
        (Cases (btest [result:bool](if result then `l0 < r0` else `l0 >= r0`)
                result Bool6) of
        | (left Test6) =>
            let (t1, result0, Post18) =
              let Pre2 =
                (quick_rec_po_1 l r Pre15 Variant1 l0 r0 Pre14 Pre13 Test6) in
              let (v, Post12) = (exist_1 [result0: Z]
                result0 = (access t0 l0) (access t0 l0)
                (refl_equal ? (access t0 l0))) in
              let (t1, result0, Post19) =
                let (result0, Post11) = (exist_1 [result0: Z]result0 = l0 
                  l0 (refl_equal ? l0)) in
                let (m0, t1, result1, Post20) =
                  let (result1, Post10) = (exist_1 [result1: Z]
                    result1 = `l0 + 1` `l0 + 1` (refl_equal ? `l0 + 1`)) in
                  let (i0, m0, t1, result2, Post21) =
                    let (i0, m0, t1, result2, Post9) =
                      (well_founded_induction Z (Zwf ZERO)
                        (Zwf_well_founded `0`) [Variant3: Z](i0: Z)(m0: Z)
                        (t1: (array N Z))(_: Variant3 = `1 + r0 - i0`)
                        (_0: ((j:Z)
                              (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
                        ((j:Z) (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                        (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\
                        (`l0 <= m0` /\ `m0 < i0`) /\ `i0 <= r0 + 1`)
                        (sig_4 Z Z (array N Z) unit [i1: Z][m1: Z]
                         [t2: (array N Z)][result2: unit]
                         ((((j:Z)
                            (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                         ((j:Z)
                          (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                         (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\
                         (`l0 <= m1` /\ `m1 < i1`) /\ `i1 <= r0 + 1`) /\
                         `i1 > r0`))
                        [Variant3: Z; wf2: (Variant4: Z)
                         (Pre3: (Zwf `0` Variant4 Variant3))(i0: Z)(m0: Z)
                         (t1: (array N Z))(_: Variant4 = `1 + r0 - i0`)
                         (_0: ((j:Z)
                               (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
                         ((j:Z)
                          (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\
                         (`l0 <= m0` /\ `m0 < i0`) /\ `i0 <= r0 + 1`)
                         (sig_4 Z Z (array N Z) unit [i1: Z][m1: Z]
                          [t2: (array N Z)][result2: unit]
                          ((((j:Z)
                             (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                          ((j:Z)
                           (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                          (sub_permut l0 r0 t2 t0) /\ `(access t2 l0) = v` /\
                          (`l0 <= m1` /\ `m1 < i1`) /\ `i1 <= r0 + 1`) /\
                          `i1 > r0`));
                         i0: Z; m0: Z; t1: (array N Z);
                         Pre7: Variant3 = `1 + r0 - i0`;
                         Pre6: ((j:Z)
                                (`l0 < j` /\ `j <= m0` -> `(access t1 j) < v`)) /\
                         ((j:Z)
                          (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                         (sub_permut l0 r0 t1 t0) /\ `(access t1 l0) = v` /\
                         (`l0 <= m0` /\ `m0 < i0`) /\ `i0 <= r0 + 1`]
                          let (result2, Bool5) =
                            let (result4, Post22) = (Z_le_gt_bool i0 r0) in
                            (exist_1 [result5: bool]
                            (if result5 then `i0 <= r0` else `i0 > r0`) 
                            result4 Post22) in
                          (Cases (btest
                                  [result2:bool](if result2 then `i0 <= r0`
                                                 else `i0 > r0`)
                                  result2 Bool5) of
                          | (left Test5) =>
                              let (i1, m1, t2, result3, Post9) =
                                let (i1, m1, t2, result3, Post13) =
                                  let (m1, t2, result3, Post23) =
                                    let (result3, Bool4) =
                                      let result4 =
                                        let Pre4 =
                                          (quick_rec_po_2 l r Pre15 Variant1
                                          l0 r0 t0 Pre14 Pre13 Test6 Pre2 v
                                          Post12 result0 Post11 result1
                                          Post10 Variant3 i0 m0 t1 Pre7 Pre6
                                          Test5) in
                                        (Z_lt_ge_bool (access t1 i0)) in
                                      let (result5, Post24) = (result4 v) in
                                      (exist_1 [result6: bool]
                                      (if result6 then `(access t1 i0) < v`
                                       else `(access t1 i0) >= v`) result5
                                      Post24) in
                                    (Cases (btest
                                            [result3:bool](if result3
                                                           then `(access t1
                                                                  i0) <
                                                                 v`
                                                           else `(access t1
                                                                  i0) >=
                                                                 v`)
                                            result3 Bool4) of
                                    | (left Test4) =>
                                        let (m1, t2, result4, Post26) =
                                          let (m1, result4, Post7) =
                                            let (result4, Post7) =
                                              (exist_1 [result4: Z]
                                              result4 = `m0 + 1` `m0 + 1`
                                              (refl_equal ? `m0 + 1`)) in
                                            (exist_2 [m2: Z][result5: unit]
                                            m2 = `m0 + 1` result4 tt Post7) in
                                          let (t2, result5, Post27) =
                                            let Pre5 =
                                              (quick_rec_po_3 l r Pre15
                                              Variant1 l0 r0 t0 Pre14 Pre13
                                              Test6 Pre2 v Post12 result0
                                              Post11 result1 Post10 Variant3
                                              i0 m0 t1 Pre7 Pre6 Test5 Test4
                                              m1 Post7) in
                                            let (t2, result7, Post28) =
                                              (swap i0 m1 t1 Pre5) in
                                            (exist_2 [t3: (array N Z)]
                                            [result8: unit]
                                            (exchange t3 t1 i0 m1) t2 
                                            result7 Post28) in
                                          (exist_3 [m2: Z][t3: (array N Z)]
                                          [result6: unit]
                                          ((i:Z)
                                           (i = `i0 + 1` ->
                                            (((j:Z)
                                              (`l0 < j` /\ `j <= m2` ->
                                               `(access t3 j) < v`)) /\
                                            ((j:Z)
                                             (`m2 < j` /\ `j < i` ->
                                              `(access t3 j) >= v`)) /\
                                            (sub_permut l0 r0 t3 t0) /\
                                            `(access t3 l0) = v` /\
                                            (`l0 <= m2` /\ `m2 < i`) /\
                                            `i <= r0 + 1`) /\
                                            (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                   i0`))) 
                                          m1 t2 result5
                                          (quick_rec_po_4 l r Pre15 Variant1
                                          l0 r0 t0 Pre14 Pre13 Test6 Pre2 v
                                          Post12 result0 Post11 result1
                                          Post10 Variant3 i0 m0 t1 Pre7 Pre6
                                          Test5 Test4 m1 Post7 t2 Post27)) in
                                        (exist_3 [m2: Z][t3: (array N Z)]
                                        [result5: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` ->
                                          (((j:Z)
                                            (`l0 < j` /\ `j <= m2` ->
                                             `(access t3 j) < v`)) /\
                                          ((j:Z)
                                           (`m2 < j` /\ `j < i` ->
                                            `(access t3 j) >= v`)) /\
                                          (sub_permut l0 r0 t3 t0) /\
                                          `(access t3 l0) = v` /\
                                          (`l0 <= m2` /\ `m2 < i`) /\
                                          `i <= r0 + 1`) /\
                                          (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))) 
                                        m1 t2 result4 Post26)
                                    | (right Test3) =>
                                        let (result4, Post25) =
                                          (exist_1 [result4: unit]
                                          ((i:Z)
                                           (i = `i0 + 1` ->
                                            (((j:Z)
                                              (`l0 < j` /\ `j <= m0` ->
                                               `(access t1 j) < v`)) /\
                                            ((j:Z)
                                             (`m0 < j` /\ `j < i` ->
                                              `(access t1 j) >= v`)) /\
                                            (sub_permut l0 r0 t1 t0) /\
                                            `(access t1 l0) = v` /\
                                            (`l0 <= m0` /\ `m0 < i`) /\
                                            `i <= r0 + 1`) /\
                                            (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                   i0`))) 
                                          tt
                                          (quick_rec_po_5 l r Pre15 Variant1
                                          l0 r0 t0 Pre14 Pre13 Test6 Pre2 v
                                          Post12 result0 Post11 result1
                                          Post10 Variant3 i0 m0 t1 Pre7 Pre6
                                          Test5 Test3)) in
                                        (exist_3 [m1: Z][t2: (array N Z)]
                                        [result5: unit]
                                        ((i:Z)
                                         (i = `i0 + 1` ->
                                          (((j:Z)
                                            (`l0 < j` /\ `j <= m1` ->
                                             `(access t2 j) < v`)) /\
                                          ((j:Z)
                                           (`m1 < j` /\ `j < i` ->
                                            `(access t2 j) >= v`)) /\
                                          (sub_permut l0 r0 t2 t0) /\
                                          `(access t2 l0) = v` /\
                                          (`l0 <= m1` /\ `m1 < i`) /\
                                          `i <= r0 + 1`) /\
                                          (Zwf `0` `1 + r0 - i` `1 + r0 - i0`))) 
                                        m0 t1 result4 Post25) end) in
                                  let (i1, result4, Post8) =
                                    let (result4, Post8) =
                                      (exist_1 [result4: Z]
                                      result4 = `i0 + 1` `i0 + 1`
                                      (refl_equal ? `i0 + 1`)) in
                                    (exist_2 [i2: Z][result5: unit]
                                    i2 = `i0 + 1` result4 tt Post8) in
                                  (exist_4 [i2: Z][m2: Z][t3: (array N Z)]
                                  [result5: unit]
                                  (((j:Z)
                                    (`l0 < j` /\ `j <= m2` ->
                                     `(access t3 j) < v`)) /\
                                  ((j:Z)
                                   (`m2 < j` /\ `j < i2` ->
                                    `(access t3 j) >= v`)) /\
                                  (sub_permut l0 r0 t3 t0) /\
                                  `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                  `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                  (Zwf `0` `1 + r0 - i2` `1 + r0 - i0`) 
                                  i1 m1 t2 result4
                                  (quick_rec_po_6 l r Pre15 Variant1 l0 r0 t0
                                  Pre14 Pre13 Test6 Pre2 v Post12 result0
                                  Post11 result1 Post10 Variant3 i0 m0 t1
                                  Pre7 Pre6 Test5 m1 t2 Post23 i1 Post8)) in
                                ((wf2 `1 + r0 - i1`)
                                  (quick_rec_po_7 l r Pre15 Variant1 l0 r0 t0
                                  Pre14 Pre13 Test6 Pre2 v Post12 result0
                                  Post11 result1 Post10 Variant3 i0 m0 t1
                                  Pre7 Pre6 Test5 i1 m1 t2 Post13) i1 
                                  m1 t2 (refl_equal ? `1 + r0 - i1`)
                                  (proj1 ? ? Post13)) in
                              (exist_4 [i2: Z][m2: Z][t3: (array N Z)]
                              [result4: unit]
                              (((j:Z)
                                (`l0 < j` /\ `j <= m2` -> `(access t3 j) < v`)) /\
                              ((j:Z)
                               (`m2 < j` /\ `j < i2` -> `(access t3 j) >= v`)) /\
                              (sub_permut l0 r0 t3 t0) /\
                              `(access t3 l0) = v` /\ (`l0 <= m2` /\
                              `m2 < i2`) /\ `i2 <= r0 + 1`) /\ `i2 > r0` 
                              i1 m1 t2 result3 Post9)
                          | (right Test2) =>
                              let (i1, m1, t2, result3, Post9) =
                                (exist_4 [i1: Z][m1: Z][t2: (array N Z)]
                                [result3: unit]
                                (((j:Z)
                                  (`l0 < j` /\ `j <= m1` ->
                                   `(access t2 j) < v`)) /\
                                ((j:Z)
                                 (`m1 < j` /\ `j < i1` ->
                                  `(access t2 j) >= v`)) /\
                                (sub_permut l0 r0 t2 t0) /\
                                `(access t2 l0) = v` /\ (`l0 <= m1` /\
                                `m1 < i1`) /\ `i1 <= r0 + 1`) /\ `i1 > r0` 
                                i0 m0 t1 tt (conj ? ? Pre6 Test2)) in
                              (exist_4 [i2: Z][m2: Z][t3: (array N Z)]
                              [result4: unit]
                              (((j:Z)
                                (`l0 < j` /\ `j <= m2` -> `(access t3 j) < v`)) /\
                              ((j:Z)
                               (`m2 < j` /\ `j < i2` -> `(access t3 j) >= v`)) /\
                              (sub_permut l0 r0 t3 t0) /\
                              `(access t3 l0) = v` /\ (`l0 <= m2` /\
                              `m2 < i2`) /\ `i2 <= r0 + 1`) /\ `i2 > r0` 
                              i1 m1 t2 result3 Post9) end) `1 + r0 - result1`
                        result1 result0 t0 (refl_equal ? `1 + r0 - result1`)
                        (quick_rec_po_8 l r Pre15 Variant1 l0 r0 t0 Pre14
                        Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                        Post10)) in
                    let (t2, result3, Post29) =
                      let Pre8 =
                        (quick_rec_po_9 l r Pre15 Variant1 l0 r0 t0 Pre14
                        Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                        Post10 i0 m0 t1 Post9) in
                      let (t2, result5, Post30) = (swap l0 m0 t1 Pre8) in
                      (exist_2 [t3: (array N Z)][result6: unit]
                      (exchange t3 t1 l0 m0) t2 result5 Post30) in
                    let (t3, result4, Post31) =
                      let Pre10 =
                        (quick_rec_po_10 l r Pre15 Variant1 l0 r0 t0 Pre14
                        Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                        Post10 i0 m0 t1 Post9 t2 Post29) in
                      let (t3, result6, Post32) =
                        ((wf1 `1 + (m0 - 1) - l0`)
                          (quick_rec_po_11 l r Pre15 Variant1 l0 r0 t0 Pre14
                          Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                          Post10 i0 m0 t1 Post9 t2 Post29 Pre10) l0 `m0 - 1`
                          t2 (refl_equal ? `1 + (m0 - 1) - l0`) Pre10) in
                      (exist_2 [t4: (array N Z)][result7: unit]
                      (sorted_array t4 l0 `m0 - 1`) /\
                      (sub_permut l0 `m0 - 1` t4 t2) t3 result6 Post32) in
                    let (t4, result5, Post33) =
                      let Pre12 =
                        (quick_rec_po_12 l r Pre15 Variant1 l0 r0 t0 Pre14
                        Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                        Post10 i0 m0 t1 Post9 t2 Post29 t3 Post31) in
                      let (t4, result7, Post34) =
                        ((wf1 `1 + r0 - (m0 + 1)`)
                          (quick_rec_po_13 l r Pre15 Variant1 l0 r0 t0 Pre14
                          Pre13 Test6 Pre2 v Post12 result0 Post11 result1
                          Post10 i0 m0 t1 Post9 t2 Post29 t3 Post31 Pre12)
                          `m0 + 1` r0 t3 (refl_equal ? `1 + r0 - (m0 + 1)`)
                          Pre12) in
                      (exist_2 [t5: (array N Z)][result8: unit]
                      (sorted_array t5 `m0 + 1` r0) /\
                      (sub_permut `m0 + 1` r0 t5 t3) t4 result7 Post34) in
                    (exist_4 [i1: Z][m1: Z][t5: (array N Z)][result6: unit]
                    (sorted_array t5 l0 r0) /\ (sub_permut l0 r0 t5 t0) 
                    i0 m0 t4 result5
                    (quick_rec_po_14 l r Pre15 Variant1 l0 r0 t0 Pre14 Pre13
                    Test6 Pre2 v Post12 result0 Post11 result1 Post10 i0 m0
                    t1 Post9 t2 Post29 t3 Post31 t4 Post33)) in
                  (exist_3 [m1: Z][t2: (array N Z)][result3: unit]
                  (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                  m0 t1 result2 Post21) in
                (exist_2 [t2: (array N Z)][result2: unit]
                (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1
                result1 Post20) in
              (exist_2 [t2: (array N Z)][result1: unit]
              (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1 
              result0 Post19) in
            (exist_2 [t2: (array N Z)][result1: unit]
            (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1 result0
            Post18)
        | (right Test1) =>
            let (result0, Post17) = (exist_1 [result0: unit]
              (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0) tt
              (quick_rec_po_15 l r Pre15 Variant1 l0 r0 t0 Pre14 Pre13 Test1)) in
            (exist_2 [t1: (array N Z)][result1: unit]
            (sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0) t0 result0
            Post17) end) `1 + r - l` l r t (refl_equal ? `1 + r - l`) Pre15).

Lemma quicksort_po_1 : 
  `0 <= 0` /\ `N - 1 < N`.
Proof.
Omega.
Save.

Lemma quicksort_po_2 : 
  (t: (array N Z))
  (Pre1: `0 <= 0` /\ `N - 1 < N`)
  (t0: (array N Z))
  (Post1: (sorted_array t0 `0` `N - 1`) /\ (sub_permut `0` `N - 1` t0 t))
  (sorted_array t0 `0` `N - 1`) /\ (permut t0 t).
Proof.
Intuition.
EAuto.
Save.

Definition quicksort := (* validation *)
  [t: (array N Z)]
    let Pre1 = quicksort_po_1 in
    let (t0, result1, Post1) = (quick_rec `0` `N - 1` t Pre1) in
    (exist_2 [t1: (array N Z)][result2: unit](sorted_array t1 `0` `N - 1`) /\
    (permut t1 t) t0 result1 (quicksort_po_2 t Pre1 t0 Post1)).

