rm -f copy_struct.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only copy_struct.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat copy_struct.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

tag S = {
  int32 i; 
  int32 j;
}

type S = [S]

tag T = {
  S[0] a; 
  S[0] b;
}

type T = [T]

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

unit f(T[..] p, T[..] q)
  requires (C_21 : (((C_23 : (\offset_min(p) <= 0)) &&
                      (C_24 : (\offset_max(p) >= 0))) &&
                     ((C_26 : (\offset_min(q) <= 0)) &&
                       (C_27 : (\offset_max(q) >= 0)))));
behavior default:
  assumes true;
  ensures (C_28 : (((C_30 : (p.a.i == q.a.i)) && (C_31 : (p.a.j == q.a.j))) &&
                    ((C_33 : (p.b.i == q.b.i)) && (C_34 : (p.b.j == q.b.j)))));
{  
   {  
      {  (C_5 : ((C_4 : (C_3 : q.a).i) = (C_2 : (C_1 : p.a).i)));
         (C_10 : ((C_9 : (C_8 : q.a).j) = (C_7 : (C_6 : p.a).j)));
         (C_15 : ((C_14 : (C_13 : q.b).i) = (C_12 : (C_11 : p.b).i)));
         (C_20 : ((C_19 : (C_18 : q.b).j) = (C_17 : (C_16 : p.b).j)))
      };
      
      (return ())
   }
}

T[0] id(T[0] v_p)
behavior default_1:
  assumes true;
  ensures (C_58 : (((C_60 : (\result.a.i == v_p.a.i)) &&
                     (C_61 : (\result.a.j == v_p.a.j))) &&
                    ((C_63 : (\result.b.i == v_p.b.i)) &&
                      (C_64 : (\result.b.j == v_p.b.j)))));
{  
   (var T[0] p);
   
   {  (C_36 : (p = (C_35 : (new T[1]))));
      
      {  (C_41 : ((C_40 : (C_39 : p.a).i) = (C_38 : (C_37 : v_p.a).i)));
         (C_46 : ((C_45 : (C_44 : p.a).j) = (C_43 : (C_42 : v_p.a).j)));
         (C_51 : ((C_50 : (C_49 : p.b).i) = (C_48 : (C_47 : v_p.b).i)));
         (C_56 : ((C_55 : (C_54 : p.b).j) = (C_53 : (C_52 : v_p.b).j)))
      };
      
      {  (C_57 : (free(p)));
         
         (return p)
      }
   }
}

T[0] idp(T[..] p)
  requires (C_88 : ((C_89 : (\offset_min(p) <= 0)) &&
                     (C_90 : (\offset_max(p) >= 0))));
behavior default_2:
  assumes true;
  ensures (C_91 : (((C_93 : (\result.a.i == p.a.i)) &&
                     (C_94 : (\result.a.j == p.a.j))) &&
                    ((C_96 : (\result.b.i == p.b.i)) &&
                      (C_97 : (\result.b.j == p.b.j)))));
{  
   (var T[0] __retres);
   
   {  (C_66 : (__retres = (C_65 : (new T[1]))));
      
      {  (C_71 : ((C_70 : (C_69 : __retres.a).i) = (C_68 : (C_67 : p.a).i)));
         (C_76 : ((C_75 : (C_74 : __retres.a).j) = (C_73 : (C_72 : p.a).j)));
         (C_81 : ((C_80 : (C_79 : __retres.b).i) = (C_78 : (C_77 : p.b).i)));
         (C_86 : ((C_85 : (C_84 : __retres.b).j) = (C_83 : (C_82 : p.b).j)))
      };
      
      {  (C_87 : (free(__retres)));
         
         (return __retres)
      }
   }
}

unit g(T[..] p)
  requires (C_165 : ((C_166 : (\offset_min(p) <= 0)) &&
                      (C_167 : (\offset_max(p) >= 0))));
{  
   (var T[0] copy);
   
   (var T[0] copy2);
   
   (var T[0] __cil_tmp6);
   
   (var T[0] __cil_tmp7);
   
   {  (C_99 : (copy = (C_98 : (new T[1]))));
      (C_101 : (copy2 = (C_100 : (new T[1]))));
      
      {  (C_103 : (__cil_tmp6 = (C_102 : id(p))));
         
         {  (C_108 : ((C_107 : (C_106 : copy.a).i) = (C_105 : (C_104 : __cil_tmp6.a).i)));
            (C_113 : ((C_112 : (C_111 : copy.a).j) = (C_110 : (C_109 : __cil_tmp6.a).j)));
            (C_118 : ((C_117 : (C_116 : copy.b).i) = (C_115 : (C_114 : __cil_tmp6.b).i)));
            (C_123 : ((C_122 : (C_121 : copy.b).j) = (C_120 : (C_119 : __cil_tmp6.b).j)))
         };
         (C_124 : (free(__cil_tmp6)))
      };
      
      {  (C_126 : (__cil_tmp7 = (C_125 : idp(p))));
         
         {  (C_131 : ((C_130 : (C_129 : copy2.a).i) = (C_128 : (C_127 : __cil_tmp7.a).i)));
            (C_136 : ((C_135 : (C_134 : copy2.a).j) = (C_133 : (C_132 : __cil_tmp7.a).j)));
            (C_141 : ((C_140 : (C_139 : copy2.b).i) = (C_138 : (C_137 : __cil_tmp7.b).i)));
            (C_146 : ((C_145 : (C_144 : copy2.b).j) = (C_143 : (C_142 : __cil_tmp7.b).j)))
         };
         (C_147 : (free(__cil_tmp7)))
      };
      (C_150 : ((C_149 : (C_148 : copy2.a).i) = 0));
      
      {  
         (assert (C_151 : (p.a.i == copy.a.i)));
         ()
      };
      (C_154 : ((C_153 : (C_152 : copy.a).j) = 1));
      
      {  
         (assert (C_155 : (p.a.j == copy2.a.j)));
         ()
      };
      (C_158 : ((C_157 : (C_156 : p.b).i) = 0));
      
      {  
         (assert (C_159 : (copy.b.i == copy2.b.i)));
         ()
      };
      
      {  
         (assert (C_160 : ((C_161 : (p.b.j == copy.b.j)) &&
                            (C_162 : (copy.b.j == copy2.b.j)))));
         ()
      };
      
      {  (C_163 : (free(copy)));
         (C_164 : (free(copy2)));
         
         (return ())
      }
   }
}
