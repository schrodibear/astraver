Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only bts0038.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD bts0038.c"
bts0038.c:29:[kernel] warning: Body of function main falls-through. Adding a return statement
[jessie] Starting Jessie translation
[kernel] warning: No code for function printf, default assigns generated for default behavior
bts0038.c:29:[jessie] warning: skipping all arguments of implicit prototype printf
[jessie] Producing Jessie files in subdir bts0038.jessie
[jessie] File bts0038.jessie/bts0038.jc written.
[jessie] File bts0038.jessie/bts0038.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int32 = -2147483648..2147483647

type int8 = -128..127

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

charP[0..3] __string__d_;

invariant valid___string__d_ :
((\offset_min(__string__d_) <= 0) && (\offset_max(__string__d_) >= 3))

unit Copy(intP[..] p, intP[..] q)
behavior default:
  ensures (C_4 : true);
{  
   {  (C_3 : ((C_2 : q.intM) = (C_1 : p.intM)));
      
      (return ())
   }
}

int32 foo(intP[..] a)
behavior default:
  ensures (C_9 : true);
{  
   (var int32 i);
   
   {  (C_5 : (i = 1));
      (C_8 : Copy((C_6 : (a + 0)), (C_7 : (a + i))));
      
      (return i)
   }
}

int32 printf()
behavior default:
  assigns \nothing;
  ensures (C_10 : true);
;

int32 main()
behavior default:
  ensures (C_22 : true);
{  
   (var intP[0..1] a_0);
   
   (var int32 tmp);
   
   (var int32 __retres);
   
   {  (C_12 : (a_0 = (C_11 : (new intP[2]))));
      (C_14 : ((C_13 : (a_0 + 0).intM) = 1));
      (C_16 : ((C_15 : (a_0 + 1).intM) = 2));
      
      {  (C_18 : (tmp = (C_17 : foo(a_0))));
         (C_19 : printf())
      };
      (C_20 : (__retres = 0));
      
      {  (C_21 : (free(a_0)));
         
         (return __retres)
      }
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs bts0038.jessie/bts0038.cloc bts0038.jessie/bts0038.jc
type __string__d__1

type charP

type int32

type int8

type intP

type padding

type voidP

exception Loop_continue_exc of unit

exception Loop_exit_exc of unit

exception Return_label_exc of unit

logic __string__d_:  -> charP pointer

logic charP_tag:  -> charP tag_id

axiom charP_int : (int_of_tag(charP_tag) = (1))

logic charP_of_pointer_address: unit pointer -> charP pointer

axiom charP_of_pointer_address_of_pointer_addr :
 (forall p:charP pointer. (p = charP_of_pointer_address(pointer_address(p))))

axiom charP_parenttag_bottom : parenttag(charP_tag, bottom_tag)

axiom charP_tags :
 (forall x:charP pointer.
  (forall charP_tag_table:charP tag_table.
   instanceof(charP_tag_table, x, charP_tag)))

logic integer_of_int32: int32 -> int

predicate eq_int32(x:int32, y:int32) =
 eq_int(integer_of_int32(x), integer_of_int32(y))

logic integer_of_int8: int8 -> int

predicate eq_int8(x:int8, y:int8) =
 eq_int(integer_of_int8(x), integer_of_int8(y))

logic int32_of_integer: int -> int32

axiom int32_coerce :
 (forall x:int.
  ((le_int((-2147483648), x) and le_int(x, (2147483647))) ->
   eq_int(integer_of_int32(int32_of_integer(x)), x)))

axiom int32_range :
 (forall x:int32.
  (le_int((-2147483648), integer_of_int32(x))
  and le_int(integer_of_int32(x), (2147483647))))

logic int8_of_integer: int -> int8

axiom int8_coerce :
 (forall x:int.
  ((le_int((-128), x) and le_int(x, (127))) ->
   eq_int(integer_of_int8(int8_of_integer(x)), x)))

axiom int8_range :
 (forall x:int8.
  (le_int((-128), integer_of_int8(x)) and le_int(integer_of_int8(x), (127))))

logic intP_tag:  -> intP tag_id

axiom intP_int : (int_of_tag(intP_tag) = (1))

logic intP_of_pointer_address: unit pointer -> intP pointer

axiom intP_of_pointer_address_of_pointer_addr :
 (forall p:intP pointer. (p = intP_of_pointer_address(pointer_address(p))))

axiom intP_parenttag_bottom : parenttag(intP_tag, bottom_tag)

axiom intP_tags :
 (forall x:intP pointer.
  (forall intP_tag_table:intP tag_table.
   instanceof(intP_tag_table, x, intP_tag)))

predicate left_valid_struct_charP(p:charP pointer, a:int,
 charP_alloc_table:charP alloc_table) =
 (offset_min(charP_alloc_table, p) <= a)

predicate left_valid_struct_intP(p:intP pointer, a:int,
 intP_alloc_table:intP alloc_table) = (offset_min(intP_alloc_table, p) <= a)

predicate left_valid_struct_voidP(p:voidP pointer, a:int,
 voidP_alloc_table:voidP alloc_table) =
 (offset_min(voidP_alloc_table, p) <= a)

axiom pointer_addr_of_charP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(charP_of_pointer_address(p))))

axiom pointer_addr_of_intP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(intP_of_pointer_address(p))))

logic voidP_of_pointer_address: unit pointer -> voidP pointer

axiom pointer_addr_of_voidP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(voidP_of_pointer_address(p))))

predicate right_valid_struct_charP(p:charP pointer, b:int,
 charP_alloc_table:charP alloc_table) =
 (offset_max(charP_alloc_table, p) >= b)

predicate right_valid_struct_intP(p:intP pointer, b:int,
 intP_alloc_table:intP alloc_table) = (offset_max(intP_alloc_table, p) >= b)

predicate right_valid_struct_voidP(p:voidP pointer, b:int,
 voidP_alloc_table:voidP alloc_table) =
 (offset_max(voidP_alloc_table, p) >= b)

predicate strict_valid_root_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) = a)
 and (offset_max(charP_alloc_table, p) = b))

predicate strict_valid_root_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) = a)
 and (offset_max(intP_alloc_table, p) = b))

predicate strict_valid_root_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) = a)
 and (offset_max(voidP_alloc_table, p) = b))

predicate strict_valid_struct_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) = a)
 and (offset_max(charP_alloc_table, p) = b))

predicate strict_valid_struct_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) = a)
 and (offset_max(intP_alloc_table, p) = b))

predicate strict_valid_struct_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) = a)
 and (offset_max(voidP_alloc_table, p) = b))

predicate valid___string__d_(charP___string__d__1_alloc_table:charP alloc_table) =
 (le_int(offset_min(charP___string__d__1_alloc_table, __string__d_), (0))
 and ge_int(offset_max(charP___string__d__1_alloc_table, __string__d_), (3)))

predicate valid_bitvector_struct_charP(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_bitvector_struct_intP(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_bitvector_struct_voidP(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_root_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) <= a)
 and (offset_max(charP_alloc_table, p) >= b))

predicate valid_root_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) <= a)
 and (offset_max(intP_alloc_table, p) >= b))

predicate valid_root_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) <= a)
 and (offset_max(voidP_alloc_table, p) >= b))

predicate valid_struct_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) <= a)
 and (offset_max(charP_alloc_table, p) >= b))

predicate valid_struct_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) <= a)
 and (offset_max(intP_alloc_table, p) >= b))

predicate valid_struct_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) <= a)
 and (offset_max(voidP_alloc_table, p) >= b))

logic voidP_tag:  -> voidP tag_id

axiom voidP_int : (int_of_tag(voidP_tag) = (1))

axiom voidP_of_pointer_address_of_pointer_addr :
 (forall p:voidP pointer. (p = voidP_of_pointer_address(pointer_address(p))))

axiom voidP_parenttag_bottom : parenttag(voidP_tag, bottom_tag)

axiom voidP_tags :
 (forall x:voidP pointer.
  (forall voidP_tag_table:voidP tag_table.
   instanceof(voidP_tag_table, x, voidP_tag)))

parameter charP___string__d__1_alloc_table : charP alloc_table ref

parameter Copy :
 p:intP pointer ->
  q:intP pointer ->
   intP_intM_q_3:(intP, int32) memory ref ->
    intP_q_3_alloc_table:intP alloc_table ->
     intP_p_2_alloc_table:intP alloc_table ->
      intP_intM_p_2:(intP, int32) memory ->
       { } unit reads charP___string__d__1_alloc_table writes intP_intM_q_3
       { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter Copy_requires :
 p:intP pointer ->
  q:intP pointer ->
   intP_intM_q_3:(intP, int32) memory ref ->
    intP_q_3_alloc_table:intP alloc_table ->
     intP_p_2_alloc_table:intP alloc_table ->
      intP_intM_p_2:(intP, int32) memory ->
       { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table))} unit
       reads charP___string__d__1_alloc_table writes intP_intM_q_3
       { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter Copy_requires_specialized :
 p:intP pointer ->
  q:intP pointer ->
   intP_intM_q_3:(intP, int32) memory ref ->
    intP_q_3_alloc_table:intP alloc_table ->
     intP_p_2_alloc_table:intP alloc_table ->
      { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table))} unit
      reads charP___string__d__1_alloc_table writes intP_intM_q_3
      { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter Copy_specialized :
 p:intP pointer ->
  q:intP pointer ->
   intP_intM_q_3:(intP, int32) memory ref ->
    intP_q_3_alloc_table:intP alloc_table ->
     intP_p_2_alloc_table:intP alloc_table ->
      { } unit reads charP___string__d__1_alloc_table writes intP_intM_q_3
      { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter alloc_bitvector_struct_charP :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_charP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_charP_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_charP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_intP :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_intP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_intP_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_intP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_voidP :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_voidP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_voidP_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_voidP(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter charP_alloc_table : charP alloc_table ref

parameter charP_tag_table : charP tag_table ref

parameter alloc_struct_charP :
 n:int ->
  charP_alloc_table:charP alloc_table ref ->
   charP_tag_table:charP tag_table ref ->
    { } charP pointer writes charP_alloc_table,charP_tag_table
    { (strict_valid_struct_charP(result, (0), sub_int(n, (1)),
       charP_alloc_table)
      and (alloc_extends(charP_alloc_table@, charP_alloc_table)
          and (alloc_fresh(charP_alloc_table@, result, n)
              and instanceof(charP_tag_table, result, charP_tag)))) }

parameter alloc_struct_charP_requires :
 n:int ->
  charP_alloc_table:charP alloc_table ref ->
   charP_tag_table:charP tag_table ref ->
    { ge_int(n, (0))} charP pointer writes charP_alloc_table,charP_tag_table
    { (strict_valid_struct_charP(result, (0), sub_int(n, (1)),
       charP_alloc_table)
      and (alloc_extends(charP_alloc_table@, charP_alloc_table)
          and (alloc_fresh(charP_alloc_table@, result, n)
              and instanceof(charP_tag_table, result, charP_tag)))) }

parameter intP_alloc_table : intP alloc_table ref

parameter intP_tag_table : intP tag_table ref

parameter alloc_struct_intP :
 n:int ->
  intP_alloc_table:intP alloc_table ref ->
   intP_tag_table:intP tag_table ref ->
    { } intP pointer writes intP_alloc_table,intP_tag_table
    { (strict_valid_struct_intP(result, (0), sub_int(n, (1)),
       intP_alloc_table)
      and (alloc_extends(intP_alloc_table@, intP_alloc_table)
          and (alloc_fresh(intP_alloc_table@, result, n)
              and instanceof(intP_tag_table, result, intP_tag)))) }

parameter alloc_struct_intP_requires :
 n:int ->
  intP_alloc_table:intP alloc_table ref ->
   intP_tag_table:intP tag_table ref ->
    { ge_int(n, (0))} intP pointer writes intP_alloc_table,intP_tag_table
    { (strict_valid_struct_intP(result, (0), sub_int(n, (1)),
       intP_alloc_table)
      and (alloc_extends(intP_alloc_table@, intP_alloc_table)
          and (alloc_fresh(intP_alloc_table@, result, n)
              and instanceof(intP_tag_table, result, intP_tag)))) }

parameter voidP_alloc_table : voidP alloc_table ref

parameter voidP_tag_table : voidP tag_table ref

parameter alloc_struct_voidP :
 n:int ->
  voidP_alloc_table:voidP alloc_table ref ->
   voidP_tag_table:voidP tag_table ref ->
    { } voidP pointer writes voidP_alloc_table,voidP_tag_table
    { (strict_valid_struct_voidP(result, (0), sub_int(n, (1)),
       voidP_alloc_table)
      and (alloc_extends(voidP_alloc_table@, voidP_alloc_table)
          and (alloc_fresh(voidP_alloc_table@, result, n)
              and instanceof(voidP_tag_table, result, voidP_tag)))) }

parameter alloc_struct_voidP_requires :
 n:int ->
  voidP_alloc_table:voidP alloc_table ref ->
   voidP_tag_table:voidP tag_table ref ->
    { ge_int(n, (0))} voidP pointer writes voidP_alloc_table,voidP_tag_table
    { (strict_valid_struct_voidP(result, (0), sub_int(n, (1)),
       voidP_alloc_table)
      and (alloc_extends(voidP_alloc_table@, voidP_alloc_table)
          and (alloc_fresh(voidP_alloc_table@, result, n)
              and instanceof(voidP_tag_table, result, voidP_tag)))) }

parameter any_int32 : unit -> { } int32 { true }

parameter any_int8 : unit -> { } int8 { true }

parameter foo :
 a:intP pointer ->
  intP_intM_a_4:(intP, int32) memory ref ->
   intP_a_4_alloc_table:intP alloc_table ->
    { } int32 reads charP___string__d__1_alloc_table,intP_intM_a_4
    writes intP_intM_a_4
    { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter foo_requires :
 a:intP pointer ->
  intP_intM_a_4:(intP, int32) memory ref ->
   intP_a_4_alloc_table:intP alloc_table ->
    { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table))} int32
    reads charP___string__d__1_alloc_table,intP_intM_a_4 writes intP_intM_a_4
    { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter int32_of_integer_ :
 x:int ->
  { (le_int((-2147483648), x) and le_int(x, (2147483647)))} int32
  { eq_int(integer_of_int32(result), x) }

parameter int8_of_integer_ :
 x:int ->
  { (le_int((-128), x) and le_int(x, (127)))} int8
  { eq_int(integer_of_int8(result), x) }

parameter main :
 tt:unit ->
  { } int32 reads charP___string__d__1_alloc_table
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter main_requires :
 tt:unit ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table))} int32
  reads charP___string__d__1_alloc_table
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter printf :
 tt:unit ->
  { } int32 reads charP___string__d__1_alloc_table
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter printf_requires :
 tt:unit ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table))} int32
  reads charP___string__d__1_alloc_table
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

parameter safe_int32_of_integer_ :
 x:int -> { } int32 { eq_int(integer_of_int32(result), x) }

parameter safe_int8_of_integer_ :
 x:int -> { } int8 { eq_int(integer_of_int8(result), x) }

let Copy_ensures_default =
 fun (p : intP pointer) (q : intP pointer) (intP_intM_q_3 : (intP, int32) memory ref) (intP_p_2_alloc_table : intP alloc_table) (intP_q_3_alloc_table : intP alloc_table) (intP_intM_p_2 : (intP, int32) memory) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  try
   (C_3:
   begin
     (let jessie_<somenum> = (C_1: ((safe_acc_ intP_intM_p_2) p)) in
     (let jessie_<somenum> = q in (((safe_upd_ intP_intM_q_3) jessie_<somenum>) jessie_<somenum>)));
    (raise Return); (raise Return) end) with Return -> void end)
  { (JC_<somenum>: true) }

let Copy_safety =
 fun (p : intP pointer) (q : intP pointer) (intP_intM_q_3 : (intP, int32) memory ref) (intP_p_2_alloc_table : intP alloc_table) (intP_q_3_alloc_table : intP alloc_table) (intP_intM_p_2 : (intP, int32) memory) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  try
   (C_3:
   begin
     (let jessie_<somenum> =
     (C_1: (JC_<somenum>: (((acc_ intP_p_2_alloc_table) intP_intM_p_2) p))) in
     (let jessie_<somenum> = q in
     (JC_<somenum>:
     ((((upd_ intP_q_3_alloc_table) intP_intM_q_3) jessie_<somenum>) jessie_<somenum>))));
    (raise Return); (raise Return) end) with Return -> void end)
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

let foo_ensures_default =
 fun (a : intP pointer) (intP_intM_a_4 : (intP, int32) memory ref) (intP_a_4_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  (let return = ref (any_int32 void) in
  try
   begin
     (let i = ref (any_int32 void) in
     (C_5:
     (C_8:
     begin
       (let jessie_<somenum> = (i := (safe_int32_of_integer_ (1))) in void);
      (let jessie_<somenum> = (C_6: ((shift a) (0))) in
      (let jessie_<somenum> = (C_7: ((shift a) (integer_of_int32 !i))) in
      (JC_<somenum>:
      (((((Copy_specialized jessie_<somenum>) jessie_<somenum>) intP_intM_a_4) intP_a_4_alloc_table) intP_a_4_alloc_table))));
      (return := !i); (raise Return) end))); absurd  end with Return ->
   !return end)) { (JC_<somenum>: true) }

let foo_safety =
 fun (a : intP pointer) (intP_intM_a_4 : (intP, int32) memory ref) (intP_a_4_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  (let return = ref (any_int32 void) in
  try
   begin
     (let i = ref (any_int32 void) in
     (C_5:
     (C_8:
     begin
       (let jessie_<somenum> = (i := (safe_int32_of_integer_ (1))) in void);
      (let jessie_<somenum> = (C_6: ((shift a) (0))) in
      (let jessie_<somenum> = (C_7: ((shift a) (integer_of_int32 !i))) in
      (JC_<somenum>:
      (assert
      { pset_disjoint(pset_range(pset_singleton(a), (0), (0)),
        pset_range(pset_singleton(a), i, i)) };
      (JC_<somenum>:
      (((((Copy_requires_specialized jessie_<somenum>) jessie_<somenum>) intP_intM_a_4) intP_a_4_alloc_table) intP_a_4_alloc_table))))));
      (return := !i); (raise Return) end))); absurd  end with Return ->
   !return end))
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }

let main_ensures_default =
 fun (tt : unit) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  (let return = ref (any_int32 void) in
  try
   begin
     (let intP_intM_a_0_5 = ref (any_memory void) in
     (let intP_a_0_5_tag_table = ref (any_tag_table void) in
     (let intP_a_0_5_alloc_table = ref (any_alloc_table void) in
     (let a_0 = ref (any_pointer void) in
     (let tmp = ref (any_int32 void) in
     (let __retres = ref (any_int32 void) in
     (C_12:
     (C_14:
     (C_16:
     (C_20:
     (C_21:
     begin
       (let jessie_<somenum> =
       (a_0 := (C_11:
               (JC_<somenum>:
               (((alloc_struct_intP (2)) intP_a_0_5_alloc_table) intP_a_0_5_tag_table)))) in
       void);
      (let jessie_<somenum> = (safe_int32_of_integer_ (1)) in
      (let jessie_<somenum> = !a_0 in
      (let jessie_<somenum> = (safe_int32_of_integer_ (2)) in
      (let jessie_<somenum> = !a_0 in
      (let jessie_<somenum> = (1) in
      (let jessie_<somenum> = ((shift jessie_<somenum>) jessie_<somenum>) in
      [ { } unit reads intP_a_0_5_alloc_table,intP_intM_a_0_5
        writes intP_intM_a_0_5
        { (not_assigns(intP_a_0_5_alloc_table, intP_intM_a_0_5@,
           intP_intM_a_0_5, pset_range(pset_singleton(jessie_<somenum>), (0), (1)))
          and ((select(intP_intM_a_0_5, shift(jessie_<somenum>, (0))) = jessie_<somenum>)
              and (select(intP_intM_a_0_5, shift(jessie_<somenum>, (1))) = jessie_<somenum>))) } ]))))));
      (let jessie_<somenum> =
      (C_18:
      begin
        (let jessie_<somenum> =
        (tmp := (C_17:
                (let jessie_<somenum> = !a_0 in
                (JC_<somenum>:
                (((foo jessie_<somenum>) intP_intM_a_0_5) !intP_a_0_5_alloc_table))))) in
        void); (C_19: (JC_<somenum>: (printf void))) end) in void);
      (let jessie_<somenum> = (__retres := (safe_int32_of_integer_ (0))) in void);
      ((safe_free_parameter intP_a_0_5_alloc_table) !a_0);
      (return := !__retres); (raise Return) end))))))))))); absurd  end with
   Return -> !return end)) { (JC_<somenum>: true) }

let main_safety =
 fun (tt : unit) ->
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }
  (init:
  (let return = ref (any_int32 void) in
  try
   begin
     (let intP_intM_a_0_5 = ref (any_memory void) in
     (let intP_a_0_5_tag_table = ref (any_tag_table void) in
     (let intP_a_0_5_alloc_table = ref (any_alloc_table void) in
     (let a_0 = ref (any_pointer void) in
     (let tmp = ref (any_int32 void) in
     (let __retres = ref (any_int32 void) in
     (C_12:
     (C_14:
     (C_16:
     (C_20:
     (C_21:
     begin
       (let jessie_<somenum> =
       (a_0 := (let jessie_<somenum> =
               (C_11:
               (JC_<somenum>:
               (((alloc_struct_intP_requires (2)) intP_a_0_5_alloc_table) intP_a_0_5_tag_table))) in
               (JC_<somenum>:
               (assert
               { ge_int(offset_max(intP_a_0_5_alloc_table, jessie_<somenum>), (1)) };
               jessie_<somenum>)))) in void);
      (let jessie_<somenum> = (safe_int32_of_integer_ (1)) in
      (let jessie_<somenum> = !a_0 in
      (let jessie_<somenum> = (safe_int32_of_integer_ (2)) in
      (let jessie_<somenum> = !a_0 in
      (let jessie_<somenum> = (1) in
      (let jessie_<somenum> = ((shift jessie_<somenum>) jessie_<somenum>) in
      [ { } unit reads intP_a_0_5_alloc_table,intP_intM_a_0_5
        writes intP_intM_a_0_5
        { (not_assigns(intP_a_0_5_alloc_table, intP_intM_a_0_5@,
           intP_intM_a_0_5, pset_range(pset_singleton(jessie_<somenum>), (0), (1)))
          and ((select(intP_intM_a_0_5, shift(jessie_<somenum>, (0))) = jessie_<somenum>)
              and (select(intP_intM_a_0_5, shift(jessie_<somenum>, (1))) = jessie_<somenum>))) } ]))))));
      (let jessie_<somenum> =
      (C_18:
      begin
        (let jessie_<somenum> =
        (tmp := (C_17:
                (let jessie_<somenum> = !a_0 in
                (JC_<somenum>:
                (((foo_requires jessie_<somenum>) intP_intM_a_0_5) !intP_a_0_5_alloc_table))))) in
        void); (C_19: (JC_<somenum>: (printf_requires void))) end) in void);
      (let jessie_<somenum> = (__retres := (safe_int32_of_integer_ (0))) in void);
      ((free_parameter intP_a_0_5_alloc_table) !a_0); (return := !__retres);
      (raise Return) end))))))))))); absurd  end with Return -> !return end))
  { (JC_<somenum>: valid___string__d_(charP___string__d__1_alloc_table)) }


WHYLIB=WHYHOME/lib WHYEXEC=WHYHOME/bin/why.opt GWHYEXEC=WHYHOME/bin/gwhy.opt make --quiet -C bts0038.jessie --quiet -f bts0038.makefile project
why --project [...] why/bts0038.why
