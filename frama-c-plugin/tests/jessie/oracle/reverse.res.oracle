Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only reverse.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD reverse.c"
[kernel] warning: ignoring status of axiomatic `List'
[kernel] warning: ignoring status of global predicate `linked_path'
[kernel] warning: ignoring status of global predicate `list_contents'
[kernel] warning: ignoring status of global predicate `null_term_list'
[jessie] Starting Jessie translation
[kernel] warning: ignoring status of global predicate `null_term_list'
[kernel] warning: ignoring status of global predicate `list_contents'
[kernel] warning: ignoring status of global predicate `linked_path'
[kernel] warning: ignoring status of axiomatic `List'
[jessie] Producing Jessie files in subdir reverse.jessie
[jessie] File reverse.jessie/reverse.jc written.
[jessie] File reverse.jessie/reverse.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int8 = -128..127

type int32 = -2147483648..2147483647

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

tag struct_list = {
  int32 hd: 32; 
  struct_list[..] tl: 32;
}

type struct_list = [struct_list]

axiomatic List {

  logic type list
   
  logic list nil 
   
  logic list cons(struct_list[..] l, list l_0)
   
  logic list app(list l1, list l2)
   
  axiom app_nil_right :
  (\forall list l_1;
    (l_1 == app(l_1, nil)))
   
  axiom app_nil_left :
  (\forall list l_2;
    (l_2 == app(nil, l_2)))
   
  logic list rev(list l_3)
   
  axiom rev_nil :
  (rev(nil) == nil)
   
  predicate disjoint(list l1_0, list l2_0)
   
  axiom disjoint_nil_right :
  (\forall list l_4;
    disjoint(l_4, nil))
   
  axiom disjoint_nil_left :
  (\forall list l_5;
    disjoint(nil, l_5))
   
  logic int32 len(list l_6)
   
  axiom len_nil :
  (len(nil) == 0)
   
  axiom len_cons :
  (\forall struct_list[..] p;
    (\forall list l_7;
      (len(cons(p, l_7)) == (1 + len(l_7)))))
   
  lemma len_app :
  (\forall list l1_1;
    (\forall list l2_1;
      (len(app(l1_1, l2_1)) == (len(l1_1) + len(l2_1)))))
  
}

predicate linked_path{L}(struct_list[..] p1, list l_8, struct_list[..] p2) {
case path_null{L}: (\forall struct_list[..] p_0;
                     linked_path{L}(p_0, nil, p_0));
  
  case path_cons{L}: (\forall struct_list[..] p1_0;
                       (\forall struct_list[..] p2_0;
                         (\forall list l_9;
                           ((((\offset_min(p1_0) <= 0) &&
                               (\offset_max(p1_0) >= 0)) &&
                              linked_path{L}(p1_0.tl, l_9, p2_0)) ==>
                             linked_path{L}(p1_0, cons(p1_0, l_9), p2_0)))));
  
}

lemma linked_path_cons_inv{L} :
(\forall struct_list[..] p1_1;
  (\forall struct_list[..] p2_1;
    (\forall struct_list[..] p3;
      (\forall list l_10;
        (linked_path{L}(p1_1, cons(p2_1, l_10), p3) ==>
          (((p1_1 == p2_1) &&
             ((\offset_min(p1_1) <= 0) && (\offset_max(p1_1) >= 0))) &&
            linked_path{L}(p1_1.tl, l_10, p3)))))))

predicate list_contents{L}(struct_list[..] p_1, list l_11) =
linked_path{L}(p_1, l_11, null)

lemma list_contents_functional{L} :
(\forall struct_list[..] p_2;
  (\forall list l1_2;
    (\forall list l2_2;
      ((list_contents{L}(p_2, l1_2) && list_contents{L}(p_2, l2_2)) ==>
        (l1_2 == l2_2)))))

lemma list_contents_valid{L} :
(\forall struct_list[..] p_3;
  (\forall list l_12;
    ((list_contents{L}(p_3, l_12) && (p_3 != null)) ==>
      ((\offset_min(p_3) <= 0) && (\offset_max(p_3) >= 0)))))

predicate null_term_list{L}(struct_list[..] p_4) =
(\exists list l_13;
  list_contents{L}(p_4, l_13))

struct_list[..] list_reverse(struct_list[..] p0)
  requires (C_11 : null_term_list{Here}(p0));
behavior default:
  ensures (C_10 : (\forall list l0;
                    (\at(list_contents{Old}(p0, l0),Old) ==>
                      list_contents{Here}(\result, rev(l0)))));
{  
   (var struct_list[..] r);
   
   (var struct_list[..] p);
   
   (var struct_list[..] q);
   
   {  (C_1 : (r = p0));
      (C_2 : (p = null));
      
      loop 
      behavior default:
        invariant (C_3 : (\exists list lp;
                           (\exists list lr;
                             (((list_contents{Here}(p, lp) &&
                                 list_contents{Here}(r, lr)) &&
                                disjoint(lp, lr)) &&
                               (\forall list l_14;
                                 (\at(list_contents{Pre}(p0, l_14),Pre) ==>
                                   (app(rev(lr), lp) == rev(l_14))))))));
      while (true)
      {  
         {  (if (r != null) then () else 
            (goto while_0_break));
            
            {  (C_4 : (q = r));
               (C_6 : (r = (C_5 : r.tl)));
               (C_8 : ((C_7 : q.tl) = p));
               (C_9 : (p = q))
            }
         }
      };
      (while_0_break : ());
      
      (return p)
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs reverse.jessie/reverse.cloc reverse.jessie/reverse.jc
