Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only bts0178.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD bts0178.c"
[jessie] Starting Jessie translation
[jessie] Producing Jessie files in subdir bts0178.jessie
[jessie] File bts0178.jessie/bts0178.jc written.
[jessie] File bts0178.jessie/bts0178.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int32 = -2147483648..2147483647

type int8 = -128..127

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

unit g(intP[..] j, intP[..] k)
behavior default:
  ensures (C_8 : true);
{  
   (var int32 tmp);
   
   {  (C_2 : (tmp = (C_1 : j.intM)));
      (C_5 : ((C_4 : j.intM) = (C_3 : k.intM)));
      (C_7 : ((C_6 : k.intM) = tmp));
      
      (return ())
   }
}

unit f(intP[..] vector, int32 size)
behavior default:
  ensures (C_15 : true);
{  
   (var int32 i);
   
   {  (C_9 : (i = 0));
      (if (i < size) then (C_14 : g((C_10 : (vector + i)),
                                    (C_13 : (vector +
                                              (C_12 : ((C_11 : (i + 1)) :> int32)))))) else ());
      
      (return ())
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs bts0178.jessie/bts0178.cloc bts0178.jessie/bts0178.jc
type charP

type int32

type int8

type intP

type padding

type voidP

logic charP_tag:  -> charP tag_id

axiom charP_int : (int_of_tag(charP_tag) = (1))

logic charP_of_pointer_address: unit pointer -> charP pointer

axiom charP_of_pointer_address_of_pointer_addr :
 (forall p:charP pointer. (p = charP_of_pointer_address(pointer_address(p))))

axiom charP_parenttag_bottom : parenttag(charP_tag, bottom_tag)

axiom charP_tags :
 (forall x:charP pointer.
  (forall charP_tag_table:charP tag_table.
   instanceof(charP_tag_table, x, charP_tag)))

logic integer_of_int32: int32 -> int

predicate eq_int32(x:int32, y:int32) =
 eq_int(integer_of_int32(x), integer_of_int32(y))

logic integer_of_int8: int8 -> int

predicate eq_int8(x:int8, y:int8) =
 eq_int(integer_of_int8(x), integer_of_int8(y))

logic int32_of_integer: int -> int32

axiom int32_coerce :
 (forall x:int.
  ((le_int((-2147483648), x) and le_int(x, (2147483647))) ->
   eq_int(integer_of_int32(int32_of_integer(x)), x)))

axiom int32_extensionality :
 (forall x:int32.
  (forall y:int32.
   (eq_int(integer_of_int32(x), integer_of_int32(y)) -> (x = y))))

axiom int32_range :
 (forall x:int32.
  (le_int((-2147483648), integer_of_int32(x))
  and le_int(integer_of_int32(x), (2147483647))))

logic int8_of_integer: int -> int8

axiom int8_coerce :
 (forall x:int.
  ((le_int((-128), x) and le_int(x, (127))) ->
   eq_int(integer_of_int8(int8_of_integer(x)), x)))

axiom int8_extensionality :
 (forall x:int8.
  (forall y:int8.
   (eq_int(integer_of_int8(x), integer_of_int8(y)) -> (x = y))))

axiom int8_range :
 (forall x:int8.
  (le_int((-128), integer_of_int8(x)) and le_int(integer_of_int8(x), (127))))

logic intP_tag:  -> intP tag_id

axiom intP_int : (int_of_tag(intP_tag) = (1))

logic intP_of_pointer_address: unit pointer -> intP pointer

axiom intP_of_pointer_address_of_pointer_addr :
 (forall p:intP pointer. (p = intP_of_pointer_address(pointer_address(p))))

axiom intP_parenttag_bottom : parenttag(intP_tag, bottom_tag)

axiom intP_tags :
 (forall x:intP pointer.
  (forall intP_tag_table:intP tag_table.
   instanceof(intP_tag_table, x, intP_tag)))

predicate left_valid_struct_charP(p:charP pointer, a:int,
 charP_alloc_table:charP alloc_table) =
 (offset_min(charP_alloc_table, p) <= a)

predicate left_valid_struct_intP(p:intP pointer, a:int,
 intP_alloc_table:intP alloc_table) = (offset_min(intP_alloc_table, p) <= a)

predicate left_valid_struct_voidP(p:voidP pointer, a:int,
 voidP_alloc_table:voidP alloc_table) =
 (offset_min(voidP_alloc_table, p) <= a)

axiom pointer_addr_of_charP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(charP_of_pointer_address(p))))

axiom pointer_addr_of_intP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(intP_of_pointer_address(p))))

logic voidP_of_pointer_address: unit pointer -> voidP pointer

axiom pointer_addr_of_voidP_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(voidP_of_pointer_address(p))))

predicate right_valid_struct_charP(p:charP pointer, b:int,
 charP_alloc_table:charP alloc_table) =
 (offset_max(charP_alloc_table, p) >= b)

predicate right_valid_struct_intP(p:intP pointer, b:int,
 intP_alloc_table:intP alloc_table) = (offset_max(intP_alloc_table, p) >= b)

predicate right_valid_struct_voidP(p:voidP pointer, b:int,
 voidP_alloc_table:voidP alloc_table) =
 (offset_max(voidP_alloc_table, p) >= b)

predicate strict_valid_root_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) = a)
 and (offset_max(charP_alloc_table, p) = b))

predicate strict_valid_root_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) = a)
 and (offset_max(intP_alloc_table, p) = b))

predicate strict_valid_root_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) = a)
 and (offset_max(voidP_alloc_table, p) = b))

predicate strict_valid_struct_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) = a)
 and (offset_max(charP_alloc_table, p) = b))

predicate strict_valid_struct_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) = a)
 and (offset_max(intP_alloc_table, p) = b))

predicate strict_valid_struct_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) = a)
 and (offset_max(voidP_alloc_table, p) = b))

predicate valid_root_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) <= a)
 and (offset_max(charP_alloc_table, p) >= b))

predicate valid_root_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) <= a)
 and (offset_max(intP_alloc_table, p) >= b))

predicate valid_root_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) <= a)
 and (offset_max(voidP_alloc_table, p) >= b))

predicate valid_struct_charP(p:charP pointer, a:int, b:int,
 charP_alloc_table:charP alloc_table) =
 ((offset_min(charP_alloc_table, p) <= a)
 and (offset_max(charP_alloc_table, p) >= b))

predicate valid_struct_intP(p:intP pointer, a:int, b:int,
 intP_alloc_table:intP alloc_table) =
 ((offset_min(intP_alloc_table, p) <= a)
 and (offset_max(intP_alloc_table, p) >= b))

predicate valid_struct_voidP(p:voidP pointer, a:int, b:int,
 voidP_alloc_table:voidP alloc_table) =
 ((offset_min(voidP_alloc_table, p) <= a)
 and (offset_max(voidP_alloc_table, p) >= b))

logic voidP_tag:  -> voidP tag_id

axiom voidP_int : (int_of_tag(voidP_tag) = (1))

axiom voidP_of_pointer_address_of_pointer_addr :
 (forall p:voidP pointer. (p = voidP_of_pointer_address(pointer_address(p))))

axiom voidP_parenttag_bottom : parenttag(voidP_tag, bottom_tag)

axiom voidP_tags :
 (forall x:voidP pointer.
  (forall voidP_tag_table:voidP tag_table.
   instanceof(voidP_tag_table, x, voidP_tag)))

exception Loop_continue_exc of unit

exception Loop_exit_exc of unit

exception Return_label_exc of unit

parameter charP_alloc_table : charP alloc_table ref

parameter charP_tag_table : charP tag_table ref

parameter alloc_struct_charP :
 n:int ->
  charP_alloc_table:charP alloc_table ref ->
   charP_tag_table:charP tag_table ref ->
    { } charP pointer writes charP_alloc_table,charP_tag_table
    { (strict_valid_struct_charP(result, (0), sub_int(n, (1)),
       charP_alloc_table)
      and (alloc_extends(charP_alloc_table@, charP_alloc_table)
          and (alloc_fresh(charP_alloc_table@, result, n)
              and instanceof(charP_tag_table, result, charP_tag)))) }

parameter alloc_struct_charP_requires :
 n:int ->
  charP_alloc_table:charP alloc_table ref ->
   charP_tag_table:charP tag_table ref ->
    { ge_int(n, (0))} charP pointer writes charP_alloc_table,charP_tag_table
    { (strict_valid_struct_charP(result, (0), sub_int(n, (1)),
       charP_alloc_table)
      and (alloc_extends(charP_alloc_table@, charP_alloc_table)
          and (alloc_fresh(charP_alloc_table@, result, n)
              and instanceof(charP_tag_table, result, charP_tag)))) }

parameter intP_alloc_table : intP alloc_table ref

parameter intP_tag_table : intP tag_table ref

parameter alloc_struct_intP :
 n:int ->
  intP_alloc_table:intP alloc_table ref ->
   intP_tag_table:intP tag_table ref ->
    { } intP pointer writes intP_alloc_table,intP_tag_table
    { (strict_valid_struct_intP(result, (0), sub_int(n, (1)),
       intP_alloc_table)
      and (alloc_extends(intP_alloc_table@, intP_alloc_table)
          and (alloc_fresh(intP_alloc_table@, result, n)
              and instanceof(intP_tag_table, result, intP_tag)))) }

parameter alloc_struct_intP_requires :
 n:int ->
  intP_alloc_table:intP alloc_table ref ->
   intP_tag_table:intP tag_table ref ->
    { ge_int(n, (0))} intP pointer writes intP_alloc_table,intP_tag_table
    { (strict_valid_struct_intP(result, (0), sub_int(n, (1)),
       intP_alloc_table)
      and (alloc_extends(intP_alloc_table@, intP_alloc_table)
          and (alloc_fresh(intP_alloc_table@, result, n)
              and instanceof(intP_tag_table, result, intP_tag)))) }

parameter voidP_alloc_table : voidP alloc_table ref

parameter voidP_tag_table : voidP tag_table ref

parameter alloc_struct_voidP :
 n:int ->
  voidP_alloc_table:voidP alloc_table ref ->
   voidP_tag_table:voidP tag_table ref ->
    { } voidP pointer writes voidP_alloc_table,voidP_tag_table
    { (strict_valid_struct_voidP(result, (0), sub_int(n, (1)),
       voidP_alloc_table)
      and (alloc_extends(voidP_alloc_table@, voidP_alloc_table)
          and (alloc_fresh(voidP_alloc_table@, result, n)
              and instanceof(voidP_tag_table, result, voidP_tag)))) }

parameter alloc_struct_voidP_requires :
 n:int ->
  voidP_alloc_table:voidP alloc_table ref ->
   voidP_tag_table:voidP tag_table ref ->
    { ge_int(n, (0))} voidP pointer writes voidP_alloc_table,voidP_tag_table
    { (strict_valid_struct_voidP(result, (0), sub_int(n, (1)),
       voidP_alloc_table)
      and (alloc_extends(voidP_alloc_table@, voidP_alloc_table)
          and (alloc_fresh(voidP_alloc_table@, result, n)
              and instanceof(voidP_tag_table, result, voidP_tag)))) }

parameter any_int32 : unit -> { } int32 { true }

parameter any_int8 : unit -> { } int8 { true }

parameter f :
 vector:intP pointer ->
  size:int32 ->
   intP_intM_vector_3:(intP, int32) memory ref ->
    intP_vector_3_alloc_table:intP alloc_table ->
     { } unit reads intP_intM_vector_3 writes intP_intM_vector_3 { true }

parameter f_requires :
 vector:intP pointer ->
  size:int32 ->
   intP_intM_vector_3:(intP, int32) memory ref ->
    intP_vector_3_alloc_table:intP alloc_table ->
     { } unit reads intP_intM_vector_3 writes intP_intM_vector_3 { true }

parameter g :
 j:intP pointer ->
  k:intP pointer ->
   intP_intM_k_2:(intP, int32) memory ref ->
    intP_intM_j_1:(intP, int32) memory ref ->
     intP_k_2_alloc_table:intP alloc_table ->
      intP_j_1_alloc_table:intP alloc_table ->
       { } unit reads intP_intM_j_1,intP_intM_k_2
       writes intP_intM_j_1,intP_intM_k_2 { true }

parameter g_requires :
 j:intP pointer ->
  k:intP pointer ->
   intP_intM_k_2:(intP, int32) memory ref ->
    intP_intM_j_1:(intP, int32) memory ref ->
     intP_k_2_alloc_table:intP alloc_table ->
      intP_j_1_alloc_table:intP alloc_table ->
       { } unit reads intP_intM_j_1,intP_intM_k_2
       writes intP_intM_j_1,intP_intM_k_2 { true }

parameter g_requires_specialized :
 j:intP pointer ->
  k:intP pointer ->
   intP_intM_j_1:(intP, int32) memory ref ->
    intP_k_2_alloc_table:intP alloc_table ->
     intP_j_1_alloc_table:intP alloc_table ->
      { } unit reads intP_intM_j_1,intP_intM_j_1
      writes intP_intM_j_1,intP_intM_j_1 { true }

parameter g_specialized :
 j:intP pointer ->
  k:intP pointer ->
   intP_intM_j_1:(intP, int32) memory ref ->
    intP_k_2_alloc_table:intP alloc_table ->
     intP_j_1_alloc_table:intP alloc_table ->
      { } unit reads intP_intM_j_1,intP_intM_j_1
      writes intP_intM_j_1,intP_intM_j_1 { true }

parameter int32_of_integer_ :
 x:int ->
  { (le_int((-2147483648), x) and le_int(x, (2147483647)))} int32
  { eq_int(integer_of_int32(result), x) }

parameter int8_of_integer_ :
 x:int ->
  { (le_int((-128), x) and le_int(x, (127)))} int8
  { eq_int(integer_of_int8(result), x) }

parameter safe_int32_of_integer_ :
 x:int -> { } int32 { eq_int(integer_of_int32(result), x) }

parameter safe_int8_of_integer_ :
 x:int -> { } int8 { eq_int(integer_of_int8(result), x) }

let f_ensures_default =
 fun (vector : intP pointer) (size : int32) (intP_intM_vector_3 : (intP, int32) memory ref) (intP_vector_3_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: true) }
  (init:
  try
   begin
     (let i = ref (any_int32 void) in
     (C_9:
     begin
       (let jessie_<somenum> = (i := (safe_int32_of_integer_ (0))) in void);
      (if ((lt_int_ (integer_of_int32 !i)) (integer_of_int32 size))
      then
       (C_14:
       (let jessie_<somenum> = (C_10: ((shift vector) (integer_of_int32 !i))) in
       (let jessie_<somenum> =
       (C_13:
       ((shift vector) (integer_of_int32 (C_12:
                                         (safe_int32_of_integer_ (C_11:
                                                                 ((add_int 
                                                                   (integer_of_int32 !i)) (1)))))))) in
       (JC_<somenum>:
       (((((g_specialized jessie_<somenum>) jessie_<somenum>) intP_intM_vector_3) intP_vector_3_alloc_table) intP_vector_3_alloc_table)))))
      else void); (raise Return) end)); (raise Return) end with Return ->
   void end) { (JC_<somenum>: true) }

let f_safety =
 fun (vector : intP pointer) (size : int32) (intP_intM_vector_3 : (intP, int32) memory ref) (intP_vector_3_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: true) }
  (init:
  try
   begin
     (let i = ref (any_int32 void) in
     (C_9:
     begin
       (let jessie_<somenum> = (i := (safe_int32_of_integer_ (0))) in void);
      (if ((lt_int_ (integer_of_int32 !i)) (integer_of_int32 size))
      then
       (C_14:
       (let jessie_<somenum> = (C_10: ((shift vector) (integer_of_int32 !i))) in
       (let jessie_<somenum> =
       (C_13:
       ((shift vector) (integer_of_int32 (C_12:
                                         (JC_<somenum>:
                                         (int32_of_integer_ (C_11:
                                                            ((add_int 
                                                              (integer_of_int32 !i)) (1))))))))) in
       (JC_<somenum>:
       (assert
       { pset_disjoint(pset_range(pset_singleton(vector),
                       add_int(integer_of_int32(i), (1)),
                       add_int(integer_of_int32(i), (1))),
         pset_range(pset_singleton(vector), i, i)) };
       (JC_<somenum>:
       (((((g_requires_specialized jessie_<somenum>) jessie_<somenum>) intP_intM_vector_3) intP_vector_3_alloc_table) intP_vector_3_alloc_table)))))))
      else void); (raise Return) end)); (raise Return) end with Return ->
   void end) { true }

let g_ensures_default =
 fun (j : intP pointer) (k : intP pointer) (intP_intM_j_1 : (intP, int32) memory ref) (intP_intM_k_2 : (intP, int32) memory ref) (intP_j_1_alloc_table : intP alloc_table) (intP_k_2_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: true) }
  (init:
  try
   begin
     (let tmp = ref (any_int32 void) in
     (C_2:
     (C_5:
     (C_7:
     begin
       (let jessie_<somenum> = (tmp := (C_1: ((safe_acc_ !intP_intM_j_1) j))) in
       void);
      (let jessie_<somenum> = (C_3: ((safe_acc_ !intP_intM_k_2) k)) in
      (let jessie_<somenum> = j in
      (((safe_upd_ intP_intM_j_1) jessie_<somenum>) jessie_<somenum>)));
      (let jessie_<somenum> = !tmp in
      (let jessie_<somenum> = k in
      (((safe_upd_ intP_intM_k_2) jessie_<somenum>) jessie_<somenum>))); (raise Return) end))));
    (raise Return) end with Return -> void end) { (JC_<somenum>: true) }

let g_safety =
 fun (j : intP pointer) (k : intP pointer) (intP_intM_j_1 : (intP, int32) memory ref) (intP_intM_k_2 : (intP, int32) memory ref) (intP_j_1_alloc_table : intP alloc_table) (intP_k_2_alloc_table : intP alloc_table) ->
  { (JC_<somenum>: true) }
  (init:
  try
   begin
     (let tmp = ref (any_int32 void) in
     (C_2:
     (C_5:
     (C_7:
     begin
       (let jessie_<somenum> =
       (tmp := (C_1:
               (JC_<somenum>: (((acc_ intP_j_1_alloc_table) !intP_intM_j_1) j)))) in
       void);
      (let jessie_<somenum> =
      (C_3: (JC_<somenum>: (((acc_ intP_k_2_alloc_table) !intP_intM_k_2) k))) in
      (let jessie_<somenum> = j in
      (JC_<somenum>:
      ((((upd_ intP_j_1_alloc_table) intP_intM_j_1) jessie_<somenum>) jessie_<somenum>))));
      (let jessie_<somenum> = !tmp in
      (let jessie_<somenum> = k in
      (JC_<somenum>:
      ((((upd_ intP_k_2_alloc_table) intP_intM_k_2) jessie_<somenum>) jessie_<somenum>))));
      (raise Return) end)))); (raise Return) end with Return -> void end)
  { true }


WHYLIB=WHYHOME/lib WHYEXEC=WHYHOME/bin/why.opt GWHYEXEC=WHYHOME/bin/gwhy.opt make --quiet -C bts0178.jessie --quiet -f bts0178.makefile project
why --project [...] why/bts0178.why
