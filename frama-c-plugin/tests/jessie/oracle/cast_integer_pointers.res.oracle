Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only cast_integer_pointers.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD cast_integer_pointers.c"
[jessie] Starting Jessie translation
cast_integer_pointers.c:34:[jessie] warning: pragma IntModel is ignored by Jessie.
[jessie] Producing Jessie files in subdir cast_integer_pointers.jessie
[jessie] File cast_integer_pointers.jessie/cast_integer_pointers.jc written.
[jessie] File cast_integer_pointers.jessie/cast_integer_pointers.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type uint16 = 0..65535

type uint32 = 0..4294967295

type uint8 = 0..255

type int8 = -128..127

type int32 = -2147483648..2147483647

tag signed_char_P = {
  int8 signed_char_M: 8;
}

type signed_char_P = [signed_char_P]

tag unsigned_char_P = {
  uint8 unsigned_char_M: 8;
}

type unsigned_char_P = [unsigned_char_P]

tag int_P = {
  int32 int_M: 32;
}

type int_P = [int_P]

tag unsigned_int_P = {
  uint32 unsigned_int_M: 32;
}

type unsigned_int_P = [unsigned_int_P]

tag unsigned_short_P = {
  uint16 unsigned_short_M: 16;
}

type unsigned_short_P = [unsigned_short_P]

tag char_P = {
  int8 char_M: 8;
}

type char_P = [char_P]

tag void_P = {
}

type void_P = [void_P]

axiomatic MemCmp {

  logic integer memcmp{L}(char_P[..] s1, char_P[..] s2, integer n)
  reads (s1 + [0..(n - 1)]).char_M, (s2 + [0..(n - 1)]).char_M;
   
  axiom memcmp_range{L} :
  (\forall char_P[..] s1_0;
    (\forall char_P[..] s2_0;
      (\forall integer n_0;
        ((((- 2147483647) - 1) <= memcmp{L}(s1_0, s2_0, n_0)) &&
          (memcmp{L}(s1_0, s2_0, n_0) <= 2147483647)))))
   
  axiom memcmp_zero{L} :
  (\forall char_P[..] s1_1;
    (\forall char_P[..] s2_1;
      (\forall integer n_1;
        ((memcmp{L}(s1_1, s2_1, n_1) == 0) <==>
          (\forall integer i;
            (((0 <= i) && (i < n_1)) ==>
              ((s1_1 + i).char_M == (s2_1 + i).char_M)))))))
  
}

axiomatic MemChr {

  logic boolean memchr{L}(char_P[..] s, integer c, integer n_2)
  reads (s + [0..(n_2 - 1)]).char_M;
   
  axiom memchr_def{L} :
  (\forall char_P[..] s_0;
    (\forall integer c_0;
      (\forall integer n_3;
        ((memchr{L}(s_0, c_0, n_3) == true) <==>
          (\exists int32 i_0;
            (((0 <= i_0) && (i_0 < n_3)) && ((s_0 + i_0).char_M == c_0)))))))
  
}

axiomatic MemSet {

  logic boolean memset{L}(char_P[..] s_1, integer c_1, integer n_4)
  reads (s_1 + [0..(n_4 - 1)]).char_M;
   
  axiom memset_def{L} :
  (\forall char_P[..] s_2;
    (\forall integer c_2;
      (\forall integer n_5;
        ((memset{L}(s_2, c_2, n_5) == true) <==>
          (\forall integer i_1;
            (((0 <= i_1) && (i_1 < n_5)) ==> ((s_2 + i_1).char_M == c_2)))))))
  
}

axiomatic StrLen {

  logic integer strlen{L}(char_P[..] s_3) reads (s_3 + [0..]).char_M;
   
  axiom strlen_pos_or_null{L} :
  (\forall char_P[..] s_4;
    (\forall integer i_2;
      (((((0 <= i_2) && (i_2 <= 2147483647)) &&
          (\forall integer j;
            (((0 <= j) && (j < i_2)) ==> ((s_4 + j).char_M != 0)))) &&
         ((s_4 + i_2).char_M == 0)) ==>
        (strlen{L}(s_4) == i_2))))
   
  axiom strlen_neg{L} :
  (\forall char_P[..] s_5;
    ((\forall integer i_3;
       (((0 <= i_3) && (i_3 <= 2147483647)) ==> ((s_5 + i_3).char_M != 0))) ==>
      (strlen{L}(s_5) < 0)))
   
  axiom strlen_range{L} :
  (\forall char_P[..] s_6;
    (strlen{L}(s_6) <= 2147483647))
   
  axiom strlen_before_null{L} :
  (\forall char_P[..] s_7;
    (\forall integer i_4;
      (((0 <= i_4) && (i_4 < strlen{L}(s_7))) ==> ((s_7 + i_4).char_M != 0))))
   
  axiom strlen_at_null{L} :
  (\forall char_P[..] s_8;
    ((0 <= strlen{L}(s_8)) ==> ((s_8 + strlen{L}(s_8)).char_M == 0)))
   
  axiom strlen_not_zero{L} :
  (\forall char_P[..] s_9;
    (\forall integer i_5;
      ((((0 <= i_5) && (i_5 <= strlen{L}(s_9))) && ((s_9 + i_5).char_M != 0)) ==>
        (i_5 < strlen{L}(s_9)))))
   
  axiom strlen_zero{L} :
  (\forall char_P[..] s_10;
    (\forall integer i_6;
      ((((0 <= i_6) && (i_6 <= strlen{L}(s_10))) &&
         ((s_10 + i_6).char_M == 0)) ==>
        (i_6 == strlen{L}(s_10)))))
   
  axiom strlen_sup{L} :
  (\forall char_P[..] s_11;
    (\forall integer i_7;
      (((0 <= i_7) && ((s_11 + i_7).char_M == 0)) ==>
        ((0 <= strlen{L}(s_11)) && (strlen{L}(s_11) <= i_7)))))
   
  axiom strlen_shift{L} :
  (\forall char_P[..] s_12;
    (\forall integer i_8;
      (((0 <= i_8) && (i_8 <= strlen{L}(s_12))) ==>
        (strlen{L}((s_12 + i_8)) == (strlen{L}(s_12) - i_8)))))
   
  axiom strlen_create{L} :
  (\forall char_P[..] s_13;
    (\forall integer i_9;
      ((((0 <= i_9) && (i_9 <= 2147483647)) && ((s_13 + i_9).char_M == 0)) ==>
        ((0 <= strlen{L}(s_13)) && (strlen{L}(s_13) <= i_9)))))
   
  axiom strlen_create_shift{L} :
  (\forall char_P[..] s_14;
    (\forall integer i_10;
      (\forall integer k;
        ((((0 <= k) && ((k <= i_10) && (i_10 <= 2147483647))) &&
           ((s_14 + i_10).char_M == 0)) ==>
          ((0 <= strlen{L}((s_14 + k))) &&
            (strlen{L}((s_14 + k)) <= (i_10 - k)))))))
   
  axiom memcmp_strlen_left{L} :
  (\forall char_P[..] s1_2;
    (\forall char_P[..] s2_2;
      (\forall integer n_6;
        (((memcmp{L}(s1_2, s2_2, n_6) == 0) && (strlen{L}(s1_2) < n_6)) ==>
          (strlen{L}(s1_2) == strlen{L}(s2_2))))))
   
  axiom memcmp_strlen_right{L} :
  (\forall char_P[..] s1_3;
    (\forall char_P[..] s2_3;
      (\forall integer n_7;
        (((memcmp{L}(s1_3, s2_3, n_7) == 0) && (strlen{L}(s2_3) < n_7)) ==>
          (strlen{L}(s1_3) == strlen{L}(s2_3))))))
   
  axiom memcmp_strlen_shift_left{L} :
  (\forall char_P[..] s1_4;
    (\forall char_P[..] s2_4;
      (\forall integer k_0;
        (\forall integer n_8;
          ((((memcmp{L}(s1_4, (s2_4 + k_0), n_8) == 0) && (0 <= k_0)) &&
             (strlen{L}(s1_4) < n_8)) ==>
            ((0 <= strlen{L}(s2_4)) &&
              (strlen{L}(s2_4) <= (k_0 + strlen{L}(s1_4)))))))))
   
  axiom memcmp_strlen_shift_right{L} :
  (\forall char_P[..] s1_5;
    (\forall char_P[..] s2_5;
      (\forall integer k_1;
        (\forall integer n_9;
          ((((memcmp{L}((s1_5 + k_1), s2_5, n_9) == 0) && (0 <= k_1)) &&
             (strlen{L}(s2_5) < n_9)) ==>
            ((0 <= strlen{L}(s1_5)) &&
              (strlen{L}(s1_5) <= (k_1 + strlen{L}(s2_5)))))))))
  
}

axiomatic StrCmp {

  logic integer strcmp{L}(char_P[..] s1_6, char_P[..] s2_6)
  reads (s1_6 + [0..strlen{L}(s1_6)]).char_M,
  (s2_6 + [0..strlen{L}(s2_6)]).char_M;
   
  axiom strcmp_range{L} :
  (\forall char_P[..] s1_7;
    (\forall char_P[..] s2_7;
      ((((- 2147483647) - 1) <= strcmp{L}(s1_7, s2_7)) &&
        (strcmp{L}(s1_7, s2_7) <= 2147483647))))
   
  axiom strcmp_zero{L} :
  (\forall char_P[..] s1_8;
    (\forall char_P[..] s2_8;
      ((strcmp{L}(s1_8, s2_8) == 0) <==>
        ((strlen{L}(s1_8) == strlen{L}(s2_8)) &&
          (\forall integer i_11;
            (((0 <= i_11) && (i_11 <= strlen{L}(s1_8))) ==>
              ((s1_8 + i_11).char_M == (s2_8 + i_11).char_M)))))))
  
}

axiomatic StrNCmp {

  logic integer strncmp{L}(char_P[..] s1_9, char_P[..] s2_9, integer n_10)
  reads (s1_9 + [0..(n_10 - 1)]).char_M, (s2_9 + [0..(n_10 - 1)]).char_M;
   
  axiom strncmp_zero{L} :
  (\forall char_P[..] s1_10;
    (\forall char_P[..] s2_10;
      (\forall integer n_11;
        ((strncmp{L}(s1_10, s2_10, n_11) == 0) <==>
          (((strlen{L}(s1_10) < n_11) && (strcmp{L}(s1_10, s2_10) == 0)) ||
            (\forall integer i_12;
              (((0 <= i_12) && (i_12 < n_11)) ==>
                ((s1_10 + i_12).char_M == (s2_10 + i_12).char_M))))))))
  
}

axiomatic StrChr {

  logic boolean strchr{L}(char_P[..] s_15, integer c_3)
  reads (s_15 + [0..strlen{L}(s_15)]).char_M;
   
  axiom strchr_def{L} :
  (\forall char_P[..] s_16;
    (\forall integer c_4;
      ((strchr{L}(s_16, c_4) == true) <==>
        (\exists integer i_13;
          (((0 <= i_13) && (i_13 <= strlen{L}(s_16))) &&
            ((s_16 + i_13).char_M == c_4))))))
  
}

axiomatic WcsLen {

  logic integer wcslen{L}(unsigned_short_P[..] s_17)
  reads (s_17 + [0..]).unsigned_short_M;
   
  axiom wcslen_pos_or_null{L} :
  (\forall unsigned_short_P[..] s_18;
    (\forall integer i_14;
      ((((0 <= i_14) &&
          (\forall integer j_0;
            (((0 <= j_0) && (j_0 < i_14)) ==>
              ((s_18 + j_0).unsigned_short_M != 0)))) &&
         ((s_18 + i_14).unsigned_short_M == 0)) ==>
        (wcslen{L}(s_18) == i_14))))
   
  axiom wcslen_neg{L} :
  (\forall unsigned_short_P[..] s_19;
    ((\forall integer i_15;
       ((0 <= i_15) ==> ((s_19 + i_15).unsigned_short_M != 0))) ==>
      (wcslen{L}(s_19) < 0)))
   
  axiom wcslen_before_null{L} :
  (\forall unsigned_short_P[..] s_20;
    (\forall int32 i_16;
      (((0 <= i_16) && (i_16 < wcslen{L}(s_20))) ==>
        ((s_20 + i_16).unsigned_short_M != 0))))
   
  axiom wcslen_at_null{L} :
  (\forall unsigned_short_P[..] s_21;
    ((0 <= wcslen{L}(s_21)) ==>
      ((s_21 + wcslen{L}(s_21)).unsigned_short_M == 0)))
   
  axiom wcslen_not_zero{L} :
  (\forall unsigned_short_P[..] s_22;
    (\forall int32 i_17;
      ((((0 <= i_17) && (i_17 <= wcslen{L}(s_22))) &&
         ((s_22 + i_17).unsigned_short_M != 0)) ==>
        (i_17 < wcslen{L}(s_22)))))
   
  axiom wcslen_zero{L} :
  (\forall unsigned_short_P[..] s_23;
    (\forall int32 i_18;
      ((((0 <= i_18) && (i_18 <= wcslen{L}(s_23))) &&
         ((s_23 + i_18).unsigned_short_M == 0)) ==>
        (i_18 == wcslen{L}(s_23)))))
   
  axiom wcslen_sup{L} :
  (\forall unsigned_short_P[..] s_24;
    (\forall int32 i_19;
      (((0 <= i_19) && ((s_24 + i_19).unsigned_short_M == 0)) ==>
        ((0 <= wcslen{L}(s_24)) && (wcslen{L}(s_24) <= i_19)))))
   
  axiom wcslen_shift{L} :
  (\forall unsigned_short_P[..] s_25;
    (\forall int32 i_20;
      (((0 <= i_20) && (i_20 <= wcslen{L}(s_25))) ==>
        (wcslen{L}((s_25 + i_20)) == (wcslen{L}(s_25) - i_20)))))
   
  axiom wcslen_create{L} :
  (\forall unsigned_short_P[..] s_26;
    (\forall int32 i_21;
      (((0 <= i_21) && ((s_26 + i_21).unsigned_short_M == 0)) ==>
        ((0 <= wcslen{L}(s_26)) && (wcslen{L}(s_26) <= i_21)))))
   
  axiom wcslen_create_shift{L} :
  (\forall unsigned_short_P[..] s_27;
    (\forall int32 i_22;
      (\forall int32 k_2;
        ((((0 <= k_2) && (k_2 <= i_22)) &&
           ((s_27 + i_22).unsigned_short_M == 0)) ==>
          ((0 <= wcslen{L}((s_27 + k_2))) &&
            (wcslen{L}((s_27 + k_2)) <= (i_22 - k_2)))))))
  
}

axiomatic WcsCmp {

  logic integer wcscmp{L}(unsigned_short_P[..] s1_11,
                          unsigned_short_P[..] s2_11)
  reads (s1_11 + [0..wcslen{L}(s1_11)]).unsigned_short_M,
  (s2_11 + [0..wcslen{L}(s2_11)]).unsigned_short_M;
   
  axiom wcscmp_zero{L} :
  (\forall unsigned_short_P[..] s1_12;
    (\forall unsigned_short_P[..] s2_12;
      ((wcscmp{L}(s1_12, s2_12) == 0) <==>
        ((wcslen{L}(s1_12) == wcslen{L}(s2_12)) &&
          (\forall integer i_23;
            (((0 <= i_23) && (i_23 <= wcslen{L}(s1_12))) ==>
              ((s1_12 + i_23).unsigned_short_M ==
                (s2_12 + i_23).unsigned_short_M)))))))
  
}

axiomatic WcsNCmp {

  logic integer wcsncmp{L}(unsigned_short_P[..] s1_13,
                           unsigned_short_P[..] s2_13, integer n_12)
  reads (s1_13 + [0..(n_12 - 1)]).unsigned_short_M,
  (s2_13 + [0..(n_12 - 1)]).unsigned_short_M;
   
  axiom wcsncmp_zero{L} :
  (\forall unsigned_short_P[..] s1_14;
    (\forall unsigned_short_P[..] s2_14;
      (\forall integer n_13;
        ((wcsncmp{L}(s1_14, s2_14, n_13) == 0) <==>
          (((wcslen{L}(s1_14) < n_13) && (wcscmp{L}(s1_14, s2_14) == 0)) ||
            (\forall integer i_24;
              (((0 <= i_24) && (i_24 < n_13)) ==>
                ((s1_14 + i_24).unsigned_short_M ==
                  (s2_14 + i_24).unsigned_short_M))))))))
  
}

logic integer minimum(integer i_25, integer j_1) =
(if (i_25 < j_1) then i_25 else j_1)

logic integer maximum(integer i_26, integer j_2) =
(if (i_26 < j_2) then j_2 else i_26)

predicate valid_string{L}(char_P[..] s_28) =
((0 <= strlen{L}(s_28)) &&
  ((\offset_min(s_28) <= 0) && (\offset_max(s_28) >= strlen{L}(s_28))))

predicate valid_string_or_null{L}(char_P[..] s_29) =
((s_29 == null) || valid_string{L}(s_29))

predicate valid_wstring{L}(unsigned_short_P[..] s_30) =
((0 <= wcslen{L}(s_30)) &&
  ((\offset_min(s_30) <= 0) && (\offset_max(s_30) >= wcslen{L}(s_30))))

predicate valid_wstring_or_null{L}(unsigned_short_P[..] s_31) =
((s_31 == null) || valid_wstring{L}(s_31))

int32 uint_to_int(unsigned_int_P[..] up)
  requires (C_7 : ((C_8 : (\offset_min(up) <= 0)) &&
                    (C_9 : (\offset_max(up) >= 0))));
behavior default:
  ensures (C_5 : true);
behavior identity:
  assumes (up.unsigned_int_M <= 2147483647);
  ensures (C_6 : (\result == \at(up,Old).unsigned_int_M));
{  
   (var int_P[..] ip);
   
   (var int32 __retres);
   
   {  (C_2 : (ip = (C_1 : (up :> int_P[..]))));
      (C_4 : (__retres = (C_3 : ip.int_M)));
      
      (return __retres)
   }
}

unit init_uint_through_int(unsigned_int_P[..] uarr)
  requires (C_21 : ((C_22 : (\offset_min(uarr) <= 0)) &&
                     (C_23 : (\offset_max(uarr) >= 9))));
behavior default:
  ensures (C_20 : true);
{  
   (var int_P[..] cur);
   
   (var int32 i);
   
   {  (C_11 : (cur = (C_10 : (uarr :> int_P[..]))));
      (C_12 : (i = 0));
      
      {  
         loop 
         behavior default:
           invariant (C_13 : (i >= 0));
         while (true)
         {  
            {  (if (i < 10) then () else 
               (goto while_0_break));
               
               {  (C_16 : ((C_15 : (C_14 : (cur + i)).int_M) = 0))
               };
               (C_19 : (i = (C_18 : ((C_17 : (i + 1)) :> int32))))
            }
         };
         (while_0_break : ())
      };
      
      (return ())
   }
}

int32 uchar_ptr(unsigned_char_P[..] p_1)
  requires (C_28 : ((C_29 : (\offset_min(p_1) <= 0)) &&
                     (C_30 : (\offset_max(p_1) >= 0))));
behavior default:
  ensures (C_27 : true);
{  
   (var int32 __retres_0);
   
   {  (C_26 : (__retres_0 = (C_25 : ((C_24 : p_1.unsigned_char_M) :> int32))));
      
      (return __retres_0)
   }
}

int32 schar_ptr(signed_char_P[..] p_0)
  requires (C_35 : ((C_36 : (\offset_min(p_0) <= 0)) &&
                     (C_37 : (\offset_max(p_0) >= 0))));
behavior default:
  ensures (C_34 : true);
{  
   (var int32 __retres_1);
   
   {  (C_33 : (__retres_1 = (C_32 : ((C_31 : p_0.signed_char_M) :> int32))));
      
      (return __retres_1)
   }
}

int32 char_ptr(char_P[..] p)
  requires (C_49 : ((C_50 : (\offset_min(p) <= 0)) &&
                     (C_51 : (\offset_max(p) >= 0))));
behavior default:
  ensures (C_48 : true);
{  
   (var int32 tmp);
   
   (var int32 tmp_0);
   
   (var int32 __retres_2);
   
   {  (if ((C_43 : ((C_42 : p.char_M) :> int32)) > 127) then 
      {  (C_40 : (tmp = (C_39 : uchar_ptr((C_38 : (p :> unsigned_char_P[..]))))));
         (C_41 : (__retres_2 = tmp));
         
         (goto return_label)
      } else ());
      (C_46 : (tmp_0 = (C_45 : schar_ptr((C_44 : (p :> signed_char_P[..]))))));
      (C_47 : (__retres_2 = tmp_0));
      (return_label : 
      (return __retres_2))
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs cast_integer_pointers.jessie/cast_integer_pointers.cloc cast_integer_pointers.jessie/cast_integer_pointers.jc
