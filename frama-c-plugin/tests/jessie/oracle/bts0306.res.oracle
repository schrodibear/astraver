Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only bts0306.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD bts0306.c"
[kernel] warning: ignoring status of axiomatic `MemCmp'
[kernel] warning: ignoring status of axiomatic `MemChr'
[kernel] warning: ignoring status of axiomatic `MemSet'
[kernel] warning: ignoring status of axiomatic `StrLen'
[kernel] warning: ignoring status of axiomatic `StrCmp'
[kernel] warning: ignoring status of axiomatic `StrNCmp'
[kernel] warning: ignoring status of axiomatic `StrChr'
[kernel] warning: ignoring status of axiomatic `WcsLen'
[kernel] warning: ignoring status of axiomatic `WcsCmp'
[kernel] warning: ignoring status of axiomatic `WcsNCmp'
[kernel] warning: ignoring status of global predicate `valid_string'
[kernel] warning: ignoring status of global predicate `valid_string_or_null'
[kernel] warning: ignoring status of global predicate `valid_wstring'
[kernel] warning: ignoring status of global predicate `valid_wstring_or_null'
[jessie] Starting Jessie translation
[kernel] warning: ignoring status of global predicate `valid_wstring_or_null'
[kernel] warning: ignoring status of global predicate `valid_wstring'
[kernel] warning: ignoring status of global predicate `valid_string_or_null'
[kernel] warning: ignoring status of global predicate `valid_string'
[kernel] warning: ignoring status of axiomatic `WcsNCmp'
[kernel] warning: ignoring status of axiomatic `WcsCmp'
[kernel] warning: ignoring status of axiomatic `WcsLen'
[kernel] warning: ignoring status of axiomatic `StrChr'
[kernel] warning: ignoring status of axiomatic `StrNCmp'
[kernel] warning: ignoring status of axiomatic `StrCmp'
[kernel] warning: ignoring status of axiomatic `StrLen'
[kernel] warning: ignoring status of axiomatic `MemSet'
[kernel] warning: ignoring status of axiomatic `MemChr'
[kernel] warning: ignoring status of axiomatic `MemCmp'
[jessie] Producing Jessie files in subdir bts0306.jessie
[jessie] File bts0306.jessie/bts0306.jc written.
[jessie] File bts0306.jessie/bts0306.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol
# TerminationPolicy = user

axiomatic Padding {

  logic type padding
  
}

type uint16 = 0..65535

type uint8 = 0..255

type int8 = -128..127

type int32 = -2147483648..2147483647

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

tag unsigned_shortP = {
  uint16 unsigned_shortM: 16;
}

type unsigned_shortP = [unsigned_shortP]

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

axiomatic MemCmp {

  logic integer memcmp{L}(charP[..] s1, charP[..] s2, integer n)
  reads (s1 + [0..(n - 1)]).charM, (s2 + [0..(n - 1)]).charM;
   
  axiom memcmp_range{L} :
  (\forall charP[..] s1_0;
    (\forall charP[..] s2_0;
      (\forall integer n_0;
        ((((- 2147483647) - 1) <= memcmp{L}(s1_0, s2_0, n_0)) &&
          (memcmp{L}(s1_0, s2_0, n_0) <= 2147483647)))))
   
  axiom memcmp_zero{L} :
  (\forall charP[..] s1_1;
    (\forall charP[..] s2_1;
      (\forall integer n_1;
        ((memcmp{L}(s1_1, s2_1, n_1) == 0) <==>
          (\forall integer i;
            (((0 <= i) && (i < n_1)) ==>
              ((s1_1 + i).charM == (s2_1 + i).charM)))))))
  
}

axiomatic MemChr {

  logic boolean memchr{L}(charP[..] s, integer c, integer n_2)
  reads (s + [0..(n_2 - 1)]).charM;
   
  axiom memchr_def{L} :
  (\forall charP[..] s_0;
    (\forall integer c_0;
      (\forall integer n_3;
        ((memchr{L}(s_0, c_0, n_3) == true) <==>
          (\exists int32 i_0;
            (((0 <= i_0) && (i_0 < n_3)) && ((s_0 + i_0).charM == c_0)))))))
  
}

axiomatic MemSet {

  logic boolean memset{L}(charP[..] s_1, integer c_1, integer n_4)
  reads (s_1 + [0..(n_4 - 1)]).charM;
   
  axiom memset_def{L} :
  (\forall charP[..] s_2;
    (\forall integer c_2;
      (\forall integer n_5;
        ((memset{L}(s_2, c_2, n_5) == true) <==>
          (\forall integer i_1;
            (((0 <= i_1) && (i_1 < n_5)) ==> ((s_2 + i_1).charM == c_2)))))))
  
}

axiomatic StrLen {

  logic integer strlen{L}(charP[..] s_3) reads (s_3 + [0..]).charM;
   
  axiom strlen_pos_or_null{L} :
  (\forall charP[..] s_4;
    (\forall integer i_2;
      (((((0 <= i_2) && (i_2 <= 2147483647)) &&
          (\forall integer j;
            (((0 <= j) && (j < i_2)) ==> ((s_4 + j).charM != 0)))) &&
         ((s_4 + i_2).charM == 0)) ==>
        (strlen{L}(s_4) == i_2))))
   
  axiom strlen_neg{L} :
  (\forall charP[..] s_5;
    ((\forall integer i_3;
       (((0 <= i_3) && (i_3 <= 2147483647)) ==> ((s_5 + i_3).charM != 0))) ==>
      (strlen{L}(s_5) < 0)))
   
  axiom strlen_range{L} :
  (\forall charP[..] s_6;
    (strlen{L}(s_6) <= 2147483647))
   
  axiom strlen_before_null{L} :
  (\forall charP[..] s_7;
    (\forall integer i_4;
      (((0 <= i_4) && (i_4 < strlen{L}(s_7))) ==> ((s_7 + i_4).charM != 0))))
   
  axiom strlen_at_null{L} :
  (\forall charP[..] s_8;
    ((0 <= strlen{L}(s_8)) ==> ((s_8 + strlen{L}(s_8)).charM == 0)))
   
  axiom strlen_not_zero{L} :
  (\forall charP[..] s_9;
    (\forall integer i_5;
      ((((0 <= i_5) && (i_5 <= strlen{L}(s_9))) && ((s_9 + i_5).charM != 0)) ==>
        (i_5 < strlen{L}(s_9)))))
   
  axiom strlen_zero{L} :
  (\forall charP[..] s_10;
    (\forall integer i_6;
      ((((0 <= i_6) && (i_6 <= strlen{L}(s_10))) &&
         ((s_10 + i_6).charM == 0)) ==>
        (i_6 == strlen{L}(s_10)))))
   
  axiom strlen_sup{L} :
  (\forall charP[..] s_11;
    (\forall integer i_7;
      (((0 <= i_7) && ((s_11 + i_7).charM == 0)) ==>
        ((0 <= strlen{L}(s_11)) && (strlen{L}(s_11) <= i_7)))))
   
  axiom strlen_shift{L} :
  (\forall charP[..] s_12;
    (\forall integer i_8;
      (((0 <= i_8) && (i_8 <= strlen{L}(s_12))) ==>
        (strlen{L}((s_12 + i_8)) == (strlen{L}(s_12) - i_8)))))
   
  axiom strlen_create{L} :
  (\forall charP[..] s_13;
    (\forall integer i_9;
      ((((0 <= i_9) && (i_9 <= 2147483647)) && ((s_13 + i_9).charM == 0)) ==>
        ((0 <= strlen{L}(s_13)) && (strlen{L}(s_13) <= i_9)))))
   
  axiom strlen_create_shift{L} :
  (\forall charP[..] s_14;
    (\forall integer i_10;
      (\forall integer k;
        ((((0 <= k) && ((k <= i_10) && (i_10 <= 2147483647))) &&
           ((s_14 + i_10).charM == 0)) ==>
          ((0 <= strlen{L}((s_14 + k))) &&
            (strlen{L}((s_14 + k)) <= (i_10 - k)))))))
   
  axiom memcmp_strlen_left{L} :
  (\forall charP[..] s1_2;
    (\forall charP[..] s2_2;
      (\forall integer n_6;
        (((memcmp{L}(s1_2, s2_2, n_6) == 0) && (strlen{L}(s1_2) < n_6)) ==>
          (strlen{L}(s1_2) == strlen{L}(s2_2))))))
   
  axiom memcmp_strlen_right{L} :
  (\forall charP[..] s1_3;
    (\forall charP[..] s2_3;
      (\forall integer n_7;
        (((memcmp{L}(s1_3, s2_3, n_7) == 0) && (strlen{L}(s2_3) < n_7)) ==>
          (strlen{L}(s1_3) == strlen{L}(s2_3))))))
   
  axiom memcmp_strlen_shift_left{L} :
  (\forall charP[..] s1_4;
    (\forall charP[..] s2_4;
      (\forall integer k_0;
        (\forall integer n_8;
          ((((memcmp{L}(s1_4, (s2_4 + k_0), n_8) == 0) && (0 <= k_0)) &&
             (strlen{L}(s1_4) < n_8)) ==>
            ((0 <= strlen{L}(s2_4)) &&
              (strlen{L}(s2_4) <= (k_0 + strlen{L}(s1_4)))))))))
   
  axiom memcmp_strlen_shift_right{L} :
  (\forall charP[..] s1_5;
    (\forall charP[..] s2_5;
      (\forall integer k_1;
        (\forall integer n_9;
          ((((memcmp{L}((s1_5 + k_1), s2_5, n_9) == 0) && (0 <= k_1)) &&
             (strlen{L}(s2_5) < n_9)) ==>
            ((0 <= strlen{L}(s1_5)) &&
              (strlen{L}(s1_5) <= (k_1 + strlen{L}(s2_5)))))))))
  
}

axiomatic StrCmp {

  logic integer strcmp{L}(charP[..] s1_6, charP[..] s2_6)
  reads (s1_6 + [0..strlen{L}(s1_6)]).charM,
  (s2_6 + [0..strlen{L}(s2_6)]).charM;
   
  axiom strcmp_range{L} :
  (\forall charP[..] s1_7;
    (\forall charP[..] s2_7;
      ((((- 2147483647) - 1) <= strcmp{L}(s1_7, s2_7)) &&
        (strcmp{L}(s1_7, s2_7) <= 2147483647))))
   
  axiom strcmp_zero{L} :
  (\forall charP[..] s1_8;
    (\forall charP[..] s2_8;
      ((strcmp{L}(s1_8, s2_8) == 0) <==>
        ((strlen{L}(s1_8) == strlen{L}(s2_8)) &&
          (\forall integer i_11;
            (((0 <= i_11) && (i_11 <= strlen{L}(s1_8))) ==>
              ((s1_8 + i_11).charM == (s2_8 + i_11).charM)))))))
  
}

axiomatic StrNCmp {

  logic integer strncmp{L}(charP[..] s1_9, charP[..] s2_9, integer n_10)
  reads (s1_9 + [0..(n_10 - 1)]).charM, (s2_9 + [0..(n_10 - 1)]).charM;
   
  axiom strncmp_zero{L} :
  (\forall charP[..] s1_10;
    (\forall charP[..] s2_10;
      (\forall integer n_11;
        ((strncmp{L}(s1_10, s2_10, n_11) == 0) <==>
          (((strlen{L}(s1_10) < n_11) && (strcmp{L}(s1_10, s2_10) == 0)) ||
            (\forall integer i_12;
              (((0 <= i_12) && (i_12 < n_11)) ==>
                ((s1_10 + i_12).charM == (s2_10 + i_12).charM))))))))
  
}

axiomatic StrChr {

  logic boolean strchr{L}(charP[..] s_15, integer c_3)
  reads (s_15 + [0..strlen{L}(s_15)]).charM;
   
  axiom strchr_def{L} :
  (\forall charP[..] s_16;
    (\forall integer c_4;
      ((strchr{L}(s_16, c_4) == true) <==>
        (\exists integer i_13;
          (((0 <= i_13) && (i_13 <= strlen{L}(s_16))) &&
            ((s_16 + i_13).charM == c_4))))))
  
}

axiomatic WcsLen {

  logic integer wcslen{L}(unsigned_shortP[..] s_17)
  reads (s_17 + [0..]).unsigned_shortM;
   
  axiom wcslen_pos_or_null{L} :
  (\forall unsigned_shortP[..] s_18;
    (\forall integer i_14;
      ((((0 <= i_14) &&
          (\forall integer j_0;
            (((0 <= j_0) && (j_0 < i_14)) ==>
              ((s_18 + j_0).unsigned_shortM != 0)))) &&
         ((s_18 + i_14).unsigned_shortM == 0)) ==>
        (wcslen{L}(s_18) == i_14))))
   
  axiom wcslen_neg{L} :
  (\forall unsigned_shortP[..] s_19;
    ((\forall integer i_15;
       ((0 <= i_15) ==> ((s_19 + i_15).unsigned_shortM != 0))) ==>
      (wcslen{L}(s_19) < 0)))
   
  axiom wcslen_before_null{L} :
  (\forall unsigned_shortP[..] s_20;
    (\forall int32 i_16;
      (((0 <= i_16) && (i_16 < wcslen{L}(s_20))) ==>
        ((s_20 + i_16).unsigned_shortM != 0))))
   
  axiom wcslen_at_null{L} :
  (\forall unsigned_shortP[..] s_21;
    ((0 <= wcslen{L}(s_21)) ==>
      ((s_21 + wcslen{L}(s_21)).unsigned_shortM == 0)))
   
  axiom wcslen_not_zero{L} :
  (\forall unsigned_shortP[..] s_22;
    (\forall int32 i_17;
      ((((0 <= i_17) && (i_17 <= wcslen{L}(s_22))) &&
         ((s_22 + i_17).unsigned_shortM != 0)) ==>
        (i_17 < wcslen{L}(s_22)))))
   
  axiom wcslen_zero{L} :
  (\forall unsigned_shortP[..] s_23;
    (\forall int32 i_18;
      ((((0 <= i_18) && (i_18 <= wcslen{L}(s_23))) &&
         ((s_23 + i_18).unsigned_shortM == 0)) ==>
        (i_18 == wcslen{L}(s_23)))))
   
  axiom wcslen_sup{L} :
  (\forall unsigned_shortP[..] s_24;
    (\forall int32 i_19;
      (((0 <= i_19) && ((s_24 + i_19).unsigned_shortM == 0)) ==>
        ((0 <= wcslen{L}(s_24)) && (wcslen{L}(s_24) <= i_19)))))
   
  axiom wcslen_shift{L} :
  (\forall unsigned_shortP[..] s_25;
    (\forall int32 i_20;
      (((0 <= i_20) && (i_20 <= wcslen{L}(s_25))) ==>
        (wcslen{L}((s_25 + i_20)) == (wcslen{L}(s_25) - i_20)))))
   
  axiom wcslen_create{L} :
  (\forall unsigned_shortP[..] s_26;
    (\forall int32 i_21;
      (((0 <= i_21) && ((s_26 + i_21).unsigned_shortM == 0)) ==>
        ((0 <= wcslen{L}(s_26)) && (wcslen{L}(s_26) <= i_21)))))
   
  axiom wcslen_create_shift{L} :
  (\forall unsigned_shortP[..] s_27;
    (\forall int32 i_22;
      (\forall int32 k_2;
        ((((0 <= k_2) && (k_2 <= i_22)) &&
           ((s_27 + i_22).unsigned_shortM == 0)) ==>
          ((0 <= wcslen{L}((s_27 + k_2))) &&
            (wcslen{L}((s_27 + k_2)) <= (i_22 - k_2)))))))
  
}

axiomatic WcsCmp {

  logic integer wcscmp{L}(unsigned_shortP[..] s1_11, unsigned_shortP[..] s2_11)
  reads (s1_11 + [0..wcslen{L}(s1_11)]).unsigned_shortM,
  (s2_11 + [0..wcslen{L}(s2_11)]).unsigned_shortM;
   
  axiom wcscmp_zero{L} :
  (\forall unsigned_shortP[..] s1_12;
    (\forall unsigned_shortP[..] s2_12;
      ((wcscmp{L}(s1_12, s2_12) == 0) <==>
        ((wcslen{L}(s1_12) == wcslen{L}(s2_12)) &&
          (\forall integer i_23;
            (((0 <= i_23) && (i_23 <= wcslen{L}(s1_12))) ==>
              ((s1_12 + i_23).unsigned_shortM ==
                (s2_12 + i_23).unsigned_shortM)))))))
  
}

axiomatic WcsNCmp {

  logic integer wcsncmp{L}(unsigned_shortP[..] s1_13,
                           unsigned_shortP[..] s2_13, integer n_12)
  reads (s1_13 + [0..(n_12 - 1)]).unsigned_shortM,
  (s2_13 + [0..(n_12 - 1)]).unsigned_shortM;
   
  axiom wcsncmp_zero{L} :
  (\forall unsigned_shortP[..] s1_14;
    (\forall unsigned_shortP[..] s2_14;
      (\forall integer n_13;
        ((wcsncmp{L}(s1_14, s2_14, n_13) == 0) <==>
          (((wcslen{L}(s1_14) < n_13) && (wcscmp{L}(s1_14, s2_14) == 0)) ||
            (\forall integer i_24;
              (((0 <= i_24) && (i_24 < n_13)) ==>
                ((s1_14 + i_24).unsigned_shortM ==
                  (s2_14 + i_24).unsigned_shortM))))))))
  
}

logic integer minimum(integer i_25, integer j_1) =
(if (i_25 < j_1) then i_25 else j_1)

logic integer maximum(integer i_26, integer j_2) =
(if (i_26 < j_2) then j_2 else i_26)

predicate valid_string{L}(charP[..] s_28) =
((0 <= strlen{L}(s_28)) &&
  ((\offset_min(s_28) <= 0) && (\offset_max(s_28) >= strlen{L}(s_28))))

predicate valid_string_or_null{L}(charP[..] s_29) =
((s_29 == null) || valid_string{L}(s_29))

predicate valid_wstring{L}(unsigned_shortP[..] s_30) =
((0 <= wcslen{L}(s_30)) &&
  ((\offset_min(s_30) <= 0) && (\offset_max(s_30) >= wcslen{L}(s_30))))

predicate valid_wstring_or_null{L}(unsigned_shortP[..] s_31) =
((s_31 == null) || valid_wstring{L}(s_31))

int32 strcmp(charP[..] s1, charP[..] s2)
behavior default:
  ensures (C_25 : true);
{  
   (var charP[..] tmp);
   
   (var charP[..] tmp_0);
   
   (var int32 __retres);
   
   {  
      loop 
      while (true)
      {  
         {  
            {  (C_1 : (tmp_0 = s2));
               (C_3 : (s2 = (C_2 : (s2 + 1))));
               ()
            };
            (if ((C_7 : ((C_6 : s1.charM) :> int32)) ==
                  (C_5 : ((C_4 : tmp_0.charM) :> int32))) then () else 
            (goto while_0_break));
            
            {  (C_8 : (tmp = s1));
               (C_10 : (s1 = (C_9 : (s1 + 1))));
               ()
            };
            (if ((C_13 : ((C_12 : tmp.charM) :> int32)) == 0) then 
            {  (C_11 : (__retres = 0));
               
               (goto return_label)
            } else ())
         }
      };
      (while_0_break : ());
      (C_15 : (s2 = (C_14 : (s2 - 1))));
      (C_24 : (__retres = (C_23 : ((C_22 : ((C_21 : ((C_20 : (C_19 : (s1 :> unsigned_charP[..])).unsigned_charM) :> int32)) -
                                             (C_18 : ((C_17 : (C_16 : (s2 :> unsigned_charP[..])).unsigned_charM) :> int32)))) :> int32))));
      (return_label : 
      (return __retres))
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs bts0306.jessie/bts0306.cloc bts0306.jessie/bts0306.jc
