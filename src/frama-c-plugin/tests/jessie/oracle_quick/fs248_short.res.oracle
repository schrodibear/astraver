rm -f fs248_short.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only fs248_short.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat fs248_short.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag int_P = {
  int32 int_M;
}

type int_P = [int_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

invariant valid_g :
((\offset_min(g) <= 0) && (\offset_max(g) >= 0))

invariant valid_e :
((\offset_min(e) <= 0) && (\offset_max(e) >= 0))

invariant valid_q2 :
((\offset_min(q2) <= 0) && (\offset_max(q2) >= 4))

invariant valid_p2 :
((\offset_min(p2) <= 0) && (\offset_max(p2) >= 4))

invariant valid_q :
((\offset_min(q) <= 0) && (\offset_max(q) >= 4))

invariant valid_p :
((\offset_min(p) <= 0) && (\offset_max(p) >= 4))

tag S = {
  int32 a; 
  int32 b; 
  int32 c;
}

type S = [S]

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

unit f(char_P[..] x_0, int_P[..] y_0)
{  
   (var char_P[..] tmp);
   
   (var int32 __jc_off_x_0);
   
   (var int32 __jc_off_tmp);
   
   {  (C_1 : (__jc_off_x_0 = 0));
      (C_9 : ((C_8 : (C_7 : (x_0 + __jc_off_x_0)).char_M) = (C_6 : ((C_5 : 
                                                                    ((C_4 : (
                                                                    (C_3 : 
                                                                    (C_2 : 
                                                                    (x_0 +
                                                                    __jc_off_x_0)).char_M) :> int32)) +
                                                                    1)) :> int8))));
      (C_10 : (__jc_off_tmp = __jc_off_x_0));
      (C_13 : (__jc_off_x_0 = (C_12 : ((C_11 : (__jc_off_x_0 + 1)) :> int32))));
      (C_21 : ((C_20 : (C_19 : (x_0 + __jc_off_x_0)).char_M) = (C_18 : (
                                                               (C_17 : 
                                                               ((C_16 : (
                                                                (C_15 : 
                                                                (C_14 : 
                                                                (x_0 +
                                                                  __jc_off_x_0)).char_M) :> int32)) +
                                                                 1)) :> int8))));
      (C_26 : ((C_25 : y_0.int_M) = (C_24 : ((C_23 : ((C_22 : y_0.int_M) + 1)) :> int32))));
      
      (return ())
   }
}

unit f2(char_P[..] x_0)
{  
   (var char_P[..] q_0);
   
   (var int32 __jc_off_q_0);
   
   {  (C_32 : ((C_31 : x_0.char_M) = (C_30 : ((C_29 : ((C_28 : ((C_27 : x_0.char_M) :> int32)) +
                                                        1)) :> int8))));
      (C_33 : (__jc_off_q_0 = 1));
      (C_41 : ((C_40 : (C_39 : (x_0 + __jc_off_q_0)).char_M) = (C_38 : (
                                                               (C_37 : 
                                                               ((C_36 : (
                                                                (C_35 : 
                                                                (C_34 : 
                                                                (x_0 +
                                                                  __jc_off_q_0)).char_M) :> int32)) +
                                                                 1)) :> int8))));
      
      (return ())
   }
}

int32 A;

int32 B;

int32 C;

int32 D;

int32 E;

int32 F;

int32 G;

int_P[0..4] p;

int_P[0..4] q;

int_P[0..4] p2;

int_P[0..4] q2;

int32 t;

int32 u;

int32 v;

int32 w;

int32 x;

int32 y;

int32 z;

int32 t2;

int32 v2;

int_P[..] PTR1;

int_P[..] PTR2;

int_P[..] PTR3;

int_P[..] PTR4;

int32 c;

int32 c1;

int32 c2;

int32 c3;

int32 c4;

S[0] e;

S[0] g;

unit main3()
{  
   (var S[..] p_0);
   
   (var S[0] s1);
   
   (var S[0] s2);
   
   (var int32 tmp_0);
   
   (var int32 tmp_3);
   
   {  (C_43 : (s1 = (C_42 : (new S[1]))));
      (C_45 : (s2 = (C_44 : (new S[1]))));
      (C_47 : ((C_46 : s1.a) = 2));
      (C_49 : ((C_48 : s1.b) = 4));
      (C_51 : ((C_50 : s1.c) = 6));
      (C_53 : ((C_52 : s2.a) = 1));
      (C_55 : ((C_54 : s2.b) = 3));
      (C_57 : ((C_56 : s2.c) = 5));
      (if (c != 0) then (C_59 : (p_0 = s1)) else (C_58 : (p_0 = s2)));
      (C_61 : ((C_60 : p_0.a) = 7));
      (C_63 : (t = (C_62 : p_0.b)));
      (C_64 : (z = 2));
      (if ((C_69 : ((C_68 : (c + (C_67 : (1 :> int32)))) :> int32)) != 0) then 
      (C_66 : (u = 0)) else (C_65 : (u = 1)));
      (C_70 : (v = u));
      (if (w == v) then (C_71 : (z = u)) else ());
      (if ((C_80 : ((C_79 : (c + (C_78 : (1 :> int32)))) :> int32)) != 0) then 
      (C_77 : (tmp_0 = 0)) else (if ((C_76 : ((C_75 : (c +
                                                        (C_74 : (2 :> int32)))) :> int32)) !=
                                      0) then (C_73 : (tmp_0 = 1)) else 
                                (C_72 : (tmp_0 = 2))));
      (C_82 : (PTR1 = (C_81 : (p2 + tmp_0))));
      (C_84 : (PTR2 = (C_83 : (PTR1 + 1))));
      (if ((C_96 : ((C_95 : (c + (C_94 : (10 :> int32)))) :> int32)) != 0) then 
      (C_93 : ((C_92 : PTR1.int_M) = 96)) else (if ((C_91 : ((C_90 : 
                                                             (c +
                                                               (C_89 : (11 :> int32)))) :> int32)) !=
                                                     0) then (C_88 : (
                                                             (C_87 : PTR1.int_M) = 97)) else 
                                               (C_86 : ((C_85 : PTR1.int_M) = 98))));
      (if ((C_105 : ((C_104 : (c + (C_103 : (3 :> int32)))) :> int32)) != 0) then 
      (C_102 : (tmp_3 = 1)) else (if ((C_101 : ((C_100 : (c +
                                                           (C_99 : (4 :> int32)))) :> int32)) !=
                                       0) then (C_98 : (tmp_3 = 2)) else 
                                 (C_97 : (tmp_3 = 4))));
      (C_107 : (PTR3 = (C_106 : (p2 + tmp_3))));
      (C_109 : ((C_108 : PTR3.int_M) = 99));
      (C_110 : (PTR4 = PTR3));
      (C_112 : (x = (C_111 : PTR1.int_M)));
      (if ((C_119 : ((C_118 : (PTR4 - PTR2)) :> int32)) == 0) then 
      {  (C_114 : (t2 = (C_113 : PTR1.int_M)));
         (C_117 : (v2 = (C_116 : ((C_115 : (PTR3 - PTR1)) :> int32))))
      } else ());
      
      {  (C_120 : (free(s1)));
         (C_121 : (free(s2)));
         
         (return ())
      }
   }
}

int32 tz1;

int32 tz2;

int32 tz3;

int32 tx;

int32 ty;

int32 tz;
