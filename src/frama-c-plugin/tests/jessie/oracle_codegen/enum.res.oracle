rm -f enum.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only enum.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
WHYLIB=../../why/lib JESSIELIB=../../why/lib ../../why/bin/jessie.opt  -why-opt -split-user-conj -why-opt -fast-wp -locs enum.cloc enum.jc
Normalized expression:
s.char_M

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      (((0 <= i) && (i > strlen{L}(s))) ==> ((s + i).char_M != 0))))

Normalized expression:
(\forall char_P[..] s, ((s + strlen{L}(s)).char_M == 0))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
         (i > strlen{L}(s)))))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
         (i == strlen{L}(s)))))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      (((0 <= i) && ((s + i).char_M == 0)) ==>
         ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      (((0 <= i) && (i <= strlen{L}(s))) ==>
         (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      (((0 <= i) && ((s + i).char_M == 0)) ==>
         ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

Normalized expression:
(\forall char_P[..] s,
   (\forall int32 i,
      (\forall int32 k,
         (((k <= i) && ((s + i).char_M == 0)) ==>
            ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

Normalized expression:
{ { (return) }
}

Normalized expression:
(C_1: (4 == 4))

Normalized expression:
true

Normalized expression:
{
(let int32 __retres in
   {
   { (C_3: { (__retres = (C_2: (TODO cast))); (return __retres) }) }
   })
}

Normalized expression:
(C_4: ((C_5: (1 <= \result)) && (C_6: (\result <= 4))))

Normalized expression:
true

Normalized expression:
{
{
  (C_11:
     {
     ((C_10: (C_9: (t + 2)).enum___anonenum_color_1_M) =
        (C_8: (C_7: (t + 0)).enum___anonenum_color_1_M));
       (return)
     })
  }
}

Normalized expression:
(C_12: ((C_13: ((\offset_min(t)) <= 0)) && (C_14: ((\offset_max(t)) >= 9))))

Normalized expression:
(C_15: ((((TODO cast) == 0) || ((TODO cast) == 1)) || ((TODO cast) == 2)))

Normalized expression:
true

Normalized expression:
{ { (C_18: { ((C_17: (C_16: (t + 1)).int_M) = 0); (return) }) }
}

Normalized expression:
(C_19: ((C_20: ((\offset_min(t)) <= 0)) && (C_21: ((\offset_max(t)) >= 2))))

Normalized expression:
(C_22: ((t + 1).int_M == 0))

Normalized expression:
true

Generating Why function f
Generating Why function g
Generating Why function h
Generating Why function enum_as_array_index
cat why/enum.why
type E

type I

type __anonenum_color_1

type _bool

type char_P

type enum___anonenum_color_1_P

type int16

type int32

type int64

type int8

type int_P

type uint16

type uint32

type uint64

type uint8

logic integer_of_E: E -> int

logic E_of_integer: int -> E

axiom E_coerce :
 (forall x:int.
  ((le_int((1), x) and le_int(x, (4))) ->
   eq_int(integer_of_E(E_of_integer(x)), x)))

axiom E_range :
 (forall x:E.
  (le_int((1), integer_of_E(x)) and le_int(integer_of_E(x), (4))))

logic integer_of_I: I -> int

logic I_of_integer: int -> I

axiom I_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (2))) ->
   eq_int(integer_of_I(I_of_integer(x)), x)))

axiom I_range :
 (forall x:I.
  (le_int((0), integer_of_I(x)) and le_int(integer_of_I(x), (2))))

exception Loop_continue_exc of unit

exception Loop_exit_exc of unit

logic integer_of___anonenum_color_1: __anonenum_color_1 -> int

logic __anonenum_color_1_of_integer: int -> __anonenum_color_1

axiom __anonenum_color_1_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (2))) ->
   eq_int(integer_of___anonenum_color_1(__anonenum_color_1_of_integer(x)), x)))

axiom __anonenum_color_1_range :
 (forall x:__anonenum_color_1.
  (le_int((0), integer_of___anonenum_color_1(x))
  and le_int(integer_of___anonenum_color_1(x), (2))))

logic integer_of__bool: _bool -> int

logic _bool_of_integer: int -> _bool

axiom _bool_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (1))) ->
   eq_int(integer_of__bool(_bool_of_integer(x)), x)))

axiom _bool_range :
 (forall x:_bool.
  (le_int((0), integer_of__bool(x)) and le_int(integer_of__bool(x), (1))))

logic char_P_tag:  -> char_P tag_id

axiom char_P_int : (int_of_tag(char_P_tag) = (1))

axiom char_P_parenttag_bottom : parenttag(char_P_tag, bottom_tag)

axiom char_P_tags :
 (forall x:char_P pointer.
  (forall char_P_tag_table:char_P tag_table.
   instanceof(char_P_tag_table, x, char_P_tag)))

logic enum___anonenum_color_1_P_tag:  -> enum___anonenum_color_1_P tag_id

axiom enum___anonenum_color_1_P_int :
 (int_of_tag(enum___anonenum_color_1_P_tag) = (1))

axiom enum___anonenum_color_1_P_parenttag_bottom :
 parenttag(enum___anonenum_color_1_P_tag, bottom_tag)

axiom enum___anonenum_color_1_P_tags :
 (forall x:enum___anonenum_color_1_P pointer.
  (forall enum___anonenum_color_1_P_tag_table:enum___anonenum_color_1_P tag_table.
   instanceof(enum___anonenum_color_1_P_tag_table, x,
   enum___anonenum_color_1_P_tag)))

predicate eq_E(x:E, y:E) = eq_int(integer_of_E(x), integer_of_E(y))

predicate eq_I(x:I, y:I) = eq_int(integer_of_I(x), integer_of_I(y))

predicate eq___anonenum_color_1(x:__anonenum_color_1,
 y:__anonenum_color_1) =
 eq_int(integer_of___anonenum_color_1(x), integer_of___anonenum_color_1(y))

predicate eq__bool(x:_bool,
 y:_bool) =
 eq_int(integer_of__bool(x), integer_of__bool(y))

logic integer_of_int16: int16 -> int

predicate eq_int16(x:int16,
 y:int16) =
 eq_int(integer_of_int16(x), integer_of_int16(y))

logic integer_of_int32: int32 -> int

predicate eq_int32(x:int32,
 y:int32) =
 eq_int(integer_of_int32(x), integer_of_int32(y))

logic integer_of_int64: int64 -> int

predicate eq_int64(x:int64,
 y:int64) =
 eq_int(integer_of_int64(x), integer_of_int64(y))

logic integer_of_int8: int8 -> int

predicate eq_int8(x:int8,
 y:int8) =
 eq_int(integer_of_int8(x), integer_of_int8(y))

logic integer_of_uint16: uint16 -> int

predicate eq_uint16(x:uint16,
 y:uint16) =
 eq_int(integer_of_uint16(x), integer_of_uint16(y))

logic integer_of_uint32: uint32 -> int

predicate eq_uint32(x:uint32,
 y:uint32) =
 eq_int(integer_of_uint32(x), integer_of_uint32(y))

logic integer_of_uint64: uint64 -> int

predicate eq_uint64(x:uint64,
 y:uint64) =
 eq_int(integer_of_uint64(x), integer_of_uint64(y))

logic integer_of_uint8: uint8 -> int

predicate eq_uint8(x:uint8,
 y:uint8) =
 eq_int(integer_of_uint8(x), integer_of_uint8(y))

logic strlen: (char_P, int8) memory, char_P pointer -> int32

axiom full_separated_strlen_char_M :
 (forall tmp:char_P pointer.
  (forall tmpval:int8.
   (forall s:char_P pointer.
    (forall char_P_char_M_at_L:(char_P,
     int8) memory.
     (full_separated(tmp, s) ->
      (strlen(char_P_char_M_at_L, s) = strlen(char_P_char_M_at_L, s)))))))

logic int16_of_integer: int -> int16

axiom int16_coerce :
 (forall x:int.
  ((le_int((-32768), x) and le_int(x, (32767))) ->
   eq_int(integer_of_int16(int16_of_integer(x)), x)))

axiom int16_range :
 (forall x:int16.
  (le_int((-32768), integer_of_int16(x))
  and le_int(integer_of_int16(x), (32767))))

logic int32_of_integer: int -> int32

axiom int32_coerce :
 (forall x:int.
  ((le_int((-2147483648), x) and le_int(x, (2147483647))) ->
   eq_int(integer_of_int32(int32_of_integer(x)), x)))

axiom int32_range :
 (forall x:int32.
  (le_int((-2147483648), integer_of_int32(x))
  and le_int(integer_of_int32(x), (2147483647))))

logic int64_of_integer: int -> int64

axiom int64_coerce :
 (forall x:int.
  ((le_int((-9223372036854775808), x) and le_int(x, (9223372036854775807))) ->
   eq_int(integer_of_int64(int64_of_integer(x)), x)))

axiom int64_range :
 (forall x:int64.
  (le_int((-9223372036854775808), integer_of_int64(x))
  and le_int(integer_of_int64(x), (9223372036854775807))))

logic int8_of_integer: int -> int8

axiom int8_coerce :
 (forall x:int.
  ((le_int((-128), x) and le_int(x, (127))) ->
   eq_int(integer_of_int8(int8_of_integer(x)), x)))

axiom int8_range :
 (forall x:int8.
  (le_int((-128), integer_of_int8(x)) and le_int(integer_of_int8(x), (127))))

logic int_P_tag:  -> int_P tag_id

axiom int_P_int : (int_of_tag(int_P_tag) = (1))

axiom int_P_parenttag_bottom : parenttag(int_P_tag, bottom_tag)

axiom int_P_tags :
 (forall x:int_P pointer.
  (forall int_P_tag_table:int_P tag_table.
   instanceof(int_P_tag_table, x, int_P_tag)))

axiom strlen_create :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_6:char_P pointer.
   (forall i_4:int32.
    ((le_int((0), integer_of_int32(i_4))
     and eq_int(integer_of_int8(select(char_P_char_M_at_L,
                                shift(s_6, integer_of_int32(i_4)))),
         (0))) ->
     (le_int((0), integer_of_int32(strlen(char_P_char_M_at_L, s_6)))
     and le_int(integer_of_int32(strlen(char_P_char_M_at_L, s_6)),
         integer_of_int32(i_4)))))))

axiom strlen_create2 :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_7:char_P pointer.
   (forall i_5:int32.
    (forall k:int32.
     ((le_int(integer_of_int32(k), integer_of_int32(i_5))
      and eq_int(integer_of_int8(select(char_P_char_M_at_L,
                                 shift(s_7, integer_of_int32(i_5)))),
          (0))) ->
      (le_int((0),
       integer_of_int32(strlen(char_P_char_M_at_L,
                        shift(s_7, integer_of_int32(k)))))
      and le_int(integer_of_int32(strlen(char_P_char_M_at_L,
                                  shift(s_7, integer_of_int32(k)))),
          sub_int(integer_of_int32(i_5), integer_of_int32(k)))))))))

axiom strlen_def1 :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_0:char_P pointer.
   (forall i:int32.
    ((le_int((0), integer_of_int32(i))
     and lt_int(integer_of_int32(i),
         integer_of_int32(strlen(char_P_char_M_at_L, s_0)))) ->
     neq_int(integer_of_int8(select(char_P_char_M_at_L,
                             shift(s_0, integer_of_int32(i)))),
     (0))))))

axiom strlen_def2 :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_1:char_P pointer.
   eq_int(integer_of_int8(select(char_P_char_M_at_L,
                          shift(s_1,
                          integer_of_int32(strlen(char_P_char_M_at_L, s_1))))),
   (0))))

axiom strlen_not_zero :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_2:char_P pointer.
   (forall i_0:int32.
    ((le_int((0), integer_of_int32(i_0))
     and (le_int(integer_of_int32(i_0),
          integer_of_int32(strlen(char_P_char_M_at_L, s_2)))
         and neq_int(integer_of_int8(select(char_P_char_M_at_L,
                                     shift(s_2, integer_of_int32(i_0)))),
             (0)))) ->
     lt_int(integer_of_int32(i_0),
     integer_of_int32(strlen(char_P_char_M_at_L, s_2)))))))

axiom strlen_shift :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_5:char_P pointer.
   (forall i_3:int32.
    ((le_int((0), integer_of_int32(i_3))
     and le_int(integer_of_int32(i_3),
         integer_of_int32(strlen(char_P_char_M_at_L, s_5)))) ->
     eq_int(integer_of_int32(strlen(char_P_char_M_at_L,
                             shift(s_5, integer_of_int32(i_3)))),
     sub_int(integer_of_int32(strlen(char_P_char_M_at_L, s_5)),
     integer_of_int32(i_3)))))))

axiom strlen_sup :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_4:char_P pointer.
   (forall i_2:int32.
    ((le_int((0), integer_of_int32(i_2))
     and eq_int(integer_of_int8(select(char_P_char_M_at_L,
                                shift(s_4, integer_of_int32(i_2)))),
         (0))) ->
     (le_int((0), integer_of_int32(strlen(char_P_char_M_at_L, s_4)))
     and le_int(integer_of_int32(strlen(char_P_char_M_at_L, s_4)),
         integer_of_int32(i_2)))))))

axiom strlen_zero :
 (forall char_P_char_M_at_L:(char_P,
  int8) memory.
  (forall s_3:char_P pointer.
   (forall i_1:int32.
    ((le_int((0), integer_of_int32(i_1))
     and (le_int(integer_of_int32(i_1),
          integer_of_int32(strlen(char_P_char_M_at_L, s_3)))
         and eq_int(integer_of_int8(select(char_P_char_M_at_L,
                                    shift(s_3, integer_of_int32(i_1)))),
             (0)))) ->
     eq_int(integer_of_int32(i_1),
     integer_of_int32(strlen(char_P_char_M_at_L, s_3)))))))

logic uint16_of_integer: int -> uint16

axiom uint16_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (65535))) ->
   eq_int(integer_of_uint16(uint16_of_integer(x)), x)))

axiom uint16_range :
 (forall x:uint16.
  (le_int((0), integer_of_uint16(x))
  and le_int(integer_of_uint16(x), (65535))))

logic uint32_of_integer: int -> uint32

axiom uint32_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (4294967295))) ->
   eq_int(integer_of_uint32(uint32_of_integer(x)), x)))

axiom uint32_range :
 (forall x:uint32.
  (le_int((0), integer_of_uint32(x))
  and le_int(integer_of_uint32(x), (4294967295))))

logic uint64_of_integer: int -> uint64

axiom uint64_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (18446744073709551615))) ->
   eq_int(integer_of_uint64(uint64_of_integer(x)), x)))

axiom uint64_range :
 (forall x:uint64.
  (le_int((0), integer_of_uint64(x))
  and le_int(integer_of_uint64(x), (18446744073709551615))))

logic uint8_of_integer: int -> uint8

axiom uint8_coerce :
 (forall x:int.
  ((le_int((0), x) and le_int(x, (255))) ->
   eq_int(integer_of_uint8(uint8_of_integer(x)), x)))

axiom uint8_range :
 (forall x:uint8.
  (le_int((0), integer_of_uint8(x)) and le_int(integer_of_uint8(x), (255))))

predicate valid_struct_char_P(p:char_P pointer,
 a:int,
 b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) = a)
 and (offset_max(char_P_alloc_table, p) = b))

predicate valid_struct_enum___anonenum_color_1_P(p:enum___anonenum_color_1_P pointer,
 a:int,
 b:int,
 enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table) =
 ((offset_min(enum___anonenum_color_1_P_alloc_table, p) = a)
 and (offset_max(enum___anonenum_color_1_P_alloc_table, p) = b))

predicate valid_struct_int_P(p:int_P pointer,
 a:int,
 b:int,
 int_P_alloc_table:int_P alloc_table) =
 ((offset_min(int_P_alloc_table, p) = a)
 and (offset_max(int_P_alloc_table, p) = b))

predicate valid_variant_char_P(p:char_P pointer,
 a:int,
 b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) = a)
 and (offset_max(char_P_alloc_table, p) = b))

predicate valid_variant_enum___anonenum_color_1_P(p:enum___anonenum_color_1_P pointer,
 a:int,
 b:int,
 enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table) =
 ((offset_min(enum___anonenum_color_1_P_alloc_table, p) = a)
 and (offset_max(enum___anonenum_color_1_P_alloc_table, p) = b))

predicate valid_variant_int_P(p:int_P pointer,
 a:int,
 b:int,
 int_P_alloc_table:int_P alloc_table) =
 ((offset_min(int_P_alloc_table, p) = a)
 and (offset_max(int_P_alloc_table, p) = b))

parameter E_of_integer_ :
 x:int ->
  { (le_int((1), x) and le_int(x, (4)))} E
  { eq_int(integer_of_E(result), x) }

parameter I_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (2)))} I
  { eq_int(integer_of_I(result), x) }

parameter __anonenum_color_1_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (2)))} __anonenum_color_1
  { eq_int(integer_of___anonenum_color_1(result), x) }

parameter _bool_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (1)))} _bool
  { eq_int(integer_of__bool(result), x) }

parameter char_P_alloc_table : char_P alloc_table ref

parameter char_P_tag_table : char_P tag_table ref

parameter alloc_char_P :
 n:int ->
  char_P_alloc_table:char_P alloc_table ref ->
   char_P_alloc_table:char_P alloc_table ref ->
    { ge_int(n, (0))} char_P pointer reads char_P_alloc_table
    writes char_P_alloc_table,char_P_tag_table
    { (valid_struct_char_P(result, (0), sub_int(n, (1)), char_P_alloc_table)
      and (instanceof(char_P_tag_table, result, char_P_tag)
          and (alloc_extends(char_P_alloc_table@, char_P_alloc_table)
              and alloc_extern(char_P_alloc_table@, result)))) }

parameter enum___anonenum_color_1_P_alloc_table :
 enum___anonenum_color_1_P alloc_table ref

parameter enum___anonenum_color_1_P_tag_table :
 enum___anonenum_color_1_P tag_table ref

parameter alloc_enum___anonenum_color_1_P :
 n:int ->
  enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table ref ->
   enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table ref ->
    { ge_int(n, (0))} enum___anonenum_color_1_P pointer
    reads enum___anonenum_color_1_P_alloc_table
    writes enum___anonenum_color_1_P_alloc_table,enum___anonenum_color_1_P_tag_table
    { (valid_struct_enum___anonenum_color_1_P(result, (0), sub_int(n, (1)),
       enum___anonenum_color_1_P_alloc_table)
      and (instanceof(enum___anonenum_color_1_P_tag_table, result,
           enum___anonenum_color_1_P_tag)
          and (alloc_extends(enum___anonenum_color_1_P_alloc_table@,
               enum___anonenum_color_1_P_alloc_table)
              and alloc_extern(enum___anonenum_color_1_P_alloc_table@,
                  result)))) }

parameter int_P_alloc_table : int_P alloc_table ref

parameter int_P_tag_table : int_P tag_table ref

parameter alloc_int_P :
 n:int ->
  int_P_alloc_table:int_P alloc_table ref ->
   int_P_alloc_table:int_P alloc_table ref ->
    { ge_int(n, (0))} int_P pointer reads int_P_alloc_table
    writes int_P_alloc_table,int_P_tag_table
    { (valid_struct_int_P(result, (0), sub_int(n, (1)), int_P_alloc_table)
      and (instanceof(int_P_tag_table, result, int_P_tag)
          and (alloc_extends(int_P_alloc_table@, int_P_alloc_table)
              and alloc_extern(int_P_alloc_table@, result)))) }

parameter alloc_one_char_P :
 tt:unit ->
  char_P_alloc_table:char_P alloc_table ref ->
   char_P_alloc_table:char_P alloc_table ref ->
    { } char_P pointer reads char_P_alloc_table
    writes char_P_alloc_table,char_P_tag_table
    { (valid_struct_char_P(result, (0), (0), char_P_alloc_table)
      and (instanceof(char_P_tag_table, result, char_P_tag)
          and (alloc_extends(char_P_alloc_table@, char_P_alloc_table)
              and alloc_extern(char_P_alloc_table@, result)))) }

parameter alloc_one_enum___anonenum_color_1_P :
 tt:unit ->
  enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table ref ->
   enum___anonenum_color_1_P_alloc_table:enum___anonenum_color_1_P alloc_table ref ->
    { } enum___anonenum_color_1_P pointer
    reads enum___anonenum_color_1_P_alloc_table
    writes enum___anonenum_color_1_P_alloc_table,enum___anonenum_color_1_P_tag_table
    { (valid_struct_enum___anonenum_color_1_P(result, (0), (0),
       enum___anonenum_color_1_P_alloc_table)
      and (instanceof(enum___anonenum_color_1_P_tag_table, result,
           enum___anonenum_color_1_P_tag)
          and (alloc_extends(enum___anonenum_color_1_P_alloc_table@,
               enum___anonenum_color_1_P_alloc_table)
              and alloc_extern(enum___anonenum_color_1_P_alloc_table@,
                  result)))) }

parameter alloc_one_int_P :
 tt:unit ->
  int_P_alloc_table:int_P alloc_table ref ->
   int_P_alloc_table:int_P alloc_table ref ->
    { } int_P pointer reads int_P_alloc_table
    writes int_P_alloc_table,int_P_tag_table
    { (valid_struct_int_P(result, (0), (0), int_P_alloc_table)
      and (instanceof(int_P_tag_table, result, int_P_tag)
          and (alloc_extends(int_P_alloc_table@, int_P_alloc_table)
              and alloc_extern(int_P_alloc_table@, result)))) }

parameter any_E : unit -> { } E { true }

parameter any_I : unit -> { } I { true }

parameter any___anonenum_color_1 : unit -> { } __anonenum_color_1 { true }

parameter any__bool : unit -> { } _bool { true }

parameter any_int16 : unit -> { } int16 { true }

parameter any_int32 : unit -> { } int32 { true }

parameter any_int64 : unit -> { } int64 { true }

parameter any_int8 : unit -> { } int8 { true }

parameter any_uint16 : unit -> { } uint16 { true }

parameter any_uint32 : unit -> { } uint32 { true }

parameter any_uint64 : unit -> { } uint64 { true }

parameter any_uint8 : unit -> { } uint8 { true }

parameter char_P_char_M : (char_P, int8) memory ref

parameter enum___anonenum_color_1_P_enum___anonenum_color_1_M :
 (enum___anonenum_color_1_P,
 __anonenum_color_1) memory ref

parameter int_P_int_M : (int_P, int32) memory ref

parameter enum_as_array_index :
 t_0:int_P pointer ->
  { (C_19:
    ((C_20: le_int(offset_min(int_P_alloc_table, t_0), (0)))
    and (C_21: ge_int(offset_max(int_P_alloc_table, t_0), (2)))))}
  unit reads int_P_alloc_table,int_P_int_M,int_P_tag_table writes int_P_int_M
  { ((true = true) ->
     (C_22:
     eq_int(integer_of_int32(select(int_P_int_M, shift(t_0, (1)))), (0)))) }

parameter f :
 tt:unit ->
  { (JC_1: true)} unit { ((true = true) -> (C_1: eq_int((4), (4)))) }

parameter g :
 e:E ->
  { (JC_4: true)} int32
  { ((true = true) ->
     (C_4:
     ((C_5: le_int((1), integer_of_int32(result)))
     and (C_6: le_int(integer_of_int32(result), (4)))))) }

parameter h :
 t:enum___anonenum_color_1_P pointer ->
  { (C_12:
    ((C_13:
     le_int(offset_min(enum___anonenum_color_1_P_alloc_table, t), (0)))
    and (C_14:
        ge_int(offset_max(enum___anonenum_color_1_P_alloc_table, t), (9)))))}
  unit
  reads enum___anonenum_color_1_P_alloc_table,enum___anonenum_color_1_P_enum___anonenum_color_1_M,enum___anonenum_color_1_P_tag_table
  writes enum___anonenum_color_1_P_enum___anonenum_color_1_M
  { ((true = true) ->
     (C_15:
     (eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                               select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                               shift(t, (2)))))),
      (0))
     or (eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                                  select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                                  shift(t, (2)))))),
         (1))
        or eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                                    select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                                    shift(t, (2)))))),
           (2)))))) }

parameter int16_of_integer_ :
 x:int ->
  { (le_int((-32768), x) and le_int(x, (32767)))} int16
  { eq_int(integer_of_int16(result), x) }

parameter int32_of_integer_ :
 x:int ->
  { (le_int((-2147483648), x) and le_int(x, (2147483647)))} int32
  { eq_int(integer_of_int32(result), x) }

parameter int64_of_integer_ :
 x:int ->
  { (le_int((-9223372036854775808), x) and le_int(x, (9223372036854775807)))}
  int64 { eq_int(integer_of_int64(result), x) }

parameter int8_of_integer_ :
 x:int ->
  { (le_int((-128), x) and le_int(x, (127)))} int8
  { eq_int(integer_of_int8(result), x) }

parameter safe_E_of_integer_ :
 x:int -> { } E { eq_int(integer_of_E(result), x) }

parameter safe_I_of_integer_ :
 x:int -> { } I { eq_int(integer_of_I(result), x) }

parameter safe___anonenum_color_1_of_integer_ :
 x:int ->
  { } __anonenum_color_1 { eq_int(integer_of___anonenum_color_1(result), x) }

parameter safe__bool_of_integer_ :
 x:int -> { } _bool { eq_int(integer_of__bool(result), x) }

parameter safe_int16_of_integer_ :
 x:int -> { } int16 { eq_int(integer_of_int16(result), x) }

parameter safe_int32_of_integer_ :
 x:int -> { } int32 { eq_int(integer_of_int32(result), x) }

parameter safe_int64_of_integer_ :
 x:int -> { } int64 { eq_int(integer_of_int64(result), x) }

parameter safe_int8_of_integer_ :
 x:int -> { } int8 { eq_int(integer_of_int8(result), x) }

parameter safe_uint16_of_integer_ :
 x:int -> { } uint16 { eq_int(integer_of_uint16(result), x) }

parameter safe_uint32_of_integer_ :
 x:int -> { } uint32 { eq_int(integer_of_uint32(result), x) }

parameter safe_uint64_of_integer_ :
 x:int -> { } uint64 { eq_int(integer_of_uint64(result), x) }

parameter safe_uint8_of_integer_ :
 x:int -> { } uint8 { eq_int(integer_of_uint8(result), x) }

parameter uint16_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (65535)))} uint16
  { eq_int(integer_of_uint16(result), x) }

parameter uint32_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (4294967295)))} uint32
  { eq_int(integer_of_uint32(result), x) }

parameter uint64_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (18446744073709551615)))} uint64
  { eq_int(integer_of_uint64(result), x) }

parameter uint8_of_integer_ :
 x:int ->
  { (le_int((0), x) and le_int(x, (255)))} uint8
  { eq_int(integer_of_uint8(result), x) }

let enum_as_array_index_ensures_default_3 =
 fun (t_0 : int_P pointer) ->
  { (C_19:
    ((C_20: le_int(offset_min(int_P_alloc_table, t_0), (0)))
    and (C_21: ge_int(offset_max(int_P_alloc_table, t_0), (2))))) }
  (init:
  try
   begin
     (C_18:
     begin
       (let jessie_14 = (let jessie_12 = (C_16: ((shift t_0) (1))) in
                        (let jessie_13 = (safe_int32_of_integer_ (0)) in
                        (((safe_upd_ int_P_int_M) (C_16: ((shift t_0) (1)))) jessie_13))) in
       void);
      (raise Return)
     end);
    (raise Return)
   end
   with
   Return ->
   void end)
  { ((true = true) ->
     (C_22:
     eq_int(integer_of_int32(select(int_P_int_M, shift(t_0, (1)))), (0)))) }

let enum_as_array_index_safety =
 fun (t_0 : int_P pointer) ->
  { (C_19:
    ((C_20: le_int(offset_min(int_P_alloc_table, t_0), (0)))
    and (C_21: ge_int(offset_max(int_P_alloc_table, t_0), (2))))) }
  (init:
  try
   begin
     (C_18:
     begin
       (let jessie_11 = (let jessie_9 = (C_16: ((shift t_0) (1))) in
                        (let jessie_10 = (safe_int32_of_integer_ (0)) in
                        (JC_12:
                        (((((offset_upd_ !int_P_alloc_table) int_P_int_M) t_0) (1)) jessie_10)))) in
       void);
      (raise Return)
     end);
    (raise Return)
   end
   with
   Return ->
   void end)
  { true }

let f_ensures_default =
 fun (tt : unit) ->
  { (JC_2: true) }
  (init:
  try begin   (raise Return); (raise Return) end with Return -> void end)
  { ((true = true) -> (C_1: eq_int((4), (4)))) }

let f_safety =
 fun (tt : unit) ->
  { (JC_2: true) }
  (init:
  try begin   (raise Return); (raise Return) end with Return -> void end)
  { true }

let g_ensures_default_1 =
 fun (e : E) ->
  { (JC_5: true) }
  (init:
  (let jessie_returned_value = ref (any_int32 void) in
  try
   begin
     (let __retres = ref (any_int32 void) in
     (C_3:
     begin
       (let jessie_2 = (__retres := (safe_int32_of_integer_ (integer_of_E e))) in
       void);
      (jessie_returned_value := !__retres);
      (raise Return)
     end));
    absurd 
   end
   with
   Return ->
   !jessie_returned_value end))
  { ((true = true) ->
     (C_4:
     ((C_5: le_int((1), integer_of_int32(result)))
     and (C_6: le_int(integer_of_int32(result), (4)))))) }

let g_safety =
 fun (e : E) ->
  { (JC_5: true) }
  (init:
  (let jessie_returned_value = ref (any_int32 void) in
  try
   begin
     (let __retres = ref (any_int32 void) in
     (C_3:
     begin
       (let jessie_1 = (__retres := (C_2:
                                    (int32_of_integer_ (integer_of_E e)))) in
       void);
      (jessie_returned_value := !__retres);
      (raise Return)
     end));
    absurd 
   end
   with
   Return ->
   !jessie_returned_value end))
  { true }

let h_ensures_default_2 =
 fun (t : enum___anonenum_color_1_P pointer) ->
  { (C_12:
    ((C_13:
     le_int(offset_min(enum___anonenum_color_1_P_alloc_table, t), (0)))
    and (C_14:
        ge_int(offset_max(enum___anonenum_color_1_P_alloc_table, t), (9))))) }
  (init:
  try
   begin
     (C_11:
     begin
       (let jessie_8 = (let jessie_6 = (C_9: ((shift t) (2))) in
                       (let jessie_7 = ((safe_acc_ !enum___anonenum_color_1_P_enum___anonenum_color_1_M) 
                                        (C_7:
                                        ((shift t) (0)))) in
                       (((safe_upd_ enum___anonenum_color_1_P_enum___anonenum_color_1_M) 
                         (C_9:
                         ((shift t) (2)))) jessie_7))) in
       void);
      (raise Return)
     end);
    (raise Return)
   end
   with
   Return ->
   void end)
  { ((true = true) ->
     (C_15:
     (eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                               select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                               shift(t, (2)))))),
      (0))
     or (eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                                  select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                                  shift(t, (2)))))),
         (1))
        or eq_int(integer_of_int32(int32_of_integer(integer_of___anonenum_color_1(
                                                    select(enum___anonenum_color_1_P_enum___anonenum_color_1_M,
                                                    shift(t, (2)))))),
           (2)))))) }

let h_safety =
 fun (t : enum___anonenum_color_1_P pointer) ->
  { (C_12:
    ((C_13:
     le_int(offset_min(enum___anonenum_color_1_P_alloc_table, t), (0)))
    and (C_14:
        ge_int(offset_max(enum___anonenum_color_1_P_alloc_table, t), (9))))) }
  (init:
  try
   begin
     (C_11:
     begin
       (let jessie_5 = (let jessie_3 = (C_9: ((shift t) (2))) in
                       (let jessie_4 = (C_8:
                                       (((acc_ !enum___anonenum_color_1_P_alloc_table) !enum___anonenum_color_1_P_enum___anonenum_color_1_M) t)) in
                       (JC_9:
                       (((((offset_upd_ !enum___anonenum_color_1_P_alloc_table) enum___anonenum_color_1_P_enum___anonenum_color_1_M) t) (2)) jessie_4)))) in
       void);
      (raise Return)
     end);
    (raise Return)
   end
   with
   Return ->
   void end)
  { true }


