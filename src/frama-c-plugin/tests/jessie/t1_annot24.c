/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

int status  = 0;
int rr  = 1;
/*@ global invariant inv: ((0 <= rr) && (rr <= 5000));

*/
//****************
//* BEGIN Primitives generated for LTL verification
//* 
//* States and Trans Variables
int buch_CurStates[2]  = {1, 0};
int buch_CurTrans[3]  = {1, 0, 0};
int buch_CurStates_old[2]  = {1, 0};
int buch_CurTrans_tmp[3]  = {1, 0, 0};
//* 
//* Their invariants
/*@
global
invariant Buch_Ranges_Validity:
                               (\valid(buch_CurTrans + (0 .. 2)) &&
                               (\valid(buch_CurTrans_tmp + (0 .. 2)) &&
                               (\valid(buch_CurStates + (0 .. 1)) &&
                               \valid(buch_CurStates_old + (0 .. 1)))));
 */
/*@
global
invariant Buch_Arrays_Coherence:
                                (\forall integer _buch_i;
                                (((0 <= _buch_i) && (_buch_i < 3)) ==>
                                (buch_CurTrans[_buch_i] ==
                                buch_CurTrans_tmp[_buch_i])));

*/
//* 
//* Acceptation States -- UNUSED AT THIS TIME !!!
int buch_AcceptStates[2]  = {0, 1};
/*@
global
invariant Buch_acc_Ranges_Validity: \valid(buch_AcceptStates + (0 .. 1));

*/
//* 
//* Some constants
enum buch_ListOper {
    op_fake = 0,
    op_main = 1,
    op_op = 2
} ;
enum buch_ListOper buch_CurOperation  = op_main;
enum Buch_OpStatusList {
    buch_Called = 0,
    buch_Terminated = 1
} ;
enum Buch_OpStatusList buch_CurOpStatus  = buch_Called;
//* 
//**************** 
//* Axiomatized transitions automata
/*@ axiomatic Automata {
  @  logic integer buch_Trans_Start(integer tr);
  @   axiom buch_Trans_Start0: (buch_Trans_Start(0) == 0);
  @   axiom buch_Trans_Start1: (buch_Trans_Start(1) == 0);
  @   axiom buch_Trans_Start2: (buch_Trans_Start(2) == 1);
  @  logic integer buch_Trans_Stop(integer tr);
  @   axiom buch_Trans_Stop0: (buch_Trans_Stop(0) == 0);
  @   axiom buch_Trans_Stop1: (buch_Trans_Stop(1) == 1);
  @   axiom buch_Trans_Stop2: (buch_Trans_Stop(2) == 1);
  @ }
  @*/

/*@ predicate buch_Trans_Cond_param{L}(integer _buch_numTrans, integer _buch_op,
                               integer _buch_status)
         =
         (((_buch_numTrans == 0) ==> (status == 0)) &&
         (((_buch_numTrans == 1) ==>
          ((_buch_op == op_op) && (_buch_status == buch_Terminated)))
         && ((_buch_numTrans == 2) ==> \true)));
 */

/*@
predicate buch_Trans_Cond{L}(integer _buch_numTrans) =
         buch_Trans_Cond_param{L}(_buch_numTrans, buch_CurOperation,
                              buch_CurOpStatus);

*/

//* 
//**************** 
//* Safety invariants
//* 
//* Inv 1 : Each active state is reachable
/*@
global
invariant _Buch_st_reach_1:
                           (\forall integer _buch_st;
                           ((((0 <= _buch_st) && (_buch_st < 2)) &&
                            (\forall integer _buch_tr;
                            (((0 <= _buch_tr) && (_buch_tr < 3)) ==>
                            ((buch_CurTrans[_buch_tr] == 0) ||
                            ((buch_Trans_Stop(_buch_tr) != _buch_st) ||
                            (!(buch_Trans_Cond(_buch_tr)) ||
                            (buch_CurStates_old[buch_Trans_Start(_buch_tr)] ==
                            0)))))))
                           ==> (buch_CurStates[_buch_st] == 0)));
 */
//* Inv 2 : Each non-active state is not reachable
/*@
global
invariant _Buch_st_reach_2:
                           (\forall integer _buch_st;
                           ((((0 <= _buch_st) && (_buch_st < 2)) &&
                            (buch_CurStates[_buch_st] == 0))
                           ==>
                           (\forall integer _buch_tr;
                           (((0 <= _buch_tr) && (_buch_tr < 3)) ==>
                           ((buch_CurTrans[_buch_tr] == 0) ||
                           ((buch_Trans_Stop(_buch_tr) != _buch_st) ||
                           (!(buch_Trans_Cond(_buch_tr)) ||
                           (buch_CurStates_old[buch_Trans_Start(_buch_tr)] ==
                           0))))))));
 */
//* Inv 3 : Each active state is reachable
/*@
global
invariant _Buch_st_reach_3:
                           (\forall integer _buch_st;
                           ((((0 <= _buch_st) && (_buch_st < 2)) &&
                            (buch_CurStates[_buch_st] != 0))
                           ==>
                           (\exists integer _buch_tr;
                           (((0 <= _buch_tr) && (_buch_tr < 3)) &&
                           ((buch_CurTrans[_buch_tr] != 0) &&
                           (buch_Trans_Cond(_buch_tr) &&
                           ((buch_Trans_Stop(_buch_tr) == _buch_st) &&
                           (buch_CurStates_old[buch_Trans_Start(_buch_tr)] !=
                           0))))))));
 */
//* Inv 4 : Each transition annotated as crossable is crossable
/*@
global
invariant _Buch_tr_cross_1:
                           (\forall integer _buch_tr;
                           ((((0 <= _buch_tr) && (_buch_tr < 3)) &&
                            (buch_CurTrans[_buch_tr] != 0))
                           ==>
                           (buch_Trans_Cond(_buch_tr) &&
                           ((buch_CurStates_old[buch_Trans_Start(_buch_tr)] !=
                            0)
                           &&
                           (buch_CurStates[buch_Trans_Stop(_buch_tr)] != 0)))));
 */
//* Inv 5 : Each crossable transition is crossed
/*@
global
invariant _Buch_tr_cross_2:
                           (\forall integer _buch_tr;
                           ((((0 <= _buch_tr) && (_buch_tr < 3)) &&
                            ((buch_CurStates_old[buch_Trans_Start(_buch_tr)]
                             != 0)
                            && buch_Trans_Cond(_buch_tr)))
                           ==>
                           ((buch_CurTrans[_buch_tr] != 0) &&
                           (buch_CurStates[buch_Trans_Stop(_buch_tr)] != 0))));
 */
//* Inv 6 : Non-crossable transitions are not crossed over
/*@
global
invariant _Buch_tr_cross_3:
                           (\forall integer _buch_tr;
                           ((((0 <= _buch_tr) && (_buch_tr < 3)) &&
                            ((buch_CurStates_old[buch_Trans_Start(_buch_tr)]
                             != 0)
                            || !(buch_Trans_Cond(_buch_tr))))
                           ==> (buch_CurTrans[_buch_tr] != 0)));

*/
//* 
//* END Primitives generated for LTL verification
//****************
/*@ requires (0 == buch_CurTrans[1]);
    requires ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
    requires \true;
    requires ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
    requires (rr < 5000);
    behavior Buchi_property_behavior:
      ensures (0 == buch_CurTrans[1]);
      ensures ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
      ensures \true;
      ensures ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
      
    behavior j:
      ensures (rr < 5001);
      */
void fake(void) 
{ 
  
  {rr ++;
  {buch_CurOperation = op_fake;
  buch_CurOpStatus = buch_Terminated;
  buch_CurStates_old[0] = buch_CurStates[0];
  buch_CurStates_old[1] = buch_CurStates[1];
  buch_CurTrans_tmp[0] = buch_CurTrans[0];
  buch_CurTrans_tmp[1] = buch_CurTrans[1];
  buch_CurTrans_tmp[2] = buch_CurTrans[2];
  buch_CurStates[0] = 0 || (status == 0 && buch_CurStates_old[0]);
  buch_CurStates[1] = 0 || (1 && buch_CurStates_old[1]);
  buch_CurTrans[0] = status == 0 && (buch_CurStates_old[0] && buch_CurStates[0]);
  buch_CurTrans[1] = 0;
  buch_CurTrans[2] = 1 && (buch_CurStates_old[1] && buch_CurStates[1]);
  return;}
  }

}
/*@ requires (0 == buch_CurTrans[1]);
    requires ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
    requires \true;
    requires ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
    behavior Buchi_property_behavior:
      ensures (0 == buch_CurTrans[1]);
      ensures ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
      ensures \true;
      ensures ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
      */
void op(void) 
{ 
  
  {status = 1;
  {buch_CurOperation = op_op;
  buch_CurOpStatus = buch_Terminated;
  buch_CurStates_old[0] = buch_CurStates[0];
  buch_CurStates_old[1] = buch_CurStates[1];
  buch_CurTrans_tmp[0] = buch_CurTrans[0];
  buch_CurTrans_tmp[1] = buch_CurTrans[1];
  buch_CurTrans_tmp[2] = buch_CurTrans[2];
  buch_CurStates[0] = 0 || (status == 0 && buch_CurStates_old[0]);
  buch_CurStates[1] = (0 || (1 && buch_CurStates_old[0])) || (1 && buch_CurStates_old[1]);
  buch_CurTrans[0] = status == 0 && (buch_CurStates_old[0] && buch_CurStates[0]);
  buch_CurTrans[1] = 1 && (buch_CurStates_old[0] && buch_CurStates[1]);
  buch_CurTrans[2] = 1 && (buch_CurStates_old[1] && buch_CurStates[1]);
  return;}
  }

}
/*@ requires (0 == buch_CurTrans[1]);
    requires ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
    requires \true;
    requires ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
    behavior Buchi_property_behavior:
      ensures (0 == buch_CurTrans[1]);
      ensures ((0 != buch_CurTrans[0]) || (0 != buch_CurTrans[2]));
      ensures \true;
      ensures ((0 != buch_CurStates[0]) || (0 != buch_CurStates[1]));
      */
int main(void) 
{ int __retres ;
  
  {if (rr < 5000) {{buch_CurOperation = op_fake;
                   buch_CurOpStatus = buch_Called;
                   fake();}
     }
  
  {buch_CurOperation = op_op;
  buch_CurOpStatus = buch_Called;
  op();}
  
  __retres = 1;
  {buch_CurOperation = op_main;
  buch_CurOpStatus = buch_Terminated;
  buch_CurStates_old[0] = buch_CurStates[0];
  buch_CurStates_old[1] = buch_CurStates[1];
  buch_CurTrans_tmp[0] = buch_CurTrans[0];
  buch_CurTrans_tmp[1] = buch_CurTrans[1];
  buch_CurTrans_tmp[2] = buch_CurTrans[2];
  buch_CurStates[0] = 0 || (status == 0 && buch_CurStates_old[0]);
  buch_CurStates[1] = 0 || (1 && buch_CurStates_old[1]);
  buch_CurTrans[0] = status == 0 && (buch_CurStates_old[0] && buch_CurStates[0]);
  buch_CurTrans[1] = 0;
  buch_CurTrans[2] = 1 && (buch_CurStates_old[1] && buch_CurStates[1]);
  return (__retres);}
  }

}

/*
Local Variables:
compile-command: "LC_ALL=C make t1_annot24"
End:  
 */
