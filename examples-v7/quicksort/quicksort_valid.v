(* This file is generated by Why; do not edit *)

Require Why.
Require Export partition_valid.
Require Export quicksort_why.

Definition quick_rec (* validation *)
  : (l: Z)(r: Z)(t: (array Z))(_: `0 <= l` /\ `r < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 l r) /\ (sub_permut l r t0 t)))
  := [l: Z; r: Z; t: (array Z); Pre15: `0 <= l` /\ `r < (array_length t)`]
       (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
         [Variant1: Z](l0: Z)(r0: Z)(t0: (array Z))
         (_: Variant1 = `1 + r0 - l0`)(_0: `0 <= l0` /\
         `r0 < (array_length t0)`)
         (sig_2 (array Z) unit [t1: (array Z)][result: unit]
          ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)))
         [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
          (l0: Z)(r0: Z)(t0: (array Z))(_: Variant2 = `1 + r0 - l0`)
          (_0: `0 <= l0` /\ `r0 < (array_length t0)`)
          (sig_2 (array Z) unit [t1: (array Z)][result: unit]
           ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)));
          l0: Z; r0: Z; t0: (array Z); Pre14: Variant1 = `1 + r0 - l0`;
          Pre13: `0 <= l0` /\ `r0 < (array_length t0)`]
           let (result, Bool3) =
             let (result1, Post2) = (Z_lt_ge_bool l0 r0) in
             (exist_1 [result2: bool]
             (if result2 then `l0 < r0` else `l0 >= r0`) result1 Post2) in
           Cases
             (btest
              [result:bool](if result then `l0 < r0` else `l0 >= r0`) result
              Bool3) of
           | (left Test2) =>
               let (t1, result0, Post4) =
                 let Pre12 =
                   (quick_rec_po_1 l r t Pre15 Variant1 l0 r0 t0 Pre14 Pre13
                   Test2) in
                 let (t1, p, Post5) =
                   let Pre2 = Pre12 in
                   let Pre3 = Pre2 in
                   let (t1, result2, Post6) = (partition l0 r0 t0 Pre2) in
                   (exist_2 [t2: (array Z)][result3: Z](`l0 <= result3` /\
                   `result3 <= r0`) /\ (partition_p t2 l0 r0 result3) /\
                   (sub_permut l0 r0 t2 t0) t1 result2 Post6) in
                 let (t2, result0, Post7) =
                   let Pre11 =
                     (quick_rec_po_2 l r t Pre15 Variant1 l0 r0 t0 Pre14
                     Pre13 Test2 Pre12 t1 p Post5) in
                   let (t2, result0, Post8) =
                     let Pre5 = Pre11 in
                     let Pre6 = Pre5 in
                     let (t2, result2, Post9) =
                       ((wf1 `1 + (p - 1) - l0`)
                         (quick_rec_po_3 l r t Pre15 Variant1 l0 r0 t0 Pre14
                         Pre13 Test2 Pre12 t1 p Post5 Pre11 Pre5 Pre6) 
                         l0 `p - 1` t1 (refl_equal ? `1 + (p - 1) - l0`)
                         Pre6) in
                     (exist_2 [t3: (array Z)][result3: unit]
                     (sorted_array t3 l0 `p - 1`) /\
                     (sub_permut l0 `p - 1` t3 t1) t2 result2 Post9) in
                   let Pre10 =
                     (quick_rec_po_4 l r t Pre15 Variant1 l0 r0 t0 Pre14
                     Pre13 Test2 Pre12 t1 p Post5 Pre11 t2 Post8) in
                   let (t3, result1, Post10) =
                     let Pre8 = Pre10 in
                     let Pre9 = Pre8 in
                     let (t3, result3, Post11) =
                       ((wf1 `1 + r0 - (p + 1)`)
                         (quick_rec_po_5 l r t Pre15 Variant1 l0 r0 t0 Pre14
                         Pre13 Test2 Pre12 t1 p Post5 Pre11 t2 Post8 Pre10
                         Pre8 Pre9) `p + 1` r0 t2
                         (refl_equal ? `1 + r0 - (p + 1)`) Pre9) in
                     (exist_2 [t4: (array Z)][result4: unit]
                     (sorted_array t4 `p + 1` r0) /\
                     (sub_permut `p + 1` r0 t4 t2) t3 result3 Post11) in
                   (exist_2 [t4: (array Z)][result2: unit]
                   (sorted_array t4 l0 r0) /\ (sub_permut l0 r0 t4 t0) 
                   t3 result1
                   (quick_rec_po_6 l r t Pre15 Variant1 l0 r0 t0 Pre14 Pre13
                   Test2 Pre12 t1 p Post5 Pre11 t2 Post8 Pre10 t3 Post10)) in
                 (exist_2 [t3: (array Z)][result1: unit]
                 (sorted_array t3 l0 r0) /\ (sub_permut l0 r0 t3 t0) 
                 t2 result0 Post7) in
               (exist_2 [t2: (array Z)][result1: unit]
               (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1 
               result0 Post4)
           | (right Test1) =>
               let (result0, Post3) = (exist_1 [result0: unit]
                 (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0) 
                 tt
                 (quick_rec_po_7 l r t Pre15 Variant1 l0 r0 t0 Pre14 Pre13
                 Test1)) in
               (exist_2 [t1: (array Z)][result1: unit]
               (sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0) t0 
               result0 Post3) end `1 + r - l` l r t
         (refl_equal ? `1 + r - l`) Pre15).

Definition quicksort (* validation *)
  : (t: (array Z))
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t)))
  := [t: (array Z)]
       let Pre1 = (quicksort_po_1 t) in
       let (t0, result1, Post1) =
         (quick_rec `0` `(array_length t) - 1` t Pre1) in
       (exist_2 [t1: (array Z)][result2: unit]
       (sorted_array t1 `0` `(array_length t1) - 1`) /\ (permut t1 t) 
       t0 result1 (quicksort_po_2 t Pre1 t0 Post1)).

