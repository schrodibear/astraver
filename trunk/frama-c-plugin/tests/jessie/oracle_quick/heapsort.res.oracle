rm -f heapsort.jc
../../bin/toplevel.opt -jessie-analysis  -jessie-gen-only heapsort.c
Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
cat heapsort.jc
# IntModel = bounded
# InvariantPolicy = Arguments

type _bool = 0..1

type int8 = -128..127

type uint8 = 0..255

type int32 = -2147483648..2147483647

type uint32 = 0..4294967295

type int16 = -32768..32767

type uint16 = 0..65535

type int64 = -9223372036854775808..9223372036854775807

type uint64 = 0..18446744073709551615

tag int_P = {
  int32 int_M;
}

type int_P = [int_P]

tag char_P = {
  int8 char_M;
}

type char_P = [char_P]

tag void_P = {
  unit void_M;
}

type void_P = [void_P]

logic int32 strlen{L}(char_P[..] s) reads s.char_M;

axiom strlen_def1{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i < strlen{L}(s))) ==> ((s + i).char_M != 0))))

axiom strlen_def2{L} :
(\forall char_P[..] s;
  ((s + strlen{L}(s)).char_M == 0))

axiom strlen_not_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M != 0)) ==>
      (i < strlen{L}(s)))))

axiom strlen_zero{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    ((((0 <= i) && (i <= strlen{L}(s))) && ((s + i).char_M == 0)) ==>
      (i == strlen{L}(s)))))

axiom strlen_sup{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_shift{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && (i <= strlen{L}(s))) ==>
      (strlen{L}((s + i)) == (strlen{L}(s) - i)))))

axiom strlen_create{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (((0 <= i) && ((s + i).char_M == 0)) ==>
      ((0 <= strlen{L}(s)) && (strlen{L}(s) <= i)))))

axiom strlen_create2{L} :
(\forall char_P[..] s;
  (\forall int32 i;
    (\forall int32 k;
      (((k <= i) && ((s + i).char_M == 0)) ==>
        ((0 <= strlen{L}((s + k))) && (strlen{L}((s + k)) <= (i - k)))))))

logic type int_array

logic int32 access(int_array a, integer i) reads \nothing;

logic int_array update(int_array a, integer i, int32 v) reads \nothing;

axiom access_update_eq :
(\forall int_array a;
  (\forall integer i;
    (\forall int32 v;
      (access(update(a, i, v), i) == v))))

axiom access_update_neq :
(\forall int_array a;
  (\forall integer i;
    (\forall integer j;
      (\forall int32 v;
        ((i != j) ==> (access(update(a, i, v), j) == access(a, j)))))))

logic Swap(int_array a1, int_array a2, integer i, integer j) =
(((access(a1, i) == access(a2, j)) && (access(a1, j) == access(a2, i))) &&
  (\forall integer k;
    ((k != i) ==> ((k != j) ==> (access(a1, k) == access(a2, k))))))

logic Permut(int_array a1, int_array a2, integer l, integer h) reads \nothing;

axiom Permut_refl :
(\forall int_array a;
  (\forall integer l;
    (\forall integer h;
      Permut(a, a, l, h))))

axiom Permut_sym :
(\forall int_array a1;
  (\forall int_array a2;
    (\forall integer l;
      (\forall integer h;
        (Permut(a1, a2, l, h) ==> Permut(a2, a1, l, h))))))

axiom Permut_trans :
(\forall int_array a1;
  (\forall int_array a2;
    (\forall int_array a3;
      (\forall integer l;
        (\forall integer h;
          (Permut(a1, a2, l, h) ==>
            (Permut(a2, a3, l, h) ==> Permut(a1, a3, l, h))))))))

axiom Permut_swap :
(\forall int_array a1;
  (\forall int_array a2;
    (\forall integer l;
      (\forall integer h;
        (\forall integer i;
          (\forall integer j;
            (((l <= i) && (i <= h)) ==>
              (((l <= j) && (j <= h)) ==>
                (Swap(a1, a2, i, j) ==> Permut(a1, a2, l, h))))))))))

axiom Permut_extend :
(\forall int_array a1;
  (\forall int_array a2;
    (\forall integer l;
      (\forall integer h;
        (\forall integer ll;
          (\forall integer hh;
            (Permut(a1, a2, l, h) ==>
              ((ll <= l) ==> ((h <= hh) ==> Permut(a1, a2, ll, hh))))))))))

logic int_array contents{L}(int_P[..] a) reads (a + [..]).int_M;

axiom access_contents{L} :
(\forall int_P[..] a;
  (\forall int32 i;
    (access(contents{L}(a), i) == (a + i).int_M)))

logic Sorted{L}(int_P[..] a, integer l, integer h) =
(\forall integer i;
  (((l <= i) && (i < h)) ==> ((a + i).int_M <= (a + (i + 1)).int_M)))

logic Hnode{L}(int_P[..] a, integer i, integer h) =
(((((2 * i) + 1) <= h) ==> ((a + i).int_M >= (a + ((2 * i) + 1)).int_M)) &&
  ((((2 * i) + 2) <= h) ==> ((a + i).int_M >= (a + ((2 * i) + 2)).int_M)))

logic H{L}(int_P[..] a, integer l, integer h) =
(\forall integer i;
  (((l <= i) && (i <= h)) ==> Hnode{L}(a, i, h)))

lemma H_init{L} :
(\forall int_P[..] a;
  (\forall integer l;
    (\forall integer h;
      (((l <= h) && (h < ((2 * l) + 1))) ==> H{L}(a, l, h)))))

lemma H_reduce{L} :
(\forall int_P[..] a;
  (\forall integer h;
    ((0 < h) ==> (H{L}(a, 0, h) ==> H{L}(a, 1, (h - 1))))))

lemma H_max{L} :
(\forall int_P[..] a;
  (\forall integer h;
    (H{L}(a, 0, h) ==>
      (\forall integer i;
        (((0 <= i) && (i <= h)) ==> ((a + 0).int_M >= (a + i).int_M))))))

lemma div2_1 :
(\forall int32 i;
  ((0 <= i) ==> ((0 <= (i / 2)) && ((i / 2) <= i))))

lemma div2_2 :
(\forall int32 i;
  ((0 < i) ==> ((0 <= (i / 2)) && ((i / 2) < i))))

lemma div2_3 :
(\forall int32 i;
  ((0 <= i) ==> ((i - 1) < ((2 * (i / 2)) + 1))))

lemma div2_4 :
(\forall int32 i;
  (\forall int32 k;
    ((0 <= i) ==>
      ((0 <= k) ==> ((k != ((i - 1) / 2)) ==> (((2 * k) + 1) != i))))))

lemma div2_5 :
(\forall int32 i;
  (\forall int32 k;
    ((0 <= i) ==>
      ((0 <= k) ==> ((k != ((i - 1) / 2)) ==> (((2 * k) + 2) != i))))))

unit sift_down(int_P[..] a, uint32 low, uint32 high, int32 v)
  requires (C_42 : ((((C_45 : (0 <= low)) && (C_46 : (low <= high))) &&
                      ((C_48 : (\offset_min(a) <= low)) &&
                        (C_49 : (\offset_max(a) >= high)))) &&
                     (C_50 : H{Here}(a, (low + 1), high))));
behavior default:
  assumes true;
  assigns (a + [low..high]).int_M;
  ensures (C_51 : ((C_52 : Permut(contents{Here}(a),
                                  \old(update(contents{Here}(a), low, v)),
                                  low, high)) &&
                    (C_53 : H{Here}(a, low, high))));
{  
   (var uint32 i);
   
   (var uint32 child);
   
   {  (C_1 : (i = low));
      
      {  
         invariant (C_2 : ((((((C_7 : (low <= i)) && (C_8 : (i <= high))) &&
                               (C_9 : Permut(contents{Here}(a),
                                             \at(contents{Pre}(a),Pre), low,
                                             high))) &&
                              (C_10 : (\forall int32 k;
                                        (((low < k) && (k <= high)) ==>
                                          Hnode{Here}(a, k, high))))) &&
                             (C_11 : ((low < i) ==>
                                       Hnode{Here}(a, low, high)))) &&
                            (C_12 : ((low <= ((i - 1) / 2)) ==>
                                      ((a + ((i - 1) / 2)).int_M >= v)))));
         variant (C_13 : (high - i));
         while (true)
         {  
            {  (C_18 : (child = (C_17 : ((C_16 : ((C_15 : ((C_14 : (2 * i)) :> uint32)) +
                                                   1)) :> uint32))));
               (if (child <= high) then () else 
               (goto while_0_break));
               (if ((C_29 : ((C_28 : (child + 1)) :> uint32)) <= high) then 
               (if ((C_27 : (C_26 : (a +
                                      (C_25 : ((C_24 : (child + 1)) :> uint32)))).int_M) >=
                     (C_23 : (C_22 : (a + child)).int_M)) then (C_21 : (child = 
                                                               (C_20 : (
                                                               (C_19 : 
                                                               (child +
                                                                 1)) :> uint32)))) else ()) else ());
               
               (goto _L);
               (_L : ());
               (if (v >= (C_31 : (C_30 : (a + child)).int_M)) then 
               (goto while_0_break) else ());
               (C_36 : ((C_35 : (C_34 : (a + i)).int_M) = (C_33 : (C_32 : 
                                                                  (a +
                                                                    child)).int_M)));
               
               {  
                  (assert (C_37 : Hnode{Here}(a, i, high)));
                  ()
               };
               (C_38 : (i = child))
            }
         };
         (while_0_break : ())
      };
      (C_41 : ((C_40 : (C_39 : (a + i)).int_M) = v));
      
      (return ())
   }
}

unit heapsort(int_P[..] a, uint32 n)
  requires (C_106 : ((C_107 : (0 <= n)) &&
                      ((C_109 : (\offset_min(a) <= 0)) &&
                        (C_110 : (\offset_max(a) >= (n - 1))))));
behavior default_1:
  assumes true;
  ensures (C_111 : ((C_112 : Permut(contents{Here}(a),
                                    \old(contents{Here}(a)), 0, (n - 1))) &&
                     (C_113 : Sorted{Here}(a, 0, (n - 1)))));
{  
   (var uint32 i);
   
   (var int32 tmp);
   
   {  (if (n <= 1) then 
      (goto return_label) else ());
      (C_56 : (i = (C_55 : ((C_54 : (n / 2)) :> uint32))));
      
      {  
         invariant (C_57 : ((((C_60 : (0 <= i)) && (C_61 : (i < n))) &&
                              (C_62 : Permut(contents{Here}(a),
                                             \at(contents{Pre}(a),Pre), 0,
                                             (n - 1)))) &&
                             (C_63 : H{Here}(a, i, (n - 1)))));
         variant (C_64 : i);
         while (true)
         {  
            {  (if (i >= 1) then () else 
               (goto while_1_break));
               (C_73 : sift_down(a, (C_66 : ((C_65 : (i - 1)) :> uint32)),
                                 (C_68 : ((C_67 : (n - 1)) :> uint32)),
                                 (C_72 : (C_71 : (a +
                                                   (C_70 : ((C_69 : (i - 1)) :> uint32)))).int_M)));
               (C_76 : (i = (C_75 : ((C_74 : (i - 1)) :> uint32))))
            }
         };
         (while_1_break : ())
      };
      (C_79 : (i = (C_78 : ((C_77 : (n - 1)) :> uint32))));
      
      {  
         invariant (C_80 : ((((((C_85 : (0 <= i)) && (C_86 : (i < n))) &&
                                (C_87 : Permut(contents{Here}(a),
                                               \at(contents{Pre}(a),Pre), 0,
                                               (n - 1)))) &&
                               (C_88 : H{Here}(a, 0, i))) &&
                              (C_89 : Sorted{Here}(a, (i + 1), (n - 1)))) &&
                             (C_90 : (\forall int32 k1;
                                       (\forall int32 k2;
                                         (((0 <= k1) && (k1 <= i)) ==>
                                           (((i < k2) && (k2 < n)) ==>
                                             ((a + k1).int_M <=
                                               (a + k2).int_M))))))));
         variant (C_91 : i);
         while (true)
         {  
            {  (if (i >= 1) then () else 
               (goto while_2_break));
               (C_94 : (tmp = (C_93 : (C_92 : (a + i)).int_M)));
               (C_99 : ((C_98 : (C_97 : (a + i)).int_M) = (C_96 : (C_95 : 
                                                                  (a +
                                                                    0)).int_M)));
               (C_102 : sift_down(a, 0,
                                  (C_101 : ((C_100 : (i - 1)) :> uint32)),
                                  tmp));
               (C_105 : (i = (C_104 : ((C_103 : (i - 1)) :> uint32))))
            }
         };
         (while_2_break : ())
      };
      (return_label : 
      (return ()))
   }
}
