Options are: -journal-disable -cpp-extra-args=-I PPCHOME/share/jessie -jessie -jessie-gen-only dillon3.c
[kernel] preprocessing with "gcc -C -E -I. -I PPCHOME/share/jessie -dD dillon3.c"
[jessie] Starting Jessie translation
[jessie] Producing Jessie files in subdir dillon3.jessie
[jessie] File dillon3.jessie/dillon3.jc written.
[jessie] File dillon3.jessie/dillon3.cloc written.
# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int8 = -128..127

tag double_P = {
  double double_M: 64;
}

type double_P = [double_P]

tag char_P = {
  int8 char_M: 8;
}

type char_P = [char_P]

tag void_P = {
}

type void_P = [void_P]

double g4(double_P[..] t)
  requires (C_8 : (((C_10 : (\offset_min(t) <= 0)) &&
                     (C_11 : (\offset_max(t) >= 0))) &&
                    ((C_13 : (\offset_min(t) <= 0)) &&
                      (C_14 : (\offset_max(t) >= 1)))));
behavior default:
  assigns \nothing;
  ensures (C_7 : ((\result :> real) ==
                   (((\at(t,Old) + 0).double_M :> real) +
                     ((\at(t,Old) + 1).double_M :> real))));
{  
   (var double y);
   
   {  (C_6 : (y = (C_5 : ((C_4 : (C_3 : (t + 0)).double_M) +
                           (C_2 : (C_1 : (t + 1)).double_M)))));
      
      (return y)
   }
}

double f4()
behavior default:
  assigns \nothing;
  ensures (C_24 : true);
{  
   (var double_P[0..1] tab);
   
   (var double r);
   
   {  (C_16 : (tab = (C_15 : (new double_P[2]))));
      (C_18 : ((C_17 : (tab + 0).double_M) = (1.0 :> double)));
      (C_20 : ((C_19 : (tab + 1).double_M) = (2.0 :> double)));
      (C_22 : (r = (C_21 : g4(tab))));
      
      {  (C_23 : (free(tab)));
         
         (return r)
      }
   }
}
WHYLIB=WHYHOME/lib WHYHOME/bin/jessie.opt -why-opt -split-user-conj -why-opt -fast-wp -locs dillon3.jessie/dillon3.cloc dillon3.jessie/dillon3.jc
type char_P

type double_P

type int8

type padding

type void_P

exception Loop_continue_exc of unit

exception Loop_exit_exc of unit

exception Return_label_exc of unit

logic char_P_tag:  -> char_P tag_id

axiom char_P_int : (int_of_tag(char_P_tag) = (1))

logic char_P_of_pointer_address: unit pointer -> char_P pointer

axiom char_P_of_pointer_address_of_pointer_addr :
 (forall p:char_P pointer.
  (p = char_P_of_pointer_address(pointer_address(p))))

axiom char_P_parenttag_bottom : parenttag(char_P_tag, bottom_tag)

axiom char_P_tags :
 (forall x:char_P pointer.
  (forall char_P_tag_table:char_P tag_table.
   instanceof(char_P_tag_table, x, char_P_tag)))

logic double_P_tag:  -> double_P tag_id

axiom double_P_int : (int_of_tag(double_P_tag) = (1))

logic double_P_of_pointer_address: unit pointer -> double_P pointer

axiom double_P_of_pointer_address_of_pointer_addr :
 (forall p:double_P pointer.
  (p = double_P_of_pointer_address(pointer_address(p))))

axiom double_P_parenttag_bottom : parenttag(double_P_tag, bottom_tag)

axiom double_P_tags :
 (forall x:double_P pointer.
  (forall double_P_tag_table:double_P tag_table.
   instanceof(double_P_tag_table, x, double_P_tag)))

logic integer_of_int8: int8 -> int

predicate eq_int8(x:int8, y:int8) =
 eq_int(integer_of_int8(x), integer_of_int8(y))

logic int8_of_integer: int -> int8

axiom int8_coerce :
 (forall x:int.
  ((le_int((-128), x) and le_int(x, (127))) ->
   eq_int(integer_of_int8(int8_of_integer(x)), x)))

axiom int8_range :
 (forall x:int8.
  (le_int((-128), integer_of_int8(x)) and le_int(integer_of_int8(x), (127))))

predicate left_valid_struct_char_P(p:char_P pointer, a:int,
 char_P_alloc_table:char_P alloc_table) =
 (offset_min(char_P_alloc_table, p) <= a)

predicate left_valid_struct_double_P(p:double_P pointer, a:int,
 double_P_alloc_table:double_P alloc_table) =
 (offset_min(double_P_alloc_table, p) <= a)

predicate left_valid_struct_void_P(p:void_P pointer, a:int,
 void_P_alloc_table:void_P alloc_table) =
 (offset_min(void_P_alloc_table, p) <= a)

axiom pointer_addr_of_char_P_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(char_P_of_pointer_address(p))))

axiom pointer_addr_of_double_P_of_pointer_address :
 (forall p:unit pointer.
  (p = pointer_address(double_P_of_pointer_address(p))))

logic void_P_of_pointer_address: unit pointer -> void_P pointer

axiom pointer_addr_of_void_P_of_pointer_address :
 (forall p:unit pointer. (p = pointer_address(void_P_of_pointer_address(p))))

predicate right_valid_struct_char_P(p:char_P pointer, b:int,
 char_P_alloc_table:char_P alloc_table) =
 (offset_max(char_P_alloc_table, p) >= b)

predicate right_valid_struct_double_P(p:double_P pointer, b:int,
 double_P_alloc_table:double_P alloc_table) =
 (offset_max(double_P_alloc_table, p) >= b)

predicate right_valid_struct_void_P(p:void_P pointer, b:int,
 void_P_alloc_table:void_P alloc_table) =
 (offset_max(void_P_alloc_table, p) >= b)

predicate strict_valid_root_char_P(p:char_P pointer, a:int, b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) = a)
 and (offset_max(char_P_alloc_table, p) = b))

predicate strict_valid_root_double_P(p:double_P pointer, a:int, b:int,
 double_P_alloc_table:double_P alloc_table) =
 ((offset_min(double_P_alloc_table, p) = a)
 and (offset_max(double_P_alloc_table, p) = b))

predicate strict_valid_root_void_P(p:void_P pointer, a:int, b:int,
 void_P_alloc_table:void_P alloc_table) =
 ((offset_min(void_P_alloc_table, p) = a)
 and (offset_max(void_P_alloc_table, p) = b))

predicate strict_valid_struct_char_P(p:char_P pointer, a:int, b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) = a)
 and (offset_max(char_P_alloc_table, p) = b))

predicate strict_valid_struct_double_P(p:double_P pointer, a:int, b:int,
 double_P_alloc_table:double_P alloc_table) =
 ((offset_min(double_P_alloc_table, p) = a)
 and (offset_max(double_P_alloc_table, p) = b))

predicate strict_valid_struct_void_P(p:void_P pointer, a:int, b:int,
 void_P_alloc_table:void_P alloc_table) =
 ((offset_min(void_P_alloc_table, p) = a)
 and (offset_max(void_P_alloc_table, p) = b))

predicate valid_bitvector_struct_char_P(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_bitvector_struct_double_P(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_bitvector_struct_void_P(p:unit pointer, a:int, b:int,
 bitvector_alloc_table:unit alloc_table) =
 ((offset_min(bitvector_alloc_table, p) = a)
 and (offset_max(bitvector_alloc_table, p) = b))

predicate valid_root_char_P(p:char_P pointer, a:int, b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) <= a)
 and (offset_max(char_P_alloc_table, p) >= b))

predicate valid_root_double_P(p:double_P pointer, a:int, b:int,
 double_P_alloc_table:double_P alloc_table) =
 ((offset_min(double_P_alloc_table, p) <= a)
 and (offset_max(double_P_alloc_table, p) >= b))

predicate valid_root_void_P(p:void_P pointer, a:int, b:int,
 void_P_alloc_table:void_P alloc_table) =
 ((offset_min(void_P_alloc_table, p) <= a)
 and (offset_max(void_P_alloc_table, p) >= b))

predicate valid_struct_char_P(p:char_P pointer, a:int, b:int,
 char_P_alloc_table:char_P alloc_table) =
 ((offset_min(char_P_alloc_table, p) <= a)
 and (offset_max(char_P_alloc_table, p) >= b))

predicate valid_struct_double_P(p:double_P pointer, a:int, b:int,
 double_P_alloc_table:double_P alloc_table) =
 ((offset_min(double_P_alloc_table, p) <= a)
 and (offset_max(double_P_alloc_table, p) >= b))

predicate valid_struct_void_P(p:void_P pointer, a:int, b:int,
 void_P_alloc_table:void_P alloc_table) =
 ((offset_min(void_P_alloc_table, p) <= a)
 and (offset_max(void_P_alloc_table, p) >= b))

logic void_P_tag:  -> void_P tag_id

axiom void_P_int : (int_of_tag(void_P_tag) = (1))

axiom void_P_of_pointer_address_of_pointer_addr :
 (forall p:void_P pointer.
  (p = void_P_of_pointer_address(pointer_address(p))))

axiom void_P_parenttag_bottom : parenttag(void_P_tag, bottom_tag)

axiom void_P_tags :
 (forall x:void_P pointer.
  (forall void_P_tag_table:void_P tag_table.
   instanceof(void_P_tag_table, x, void_P_tag)))

parameter alloc_bitvector_struct_char_P :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_char_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_char_P_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_char_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_double_P :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_double_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_double_P_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_double_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_void_P :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { } unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_void_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter alloc_bitvector_struct_void_P_requires :
 n:int ->
  bitvector_alloc_table:unit alloc_table ref ->
   { ge_int(n, (0))} unit pointer writes bitvector_alloc_table
   { (valid_bitvector_struct_void_P(result, (0), sub_int(n, (1)),
      bitvector_alloc_table)
     and (alloc_extends(bitvector_alloc_table@, bitvector_alloc_table)
         and alloc_fresh(bitvector_alloc_table@, result, n))) }

parameter char_P_alloc_table : char_P alloc_table ref

parameter char_P_tag_table : char_P tag_table ref

parameter alloc_struct_char_P :
 n:int ->
  char_P_alloc_table:char_P alloc_table ref ->
   char_P_tag_table:char_P tag_table ref ->
    { } char_P pointer writes char_P_alloc_table,char_P_tag_table
    { (strict_valid_struct_char_P(result, (0), sub_int(n, (1)),
       char_P_alloc_table)
      and (alloc_extends(char_P_alloc_table@, char_P_alloc_table)
          and (alloc_fresh(char_P_alloc_table@, result, n)
              and instanceof(char_P_tag_table, result, char_P_tag)))) }

parameter alloc_struct_char_P_requires :
 n:int ->
  char_P_alloc_table:char_P alloc_table ref ->
   char_P_tag_table:char_P tag_table ref ->
    { ge_int(n, (0))} char_P pointer
    writes char_P_alloc_table,char_P_tag_table
    { (strict_valid_struct_char_P(result, (0), sub_int(n, (1)),
       char_P_alloc_table)
      and (alloc_extends(char_P_alloc_table@, char_P_alloc_table)
          and (alloc_fresh(char_P_alloc_table@, result, n)
              and instanceof(char_P_tag_table, result, char_P_tag)))) }

parameter double_P_alloc_table : double_P alloc_table ref

parameter double_P_tag_table : double_P tag_table ref

parameter alloc_struct_double_P :
 n:int ->
  double_P_alloc_table:double_P alloc_table ref ->
   double_P_tag_table:double_P tag_table ref ->
    { } double_P pointer writes double_P_alloc_table,double_P_tag_table
    { (strict_valid_struct_double_P(result, (0), sub_int(n, (1)),
       double_P_alloc_table)
      and (alloc_extends(double_P_alloc_table@, double_P_alloc_table)
          and (alloc_fresh(double_P_alloc_table@, result, n)
              and instanceof(double_P_tag_table, result, double_P_tag)))) }

parameter alloc_struct_double_P_requires :
 n:int ->
  double_P_alloc_table:double_P alloc_table ref ->
   double_P_tag_table:double_P tag_table ref ->
    { ge_int(n, (0))} double_P pointer
    writes double_P_alloc_table,double_P_tag_table
    { (strict_valid_struct_double_P(result, (0), sub_int(n, (1)),
       double_P_alloc_table)
      and (alloc_extends(double_P_alloc_table@, double_P_alloc_table)
          and (alloc_fresh(double_P_alloc_table@, result, n)
              and instanceof(double_P_tag_table, result, double_P_tag)))) }

parameter void_P_alloc_table : void_P alloc_table ref

parameter void_P_tag_table : void_P tag_table ref

parameter alloc_struct_void_P :
 n:int ->
  void_P_alloc_table:void_P alloc_table ref ->
   void_P_tag_table:void_P tag_table ref ->
    { } void_P pointer writes void_P_alloc_table,void_P_tag_table
    { (strict_valid_struct_void_P(result, (0), sub_int(n, (1)),
       void_P_alloc_table)
      and (alloc_extends(void_P_alloc_table@, void_P_alloc_table)
          and (alloc_fresh(void_P_alloc_table@, result, n)
              and instanceof(void_P_tag_table, result, void_P_tag)))) }

parameter alloc_struct_void_P_requires :
 n:int ->
  void_P_alloc_table:void_P alloc_table ref ->
   void_P_tag_table:void_P tag_table ref ->
    { ge_int(n, (0))} void_P pointer
    writes void_P_alloc_table,void_P_tag_table
    { (strict_valid_struct_void_P(result, (0), sub_int(n, (1)),
       void_P_alloc_table)
      and (alloc_extends(void_P_alloc_table@, void_P_alloc_table)
          and (alloc_fresh(void_P_alloc_table@, result, n)
              and instanceof(void_P_tag_table, result, void_P_tag)))) }

parameter any_int8 : unit -> { } int8 { true }

parameter f4 :
 tt:unit ->
  { } double
  { (JC_<somenum>:
    not_assigns(double_P_tab_2_alloc_table@, double_P_double_M_tab_2@,
    double_P_double_M_tab_2, pset_empty)) }

parameter f4_requires :
 tt:unit ->
  { } double
  { (JC_<somenum>:
    not_assigns(double_P_tab_2_alloc_table@, double_P_double_M_tab_2@,
    double_P_double_M_tab_2, pset_empty)) }

parameter g4 :
 t:double_P pointer ->
  double_P_t_1_alloc_table:double_P alloc_table ->
   double_P_double_M_t_1:(double_P, double) memory ->
    { } double
    { (JC_<somenum>:
      eq_real(double_value(result),
      add_real(double_value(select(double_P_double_M_t_1, shift(t@, (0)))),
      double_value(select(double_P_double_M_t_1, shift(t@, (1))))))) }

parameter g4_requires :
 t:double_P pointer ->
  double_P_t_1_alloc_table:double_P alloc_table ->
   double_P_double_M_t_1:(double_P, double) memory ->
    { (JC_<somenum>:
      ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
      and ((JC_<somenum>: ge_int(offset_max(double_P_t_1_alloc_table, t), (0)))
          and ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
              and (JC_<somenum>:
                  ge_int(offset_max(double_P_t_1_alloc_table, t), (1)))))))}
    double
    { (JC_<somenum>:
      eq_real(double_value(result),
      add_real(double_value(select(double_P_double_M_t_1, shift(t@, (0)))),
      double_value(select(double_P_double_M_t_1, shift(t@, (1))))))) }

parameter int8_of_integer_ :
 x:int ->
  { (le_int((-128), x) and le_int(x, (127)))} int8
  { eq_int(integer_of_int8(result), x) }

parameter safe_int8_of_integer_ :
 x:int -> { } int8 { eq_int(integer_of_int8(result), x) }

let f4_ensures_default =
 fun (tt : unit) ->
  { (JC_<somenum>: true) }
  (init:
  (let return = ref (any_double void) in
  try
   begin
     (let double_P_double_M_tab_2 = ref (any_memory void) in
     (let double_P_tab_2_tag_table = ref (any_tag_table void) in
     (let double_P_tab_2_alloc_table = ref (any_alloc_table void) in
     (let tab = ref (any_pointer void) in
     (let r = ref (any_double void) in
     (C_16:
     (C_18:
     (C_20:
     (C_22:
     (C_23:
     begin
       (let jessie_<somenum> =
       (tab := (C_15:
               (JC_<somenum>:
               (((alloc_struct_double_P (2)) double_P_tab_2_alloc_table) double_P_tab_2_tag_table)))) in
       void);
      (let jessie_<somenum> = (double_of_real_exact 1.0) in
      (let jessie_<somenum> = !tab in
      (let jessie_<somenum> = (double_of_real_exact 2.0) in
      (let jessie_<somenum> = !tab in
      (let jessie_<somenum> = (1) in
      (let jessie_<somenum> = ((shift jessie_<somenum>) jessie_<somenum>) in
      [ { } unit reads double_P_double_M_tab_2,double_P_tab_2_alloc_table
        writes double_P_double_M_tab_2
        { (not_assigns(double_P_tab_2_alloc_table, double_P_double_M_tab_2@,
           double_P_double_M_tab_2,
           pset_range(pset_singleton(jessie_<somenum>), (0), (1)))
          and ((select(double_P_double_M_tab_2, shift(jessie_<somenum>, (0))) = jessie_<somenum>)
              and (select(double_P_double_M_tab_2, shift(jessie_<somenum>, (1))) = jessie_<somenum>))) } ]))))));
      (let jessie_<somenum> =
      (r := (C_21:
            (let jessie_<somenum> = !tab in
            (JC_<somenum>:
            (((g4 jessie_<somenum>) !double_P_tab_2_alloc_table) !double_P_double_M_tab_2))))) in
      void); ((safe_free_parameter double_P_tab_2_alloc_table) !tab);
      (return := !r); (raise Return) end)))))))))); absurd  end with
   Return -> !return end))
  { (JC_<somenum>:
    not_assigns(double_P_tab_2_alloc_table@, double_P_double_M_tab_2@,
    double_P_double_M_tab_2, pset_empty)) }

let f4_safety =
 fun (tt : unit) ->
  { (JC_<somenum>: true) }
  (init:
  (let return = ref (any_double void) in
  try
   begin
     (let double_P_double_M_tab_2 = ref (any_memory void) in
     (let double_P_tab_2_tag_table = ref (any_tag_table void) in
     (let double_P_tab_2_alloc_table = ref (any_alloc_table void) in
     (let tab = ref (any_pointer void) in
     (let r = ref (any_double void) in
     (C_16:
     (C_18:
     (C_20:
     (C_22:
     (C_23:
     begin
       (let jessie_<somenum> =
       (tab := (let jessie_<somenum> =
               (C_15:
               (JC_<somenum>:
               (((alloc_struct_double_P_requires (2)) double_P_tab_2_alloc_table) double_P_tab_2_tag_table))) in
               (JC_<somenum>:
               (assert
               { ge_int(offset_max(double_P_tab_2_alloc_table, jessie_<somenum>),
                 (1)) }; jessie_<somenum>)))) in void);
      (let jessie_<somenum> = (double_of_real_exact 1.0) in
      (let jessie_<somenum> = !tab in
      (let jessie_<somenum> = (double_of_real_exact 2.0) in
      (let jessie_<somenum> = !tab in
      (let jessie_<somenum> = (1) in
      (let jessie_<somenum> = ((shift jessie_<somenum>) jessie_<somenum>) in
      [ { } unit reads double_P_double_M_tab_2,double_P_tab_2_alloc_table
        writes double_P_double_M_tab_2
        { (not_assigns(double_P_tab_2_alloc_table, double_P_double_M_tab_2@,
           double_P_double_M_tab_2,
           pset_range(pset_singleton(jessie_<somenum>), (0), (1)))
          and ((select(double_P_double_M_tab_2, shift(jessie_<somenum>, (0))) = jessie_<somenum>)
              and (select(double_P_double_M_tab_2, shift(jessie_<somenum>, (1))) = jessie_<somenum>))) } ]))))));
      (let jessie_<somenum> =
      (r := (C_21:
            (let jessie_<somenum> = !tab in
            (JC_<somenum>:
            (((g4_requires jessie_<somenum>) !double_P_tab_2_alloc_table) !double_P_double_M_tab_2))))) in
      void); ((free_parameter double_P_tab_2_alloc_table) !tab);
      (return := !r); (raise Return) end)))))))))); absurd  end with
   Return -> !return end)) { true }

let g4_ensures_default =
 fun (t : double_P pointer) (double_P_t_1_alloc_table : double_P alloc_table) (double_P_double_M_t_1 : (double_P, double) memory) ->
  { (JC_<somenum>:
    ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
    and ((JC_<somenum>: ge_int(offset_max(double_P_t_1_alloc_table, t), (0)))
        and ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
            and (JC_<somenum>: ge_int(offset_max(double_P_t_1_alloc_table, t), (1))))))) }
  (init:
  (let return = ref (any_double void) in
  try
   begin
     (let y = ref (any_double void) in
     (C_6:
     begin
       (let jessie_<somenum> =
       (y := (C_5:
             (JC_<somenum>:
             (((add_double_safe nearest_even) (C_4:
                                              ((safe_acc_ double_P_double_M_t_1) 
                                               (C_3: ((shift t) (0)))))) 
              (C_2:
              ((safe_acc_ double_P_double_M_t_1) (C_1: ((shift t) (1))))))))) in
       void); (return := !y); (raise Return) end)); absurd  end with
   Return -> !return end))
  { (JC_<somenum>:
    eq_real(double_value(result),
    add_real(double_value(select(double_P_double_M_t_1, shift(t@, (0)))),
    double_value(select(double_P_double_M_t_1, shift(t@, (1))))))) }

let g4_safety =
 fun (t : double_P pointer) (double_P_t_1_alloc_table : double_P alloc_table) (double_P_double_M_t_1 : (double_P, double) memory) ->
  { (JC_<somenum>:
    ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
    and ((JC_<somenum>: ge_int(offset_max(double_P_t_1_alloc_table, t), (0)))
        and ((JC_<somenum>: le_int(offset_min(double_P_t_1_alloc_table, t), (0)))
            and (JC_<somenum>: ge_int(offset_max(double_P_t_1_alloc_table, t), (1))))))) }
  (init:
  (let return = ref (any_double void) in
  try
   begin
     (let y = ref (any_double void) in
     (C_6:
     begin
       (let jessie_<somenum> =
       (y := (C_5:
             (JC_<somenum>:
             (((add_double nearest_even) (C_4:
                                         (JC_<somenum>:
                                         (((acc_ double_P_t_1_alloc_table) double_P_double_M_t_1) t)))) 
              (C_2:
              (JC_<somenum>:
              ((((offset_acc_ double_P_t_1_alloc_table) double_P_double_M_t_1) t) (1)))))))) in
       void); (return := !y); (raise Return) end)); absurd  end with
   Return -> !return end)) { true }


WHYLIB=WHYHOME/lib WHYEXEC=WHYHOME/bin/why.opt GWHYEXEC=WHYHOME/bin/gwhy.opt make --quiet -C dillon3.jessie --quiet -f dillon3.makefile project
why --project [...] why/dillon3.why
