
#InvariantPolicy = Ownership

axiomatic Bag {

  logic type bag

  logic bag emptybag()
  logic bag union(bag b1, bag b2)
  logic bag single(real x)

  logic integer cardinal(bag b)

  axiom cardinal_empty: cardinal(emptybag()) == 0
  axiom cardinal_single: \forall real x; cardinal(single(x)) == 1
  axiom cardinal_union: \forall bag b1,b2; 
     cardinal(union(b1,b2)) == cardinal(b1) + cardinal(b2)

  axiom cardinal_non_empty: \forall bag b; b != emptybag() ==> cardinal(b) > 0

  logic real sumbag(bag b)

  axiom sumbag_empty: sumbag(emptybag()) == 0.0
  axiom sumbag_single: \forall real x; sumbag(single(x)) == x
  axiom sumbag_union: \forall bag b1,b2; 
     sumbag(union(b1,b2)) == sumbag(b1) + sumbag(b2)

}

logic glue_inv{L}(bag c, Calc[0] this) =
   this.count == cardinal(c) && this.sum == sumbag(c)



tag Calc = {

  abstract bag coll;
  integer count;
  real sum;
 
  invariant glue(this) = 
     this.count == cardinal(this.coll) && this.sum == sumbag(this.coll);

}


type Calc = [ Calc ]


unit simupack_reset(Calc[0] this)
  requires \exists bag c; c == emptybag() && glue_inv(c,this) ;
  behavior default:
    assigns this.coll;
    ensures this.coll == emptybag() && glue(this) &&
     \mutable(this,Calc) && this.committed == false;
;

unit reset(Calc[0] this) 
  requires \mutable(this,Calc) && this.committed == false;
  behavior default:
    assigns this.coll,this.count,this.sum;
    ensures this.coll == emptybag() &&
      \mutable(this,Calc) && this.committed == false;
{
  unpack(this);
  this.count = 0;
  this.sum = 0.0;
  simupack_reset(this);
}

unit simupack_add(Calc[0] this, real x)
  requires \exists bag c; c == union(this.coll,single(x)) && glue_inv(c,this) ;
  behavior default:
    assigns this.coll;
    ensures this.coll == union(\old(this.coll),single(x)) && glue(this) &&
      \mutable(this,Calc) && this.committed == false;
;

unit add(Calc[0] this, real x) 
  requires \mutable(this,Calc) && this.committed == false;
  behavior default:
    assigns this.coll,this.count,this.sum;
    ensures this.coll == union(\old(this.coll),single(x)) &&
      \mutable(this,Calc) && this.committed == false;
{
  unpack(this);
  this.count++;
  this.sum += x;
  simupack_add(this,x);
}


real mean(Calc[0] this)
  requires \mutable(this,Calc) && this.committed == false &&
     this.coll != emptybag();
  behavior default:
     assigns \nothing;
     ensures \result == sumbag(this.coll) / cardinal(this.coll);
{
  return this.sum / this.count;
}


lemma hint0: \real_of_integer(2) == 2.0
lemma hint2: \forall integer i; i != 0 ==> \real_of_integer(i) != 0.0
lemma hint1: (14.0 + 17.0) / \real_of_integer(2) == 15.5

unit f(Calc[0] c) 
     requires \mutable(c,Calc) && c.committed == false;
{
  var real m;

  reset(c);
  add(c,14.0);
  add(c,17.0);
  m = mean(c);
  assert cardinal(c.coll) == 2;
  assert sumbag(c.coll) == 31.0;
  assert m==15.5;
}

