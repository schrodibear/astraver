(* This file is generated by Why; do not edit *)

Require Why.
Require Export quicksort2_why.

Definition swap (* validation *)
  : (i: Z)(j: Z)(t: (array Z))(_: (`0 <= i` /\ `i < (array_length t)`) /\
    `0 <= j` /\ `j < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]((exchange t0 t i j)))
  := [i: Z; j: Z; t: (array Z); Pre5: (`0 <= i` /\ `i < (array_length t)`) /\
      `0 <= j` /\ `j < (array_length t)`]
       let Pre4 = (proj1 ? ? Pre5) in
       let (v, Post3) = (exist_1 [result: Z]
         result = (access t i) (access t i) (refl_equal ? (access t i))) in
       let (t0, result, Post4) =
         let Pre2 = Pre4 in
         let Pre3 = (swap_po_1 i j t Pre5 Pre4 v Post3 Pre2) in
         let (t0, result, Post1) = (exist_2 [t1: (array Z)][result1: unit]
           t1 = (store t i (access t j)) (store t i (access t j)) tt
           (refl_equal ? (store t i (access t j)))) in
         let Pre1 = (swap_po_2 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1) in
         let (t1, result0, Post2) = (exist_2 [t2: (array Z)][result2: unit]
           t2 = (store t0 j v) (store t0 j v) tt
           (refl_equal ? (store t0 j v))) in
         (exist_2 [t2: (array Z)][result1: unit](exchange t2 t i j) t1
         result0
         (swap_po_3 i j t Pre5 Pre4 v Post3 Pre2 Pre3 t0 Post1 Pre1 t1 Post2)) in
       (exist_2 [t1: (array Z)][result0: unit](exchange t1 t i j) t0 
       result Post4).

Definition quick_rec (* validation *)
  : (l: Z)(r: Z)(t: (array Z))(_: `0 <= l` /\ `r < (array_length t)`)
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 l r) /\ (sub_permut l r t0 t)))
  := [l: Z; r: Z; t: (array Z); Pre23: `0 <= l` /\ `r < (array_length t)`]
       (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
         [Variant1: Z](l0: Z)(r0: Z)(t0: (array Z))
         (_: Variant1 = `1 + r0 - l0`)(_0: `0 <= l0` /\
         `r0 < (array_length t0)`)
         (sig_2 (array Z) unit [t1: (array Z)][result: unit]
          ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)))
         [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
          (l0: Z)(r0: Z)(t0: (array Z))(_: Variant2 = `1 + r0 - l0`)
          (_0: `0 <= l0` /\ `r0 < (array_length t0)`)
          (sig_2 (array Z) unit [t1: (array Z)][result: unit]
           ((sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0)));
          l0: Z; r0: Z; t0: (array Z); Pre22: Variant1 = `1 + r0 - l0`;
          Pre21: `0 <= l0` /\ `r0 < (array_length t0)`]
           let (result, Bool9) =
             let (result1, Post22) = (Z_lt_ge_bool l0 r0) in
             (exist_1 [result2: bool]
             (if result2 then `l0 < r0` else `l0 >= r0`) result1 Post22) in
           Cases
             (btest
              [result:bool](if result then `l0 < r0` else `l0 >= r0`) result
              Bool9) of
           | (left Test6) =>
               let (t1, result0, Post24) =
                 let Pre20 =
                   (quick_rec_po_1 l r t Pre23 Variant1 l0 r0 t0 Pre22 Pre21
                   Test6) in
                 let (v, Post18) = (exist_1 [result0: Z]
                   result0 = (access t0 l0) (access t0 l0)
                   (refl_equal ? (access t0 l0))) in
                 let (t1, result0, Post25) =
                   let (result0, Post17) = (exist_1 [result0: Z]
                     result0 = l0 l0 (refl_equal ? l0)) in
                   let (m0, t1, result1, Post26) =
                     let (result1, Post16) = (exist_1 [result1: Z]
                       result1 = `l0 + 1` `l0 + 1`
                       (refl_equal ? `l0 + 1`)) in
                     let (i0, m0, t1, result2, Post27) =
                       let (i0, m0, t1, result2, Post15) =
                         (well_founded_induction Z (Zwf ZERO)
                           (Zwf_well_founded `0`) [Variant3: Z](i0: Z)(m0: Z)
                           (t1: (array Z))(_: Variant3 = `1 + r0 - i0`)
                           (_0: ((j:Z)
                                 (`l0 < j` /\ `j <= m0` ->
                                  `(access t1 j) < v`)) /\
                           ((j:Z)
                            (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                           (sub_permut l0 r0 t1 t0) /\
                           `(access t1 l0) = v` /\ (`l0 <= m0` /\
                           `m0 < i0`) /\ `i0 <= r0 + 1`)
                           (sig_4 Z Z (array Z) unit [i1: Z][m1: Z]
                            [t2: (array Z)][result2: unit]
                            ((((j:Z)
                               (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                            ((j:Z)
                             (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                            (sub_permut l0 r0 t2 t0) /\
                            `(access t2 l0) = v` /\ (`l0 <= m1` /\
                            `m1 < i1`) /\ `i1 <= r0 + 1`) /\ `i1 > r0`))
                           [Variant3: Z; wf2: (Variant4: Z)
                            (Pre2: (Zwf `0` Variant4 Variant3))(i0: Z)(m0: Z)
                            (t1: (array Z))(_: Variant4 = `1 + r0 - i0`)
                            (_0: ((j:Z)
                                  (`l0 < j` /\ `j <= m0` ->
                                   `(access t1 j) < v`)) /\
                            ((j:Z)
                             (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                            (sub_permut l0 r0 t1 t0) /\
                            `(access t1 l0) = v` /\ (`l0 <= m0` /\
                            `m0 < i0`) /\ `i0 <= r0 + 1`)
                            (sig_4 Z Z (array Z) unit [i1: Z][m1: Z]
                             [t2: (array Z)][result2: unit]
                             ((((j:Z)
                                (`l0 < j` /\ `j <= m1` -> `(access t2 j) < v`)) /\
                             ((j:Z)
                              (`m1 < j` /\ `j < i1` -> `(access t2 j) >= v`)) /\
                             (sub_permut l0 r0 t2 t0) /\
                             `(access t2 l0) = v` /\ (`l0 <= m1` /\
                             `m1 < i1`) /\ `i1 <= r0 + 1`) /\ `i1 > r0`));
                            i0: Z; m0: Z; t1: (array Z);
                            Pre8: Variant3 = `1 + r0 - i0`;
                            Pre7: ((j:Z)
                                   (`l0 < j` /\ `j <= m0` ->
                                    `(access t1 j) < v`)) /\
                            ((j:Z)
                             (`m0 < j` /\ `j < i0` -> `(access t1 j) >= v`)) /\
                            (sub_permut l0 r0 t1 t0) /\
                            `(access t1 l0) = v` /\ (`l0 <= m0` /\
                            `m0 < i0`) /\ `i0 <= r0 + 1`]
                             let (result2, Bool8) =
                               let (result4, Post28) =
                                 (Z_le_gt_bool i0 r0) in
                               (exist_1 [result5: bool]
                               (if result5 then `i0 <= r0` else `i0 > r0`) 
                               result4 Post28) in
                             Cases
                               (btest
                                [result2:bool]
                                (if result2 then `i0 <= r0` else `i0 > r0`) result2
                                Bool8) of
                             | (left Test5) =>
                                 let (i1, m1, t2, result3, Post15) =
                                   let (i1, m1, t2, result3, Post19) =
                                     let (m1, t2, result3, WP5) =
                                       let (result3, Bool7) =
                                         let result4 =
                                           let Pre3 =
                                             (quick_rec_po_2 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5) in
                                           (Z_lt_ge_bool (access t1 i0)) in
                                         let (result5, Post29) =
                                           (result4 v) in
                                         (exist_1 [result6: bool]
                                         (if result6
                                          then `(access t1 i0) < v`
                                          else `(access t1 i0) >= v`) 
                                         result5 Post29) in
                                       Cases
                                         (btest
                                          [result3:bool]
                                          (if result3
                                           then `(access t1 i0) < v`
                                           else `(access t1 i0) >= v`) result3
                                          Bool7) of
                                       | (left Test4) =>
                                           let (m1, t2, result4, WP5) =
                                             let (m1, result4, Post13) =
                                               let (result4, Post13) =
                                                 (exist_1 [result4: Z]
                                                 result4 = `m0 + 1` `m0 + 1`
                                                 (refl_equal ? `m0 + 1`)) in
                                               (exist_2 [m2: Z]
                                               [result5: unit]
                                               m2 = `m0 + 1` result4 
                                               tt Post13) in
                                             let Pre6 =
                                               (quick_rec_po_3 l r t Pre23
                                               Variant1 l0 r0 t0 Pre22 Pre21
                                               Test6 Pre20 v Post18 result0
                                               Post17 result1 Post16 Variant3
                                               i0 m0 t1 Pre8 Pre7 Test5 Test4
                                               m1 Post13) in
                                             let (t2, result5, Post30) =
                                               let Pre4 = Pre6 in
                                               let Pre5 = Pre4 in
                                               let (t2, result7, Post31) =
                                                 (swap i0 m1 t1 Pre4) in
                                               (exist_2 [t3: (array Z)]
                                               [result8: unit]
                                               (exchange t3 t1 i0 m1) 
                                               t2 result7 Post31) in
                                             (exist_3 [m2: Z][t3: (array Z)]
                                             [result6: unit]
                                             ((i:Z)
                                              (i = `i0 + 1` ->
                                               (((j:Z)
                                                 (`l0 < j` /\ `j <= m2` ->
                                                  `(access t3 j) < v`)) /\
                                               ((j:Z)
                                                (`m2 < j` /\ `j < i` ->
                                                 `(access t3 j) >= v`)) /\
                                               (sub_permut l0 r0 t3 t0) /\
                                               `(access t3 l0) = v` /\
                                               (`l0 <= m2` /\ `m2 < i`) /\
                                               `i <= r0 + 1`) /\
                                               (Zwf `0` `1 + r0 - i` `
                                               1 + r0 - i0`))) m1
                                             t2 result5
                                             (quick_rec_po_4 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5 Test4
                                             m1 Post13 Pre6 t2 Post30)) in
                                           (exist_3 [m2: Z][t3: (array Z)]
                                           [result5: unit]
                                           ((i:Z)
                                            (i = `i0 + 1` ->
                                             (((j:Z)
                                               (`l0 < j` /\ `j <= m2` ->
                                                `(access t3 j) < v`)) /\
                                             ((j:Z)
                                              (`m2 < j` /\ `j < i` ->
                                               `(access t3 j) >= v`)) /\
                                             (sub_permut l0 r0 t3 t0) /\
                                             `(access t3 l0) = v` /\
                                             (`l0 <= m2` /\ `m2 < i`) /\
                                             `i <= r0 + 1`) /\
                                             (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                    i0`))) 
                                           m1 t2 result4 WP5)
                                       | (right Test3) =>
                                           let (result4, WP5) =
                                             (exist_1 [result4: unit]
                                             ((i:Z)
                                              (i = `i0 + 1` ->
                                               (((j:Z)
                                                 (`l0 < j` /\ `j <= m0` ->
                                                  `(access t1 j) < v`)) /\
                                               ((j:Z)
                                                (`m0 < j` /\ `j < i` ->
                                                 `(access t1 j) >= v`)) /\
                                               (sub_permut l0 r0 t1 t0) /\
                                               `(access t1 l0) = v` /\
                                               (`l0 <= m0` /\ `m0 < i`) /\
                                               `i <= r0 + 1`) /\
                                               (Zwf `0` `1 + r0 - i` `
                                               1 + r0 - i0`))) tt
                                             (quick_rec_po_5 l r t Pre23
                                             Variant1 l0 r0 t0 Pre22 Pre21
                                             Test6 Pre20 v Post18 result0
                                             Post17 result1 Post16 Variant3
                                             i0 m0 t1 Pre8 Pre7 Test5 Test3)) in
                                           (exist_3 [m1: Z][t2: (array Z)]
                                           [result5: unit]
                                           ((i:Z)
                                            (i = `i0 + 1` ->
                                             (((j:Z)
                                               (`l0 < j` /\ `j <= m1` ->
                                                `(access t2 j) < v`)) /\
                                             ((j:Z)
                                              (`m1 < j` /\ `j < i` ->
                                               `(access t2 j) >= v`)) /\
                                             (sub_permut l0 r0 t2 t0) /\
                                             `(access t2 l0) = v` /\
                                             (`l0 <= m1` /\ `m1 < i`) /\
                                             `i <= r0 + 1`) /\
                                             (Zwf `0` `1 + r0 - i` `1 + r0 -
                                                                    i0`))) 
                                           m0 t1 result4 WP5) end in
                                     let (i1, result4, Post14) =
                                       let (result4, Post14) =
                                         (exist_1 [result4: Z]
                                         result4 = `i0 + 1` `i0 + 1`
                                         (refl_equal ? `i0 + 1`)) in
                                       (exist_2 [i2: Z][result5: unit]
                                       i2 = `i0 + 1` result4 tt Post14) in
                                     (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                     [result5: unit]
                                     (((j:Z)
                                       (`l0 < j` /\ `j <= m2` ->
                                        `(access t3 j) < v`)) /\
                                     ((j:Z)
                                      (`m2 < j` /\ `j < i2` ->
                                       `(access t3 j) >= v`)) /\
                                     (sub_permut l0 r0 t3 t0) /\
                                     `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                     `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                     (Zwf `0` `1 + r0 - i2` `1 + r0 - i0`) 
                                     i1 m1 t2 result4
                                     let HW_3 = (WP5 i1 Post14) in
                                     HW_3) in
                                   ((wf2 `1 + r0 - i1`)
                                     (loop_variant_1 Pre8 Post19) i1 
                                     m1 t2 (refl_equal ? `1 + r0 - i1`)
                                     (proj1 ? ? Post19)) in
                                 (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                 [result4: unit]
                                 (((j:Z)
                                   (`l0 < j` /\ `j <= m2` ->
                                    `(access t3 j) < v`)) /\
                                 ((j:Z)
                                  (`m2 < j` /\ `j < i2` ->
                                   `(access t3 j) >= v`)) /\
                                 (sub_permut l0 r0 t3 t0) /\
                                 `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                 `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                 `i2 > r0` i1 m1 t2 result3 Post15)
                             | (right Test2) =>
                                 let (i1, m1, t2, result3, Post15) =
                                   (exist_4 [i1: Z][m1: Z][t2: (array Z)]
                                   [result3: unit]
                                   (((j:Z)
                                     (`l0 < j` /\ `j <= m1` ->
                                      `(access t2 j) < v`)) /\
                                   ((j:Z)
                                    (`m1 < j` /\ `j < i1` ->
                                     `(access t2 j) >= v`)) /\
                                   (sub_permut l0 r0 t2 t0) /\
                                   `(access t2 l0) = v` /\ (`l0 <= m1` /\
                                   `m1 < i1`) /\ `i1 <= r0 + 1`) /\
                                   `i1 > r0` i0 m0 t1 tt
                                   (conj ? ? Pre7 Test2)) in
                                 (exist_4 [i2: Z][m2: Z][t3: (array Z)]
                                 [result4: unit]
                                 (((j:Z)
                                   (`l0 < j` /\ `j <= m2` ->
                                    `(access t3 j) < v`)) /\
                                 ((j:Z)
                                  (`m2 < j` /\ `j < i2` ->
                                   `(access t3 j) >= v`)) /\
                                 (sub_permut l0 r0 t3 t0) /\
                                 `(access t3 l0) = v` /\ (`l0 <= m2` /\
                                 `m2 < i2`) /\ `i2 <= r0 + 1`) /\
                                 `i2 > r0` i1 m1 t2 result3 Post15) end
                           `1 + r0 - result1` result1 result0 t0
                           (refl_equal ? `1 + r0 - result1`)
                           (quick_rec_po_6 l r t Pre23 Variant1 l0 r0 t0
                           Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                           result1 Post16)) in
                       let Pre19 =
                         (quick_rec_po_7 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15) in
                       let (t2, result3, Post32) =
                         let Pre9 = Pre19 in
                         let Pre10 = Pre9 in
                         let (t2, result5, Post33) = (swap l0 m0 t1 Pre9) in
                         (exist_2 [t3: (array Z)][result6: unit]
                         (exchange t3 t1 l0 m0) t2 result5 Post33) in
                       let Pre18 =
                         (quick_rec_po_8 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15 Pre19 t2 Post32) in
                       let (t3, result4, Post34) =
                         let Pre12 = Pre18 in
                         let Pre13 = Pre12 in
                         let (t3, result6, Post35) =
                           ((wf1 `1 + (m0 - 1) - l0`)
                             (quick_rec_po_9 l r t Pre23 Variant1 l0 r0 t0
                             Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                             result1 Post16 i0 m0 t1 Post15 Pre19 t2 Post32
                             Pre18 Pre12 Pre13) l0 `m0 - 1` t2
                             (refl_equal ? `1 + (m0 - 1) - l0`) Pre13) in
                         (exist_2 [t4: (array Z)][result7: unit]
                         (sorted_array t4 l0 `m0 - 1`) /\
                         (sub_permut l0 `m0 - 1` t4 t2) t3 result6 Post35) in
                       let Pre17 =
                         (quick_rec_po_10 l r t Pre23 Variant1 l0 r0 t0 Pre22
                         Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                         Post16 i0 m0 t1 Post15 Pre19 t2 Post32 Pre18 t3
                         Post34) in
                       let (t4, result5, Post36) =
                         let Pre15 = Pre17 in
                         let Pre16 = Pre15 in
                         let (t4, result7, Post37) =
                           ((wf1 `1 + r0 - (m0 + 1)`)
                             (quick_rec_po_11 l r t Pre23 Variant1 l0 r0 t0
                             Pre22 Pre21 Test6 Pre20 v Post18 result0 Post17
                             result1 Post16 i0 m0 t1 Post15 Pre19 t2 Post32
                             Pre18 t3 Post34 Pre17 Pre15 Pre16) `m0 + 1` 
                             r0 t3 (refl_equal ? `1 + r0 - (m0 + 1)`) Pre16) in
                         (exist_2 [t5: (array Z)][result8: unit]
                         (sorted_array t5 `m0 + 1` r0) /\
                         (sub_permut `m0 + 1` r0 t5 t3) t4 result7 Post37) in
                       (exist_4 [i1: Z][m1: Z][t5: (array Z)][result6: unit]
                       (sorted_array t5 l0 r0) /\ (sub_permut l0 r0 t5 t0) 
                       i0 m0 t4 result5
                       (quick_rec_po_12 l r t Pre23 Variant1 l0 r0 t0 Pre22
                       Pre21 Test6 Pre20 v Post18 result0 Post17 result1
                       Post16 i0 m0 t1 Post15 Pre19 t2 Post32 Pre18 t3 Post34
                       Pre17 t4 Post36)) in
                     (exist_3 [m1: Z][t2: (array Z)][result3: unit]
                     (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                     m0 t1 result2 Post27) in
                   (exist_2 [t2: (array Z)][result2: unit]
                   (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                   t1 result1 Post26) in
                 (exist_2 [t2: (array Z)][result1: unit]
                 (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) 
                 t1 result0 Post25) in
               (exist_2 [t2: (array Z)][result1: unit]
               (sorted_array t2 l0 r0) /\ (sub_permut l0 r0 t2 t0) t1 
               result0 Post24)
           | (right Test1) =>
               let (result0, Post23) = (exist_1 [result0: unit]
                 (sorted_array t0 l0 r0) /\ (sub_permut l0 r0 t0 t0) 
                 tt
                 (quick_rec_po_13 l r t Pre23 Variant1 l0 r0 t0 Pre22 Pre21
                 Test1)) in
               (exist_2 [t1: (array Z)][result1: unit]
               (sorted_array t1 l0 r0) /\ (sub_permut l0 r0 t1 t0) t0 
               result0 Post23) end `1 + r - l` l r t
         (refl_equal ? `1 + r - l`) Pre23).

Definition quicksort (* validation *)
  : (t: (array Z))
    (sig_2 (array Z) unit [t0: (array Z)][result: unit]
     ((sorted_array t0 `0` `(array_length t0) - 1`) /\ (permut t0 t)))
  := [t: (array Z)]
       let Pre1 = (quicksort_po_1 t) in
       let (t0, result1, Post1) =
         (quick_rec `0` `(array_length t) - 1` t Pre1) in
       (exist_2 [t1: (array Z)][result2: unit]
       (sorted_array t1 `0` `(array_length t1) - 1`) /\ (permut t1 t) 
       t0 result1 (quicksort_po_2 t Pre1 t0 Post1)).

