(* This file is generated by Why; do not edit *)

Require Why.
Require Export peano_why.

Definition add1 (* validation *)
  : (y: Z)(x: Z)(_: `y >= 0`)
    (sig_2 Z unit [x0: Z][result: unit](`x0 = x + y`))
  := [y: Z; x: Z; Pre3: `y >= 0`]
       let (x0, result, Post4) =
         let (z, Post3) = (exist_1 [result: Z]result = y y
           (refl_equal ? y)) in
         let (x0, z1, result, I) =
           (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
             [Variant1: Z](x0: Z)(z1: Z)(_: Variant1 = z1)(I: `0 <= z1` /\
             `x0 = x + (y - z1)`)
             (sig_3 Z Z unit [x1: Z][z2: Z][result: unit]((`0 <= z2` /\
              `x1 = x + (y - z2)`) /\ `z2 <= 0`))
             [Variant1: Z; wf1: (Variant2: Z)
              (Pre1: (Zwf `0` Variant2 Variant1))(x0: Z)(z1: Z)
              (_: Variant2 = z1)(I: `0 <= z1` /\ `x0 = x + (y - z1)`)
              (sig_3 Z Z unit [x1: Z][z2: Z][result: unit]((`0 <= z2` /\
               `x1 = x + (y - z2)`) /\ `z2 <= 0`));
              x0: Z; z1: Z; Pre2: Variant1 = z1; I: `0 <= z1` /\
              `x0 = x + (y - z1)`]
               let (result, Bool1) =
                 let (result1, Post5) = (Z_gt_le_bool z1 `0`) in
                 (exist_1 [result2: bool]
                 (if result2 then `z1 > 0` else `z1 <= 0`) result1 Post5) in
               Cases
                 (btest
                  [result:bool](if result then `z1 > 0` else `z1 <= 0`) result
                  Bool1) of
               | (left Test2) =>
                   let (x1, z2, result0, I0) =
                     let (x1, z2, result0, I0) =
                       let (x1, result0, Post1) =
                         let (result0, Post1) = (exist_1 [result0: Z]
                           result0 = `x0 + 1` `x0 + 1`
                           (refl_equal ? `x0 + 1`)) in
                         (exist_2 [x2: Z][result1: unit]x2 = `x0 + 1` 
                         result0 tt Post1) in
                       let (z2, result1, Post2) =
                         let (result1, Post2) = (exist_1 [result1: Z]
                           result1 = `z1 - 1` `z1 - 1`
                           (refl_equal ? `z1 - 1`)) in
                         (exist_2 [z3: Z][result2: unit]z3 = `z1 - 1` 
                         result1 tt Post2) in
                       (exist_3 [x2: Z][z3: Z][result2: unit](`0 <= z3` /\
                       `x2 = x + (y - z3)`) /\ (Zwf `0` z3 z1) x1 z2 
                       result1
                       (add1_po_1 y x Pre3 z Post3 Variant1 x0 z1 Pre2 I
                       Test2 x1 Post1 z2 Post2)) in
                     ((wf1 z2) (loop_variant_1 Pre2 I0) x1 z2
                       (refl_equal ? z2) (proj1 ? ? I0)) in
                   (exist_3 [x2: Z][z3: Z][result1: unit](`0 <= z3` /\
                   `x2 = x + (y - z3)`) /\ `z3 <= 0` x1 z2 result0 I0)
               | (right Test1) =>
                   let (x1, z2, result0, I0) = (exist_3 [x1: Z][z2: Z]
                     [result0: unit](`0 <= z2` /\ `x1 = x + (y - z2)`) /\
                     `z2 <= 0` x0 z1 tt (conj ? ? I Test1)) in
                   (exist_3 [x2: Z][z3: Z][result1: unit](`0 <= z3` /\
                   `x2 = x + (y - z3)`) /\ `z3 <= 0` x1 z2 result0 I0) end 
             z x z (refl_equal ? z) (add1_po_2 y x Pre3 z Post3)) in
         (exist_2 [x1: Z][result0: unit]`x1 = x + y` x0 result
         (add1_po_3 y x Pre3 z Post3 x0 z1 I)) in
       (exist_2 [x1: Z][result0: unit]`x1 = x + y` x0 result Post4).

Definition u1 (* validation *)
  : unit
  := let (r, Post1) = (exist_1 [result: Z]result = `3` `3`
       (refl_equal ? `3`)) in
     let (r1, result, Post2) =
       let Pre1 = (u1_po_1 r Post1) in
       let (r1, result1, Post3) = (add1 `7` r Pre1) in
       (exist_2 [r2: Z][result2: unit]`r2 = 10` r1 result1
       (u1_po_2 r Post1 Pre1 r1 Post3)) in
     result.

Definition rec_add1 (* validation *)
  : (y: Z)(x: Z)(_: `y >= 0`)
    (sig_2 Z unit [x0: Z][result: unit](`x0 = x + y`))
  := [y: Z; x: Z; Pre8: `y >= 0`]
       (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `0`)
         [Variant1: Z](y0: Z)(x0: Z)(_: Variant1 = y0)(_0: `y0 >= 0`)
         (sig_2 Z unit [x1: Z][result: unit](`x1 = x0 + y0`))
         [Variant1: Z; wf1: (Variant2: Z)(Pre1: (Zwf `0` Variant2 Variant1))
          (y0: Z)(x0: Z)(_: Variant2 = y0)(_0: `y0 >= 0`)
          (sig_2 Z unit [x1: Z][result: unit](`x1 = x0 + y0`)); y0: Z; x0: Z;
          Pre7: Variant1 = y0; Pre6: `y0 >= 0`]
           let (result, Bool3) =
             let (result1, Post5) = (Z_lt_ge_bool `0` y0) in
             (exist_1 [result2: bool]
             (if result2 then `0 < y0` else `0 >= y0`) result1 Post5) in
           Cases
             (btest
              [result:bool](if result then `0 < y0` else `0 >= y0`) result
              Bool3) of
           | (left Test2) =>
               let (x1, result0, Post7) =
                 let (x1, result0, Post3) =
                   let (result0, Post3) = (exist_1 [result0: Z]
                     result0 = `x0 + 1` `x0 + 1` (refl_equal ? `x0 + 1`)) in
                   (exist_2 [x2: Z][result1: unit]x2 = `x0 + 1` result0 
                   tt Post3) in
                 let Pre5 =
                   (rec_add1_po_1 y Pre8 Variant1 y0 x0 Pre7 Pre6 Test2 x1
                   Post3) in
                 let (x2, result1, Post8) =
                   let Pre3 = Pre5 in
                   let Pre4 = Pre3 in
                   let (x2, result3, Post9) =
                     ((wf1 `y0 - 1`)
                       (rec_add1_po_2 y Pre8 Variant1 y0 x0 Pre7 Pre6 Test2
                       x1 Post3 Pre5 Pre3 Pre4) `y0 - 1` x1
                       (refl_equal ? `y0 - 1`) Pre4) in
                   (exist_2 [x3: Z][result4: unit]`x3 = x1 + (y0 - 1)` 
                   x2 result3 Post9) in
                 (exist_2 [x3: Z][result2: unit]`x3 = x0 + y0` x2 result1
                 (rec_add1_po_3 y Pre8 Variant1 y0 x0 Pre7 Pre6 Test2 x1
                 Post3 Pre5 x2 Post8)) in
               (exist_2 [x2: Z][result1: unit]`x2 = x0 + y0` x1 result0
               Post7)
           | (right Test1) =>
               let (result0, Post6) = (exist_1 [result0: unit]
                 `x0 = x0 + y0` tt
                 (rec_add1_po_4 y Pre8 Variant1 y0 x0 Pre7 Pre6 Test1)) in
               (exist_2 [x1: Z][result1: unit]`x1 = x0 + y0` x0 result0
               Post6) end y y x (refl_equal ? y) Pre8).

Definition u11 (* validation *)
  : unit
  := let (r, Post1) = (exist_1 [result: Z]result = `3` `3`
       (refl_equal ? `3`)) in
     let (r1, result, Post2) =
       let Pre1 = (u11_po_1 r Post1) in
       let (r1, result1, Post3) = (rec_add1 `7` r Pre1) in
       (exist_2 [r2: Z][result2: unit]`r2 = 10` r1 result1
       (u11_po_2 r Post1 Pre1 r1 Post3)) in
     result.

Definition mult1 (* validation *)
  : (y: Z)(x: Z)(_: `x >= 0` /\ `y >= 0`)
    (sig_2 Z unit [x0: Z][result: unit](`x0 = x * y`))
  := [y: Z; x: Z; Pre6: `x >= 0` /\ `y >= 0`]
       let (x0, result, Post5) =
         let (z, Post4) = (exist_1 [result: Z]result = y y
           (refl_equal ? y)) in
         let (x0, z1, result, Post6) =
           let (savex, Post3) = (exist_1 [result: Z]result = x x
             (refl_equal ? x)) in
           let (x0, z1, result, Post7) =
             let (x0, result, Post1) =
               let (result, Post1) = (exist_1 [result: Z]result = `0` 
                 `0` (refl_equal ? `0`)) in
               (exist_2 [x1: Z][result0: unit]x1 = `0` result tt Post1) in
             let (x1, z1, result0, I) =
               (well_founded_induction Z (Zwf ZERO) (Zwf_well_founded `
                 0`) [Variant1: Z](x1: Z)(z1: Z)(_: Variant1 = z1)
                 (I: `0 <= z1` /\ `x1 = x * (y - z1)`)
                 (sig_3 Z Z unit [x2: Z][z2: Z][result0: unit]((`0 <= z2` /\
                  `x2 = x * (y - z2)`) /\ `z2 <= 0`))
                 [Variant1: Z; wf1: (Variant2: Z)
                  (Pre1: (Zwf `0` Variant2 Variant1))(x1: Z)(z1: Z)
                  (_: Variant2 = z1)(I: `0 <= z1` /\ `x1 = x * (y - z1)`)
                  (sig_3 Z Z unit [x2: Z][z2: Z][result0: unit]((`0 <= z2` /\
                   `x2 = x * (y - z2)`) /\ `z2 <= 0`));
                  x1: Z; z1: Z; Pre5: Variant1 = z1; I: `0 <= z1` /\
                  `x1 = x * (y - z1)`]
                   let (result0, Bool1) =
                     let (result2, Post8) = (Z_gt_le_bool z1 `0`) in
                     (exist_1 [result3: bool]
                     (if result3 then `z1 > 0` else `z1 <= 0`) result2 Post8) in
                   Cases
                     (btest
                      [result0:bool](if result0 then `z1 > 0` else `z1 <= 0`) result0
                      Bool1) of
                   | (left Test2) =>
                       let (x2, z2, result1, I0) =
                         let (x2, z2, result1, I0) =
                           let Pre4 =
                             (mult1_po_1 y x Pre6 z Post4 savex Post3 x0
                             Post1 Variant1 x1 z1 Pre5 I Test2) in
                           let (x2, result1, Post9) =
                             let Pre2 = Pre4 in
                             let Pre3 = Pre2 in
                             let (x2, result3, Post10) =
                               (add1 savex x1 Pre2) in
                             (exist_2 [x3: Z][result4: unit]
                             `x3 = x1 + savex` x2 result3 Post10) in
                           let (z2, result2, Post2) =
                             let (result2, Post2) = (exist_1 [result2: Z]
                               result2 = `z1 - 1` `z1 - 1`
                               (refl_equal ? `z1 - 1`)) in
                             (exist_2 [z3: Z][result3: unit]
                             z3 = `z1 - 1` result2 tt Post2) in
                           (exist_3 [x3: Z][z3: Z][result3: unit]
                           (`0 <= z3` /\ `x3 = x * (y - z3)`) /\
                           (Zwf `0` z3 z1) x2 z2 result2
                           (mult1_po_2 y x Pre6 z Post4 savex Post3 x0 Post1
                           Variant1 x1 z1 Pre5 I Test2 Pre4 x2 Post9 z2
                           Post2)) in
                         ((wf1 z2) (loop_variant_1 Pre5 I0) x2 z2
                           (refl_equal ? z2) (proj1 ? ? I0)) in
                       (exist_3 [x3: Z][z3: Z][result2: unit](`0 <= z3` /\
                       `x3 = x * (y - z3)`) /\ `z3 <= 0` x2 z2 result1 I0)
                   | (right Test1) =>
                       let (x2, z2, result1, I0) = (exist_3 [x2: Z][z2: Z]
                         [result1: unit](`0 <= z2` /\ `x2 = x * (y - z2)`) /\
                         `z2 <= 0` x1 z1 tt (conj ? ? I Test1)) in
                       (exist_3 [x3: Z][z3: Z][result2: unit](`0 <= z3` /\
                       `x3 = x * (y - z3)`) /\ `z3 <= 0` x2 z2 result1 I0) end
                 z x0 z (refl_equal ? z)
                 (mult1_po_3 y x Pre6 z Post4 savex Post3 x0 Post1)) in
             (exist_3 [x2: Z][z2: Z][result1: unit]`x2 = x * y` x1 z1 
             result0
             (mult1_po_4 y x Pre6 z Post4 savex Post3 x0 Post1 x1 z1 I)) in
           (exist_3 [x1: Z][z2: Z][result0: unit]`x1 = x * y` x0 z1 result
           Post7) in
         (exist_2 [x1: Z][result0: unit]`x1 = x * y` x0 result Post6) in
       (exist_2 [x1: Z][result0: unit]`x1 = x * y` x0 result Post5).

Definition u2 (* validation *)
  : unit
  := let (r, Post1) = (exist_1 [result: Z]result = `4` `4`
       (refl_equal ? `4`)) in
     let (r1, result, Post2) =
       let Pre1 = (u2_po_1 r Post1) in
       let (r1, result1, Post3) = (mult1 `6` r Pre1) in
       (exist_2 [r2: Z][result2: unit]`r2 = 24` r1 result1
       (u2_po_2 r Post1 Pre1 r1 Post3)) in
     result.

