(* This file is generated by Why; do not edit *)

Require Why.
Require Export swap0_why.

Definition swap1 (* validation *)
  : (x: Z)(y: Z)
    (sig_3 Z Z unit [x0: Z][y0: Z][result: unit](`x0 = y` /\ `y0 = x`))
  := [x: Z; y: Z]
       let (t, Post3) = (exist_1 [result: Z]result = x x (refl_equal ? x)) in
       let (x0, y0, result, Post4) =
         let (x0, result, Post1) =
           let (result, Post1) = (exist_1 [result: Z]result = y y
             (refl_equal ? y)) in
           (exist_2 [x1: Z][result0: unit]x1 = y result tt Post1) in
         let (y0, result0, Post2) =
           let (result0, Post2) = (exist_1 [result0: Z]result0 = t t
             (refl_equal ? t)) in
           (exist_2 [y1: Z][result1: unit]y1 = t result0 tt Post2) in
         (exist_3 [x1: Z][y1: Z][result1: unit]`x1 = y` /\ `y1 = x` x0 
         y0 result0 (swap1_po_1 x y t Post3 x0 Post1 y0 Post2)) in
       (exist_3 [x1: Z][y1: Z][result0: unit]`x1 = y` /\ `y1 = x` x0 
       y0 result Post4).

Definition swap2 (* validation *)
  : (x: Z)(y: Z)
    (sig_3 Z Z unit [x0: Z][y0: Z][result: unit](`x0 = y` /\ `y0 = x`))
  := [x: Z; y: Z]
       let (x0, y0, result, Post4) =
         let (t, Post3) = (exist_1 [result: Z]result = x x
           (refl_equal ? x)) in
         let (x0, y0, result, Post5) =
           let (x0, result, Post1) =
             let (result, Post1) = (exist_1 [result: Z]result = y y
               (refl_equal ? y)) in
             (exist_2 [x1: Z][result0: unit]x1 = y result tt Post1) in
           let (y0, result0, Post2) =
             let (result0, Post2) = (exist_1 [result0: Z]result0 = t 
               t (refl_equal ? t)) in
             (exist_2 [y1: Z][result1: unit]y1 = t result0 tt Post2) in
           (exist_3 [x1: Z][y1: Z][result1: unit]`x1 = y` /\ `y1 = x` 
           x0 y0 result0 (swap2_po_1 x y t Post3 x0 Post1 y0 Post2)) in
         (exist_3 [x1: Z][y1: Z][result0: unit]`x1 = y` /\ `y1 = x` x0 
         y0 result Post5) in
       (exist_3 [x1: Z][y1: Z][result0: unit]`x1 = y` /\ `y1 = x` x0 
       y0 result Post4).

Definition swap3 (* validation *)
  : (a: Z)(b: Z)
    (sig_3 Z Z unit [a0: Z][b0: Z][result: unit](`a0 = b` /\ `b0 = a`))
  := [a: Z; b: Z]
       let (t, Post3) = (exist_1 [result: Z]result = a a (refl_equal ? a)) in
       let (a0, b0, result, Post4) =
         let (a0, result, Post1) =
           let (result, Post1) = (exist_1 [result: Z]result = b b
             (refl_equal ? b)) in
           (exist_2 [a1: Z][result0: unit]a1 = b result tt Post1) in
         let (b0, result0, Post2) =
           let (result0, Post2) = (exist_1 [result0: Z]result0 = t t
             (refl_equal ? t)) in
           (exist_2 [b1: Z][result1: unit]b1 = t result0 tt Post2) in
         (exist_3 [a1: Z][b1: Z][result1: unit]`a1 = b` /\ `b1 = a` a0 
         b0 result0 (swap3_po_1 a b t Post3 a0 Post1 b0 Post2)) in
       (exist_3 [a1: Z][b1: Z][result0: unit]`a1 = b` /\ `b1 = a` a0 
       b0 result Post4).

Definition test_swap3 (* validation *)
  : unit
  := let (c, Post2) = (exist_1 [result: Z]result = `1` `1`
       (refl_equal ? `1`)) in
     let (c1, result) =
       let (d, Post1) = (exist_1 [result: Z]result = `2` `2`
         (refl_equal ? `2`)) in
       let (c1, d1, result, Post3) =
         let (c1, d1, result0, Post4) = (swap3 c d) in
         (exist_3 [c2: Z][d2: Z][result1: unit]`d2 = 1` c1 d1 result0
         (test_swap3_po_1 c Post2 d Post1 c1 d1 Post4)) in
       (Build_tuple_2 c1 result) in
     result.

Definition call_swap3_x_y (* validation *)
  : (x: Z)(y: Z)
    (sig_3 Z Z unit [x0: Z][y0: Z][result: unit](`x0 = y` /\ `y0 = x`))
  := [x: Z; y: Z]
       let (x0, y0, result0, Post1) = (swap3 x y) in
       (exist_3 [x1: Z][y1: Z][result1: unit]`x1 = y` /\ `y1 = x` x0 
       y0 result0 Post1).

Definition call_swap3_y_x (* validation *)
  : (x: Z)(y: Z)
    (sig_3 Z Z unit [x0: Z][y0: Z][result: unit](`x0 = y` /\ `y0 = x`))
  := [x: Z; y: Z]
       let (y0, x0, result0, Post1) = (swap3 y x) in
       (exist_3 [x1: Z][y1: Z][result1: unit]`x1 = y` /\ `y1 = x` x0 
       y0 result0 (call_swap3_y_x_po_1 x y y0 x0 Post1)).

Definition swap4 (* validation *)
  : (a: Z)(b: Z)(tmp: Z)
    (sig_4 Z Z Z unit [a0: Z][b0: Z][tmp0: Z][result: unit](`a0 = b` /\
     `b0 = a`))
  := [a: Z; b: Z; tmp: Z]
       let (tmp0, result, Post1) =
         let (result, Post1) = (exist_1 [result: Z]result = a a
           (refl_equal ? a)) in
         (exist_2 [tmp1: Z][result0: unit]tmp1 = a result tt Post1) in
       let (a0, result0, Post2) =
         let (result0, Post2) = (exist_1 [result0: Z]result0 = b b
           (refl_equal ? b)) in
         (exist_2 [a1: Z][result1: unit]a1 = b result0 tt Post2) in
       let (b0, result1, Post3) =
         let (result1, Post3) = (exist_1 [result1: Z]result1 = tmp0 tmp0
           (refl_equal ? tmp0)) in
         (exist_2 [b1: Z][result2: unit]b1 = tmp0 result1 tt Post3) in
       (exist_4 [a1: Z][b1: Z][tmp1: Z][result2: unit]`a1 = b` /\ `b1 = a` 
       a0 b0 tmp0 result1 (swap4_po_1 a b tmp0 Post1 a0 Post2 b0 Post3)).

Definition test_swap4 (* validation *)
  : (tmp: Z)(tuple_2 Z unit)
  := [tmp: Z]
       let (c, Post2) = (exist_1 [result: Z]result = `1` `1`
         (refl_equal ? `1`)) in
       let (c1, tmp0, result) =
         let (d, Post1) = (exist_1 [result: Z]result = `2` `2`
           (refl_equal ? `2`)) in
         let (c1, d1, tmp0, result, Post3) =
           let (c1, d1, tmp0, result0, Post4) = (swap4 c d tmp) in
           (exist_4 [c2: Z][d2: Z][tmp1: Z][result1: unit]`d2 = 1` c1 
           d1 tmp0 result0 (test_swap4_po_1 c Post2 d Post1 c1 d1 Post4)) in
         (Build_tuple_3 c1 tmp0 result) in
       (Build_tuple_2 tmp0 result).

Definition call_swap4_x_y (* validation *)
  : (tmp: Z)(x: Z)(y: Z)(_: `x = 3`)
    (sig_4 Z Z Z unit [tmp0: Z][x0: Z][y0: Z][result: unit](`y0 = 3`))
  := [tmp: Z; x: Z; y: Z; Pre1: `x = 3`]
       let (x0, y0, tmp0, result0, Post1) = (swap4 x y tmp) in
       (exist_4 [tmp1: Z][x1: Z][y1: Z][result1: unit]`y1 = 3` tmp0 x0 
       y0 result0 (call_swap4_x_y_po_1 x y Pre1 x0 y0 Post1)).

Definition call_swap4_y_x (* validation *)
  : (tmp: Z)(x: Z)(y: Z)(_: `x = 3`)
    (sig_4 Z Z Z unit [tmp0: Z][x0: Z][y0: Z][result: unit](`y0 = 3`))
  := [tmp: Z; x: Z; y: Z; Pre1: `x = 3`]
       let (y0, x0, tmp0, result0, Post1) = (swap4 y x tmp) in
       (exist_4 [tmp1: Z][x1: Z][y1: Z][result1: unit]`y1 = 3` tmp0 x0 
       y0 result0 (call_swap4_y_x_po_1 x y Pre1 y0 x0 Post1)).

