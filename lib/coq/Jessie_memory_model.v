(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.

(* Why3 comment *)
(* infix_eq is replaced with (x = x1) by the coq driver *)

(* Why3 comment *)
(* infix_ls is replaced with (x < x1)%Z by the coq driver *)

(* Why3 goal *)
Lemma infix_lseq_def : forall (x:Z) (y:Z), (x <= y)%Z <-> ((x < y)%Z \/
  (x = y)).
intros x y.

Admitted.

(* Why3 comment *)
(* infix_pl is replaced with (x + x1)%Z by the coq driver *)

(* Why3 comment *)
(* prefix_mn is replaced with (-x)%Z by the coq driver *)

(* Why3 comment *)
(* infix_as is replaced with (x * x1)%Z by the coq driver *)

(* Why3 goal *)
Lemma Assoc : forall (x:Z) (y:Z) (z:Z),
  (((x + y)%Z + z)%Z = (x + (y + z)%Z)%Z).
intros x y z.

Admitted.

(* Why3 goal *)
Lemma Unit_def_l : forall (x:Z), ((0%Z + x)%Z = x).
intros x.

Admitted.

(* Why3 goal *)
Lemma Unit_def_r : forall (x:Z), ((x + 0%Z)%Z = x).
intros x.

Admitted.

(* Why3 goal *)
Lemma Inv_def_l : forall (x:Z), (((-x)%Z + x)%Z = 0%Z).
intros x.

Admitted.

(* Why3 goal *)
Lemma Inv_def_r : forall (x:Z), ((x + (-x)%Z)%Z = 0%Z).
intros x.

Admitted.

(* Why3 goal *)
Lemma Comm : forall (x:Z) (y:Z), ((x + y)%Z = (y + x)%Z).
intros x y.

Admitted.

(* Why3 goal *)
Lemma Assoc1 : forall (x:Z) (y:Z) (z:Z),
  (((x * y)%Z * z)%Z = (x * (y * z)%Z)%Z).
intros x y z.

Admitted.

(* Why3 goal *)
Lemma Mul_distr_l : forall (x:Z) (y:Z) (z:Z),
  ((x * (y + z)%Z)%Z = ((x * y)%Z + (x * z)%Z)%Z).
intros x y z.

Admitted.

(* Why3 goal *)
Lemma Mul_distr_r : forall (x:Z) (y:Z) (z:Z),
  (((y + z)%Z * x)%Z = ((y * x)%Z + (z * x)%Z)%Z).
intros x y z.

Admitted.

(* Why3 goal *)
Lemma infix_mn_def : forall (x:Z) (y:Z), ((x - y)%Z = (x + (-y)%Z)%Z).
intros x y.

Admitted.

(* Why3 goal *)
Lemma Comm1 : forall (x:Z) (y:Z), ((x * y)%Z = (y * x)%Z).
intros x y.

Admitted.

(* Why3 goal *)
Lemma Unitary : forall (x:Z), ((1%Z * x)%Z = x).
intros x.

Admitted.

(* Why3 goal *)
Lemma NonTrivialRing : ~ (0%Z = 1%Z).


Admitted.

(* Why3 goal *)
Lemma Refl : forall (x:Z), (x <= x)%Z.
intros x.

Admitted.

(* Why3 goal *)
Lemma Trans : forall (x:Z) (y:Z) (z:Z), (x <= y)%Z -> ((y <= z)%Z ->
  (x <= z)%Z).
intros x y z h1 h2.

Admitted.

(* Why3 goal *)
Lemma Antisymm : forall (x:Z) (y:Z), (x <= y)%Z -> ((y <= x)%Z -> (x = y)).
intros x y h1 h2.

Admitted.

(* Why3 goal *)
Lemma Total : forall (x:Z) (y:Z), (x <= y)%Z \/ (y <= x)%Z.
intros x y.

Admitted.

(* Why3 goal *)
Lemma ZeroLessOne : (0%Z <= 1%Z)%Z.


Admitted.

(* Why3 goal *)
Lemma CompatOrderAdd : forall (x:Z) (y:Z) (z:Z), (x <= y)%Z ->
  ((x + z)%Z <= (y + z)%Z)%Z.
intros x y z h1.

Admitted.

(* Why3 goal *)
Lemma CompatOrderMult : forall (x:Z) (y:Z) (z:Z), (x <= y)%Z ->
  ((0%Z <= z)%Z -> ((x * z)%Z <= (y * z)%Z)%Z).
intros x y z h1 h2.

Admitted.

(* Why3 assumption *)
Definition zwf_zero (a:Z) (b:Z): Prop := (0%Z <= a)%Z /\ (a < b)%Z.

(* Why3 goal *)
Definition alloc_table : forall (t:Type), Type.

Admitted.

(* Why3 goal *)
Definition pointer : forall (t:Type), Type.

Admitted.

(* Why3 goal *)
Definition offset_max: forall {t:Type} {t_WT:WhyType t}, (alloc_table t) ->
  (pointer t) -> Z.

Admitted.

(* Why3 goal *)
Definition offset_min: forall {t:Type} {t_WT:WhyType t}, (alloc_table t) ->
  (pointer t) -> Z.

Admitted.

(* Why3 assumption *)
Definition valid {t:Type} {t_WT:WhyType t} (a:(alloc_table t)) (p:(pointer
  t)): Prop := ((offset_min a p) <= 0%Z)%Z /\ (0%Z <= (offset_max a p))%Z.

(* Why3 goal *)
Definition same_block: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (pointer t) -> Prop.

Admitted.

(* Why3 goal *)
Definition sub_pointer: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (pointer t) -> Z.

Admitted.

(* Why3 goal *)
Definition shift: forall {t:Type} {t_WT:WhyType t}, (pointer t) -> Z ->
  (pointer t).

Admitted.

(* Why3 goal *)
Definition null: forall {t:Type} {t_WT:WhyType t}, (pointer t).

Admitted.

(* Why3 goal *)
Lemma shift_zero : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer t)),
  ((shift p 0%Z) = p).
intros t t_WT p.

Admitted.

(* Why3 goal *)
Lemma shift_shift : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer t)),
  forall (i:Z), forall (j:Z), ((shift (shift p i) j) = (shift p (i + j)%Z)).
intros t t_WT p i j.

Admitted.

(* Why3 goal *)
Lemma offset_max_shift : forall {t:Type} {t_WT:WhyType t},
  forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z),
  ((offset_max a (shift p i)) = ((offset_max a p) - i)%Z).
intros t t_WT a p i.

Admitted.

(* Why3 goal *)
Lemma offset_min_shift : forall {t:Type} {t_WT:WhyType t},
  forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z),
  ((offset_min a (shift p i)) = ((offset_min a p) - i)%Z).
intros t t_WT a p i.

Admitted.

(* Why3 goal *)
Lemma neq_shift : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer t)),
  forall (i:Z), forall (j:Z), (~ (i = j)) -> ~ ((shift p i) = (shift p j)).
intros t t_WT p i j h1.

Admitted.

(* Why3 goal *)
Lemma null_pointer : forall {t:Type} {t_WT:WhyType t}, forall (a:(alloc_table
  t)), ((offset_max a (null : (pointer t))) < (offset_min a (null : (pointer
  t))))%Z.
intros t t_WT a.

Admitted.

(* Why3 goal *)
Lemma andb_def : forall (x:bool) (y:bool),
  ((Init.Datatypes.andb x y) = match x with
  | true => y
  | false => false
  end).
intros x y.

Admitted.

(* Why3 goal *)
Lemma orb_def : forall (x:bool) (y:bool),
  ((Init.Datatypes.orb x y) = match x with
  | false => y
  | true => true
  end).
intros x y.

Admitted.

(* Why3 goal *)
Lemma xorb_def : forall (x:bool) (y:bool),
  ((Init.Datatypes.xorb x y) = match (x,
  y) with
  | (true, false) => true
  | (false, true) => true
  | (_, _) => false
  end).
intros x y.

Admitted.

(* Why3 goal *)
Lemma notb_def : forall (x:bool),
  ((Init.Datatypes.negb x) = match x with
  | false => true
  | true => false
  end).
intros x.

Admitted.

(* Why3 goal *)
Lemma implb_def : forall (x:bool) (y:bool),
  ((Init.Datatypes.implb x y) = match (x,
  y) with
  | (true, false) => false
  | (_, _) => true
  end).
intros x y.

Admitted.

(* Why3 goal *)
Definition eq_pointer_bool: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (pointer t) -> bool.

Admitted.

(* Why3 goal *)
Lemma eq_pointer_bool_def : forall {t:Type} {t_WT:WhyType t},
  forall (p1:(pointer t)) (p2:(pointer t)), ((p1 = p2) ->
  ((eq_pointer_bool p1 p2) = true)) /\ ((~ (p1 = p2)) -> ((eq_pointer_bool p1
  p2) = false)).
intros t t_WT p1 p2.

Admitted.

(* Why3 goal *)
Definition neq_pointer_bool: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (pointer t) -> bool.

Admitted.

(* Why3 goal *)
Lemma neq_pointer_bool_def : forall {t:Type} {t_WT:WhyType t},
  forall (p1:(pointer t)) (p2:(pointer t)), ((~ (p1 = p2)) ->
  ((neq_pointer_bool p1 p2) = true)) /\ ((p1 = p2) -> ((neq_pointer_bool p1
  p2) = false)).
intros t t_WT p1 p2.

Admitted.

(* Why3 goal *)
Lemma same_block_shift_right : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (q:(pointer t)), forall (i:Z), (same_block p
  q) -> (same_block p (shift q i)).
intros t t_WT p q i h1.

Admitted.

(* Why3 goal *)
Lemma same_block_shift_left : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (q:(pointer t)), forall (i:Z), (same_block q
  p) -> (same_block (shift q i) p).
intros t t_WT p q i h1.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_shift : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)) (q:(pointer t)), (same_block p q) -> (p = (shift q
  (sub_pointer p q))).
intros t t_WT p q h1.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_self : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)), ((sub_pointer p p) = 0%Z).
intros t t_WT p.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_zero : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)) (q:(pointer t)), (same_block p q) -> (((sub_pointer p q) = 0%Z) ->
  (p = q)).
intros t t_WT p q h1 h2.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_shift_left : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)) (q:(pointer t)) (i:Z), (same_block p q) ->
  ((sub_pointer (shift p i) q) = ((sub_pointer p q) + i)%Z).
intros t t_WT p q i h1.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_shift_right : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)) (q:(pointer t)) (i:Z), (same_block p q) ->
  ((sub_pointer p (shift q i)) = ((sub_pointer p q) - i)%Z).
intros t t_WT p q i h1.

Admitted.

(* Why3 goal *)
Lemma sub_pointer_neg : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)) (q:(pointer t)), ((sub_pointer p q) = (-(sub_pointer q p))%Z).
intros t t_WT p q.

Admitted.

(* Why3 goal *)
Definition map : forall (a:Type) (b:Type), Type.

Admitted.

(* Why3 goal *)
Definition get: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (map a b) -> a -> b.

Admitted.

(* Why3 goal *)
Definition set: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (map a b) -> a -> b -> (map a b).

Admitted.

(* Why3 goal *)
Lemma Select_eq : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (m:(map a b)), forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) ->
  ((get (set m a1 b1) a2) = b1).
intros a a_WT b b_WT m a1 a2 b1 h1.

Admitted.

(* Why3 goal *)
Lemma Select_neq : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (m:(map a b)), forall (a1:a) (a2:a),
  forall (b1:b), (~ (a1 = a2)) -> ((get (set m a1 b1) a2) = (get m a2)).
intros a a_WT b b_WT m a1 a2 b1 h1.

Admitted.

(* Why3 goal *)
Definition const: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  b -> (map a b).

Admitted.

(* Why3 goal *)
Lemma Const : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (b1:b) (a1:a), ((get (const b1: (map a b)) a1) = b1).
intros a a_WT b b_WT b1 a1.

Admitted.

(* Why3 assumption *)
Definition memory (t:Type) (v:Type) := (map (pointer t) v).

(* Why3 goal *)
Definition pset : forall (t:Type), Type.

Admitted.

(* Why3 goal *)
Definition pset_empty: forall {t:Type} {t_WT:WhyType t}, (pset t).

Admitted.

(* Why3 goal *)
Definition pset_singleton: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (pset t).

Admitted.

(* Why3 goal *)
Definition pset_deref: forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, (map (pointer t) (pointer v)) -> (pset t) ->
  (pset v).

Admitted.

(* Why3 goal *)
Definition pset_union: forall {t:Type} {t_WT:WhyType t}, (pset t) -> (pset
  t) -> (pset t).

Admitted.

(* Why3 goal *)
Definition pset_all: forall {z:Type} {z_WT:WhyType z}, (pset z) -> (pset z).

Admitted.

(* Why3 goal *)
Definition pset_range: forall {t:Type} {t_WT:WhyType t}, (pset t) -> Z ->
  Z -> (pset t).

Admitted.

(* Why3 goal *)
Definition pset_range_left: forall {z:Type} {z_WT:WhyType z}, (pset z) ->
  Z -> (pset z).

Admitted.

(* Why3 goal *)
Definition pset_range_right: forall {z:Type} {z_WT:WhyType z}, (pset z) ->
  Z -> (pset z).

Admitted.

(* Why3 goal *)
Definition in_pset: forall {t:Type} {t_WT:WhyType t}, (pointer t) -> (pset
  t) -> Prop.

Admitted.

(* Why3 assumption *)
Definition pset_disjoint {t:Type} {t_WT:WhyType t} (ps1:(pset t)) (ps2:(pset
  t)): Prop := forall (p:(pointer t)), ~ ((in_pset p ps1) /\ (in_pset p
  ps2)).

(* Why3 goal *)
Lemma in_pset_empty : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)), ~ (in_pset p (pset_empty : (pset t))).
intros t t_WT p.

Admitted.

(* Why3 goal *)
Lemma in_pset_singleton : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (q:(pointer t)), (in_pset p
  (pset_singleton q)) <-> (p = q).
intros t t_WT p q.

Admitted.

(* Why3 goal *)
Lemma in_pset_deref : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v} {p_WT:WhyType (pointer t)} {p_WT:WhyType (pointer v)},
  forall (p:(pointer v)), forall (m:(map (pointer
  t) (pointer v))), forall (q:(pset t)), (in_pset p (pset_deref m q)) <->
  exists r:(pointer t), (in_pset r q) /\ (p = (get m r)).

Admitted.

(* Why3 goal *)
Lemma in_pset_all : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer t)),
  forall (q:(pset t)), (in_pset p (pset_all q)) <-> exists i:Z,
  exists r:(pointer t), (in_pset r q) /\ (p = (shift r i)).
intros t t_WT p q.

Admitted.

(* Why3 goal *)
Lemma in_pset_range : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)), forall (q:(pset t)), forall (a:Z), forall (b:Z), (in_pset p
  (pset_range q a b)) <-> exists i:Z, exists r:(pointer t), (a <= i)%Z /\
  ((i <= b)%Z /\ ((in_pset r q) /\ (p = (shift r i)))).
intros t t_WT p q a b.

Admitted.

(* Why3 goal *)
Lemma in_pset_range_left : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (q:(pset t)), forall (b:Z), (in_pset p
  (pset_range_left q b)) <-> exists i:Z, exists r:(pointer t), (i <= b)%Z /\
  ((in_pset r q) /\ (p = (shift r i))).
intros t t_WT p q b.

Admitted.

(* Why3 goal *)
Lemma in_pset_range_right : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (q:(pset t)), forall (a:Z), (in_pset p
  (pset_range_right q a)) <-> exists i:Z, exists r:(pointer t), (a <= i)%Z /\
  ((in_pset r q) /\ (p = (shift r i))).
intros t t_WT p q a.

Admitted.

(* Why3 goal *)
Lemma in_pset_union : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)), forall (s1:(pset t)), forall (s2:(pset t)), (in_pset p (pset_union s1
  s2)) <-> ((in_pset p s1) \/ (in_pset p s2)).
intros t t_WT p s1 s2.

Admitted.

(* Why3 assumption *)
Definition not_assigns {t:Type} {t_WT:WhyType t} {v:Type} {v_WT:WhyType v}
{p_WT:WhyType (pointer t)} {p_WT:WhyType (pointer v)}
  (a:(alloc_table t)) (m1:(map (pointer t) v)) (m2:(map (pointer t) v))
  (l:(pset t)): Prop := forall (p:(pointer t)), ((valid a p) /\ ~ (in_pset p
  l)) -> ((get m2 p) = (get m1 p)).

(* Why3 goal *)
Lemma not_assigns_refl : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v} {p_WT:WhyType (pointer t)} {p_WT:WhyType (pointer v)}, forall (a:(alloc_table t)), forall (m:(map
  (pointer t) v)), forall (l:(pset t)), (not_assigns a m m l).
intros t t_WT v v_WT a m l.

Admitted.

(* Why3 goal *)
Lemma not_assigns_trans : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v} {p_WT:WhyType (pointer t)} {p_WT:WhyType (pointer v)}, forall (a:(alloc_table t)), forall (m1:(map
  (pointer t) v)), forall (m2:(map (pointer t) v)), forall (m3:(map (pointer
  t) v)), forall (l:(pset t)), (not_assigns a m1 m2 l) -> ((not_assigns a m2
  m3 l) -> (not_assigns a m1 m3 l)).
intros t t_WT v v_WT a m1 m2 m3 l h1 h2.

Admitted.

(* Why3 goal *)
Definition tag_table : forall (t:Type), Type.

Admitted.

(* Why3 goal *)
Definition tag_id : forall (t:Type), Type.

Admitted.

(* Why3 goal *)
Definition int_of_tag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> Z.

Admitted.

(* Why3 goal *)
Definition typeof: forall {t:Type} {t_WT:WhyType t}, (pointer t) -> (tag_id
  t).

Admitted.

(* Why3 goal *)
Definition cast_factor: forall {t:Type} {t_WT:WhyType t}, (tag_id t) ->
  (tag_id t) -> Z.

Admitted.

(* Why3 goal *)
Definition parenttag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> (tag_id
  t) -> Prop.

Admitted.

(* Why3 goal *)
Definition subtag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> (tag_id
  t) -> Prop.

Admitted.

(* Why3 goal *)
Definition subtag_bool: forall {t:Type} {t_WT:WhyType t}, (tag_id t) ->
  (tag_id t) -> bool.

Admitted.

(* Why3 goal *)
Lemma subtag_bool_def : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id
  t)), forall (t2:(tag_id t)), ((subtag_bool t1 t2) = true) <-> (subtag t1
  t2).
intros t t_WT t1 t2.

Admitted.

(* Why3 goal *)
Lemma subtag_refl : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id t)),
  (subtag t1 t1).
intros t t_WT t1.

Admitted.

(* Why3 goal *)
Lemma subtag_parent : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id
  t)), forall (t2:(tag_id t)), forall (t3:(tag_id t)), (subtag t1 t2) ->
  ((parenttag t2 t3) -> (subtag t1 t3)).
intros t t_WT t1 t2 t3 h1 h2.

Admitted.

(* Why3 assumption *)
Definition instanceof {t:Type} {t_WT:WhyType t} (p:(pointer t)) (s:(tag_id
  t)): Prop := (subtag (typeof p) s).

(* Why3 goal *)
Definition instanceof_bool: forall {t:Type} {t_WT:WhyType t}, (pointer t) ->
  (tag_id t) -> bool.

Admitted.

(* Why3 goal *)
Lemma instanceof_bool_def : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)) (s:(tag_id t)), ((instanceof p s) ->
  ((instanceof_bool p s) = true)) /\ ((~ (instanceof p s)) ->
  ((instanceof_bool p s) = false)).
intros t t_WT p s.

Admitted.

(* Why3 goal *)
Definition downcast: forall {t:Type} {t_WT:WhyType t}, (pointer t) -> (tag_id
  t) -> (pointer t).

Admitted.

(* Why3 goal *)
Lemma downcast_reduce : forall {t:Type} {t_WT:WhyType t}, forall (p:(pointer
  t)), forall (s2:(tag_id t)), forall (s1:(tag_id t)), (~ ((cast_factor s1
  s2) = 0%Z)) -> ((downcast (downcast p s1) s2) = (downcast p s2)).
intros t t_WT p s2 s1 h1.

Admitted.

(* Why3 goal *)
Lemma downcast_instanceof : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (s:(tag_id t)), (instanceof p s) ->
  ((downcast p s) = p).
intros t t_WT p s h1.

Admitted.

(* Why3 goal *)
Lemma instanceof_downcast : forall {t:Type} {t_WT:WhyType t},
  forall (p:(pointer t)), forall (s:(tag_id t)), (instanceof (downcast p s)
  s).
intros t t_WT p s.

Admitted.

(* Why3 comment *)
(* abs is replaced with (ZArith.BinInt.Z.abs x) by the coq driver *)

(* Why3 goal *)
Lemma abs_def : forall (x:Z), ((0%Z <= x)%Z ->
  ((ZArith.BinInt.Z.abs x) = x)) /\ ((~ (0%Z <= x)%Z) ->
  ((ZArith.BinInt.Z.abs x) = (-x)%Z)).
intros x.

Admitted.

(* Why3 goal *)
Lemma Abs_le : forall (x:Z) (y:Z), ((ZArith.BinInt.Z.abs x) <= y)%Z <->
  (((-y)%Z <= x)%Z /\ (x <= y)%Z).
intros x y.

Admitted.

(* Why3 goal *)
Lemma Abs_pos : forall (x:Z), (0%Z <= (ZArith.BinInt.Z.abs x))%Z.
intros x.

Admitted.

(* Why3 comment *)
(* div is replaced with (ZArith.BinInt.Z.quot x x1) by the coq driver *)

(* Why3 comment *)
(* mod1 is replaced with (ZArith.BinInt.Z.rem x x1) by the coq driver *)

(* Why3 goal *)
Lemma Div_mod : forall (x:Z) (y:Z), (~ (y = 0%Z)) ->
  (x = ((y * (ZArith.BinInt.Z.quot x y))%Z + (ZArith.BinInt.Z.rem x y))%Z).
intros x y h1.

Admitted.

(* Why3 goal *)
Lemma Div_bound : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (0%Z < y)%Z) ->
  ((0%Z <= (ZArith.BinInt.Z.quot x y))%Z /\
  ((ZArith.BinInt.Z.quot x y) <= x)%Z).
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Mod_bound : forall (x:Z) (y:Z), (~ (y = 0%Z)) ->
  (((-(ZArith.BinInt.Z.abs y))%Z < (ZArith.BinInt.Z.rem x y))%Z /\
  ((ZArith.BinInt.Z.rem x y) < (ZArith.BinInt.Z.abs y))%Z).
intros x y h1.

Admitted.

(* Why3 goal *)
Lemma Div_sign_pos : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (0%Z < y)%Z) ->
  (0%Z <= (ZArith.BinInt.Z.quot x y))%Z.
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Div_sign_neg : forall (x:Z) (y:Z), ((x <= 0%Z)%Z /\ (0%Z < y)%Z) ->
  ((ZArith.BinInt.Z.quot x y) <= 0%Z)%Z.
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Mod_sign_pos : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ ~ (y = 0%Z)) ->
  (0%Z <= (ZArith.BinInt.Z.rem x y))%Z.
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Mod_sign_neg : forall (x:Z) (y:Z), ((x <= 0%Z)%Z /\ ~ (y = 0%Z)) ->
  ((ZArith.BinInt.Z.rem x y) <= 0%Z)%Z.
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Rounds_toward_zero : forall (x:Z) (y:Z), (~ (y = 0%Z)) ->
  ((ZArith.BinInt.Z.abs ((ZArith.BinInt.Z.quot x y) * y)%Z) <= (ZArith.BinInt.Z.abs x))%Z.
intros x y h1.

Admitted.

(* Why3 goal *)
Lemma Div_1 : forall (x:Z), ((ZArith.BinInt.Z.quot x 1%Z) = x).
intros x.

Admitted.

(* Why3 goal *)
Lemma Mod_1 : forall (x:Z), ((ZArith.BinInt.Z.rem x 1%Z) = 0%Z).
intros x.

Admitted.

(* Why3 goal *)
Lemma Div_inf : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (x < y)%Z) ->
  ((ZArith.BinInt.Z.quot x y) = 0%Z).
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Mod_inf : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (x < y)%Z) ->
  ((ZArith.BinInt.Z.rem x y) = x).
intros x y (h1,h2).

Admitted.

(* Why3 goal *)
Lemma Div_mult : forall (x:Z) (y:Z) (z:Z), ((0%Z < x)%Z /\ ((0%Z <= y)%Z /\
  (0%Z <= z)%Z)) ->
  ((ZArith.BinInt.Z.quot ((x * y)%Z + z)%Z x) = (y + (ZArith.BinInt.Z.quot z x))%Z).
intros x y z (h1,(h2,h3)).

Admitted.

(* Why3 goal *)
Lemma Mod_mult : forall (x:Z) (y:Z) (z:Z), ((0%Z < x)%Z /\ ((0%Z <= y)%Z /\
  (0%Z <= z)%Z)) ->
  ((ZArith.BinInt.Z.rem ((x * y)%Z + z)%Z x) = (ZArith.BinInt.Z.rem z x)).
intros x y z (h1,(h2,h3)).

Admitted.

(* Why3 goal *)
Definition bottom_tag: forall {a:Type} {a_WT:WhyType a}, (tag_id a).

Admitted.

(* Why3 goal *)
Lemma bottom_tag_axiom : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id
  t)), (subtag t1 (bottom_tag : (tag_id t))).
intros t t_WT t1.

Admitted.

(* Why3 goal *)
Lemma root_subtag : forall {t:Type} {t_WT:WhyType t}, forall (a:(tag_id t)),
  forall (b:(tag_id t)), forall (c:(tag_id t)), (parenttag a
  (bottom_tag : (tag_id t))) -> ((parenttag b (bottom_tag : (tag_id t))) ->
  ((~ (a = b)) -> ((subtag c a) -> ~ (subtag c b)))).
intros t t_WT a b c h1 h2 h3 h4.

Admitted.

(* Why3 assumption *)
Definition reinterpret_cast_merge {t:Type} {t_WT:WhyType t} (a1:(alloc_table
  t)) (a2:(alloc_table t)) (p:(pointer t)) (s:(tag_id t)) (c:Z): Prop :=
  let ps := (downcast p s) in ((forall (i:Z),
  ((ZArith.BinInt.Z.rem i c) = 0%Z) -> ((downcast (shift p i) s) = (shift ps
  (ZArith.BinInt.Z.quot i c)))) /\ ((forall (i:Z), ((downcast (shift p
  (i * c)%Z) s) = (shift ps i))) /\ (((offset_min a2
  ps) = (ZArith.BinInt.Z.quot (offset_min a1 p) c)) /\ ((offset_max a2
  ps) = ((ZArith.BinInt.Z.quot ((offset_max a1 p) + 1%Z)%Z c) - 1%Z)%Z)))).

(* Why3 assumption *)
Definition reinterpret_cast_split {t:Type} {t_WT:WhyType t} (a1:(alloc_table
  t)) (a2:(alloc_table t)) (p:(pointer t)) (s:(tag_id t)) (c:Z): Prop :=
  let ps := (downcast p s) in ((forall (i:Z), ((downcast (shift p i)
  s) = (shift ps (i * c)%Z))) /\ ((forall (i:Z),
  ((ZArith.BinInt.Z.rem i c) = 0%Z) -> ((downcast (shift p
  (ZArith.BinInt.Z.quot i c)) s) = (shift ps i))) /\ (((offset_min a2
  ps) = (c * (offset_min a1 p))%Z) /\ ((offset_max a2
  ps) = ((c * ((offset_max a1 p) + 1%Z)%Z)%Z - 1%Z)%Z)))).

(* Why3 assumption *)
Definition reinterpret_cast_retain {t:Type} {t_WT:WhyType t} (a1:(alloc_table
  t)) (a2:(alloc_table t)) (p:(pointer t)) (s:(tag_id t)): Prop := let ps :=
  (downcast p s) in ((forall (i:Z), ((downcast (shift p i) s) = (shift ps
  i))) /\ (((offset_min a2 ps) = (offset_min a1 p)) /\ ((offset_max a2
  ps) = (offset_max a1 p)))).

(* Why3 goal *)
Definition bw_compl: Z -> Z.

Admitted.

(* Why3 goal *)
Definition bw_and: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Lemma bw_and_not_null : forall (a:Z), forall (b:Z), (~ ((bw_and a
  b) = 0%Z)) -> ((~ (a = 0%Z)) /\ ~ (b = 0%Z)).
intros a b h1.

Admitted.

(* Why3 goal *)
Definition bw_xor: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Definition bw_or: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Definition pow2: Z -> Z.

Admitted.

(* Why3 goal *)
Lemma pow2_definition : ((pow2 0%Z) = 1%Z) /\ (((pow2 1%Z) = 2%Z) /\
  (((pow2 2%Z) = 4%Z) /\ (((pow2 3%Z) = 8%Z) /\ (((pow2 4%Z) = 16%Z) /\
  (((pow2 5%Z) = 32%Z) /\ (((pow2 6%Z) = 64%Z) /\ (((pow2 7%Z) = 128%Z) /\
  (((pow2 8%Z) = 256%Z) /\ (((pow2 9%Z) = 512%Z) /\
  (((pow2 10%Z) = 1024%Z) /\ (((pow2 11%Z) = 2048%Z) /\
  (((pow2 12%Z) = 4096%Z) /\ (((pow2 13%Z) = 8192%Z) /\
  (((pow2 14%Z) = 16384%Z) /\ (((pow2 15%Z) = 32768%Z) /\
  (((pow2 16%Z) = 65536%Z) /\ (((pow2 17%Z) = 131072%Z) /\
  (((pow2 18%Z) = 262144%Z) /\ (((pow2 19%Z) = 524288%Z) /\
  (((pow2 20%Z) = 1048576%Z) /\ (((pow2 21%Z) = 2097152%Z) /\
  (((pow2 22%Z) = 4194304%Z) /\ (((pow2 23%Z) = 8388608%Z) /\
  (((pow2 24%Z) = 16777216%Z) /\ (((pow2 25%Z) = 33554432%Z) /\
  (((pow2 26%Z) = 67108864%Z) /\ (((pow2 27%Z) = 134217728%Z) /\
  (((pow2 28%Z) = 268435456%Z) /\ (((pow2 29%Z) = 536870912%Z) /\
  (((pow2 30%Z) = 1073741824%Z) /\
  ((pow2 31%Z) = 2147483648%Z))))))))))))))))))))))))))))))).


Admitted.

(* Why3 goal *)
Lemma bw_or_plus : forall (a:Z), forall (b:Z), ((0%Z <= a)%Z /\
  ((0%Z <= b)%Z /\ ((bw_and a b) = 0%Z))) -> ((bw_or a b) = (a + b)%Z).
intros a b (h1,(h2,h3)).

Admitted.

(* Why3 assumption *)
Definition bw_set (pos:Z) (n:Z): Prop := ~ ((bw_and (pow2 pos) n) = 0%Z).

(* Why3 goal *)
Lemma pow2_bw_set : forall (n:Z), forall (m:Z), (bw_set n (pow2 m)) <->
  (n = m).
intros n m.

Admitted.

(* Why3 goal *)
Lemma zero_bw_set : forall (n:Z), ~ (bw_set n 0%Z).
intros n.

Admitted.

(* Why3 goal *)
Lemma zero_bw_set_iff1 : forall (a:Z), forall (n:Z), (a = 0%Z) -> ~ (bw_set n
  a).
intros a n h1.

Admitted.

(* Why3 goal *)
Lemma zero_bw_set_iff2 : forall (a:Z), forall (n:Z), (bw_set n a) ->
  ~ (a = 0%Z).
intros a n h1.

Admitted.

(* Why3 goal *)
Lemma bw_and_self : forall (a:Z), ((bw_and a a) = a).
intros a.

Admitted.

(* Why3 goal *)
Lemma bw_or_self : forall (a:Z), ((bw_or a a) = a).
intros a.

Admitted.

(* Why3 goal *)
Lemma bw_and_definition : forall (n:Z), forall (a:Z), forall (b:Z), (bw_set n
  (bw_and a b)) <-> ((bw_set n a) /\ (bw_set n b)).
intros n a b.

Admitted.

(* Why3 goal *)
Lemma bw_or_definition : forall (n:Z), forall (a:Z), forall (b:Z), (bw_set n
  (bw_or a b)) <-> ((bw_set n a) \/ (bw_set n b)).
intros n a b.

Admitted.

(* Why3 goal *)
Lemma bw_xor_definition : forall (n:Z), forall (a:Z), forall (b:Z), (bw_set n
  (bw_xor a b)) <-> ~ ((bw_set n a) <-> (bw_set n b)).
intros n a b.

Admitted.

(* Why3 goal *)
Lemma bw_compl_definition : forall (n:Z), forall (a:Z), (bw_set n
  (bw_compl a)) <-> ~ (bw_set n a).
intros n a.

Admitted.

(* Why3 goal *)
Lemma bw_and_assoc : forall (a:Z), forall (b:Z), forall (c:Z),
  ((bw_and (bw_and a b) c) = (bw_and a (bw_and b c))).
intros a b c.

Admitted.

(* Why3 goal *)
Lemma bw_or_assoc : forall (a:Z), forall (b:Z), forall (c:Z),
  ((bw_or (bw_or a b) c) = (bw_or a (bw_or b c))).
intros a b c.

Admitted.

(* Why3 goal *)
Lemma bw_xor_assoc : forall (a:Z), forall (b:Z), forall (c:Z),
  ((bw_xor (bw_xor a b) c) = (bw_xor a (bw_xor b c))).
intros a b c.

Admitted.

(* Why3 goal *)
Lemma bw_and_comm : forall (a:Z), forall (b:Z), ((bw_and a b) = (bw_and b
  a)).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_or_comm : forall (a:Z), forall (b:Z), ((bw_or a b) = (bw_or b a)).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_xor_comm : forall (a:Z), forall (b:Z), ((bw_xor a b) = (bw_xor b
  a)).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_and_or_distr : forall (a:Z), forall (b:Z), forall (c:Z), ((bw_and a
  (bw_or b c)) = (bw_or (bw_and a b) (bw_and a c))).
intros a b c.

Admitted.

(* Why3 goal *)
Lemma bw_or_and_distr : forall (a:Z), forall (b:Z), forall (c:Z), ((bw_or a
  (bw_and b c)) = (bw_and (bw_or a b) (bw_or a c))).
intros a b c.

Admitted.

(* Why3 goal *)
Lemma bw_and_mono : forall (a:Z), forall (b:Z), ((0%Z <= a)%Z /\
  (0%Z <= b)%Z) -> (((bw_and a b) <= a)%Z /\ ((bw_and a b) <= b)%Z).
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma bw_or_mono : forall (a:Z), forall (b:Z), ((0%Z <= a)%Z /\
  (0%Z <= b)%Z) -> ((a <= (bw_or a b))%Z /\ (b <= (bw_or a b))%Z).
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma bw_compl_nooverflow_signed : forall (a:Z), ((((-128%Z)%Z <= a)%Z /\
  (a <= 127%Z)%Z) -> (((-128%Z)%Z <= (bw_compl a))%Z /\
  ((bw_compl a) <= 127%Z)%Z)) /\ (((((-32768%Z)%Z <= a)%Z /\
  (a <= 32767%Z)%Z) -> (((-32768%Z)%Z <= (bw_compl a))%Z /\
  ((bw_compl a) <= 32767%Z)%Z)) /\ (((((-2147483648%Z)%Z <= a)%Z /\
  (a <= 2147483647%Z)%Z) -> (((-2147483648%Z)%Z <= (bw_compl a))%Z /\
  ((bw_compl a) <= 2147483647%Z)%Z)) /\
  ((((-9223372036854775808%Z)%Z <= a)%Z /\ (a <= 9223372036854775807%Z)%Z) ->
  (((-9223372036854775808%Z)%Z <= (bw_compl a))%Z /\
  ((bw_compl a) <= 9223372036854775807%Z)%Z)))).
intros a.

Admitted.

(* Why3 goal *)
Lemma bw_or_nooverflow_signed : forall (a:Z), forall (b:Z),
  ((((-128%Z)%Z <= a)%Z /\ ((a <= 127%Z)%Z /\ (((-128%Z)%Z <= b)%Z /\
  (b <= 127%Z)%Z))) -> (((-128%Z)%Z <= (bw_or a b))%Z /\ ((bw_or a
  b) <= 127%Z)%Z)) /\ (((((-32768%Z)%Z <= a)%Z /\ ((a <= 32767%Z)%Z /\
  (((-32768%Z)%Z <= b)%Z /\ (b <= 32767%Z)%Z))) -> (((-32768%Z)%Z <= (bw_or a
  b))%Z /\ ((bw_or a b) <= 32767%Z)%Z)) /\ (((((-2147483648%Z)%Z <= a)%Z /\
  ((a <= 2147483647%Z)%Z /\ (((-2147483648%Z)%Z <= b)%Z /\
  (b <= 2147483647%Z)%Z))) -> (((-2147483648%Z)%Z <= (bw_or a b))%Z /\
  ((bw_or a b) <= 2147483647%Z)%Z)) /\
  ((((-9223372036854775808%Z)%Z <= a)%Z /\ ((a <= 9223372036854775807%Z)%Z /\
  (((-9223372036854775808%Z)%Z <= b)%Z /\
  (b <= 9223372036854775807%Z)%Z))) ->
  (((-9223372036854775808%Z)%Z <= (bw_or a b))%Z /\ ((bw_or a
  b) <= 9223372036854775807%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_and_nooverflow_signed : forall (a:Z), forall (b:Z),
  ((((-128%Z)%Z <= a)%Z /\ ((a <= 127%Z)%Z /\ (((-128%Z)%Z <= b)%Z /\
  (b <= 127%Z)%Z))) -> (((-128%Z)%Z <= (bw_and a b))%Z /\ ((bw_and a
  b) <= 127%Z)%Z)) /\ (((((-32768%Z)%Z <= a)%Z /\ ((a <= 32767%Z)%Z /\
  (((-32768%Z)%Z <= b)%Z /\ (b <= 32767%Z)%Z))) ->
  (((-32768%Z)%Z <= (bw_and a b))%Z /\ ((bw_and a b) <= 32767%Z)%Z)) /\
  (((((-2147483648%Z)%Z <= a)%Z /\ ((a <= 2147483647%Z)%Z /\
  (((-2147483648%Z)%Z <= b)%Z /\ (b <= 2147483647%Z)%Z))) ->
  (((-2147483648%Z)%Z <= (bw_and a b))%Z /\ ((bw_and a
  b) <= 2147483647%Z)%Z)) /\ ((((-9223372036854775808%Z)%Z <= a)%Z /\
  ((a <= 9223372036854775807%Z)%Z /\ (((-9223372036854775808%Z)%Z <= b)%Z /\
  (b <= 9223372036854775807%Z)%Z))) ->
  (((-9223372036854775808%Z)%Z <= (bw_and a b))%Z /\ ((bw_and a
  b) <= 9223372036854775807%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_xor_nooverflow_signed : forall (a:Z), forall (b:Z),
  ((((-128%Z)%Z <= a)%Z /\ ((a <= 127%Z)%Z /\ (((-128%Z)%Z <= b)%Z /\
  (b <= 127%Z)%Z))) -> (((-128%Z)%Z <= (bw_xor a b))%Z /\ ((bw_xor a
  b) <= 127%Z)%Z)) /\ (((((-32768%Z)%Z <= a)%Z /\ ((a <= 32767%Z)%Z /\
  (((-32768%Z)%Z <= b)%Z /\ (b <= 32767%Z)%Z))) ->
  (((-32768%Z)%Z <= (bw_xor a b))%Z /\ ((bw_xor a b) <= 32767%Z)%Z)) /\
  (((((-2147483648%Z)%Z <= a)%Z /\ ((a <= 2147483647%Z)%Z /\
  (((-2147483648%Z)%Z <= b)%Z /\ (b <= 2147483647%Z)%Z))) ->
  (((-2147483648%Z)%Z <= (bw_xor a b))%Z /\ ((bw_xor a
  b) <= 2147483647%Z)%Z)) /\ ((((-9223372036854775808%Z)%Z <= a)%Z /\
  ((a <= 9223372036854775807%Z)%Z /\ (((-9223372036854775808%Z)%Z <= b)%Z /\
  (b <= 9223372036854775807%Z)%Z))) ->
  (((-9223372036854775808%Z)%Z <= (bw_xor a b))%Z /\ ((bw_xor a
  b) <= 9223372036854775807%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_or_nooverflow_unsigned : forall (a:Z), forall (b:Z),
  (((0%Z <= a)%Z /\ ((a <= 255%Z)%Z /\ ((0%Z <= b)%Z /\ (b <= 255%Z)%Z))) ->
  ((0%Z <= (bw_or a b))%Z /\ ((bw_or a b) <= 255%Z)%Z)) /\ ((((0%Z <= a)%Z /\
  ((a <= 65535%Z)%Z /\ ((0%Z <= b)%Z /\ (b <= 65535%Z)%Z))) ->
  ((0%Z <= (bw_or a b))%Z /\ ((bw_or a b) <= 65535%Z)%Z)) /\
  ((((0%Z <= a)%Z /\ ((a <= 4294967295%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 4294967295%Z)%Z))) -> ((0%Z <= (bw_or a b))%Z /\ ((bw_or a
  b) <= 4294967295%Z)%Z)) /\ (((0%Z <= a)%Z /\
  ((a <= 18446744073709551615%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 18446744073709551615%Z)%Z))) -> ((0%Z <= (bw_or a b))%Z /\ ((bw_or a
  b) <= 18446744073709551615%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_and_nooverflow_unsigned : forall (a:Z), forall (b:Z),
  (((0%Z <= a)%Z /\ ((a <= 255%Z)%Z /\ ((0%Z <= b)%Z /\ (b <= 255%Z)%Z))) ->
  ((0%Z <= (bw_and a b))%Z /\ ((bw_and a b) <= 255%Z)%Z)) /\
  ((((0%Z <= a)%Z /\ ((a <= 65535%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 65535%Z)%Z))) -> ((0%Z <= (bw_and a b))%Z /\ ((bw_and a
  b) <= 65535%Z)%Z)) /\ ((((0%Z <= a)%Z /\ ((a <= 4294967295%Z)%Z /\
  ((0%Z <= b)%Z /\ (b <= 4294967295%Z)%Z))) -> ((0%Z <= (bw_and a b))%Z /\
  ((bw_and a b) <= 4294967295%Z)%Z)) /\ (((0%Z <= a)%Z /\
  ((a <= 18446744073709551615%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 18446744073709551615%Z)%Z))) -> ((0%Z <= (bw_and a b))%Z /\
  ((bw_and a b) <= 18446744073709551615%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Lemma bw_xor_nooverflow_unsigned : forall (a:Z), forall (b:Z),
  (((0%Z <= a)%Z /\ ((a <= 255%Z)%Z /\ ((0%Z <= b)%Z /\ (b <= 255%Z)%Z))) ->
  ((0%Z <= (bw_xor a b))%Z /\ ((bw_xor a b) <= 255%Z)%Z)) /\
  ((((0%Z <= a)%Z /\ ((a <= 65535%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 65535%Z)%Z))) -> ((0%Z <= (bw_xor a b))%Z /\ ((bw_xor a
  b) <= 65535%Z)%Z)) /\ ((((0%Z <= a)%Z /\ ((a <= 4294967295%Z)%Z /\
  ((0%Z <= b)%Z /\ (b <= 4294967295%Z)%Z))) -> ((0%Z <= (bw_xor a b))%Z /\
  ((bw_xor a b) <= 4294967295%Z)%Z)) /\ (((0%Z <= a)%Z /\
  ((a <= 18446744073709551615%Z)%Z /\ ((0%Z <= b)%Z /\
  (b <= 18446744073709551615%Z)%Z))) -> ((0%Z <= (bw_xor a b))%Z /\
  ((bw_xor a b) <= 18446744073709551615%Z)%Z)))).
intros a b.

Admitted.

(* Why3 goal *)
Definition lsl: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Lemma lsl_left_positive_returns_positive : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> (0%Z <= (lsl a b))%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsl_left_positive_monotone : forall (a1:Z), forall (a2:Z),
  forall (b:Z), ((0%Z <= a1)%Z /\ ((a1 <= a2)%Z /\ (0%Z <= b)%Z)) -> ((lsl a1
  b) <= (lsl a2 b))%Z.
intros a1 a2 b (h1,(h2,h3)).

Admitted.

(* Why3 goal *)
Definition lsr: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Lemma lsr_left_positive_returns_positive : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> (0%Z <= (lsr a b))%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsr_left_positive_decreases : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> ((lsr a b) <= a)%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Definition asr: Z -> Z -> Z.

Admitted.

(* Why3 goal *)
Lemma asr_positive_on_positive : forall (a:Z), forall (b:Z), ((0%Z <= a)%Z /\
  (0%Z <= b)%Z) -> (0%Z <= (asr a b))%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma asr_decreases_on_positive : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> ((asr a b) <= a)%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma asr_lsr_same_on_positive : forall (a:Z), forall (b:Z), ((0%Z <= a)%Z /\
  (0%Z <= b)%Z) -> ((asr a b) = (lsr a b)).
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsl_of_lsr_decreases_on_positive : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> ((lsl (lsr a b) b) <= a)%Z.
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsr_of_lsl_identity_on_positive : forall (a:Z), forall (b:Z),
  ((0%Z <= a)%Z /\ (0%Z <= b)%Z) -> ((lsr (lsl a b) b) = a).
intros a b (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsl_definition : forall (m:Z), forall (a:Z), forall (n:Z),
  (0%Z <= m)%Z -> ((~ (bw_set n (lsl a m))) <-> ((~ (bw_set (n - m)%Z a)) \/
  (n < m)%Z)).
intros m a n h1.

Admitted.

(* Why3 goal *)
Lemma lsr_definition : forall (m:Z), forall (a:Z), forall (n:Z),
  (0%Z <= m)%Z -> ((bw_set n (lsr a m)) <-> (bw_set (n + m)%Z a)).
intros m a n h1.

Admitted.

(* Why3 goal *)
Lemma lsl_induction : forall (a:Z), forall (n:Z), forall (m:Z), forall (k:Z),
  ((0%Z <= k)%Z /\ ((0%Z <= n)%Z /\ ((0%Z <= m)%Z /\ (k = (n + m)%Z)))) ->
  ((lsl a k) = (lsl (lsl a n) m)).
intros a n m k (h1,(h2,(h3,h4))).

Admitted.

(* Why3 goal *)
Lemma lsr_induction : forall (a:Z), forall (n:Z), forall (m:Z), forall (k:Z),
  ((0%Z <= k)%Z /\ ((0%Z <= n)%Z /\ ((0%Z <= m)%Z /\ (k = (n + m)%Z)))) ->
  ((lsr a k) = (lsr (lsr a n) m)).
intros a n m k (h1,(h2,(h3,h4))).

Admitted.

(* Why3 goal *)
Lemma lsl_assoc : forall (n:Z), forall (m:Z), forall (a:Z), ((0%Z <= n)%Z /\
  (0%Z <= m)%Z) -> ((lsl (lsl a m) n) = (lsl (lsl a n) m)).
intros n m a (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsr_assoc : forall (n:Z), forall (m:Z), forall (a:Z), ((0%Z <= n)%Z /\
  (0%Z <= m)%Z) -> ((lsr (lsr a m) n) = (lsr (lsr a n) m)).
intros n m a (h1,h2).

Admitted.

(* Why3 goal *)
Lemma lsl_init : forall (a:Z), (0%Z <= a)%Z -> ((lsl a 1%Z) = (a * 2%Z)%Z).
intros a h1.

Admitted.

(* Why3 goal *)
Lemma lsl_multiply : forall (a:Z), forall (n:Z), (0%Z <= a)%Z -> ((lsl a
  n) = (a * (pow2 n))%Z).
intros a n h1.

Admitted.

(* Why3 goal *)
Lemma lsr_init : forall (a:Z), (0%Z <= a)%Z -> ((lsr a
  1%Z) = (ZArith.BinInt.Z.quot a 2%Z)).
intros a h1.

Admitted.

(* Why3 goal *)
Lemma lsr_divide : forall (a:Z), forall (n:Z), (0%Z <= a)%Z -> ((lsr a
  n) = (ZArith.BinInt.Z.quot a (pow2 n))).
intros a n h1.

Admitted.

(* Why3 assumption *)
Definition alloc_fresh {t:Type} {t_WT:WhyType t} (a:(alloc_table t))
  (p:(pointer t)) (n:Z): Prop := (0%Z < n)%Z -> ((offset_max a
  p) < (offset_min a p))%Z.

(* Why3 assumption *)
Definition alloc_extends {t:Type} {t_WT:WhyType t} (a1:(alloc_table t))
  (a2:(alloc_table t)): Prop := forall (p:(pointer t)), (valid a1 p) ->
  (((offset_min a1 p) = (offset_min a2 p)) /\ ((offset_max a1
  p) = (offset_max a2 p))).

(* Why3 assumption *)
Definition alloc_extends_except {t:Type} {t_WT:WhyType t} (a1:(alloc_table
  t)) (a2:(alloc_table t)) (l:(pset t)): Prop := forall (p:(pointer t)),
  ((valid a1 p) /\ ~ (in_pset p l)) -> (((offset_min a1 p) = (offset_min a2
  p)) /\ ((offset_max a1 p) = (offset_max a2 p))).

(* Why3 goal *)
Lemma alloc_extends_alloc_extends_except : forall {t:Type} {t_WT:WhyType t},
  forall (a1:(alloc_table t)), forall (a2:(alloc_table t)), forall (l:(pset
  t)), (alloc_extends a1 a2) -> (alloc_extends_except a1 a2 l).
intros t t_WT a1 a2 l h1.

Admitted.

