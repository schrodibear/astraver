(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require Enum_intf.
Require Enum.
Require Powers_of_2.
Require Bit_enum_intf.
Require Bit_enum.
Require Uint32.

(* Why3 assumption *)
Definition normalize (x:Z): Z :=
  (0%Z + (int.EuclideanDivision.mod1 (x - 0%Z)%Z
  ((4294967295%Z - 0%Z)%Z + 1%Z)%Z))%Z.

Parameter of_int_modulo: Z -> Uint32.t.

Parameter of_int_const: Z -> Uint32.t.

Parameter infix_plpc: Uint32.t -> Uint32.t -> Uint32.t.

Parameter infix_mnpc: Uint32.t -> Uint32.t -> Uint32.t.

Parameter prefix_mnpc: Uint32.t -> Uint32.t.

Parameter infix_aspc: Uint32.t -> Uint32.t -> Uint32.t.

Parameter infix_slpc: Uint32.t -> Uint32.t -> Uint32.t.

Parameter infix_pcpc: Uint32.t -> Uint32.t -> Uint32.t.

Parameter infix_et: Uint32.t -> Uint32.t -> Uint32.t.

Parameter infix_brcf: Uint32.t -> Uint32.t -> Uint32.t.

Parameter prefix_tl: Uint32.t -> Uint32.t.

Parameter infix_cf: Uint32.t -> Uint32.t -> Uint32.t.

Parameter lsl: Uint32.t -> Uint32.t -> Uint32.t.

Parameter lsl_modulo: Uint32.t -> Uint32.t -> Uint32.t.

Parameter lsr: Uint32.t -> Uint32.t -> Uint32.t.

Parameter asr: Uint32.t -> Uint32.t -> Uint32.t.

Parameter lt: Uint32.t -> Uint32.t -> Prop.

Parameter le: Uint32.t -> Uint32.t -> Prop.

Parameter gt: Uint32.t -> Uint32.t -> Prop.

Parameter ge: Uint32.t -> Uint32.t -> Prop.

Axiom Of_int_modulo : forall (n:Z),
  ((of_int_modulo n) = (Uint32.of_int (normalize n))).

Axiom Add_modulo : forall (a:Uint32.t) (b:Uint32.t), ((infix_plpc a
  b) = (Uint32.of_int (normalize ((Uint32.to_int a) + (Uint32.to_int b))%Z))).

Axiom Neg_modulo : forall (a:Uint32.t),
  ((prefix_mnpc a) = (Uint32.of_int (normalize (-(Uint32.to_int a))%Z))).

Axiom Sub_modulo : forall (a:Uint32.t) (b:Uint32.t), ((infix_mnpc a
  b) = (Uint32.of_int (normalize ((Uint32.to_int a) - (Uint32.to_int b))%Z))).

Axiom Mult_modulo : forall (a:Uint32.t) (b:Uint32.t), ((infix_aspc a
  b) = (Uint32.of_int (normalize ((Uint32.to_int a) * (Uint32.to_int b))%Z))).

Axiom Div_modulo : forall (a:Uint32.t) (b:Uint32.t), ((infix_slpc a
  b) = (Uint32.of_int (normalize (ZArith.BinInt.Z.quot (Uint32.to_int a) (Uint32.to_int b))))).

Axiom Mod_modulo : forall (a:Uint32.t) (b:Uint32.t), ((infix_pcpc a
  b) = (Uint32.of_int (ZArith.BinInt.Z.rem (Uint32.to_int a) (Uint32.to_int b)))).

Axiom Val_two_power_size : ((Powers_of_2.power2 32%Z) = ((4294967295%Z - 0%Z)%Z + 1%Z)%Z).

Axiom Of_int_const : forall (n:Z), ((of_int_const n) = (Uint32.of_int n)).

Axiom Of_int_def : forall (n:Z), (Uint32.in_bounds n) ->
  ((Uint32.of_int n) = (of_int_modulo n)).

Parameter to_uint: Uint32.t -> Z.

Axiom To_uint : True.

Parameter nth: Uint32.t -> Z -> Prop.

Axiom Nth : forall (a:Uint32.t), forall (n:Z), ((0%Z <= n)%Z /\
  (n < 32%Z)%Z) -> ((nth a n) <-> (((0%Z <= (Uint32.to_int a))%Z /\
  ((Powers_of_2.power2 n) <= (ZArith.BinInt.Z.rem (Uint32.to_int a) (Powers_of_2.power2 (n + 1%Z)%Z)))%Z) \/
  (((Uint32.to_int a) < 0%Z)%Z /\
  ((Powers_of_2.power2 n) <= (ZArith.BinInt.Z.rem (((4294967295%Z - 0%Z)%Z + 1%Z)%Z + (Uint32.to_int a))%Z (Powers_of_2.power2 (n + 1%Z)%Z)))%Z))).

Axiom Lt_eq : forall (a:Uint32.t) (b:Uint32.t), (Uint32.infix_ls a b) <-> (lt
  a b).

Axiom Le_eq : forall (a:Uint32.t) (b:Uint32.t), (Uint32.infix_lseq a b) <->
  (le a b).

Axiom Gt_eq : forall (a:Uint32.t) (b:Uint32.t), (Uint32.infix_gt a b) <-> (gt
  a b).

Axiom Ge_eq : forall (a:Uint32.t) (b:Uint32.t), (Uint32.infix_gteq a b) <->
  (ge a b).

Axiom Nth_bw_and : forall (a:Uint32.t) (b:Uint32.t), forall (n:Z),
  ((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> ((nth (infix_et a b) n) <-> ((nth a n) /\
  (nth b n))).

Axiom Nth_bw_or : forall (a:Uint32.t) (b:Uint32.t), forall (n:Z),
  ((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> ((nth (infix_brcf a b) n) <-> ((nth a
  n) \/ (nth b n))).

Axiom Nth_bw_xor : forall (a:Uint32.t) (b:Uint32.t), forall (n:Z),
  ((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> ((nth (infix_cf a b) n) <-> ~ ((nth a
  n) <-> (nth b n))).

Axiom Nth_bw_not : forall (a:Uint32.t), forall (n:Z), ((0%Z <= n)%Z /\
  (n < 32%Z)%Z) -> ((nth (prefix_tl a) n) <-> ~ (nth a n)).

Axiom Lsl_def : forall (b:Uint32.t), forall (s:Uint32.t), (ge (lsl_modulo b
  s) (of_int_const 0%Z)) -> ((lsl b s) = (lsl_modulo b s)).

Axiom Lsr_nth_low : forall (b:Uint32.t), forall (s:Uint32.t), forall (n:Z),
  ((0%Z <= (Uint32.to_int s))%Z /\ ((Uint32.to_int s) < 32%Z)%Z) ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> (((n + (Uint32.to_int s))%Z < 32%Z)%Z ->
  ((nth (lsr b s) n) <-> (nth b (n + (Uint32.to_int s))%Z)))).

Axiom Lsr_nth_high : forall (b:Uint32.t), forall (s:Uint32.t), forall (n:Z),
  ((0%Z <= (Uint32.to_int s))%Z /\ ((Uint32.to_int s) < 32%Z)%Z) ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  ((32%Z <= (n + (Uint32.to_int s))%Z)%Z -> ~ (nth (lsr b s) n))).

Axiom Asr_nth_low : forall (b:Uint32.t), forall (s:Uint32.t), forall (n:Z),
  ((0%Z <= (Uint32.to_int s))%Z /\ ((Uint32.to_int s) < 32%Z)%Z) ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  (((0%Z <= (n + (Uint32.to_int s))%Z)%Z /\
  ((n + (Uint32.to_int s))%Z < 32%Z)%Z) -> ((nth (asr b s) n) <-> (nth b
  (n + (Uint32.to_int s))%Z)))).

Axiom Asr_nth_high : forall (b:Uint32.t), forall (s:Uint32.t), forall (n:Z),
  ((0%Z <= (Uint32.to_int s))%Z /\ ((Uint32.to_int s) < 32%Z)%Z) ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  ((32%Z <= (n + (Uint32.to_int s))%Z)%Z -> ((nth (asr b s) n) <-> (nth b
  (32%Z - 1%Z)%Z)))).

Axiom Lsl_modulo_nth_high : forall (b:Uint32.t), forall (s:Uint32.t),
  forall (n:Z), ((0%Z <= (Uint32.to_int s))%Z /\
  ((Uint32.to_int s) < 32%Z)%Z) -> (((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  (((0%Z <= (n - (Uint32.to_int s))%Z)%Z /\
  ((n - (Uint32.to_int s))%Z < 32%Z)%Z) -> ((nth (lsl_modulo b s) n) <-> (nth
  b (n - (Uint32.to_int s))%Z)))).

Axiom Lsl_modulo_nth_low : forall (b:Uint32.t), forall (s:Uint32.t),
  forall (n:Z), ((0%Z <= (Uint32.to_int s))%Z /\
  ((Uint32.to_int s) < 32%Z)%Z) -> (((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  (((n - (Uint32.to_int s))%Z < 0%Z)%Z -> ~ (nth (lsl_modulo b s) n))).

Axiom To_uint_lsr : forall (a:Uint32.t), forall (n:Uint32.t),
  (0%Z <= (Uint32.to_int n))%Z -> ((Uint32.to_int (lsr a
  n)) = (int.EuclideanDivision.div (Uint32.to_int a)
  (Powers_of_2.power2 (Uint32.to_int n)))).

Axiom To_uint_lsl_modulo : forall (a:Uint32.t), forall (n:Uint32.t),
  (0%Z <= (Uint32.to_int n))%Z -> ((Uint32.to_int (lsl_modulo a
  n)) = (int.EuclideanDivision.mod1 ((Uint32.to_int a) * (Powers_of_2.power2 (Uint32.to_int n)))%Z
  ((4294967295%Z - 0%Z)%Z + 1%Z)%Z)).

