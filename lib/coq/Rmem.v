(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require Pointer.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require Alloc_table.
Require Memory.
Require map.Map.
Require Pset.
Require Pset_range.
Require Pset_union.
Require Assigns.

Parameter rmem: forall {t:Type} {t_WT:WhyType t} {v1:Type} {v1_WT:WhyType v1}
  {v2:Type} {v2_WT:WhyType v2}, (map.Map.map (Pointer.pointer t) v1) ->
  (map.Map.map (Pointer.pointer t) v2).

Parameter rfactor: forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, (map.Map.map (Pointer.pointer t) v) ->
  Numbers.BinNums.Z.

Parameter rpointer_new: forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, (map.Map.map (Pointer.pointer t) v) ->
  (Pointer.pointer t) -> (Pointer.pointer t).

Parameter pset_reinterpret: forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, (map.Map.map (Pointer.pointer t) v) ->
  (Pset.pset t) -> (Pset.pset t).

Axiom Pset_reinterpret_empty : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, forall (m:(map.Map.map (Pointer.pointer t) v)),
  ((pset_reinterpret m (Pset.pset_empty : (Pset.pset
  t))) = (Pset.pset_empty : (Pset.pset t))).

Axiom Pset_reinterpret_pset_range : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, forall (m:(map.Map.map (Pointer.pointer t) v)),
  forall (p:(Pointer.pointer t)), forall (a:Numbers.BinNums.Z)
  (b:Numbers.BinNums.Z), ((0%Z < (rfactor m))%Z -> ((pset_reinterpret m
  (Pset_range.pset_range (Pset.pset_singleton p) a
  b)) = (Pset_range.pset_range (Pset.pset_singleton (rpointer_new m p))
  (a * (rfactor m))%Z (((b + 1%Z)%Z * (rfactor m))%Z - 1%Z)%Z))) /\
  (((((rfactor m) < 0%Z)%Z /\ (((ZArith.BinInt.Z.rem a (rfactor m)) = 0%Z) /\
  ((ZArith.BinInt.Z.rem (b + 1%Z)%Z (rfactor m)) = 0%Z))) ->
  ((pset_reinterpret m (Pset_range.pset_range (Pset.pset_singleton p) a
  b)) = (Pset_range.pset_range (Pset.pset_singleton (rpointer_new m p))
  (ZArith.BinInt.Z.quot a (rfactor m))
  ((ZArith.BinInt.Z.quot (b + 1%Z)%Z (rfactor m)) - 1%Z)%Z))) /\
  (((rfactor m) = 0%Z) -> ((pset_reinterpret m
  (Pset_range.pset_range (Pset.pset_singleton p) a
  b)) = (Pset_range.pset_range (Pset.pset_singleton (rpointer_new m p)) a
  b)))).

Axiom Pset_reinterpret_pset_union_distrib : forall {t:Type} {t_WT:WhyType t}
  {v:Type} {v_WT:WhyType v}, forall (m:(map.Map.map (Pointer.pointer t) v)),
  forall (l1:(Pset.pset t)) (l2:(Pset.pset t)), ((pset_reinterpret m
  (Pset_union.pset_union l1 l2)) = (Pset_union.pset_union (pset_reinterpret m
  l1) (pset_reinterpret m l2))).

Axiom Rmem_not_assigns : forall {t:Type} {t_WT:WhyType t}
  {v1:Type} {v1_WT:WhyType v1} {v2:Type} {v2_WT:WhyType v2},
  forall (m1:(map.Map.map (Pointer.pointer t) v1)), forall (m3:(map.Map.map
  (Pointer.pointer t) v2)), forall (a1:(Alloc_table.alloc_table t))
  (a2:(Alloc_table.alloc_table t)), forall (l:(Pset.pset t)),
  ((Assigns.not_assigns a1 a2 (rmem m1: (map.Map.map (Pointer.pointer t) v2))
  m3 l) <-> (Assigns.not_assigns a1 a2 m1 (rmem m3: (map.Map.map
  (Pointer.pointer t) v1)) (pset_reinterpret m3 l))) /\ ((Assigns.not_assigns
  a1 a2 (rmem m1: (map.Map.map (Pointer.pointer t) v2)) m3
  (pset_reinterpret m1 l)) <-> (Assigns.not_assigns a1 a2 m1
  (rmem m3: (map.Map.map (Pointer.pointer t) v1)) l)).

