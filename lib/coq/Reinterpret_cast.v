(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require Pointer.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require Alloc_table.
Require map.Map.
Require Tag_id.
Require Tag.
Require Tag_table_type.
Require Tag_table.
Require Sidecast.

(* Why3 assumption *)
Definition reinterpret_cast_merge {t:Type} {t_WT:WhyType t} (t1:(map.Map.map
  (Pointer.pointer t) (Tag_id.tag_id t))) (a1:(Alloc_table.alloc_table t))
  (a2:(Alloc_table.alloc_table t)) (p:(Pointer.pointer t)) (s:(Tag_id.tag_id
  t)) (c:Numbers.BinNums.Z): Prop := let ps := (Sidecast.sidecast t1 p s) in
  ((forall (i:Numbers.BinNums.Z), ((ZArith.BinInt.Z.rem i c) = 0%Z) ->
  ((Sidecast.sidecast t1 (Pointer.shift p i) s) = (Pointer.shift ps
  (ZArith.BinInt.Z.quot i c)))) /\ ((forall (i:Numbers.BinNums.Z),
  ((Sidecast.sidecast t1 (Pointer.shift p (i * c)%Z) s) = (Pointer.shift ps
  i))) /\ (((Alloc_table.offset_min a2
  ps) = (ZArith.BinInt.Z.quot (Alloc_table.offset_min a1 p) c)) /\
  ((Alloc_table.offset_max a2
  ps) = ((ZArith.BinInt.Z.quot ((Alloc_table.offset_max a1
  p) + 1%Z)%Z c) - 1%Z)%Z)))).

(* Why3 assumption *)
Definition reinterpret_cast_split {t:Type} {t_WT:WhyType t} (t1:(map.Map.map
  (Pointer.pointer t) (Tag_id.tag_id t))) (a1:(Alloc_table.alloc_table t))
  (a2:(Alloc_table.alloc_table t)) (p:(Pointer.pointer t)) (s:(Tag_id.tag_id
  t)) (c:Numbers.BinNums.Z): Prop := let ps := (Sidecast.sidecast t1 p s) in
  ((forall (i:Numbers.BinNums.Z), ((Sidecast.sidecast t1 (Pointer.shift p i)
  s) = (Pointer.shift ps (i * c)%Z))) /\ ((forall (i:Numbers.BinNums.Z),
  ((ZArith.BinInt.Z.rem i c) = 0%Z) -> ((Sidecast.sidecast t1
  (Pointer.shift p (ZArith.BinInt.Z.quot i c)) s) = (Pointer.shift ps i))) /\
  (((Alloc_table.offset_min a2 ps) = (c * (Alloc_table.offset_min a1
  p))%Z) /\ ((Alloc_table.offset_max a2
  ps) = ((c * ((Alloc_table.offset_max a1 p) + 1%Z)%Z)%Z - 1%Z)%Z)))).

(* Why3 assumption *)
Definition reinterpret_cast_retain {t:Type} {t_WT:WhyType t} (t1:(map.Map.map
  (Pointer.pointer t) (Tag_id.tag_id t))) (a1:(Alloc_table.alloc_table t))
  (a2:(Alloc_table.alloc_table t)) (p:(Pointer.pointer t)) (s:(Tag_id.tag_id
  t)): Prop := let ps := (Sidecast.sidecast t1 p s) in
  ((forall (i:Numbers.BinNums.Z), ((Sidecast.sidecast t1 (Pointer.shift p i)
  s) = (Pointer.shift ps i))) /\ (((Alloc_table.offset_min a2
  ps) = (Alloc_table.offset_min a1 p)) /\ ((Alloc_table.offset_max a2
  ps) = (Alloc_table.offset_max a1 p)))).

