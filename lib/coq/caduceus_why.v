(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Export Why.
Require Export WhyFloat.

Parameter addr : Set.
Parameter pointer : Set. (* = addr * Z *)
Parameter alloc_table : Set.
Parameter memory : Set -> Set.
Parameter assign_loc : Set.

(*Why logic*) Definition bw_compl : Z -> Z.
Admitted.

(*Why logic*) Definition bw_and : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition bw_xor : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition bw_or : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition lsl : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition lsr : Z -> Z -> Z.
Admitted.

(*Why*) Parameter any_int : forall (_: unit), Z.


(*Why*) Parameter any_real : forall (_: unit), R.

(*Why*) Parameter any_pointer : forall (_: unit), pointer.

(*Why*) Parameter null : pointer.

(*Why logic*) Definition block_length : alloc_table -> pointer -> Z.
Admitted.

(*Why logic*) Definition base_addr : pointer -> addr.
Admitted.

(*Why logic*) Definition offset : pointer -> Z.
Admitted.

(*Why logic*) Definition shift : pointer -> Z -> pointer.
Admitted.

(*Why logic*) Definition sub_pointer : pointer -> pointer -> Z.
Admitted.

(*Why predicate*) Definition lt_pointer  (p1:pointer) (p2:pointer)
  := (base_addr p1) = (base_addr p2) /\ (offset p1) < (offset p2).

(*Why predicate*) Definition le_pointer  (p1:pointer) (p2:pointer)
  := (base_addr p1) = (base_addr p2) /\ (offset p1) <= (offset p2).

(*Why predicate*) Definition gt_pointer  (p1:pointer) (p2:pointer)
  := (base_addr p1) = (base_addr p2) /\ (offset p1) > (offset p2).

(*Why predicate*) Definition ge_pointer  (p1:pointer) (p2:pointer)
  := (base_addr p1) = (base_addr p2) /\ (offset p1) >= (offset p2).

(*Why*) Parameter eq_pointer :
  forall (p: pointer), forall (q: pointer),
  (sig_1 bool (fun (result: bool)  => ((if result then p = q else ~(p = q))))).

(*Why*) Parameter neq_pointer :
  forall (p: pointer), forall (q: pointer),
  (sig_1 bool (fun (result: bool)  => ((if result then ~(p = q) else p = q)))).

(*Why predicate*) Definition valid  (a:alloc_table) (p:pointer)
  := ~(p = null) /\ 0 <= (offset p) /\ (offset p) < (block_length a p).

(*Why predicate*) Definition valid_index  (a:alloc_table) (p:pointer) (i:Z)
  := ~(p = null) /\ 0 <= ((offset p) + i) /\ ((offset p) + i) <
     (block_length a p).

(*Why predicate*) Definition valid_range  (a:alloc_table) (p:pointer) (i:Z)
  (j:Z)
  := ~(p = null) /\ 0 <= ((offset p) + i) /\ i <= j /\ ((offset p) + j) <
     (block_length a p).

(*Why axiom*) Lemma shift_shift :
  (forall (p:pointer),
   (forall (i:Z), (forall (j:Z), (shift (shift p i) j) = (shift p (i + j))))).
Admitted.

(*Why axiom*) Lemma base_addr_shift :
  (forall (p:pointer),
   (forall (i:Z), (base_addr (shift p i)) = (base_addr p))).
Admitted.

(*Why axiom*) Lemma block_length_shift :
  (forall (a:alloc_table),
   (forall (p:pointer),
    (forall (i:Z), (block_length a (shift p i)) = (block_length a p)))).
Admitted.

(*Why axiom*) Lemma shift_null :
  (forall (p:pointer), (forall (i:Z), (p = null -> (shift p i) = null))).
Admitted.

(*Why axiom*) Lemma shift_not_null :
  (forall (p:pointer), (forall (i:Z), (~(p = null) -> ~((shift p i) = null)))).
Admitted.

(*Why axiom*) Lemma base_addr_block_length :
  (forall (a:alloc_table),
   (forall (p1:pointer),
    (forall (p2:pointer),
     ((base_addr p1) = (base_addr p2) -> (block_length a p1) =
      (block_length a p2))))).
Admitted.

(*Why axiom*) Lemma pointer_pair_1 :
  (forall (p1:pointer),
   (forall (p2:pointer),
    ((base_addr p1) = (base_addr p2) /\ (offset p1) = (offset p2) -> p1 = p2))).
Admitted.

(*Why axiom*) Lemma pointer_pair_2 :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (p1 = p2 -> (base_addr p1) = (base_addr p2) /\ (offset p1) = (offset p2)))).
Admitted.

(*Why axiom*) Lemma neq_base_addr_neq_shift :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (forall (i:Z),
     (forall (j:Z),
      (~((base_addr p1) = (base_addr p2)) -> ~((shift p1 i) = (shift p2 j))))))).
Admitted.

(*Why axiom*) Lemma neq_offset_neq_shift :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (forall (i:Z),
     (forall (j:Z),
      (((offset p1) + i) <> ((offset p2) + j) ->
       ~((shift p1 i) = (shift p2 j))))))).
Admitted.

(*Why axiom*) Lemma eq_offset_eq_shift :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (forall (i:Z),
     (forall (j:Z),
      ((base_addr p1) = (base_addr p2) ->
       (((offset p1) + i) = ((offset p2) + j) -> (shift p1 i) = (shift p2 j))))))).
Admitted.

(*Why axiom*) Lemma valid_index_valid_shift :
  (forall (a:alloc_table),
   (forall (p:pointer),
    (forall (i:Z), ((valid_index a p i) -> (valid a (shift p i)))))).
Admitted.

(*Why axiom*) Lemma valid_range_valid_shift :
  (forall (a:alloc_table),
   (forall (p:pointer),
    (forall (i:Z),
     (forall (j:Z),
      (forall (k:Z),
       ((valid_range a p i j) -> (i <= k /\ k <= j -> (valid a (shift p k))))))))).
Admitted.

(*Why axiom*) Lemma valid_range_valid_index :
  (forall (a:alloc_table),
   (forall (p:pointer),
    (forall (i:Z),
     (forall (j:Z),
      (forall (k:Z),
       ((valid_range a p i j) -> (i <= k /\ k <= j -> (valid_index a p k)))))))).
Admitted.

(*Why axiom*) Lemma sub_pointer_def :
  (forall (p1:pointer),
   (forall (p2:pointer),
    ((base_addr p1) = (base_addr p2) -> (sub_pointer p1 p2) =
     ((offset p1) - (offset p2))))).
Admitted.

(*Why*) Parameter shift_ :
  forall (p: pointer), forall (i: Z),
  (sig_1 pointer (fun (result: pointer)  => (result = (shift p i)))).

(*Why*) Parameter sub_pointer_ :
  forall (p1: pointer), forall (p2: pointer),
  forall (H: (base_addr p1) = (base_addr p2)),
  (sig_1 Z (fun (result: Z)  => (result = ((offset p1) - (offset p2))))).

(*Why*) Parameter lt_pointer_ :
  forall (p1: pointer), forall (p2: pointer),
  forall (H: (base_addr p1) = (base_addr p2)),
  (sig_1 bool
   (fun (result: bool)  =>
    ((if result then (offset p1) < (offset p2) else (offset p1) >=
      (offset p2))))).

(*Why*) Parameter le_pointer_ :
  forall (p1: pointer), forall (p2: pointer),
  forall (H: (base_addr p1) = (base_addr p2)),
  (sig_1 bool
   (fun (result: bool)  =>
    ((if result then (offset p1) <= (offset p2) else (offset p1) >
      (offset p2))))).

(*Why*) Parameter gt_pointer_ :
  forall (p1: pointer), forall (p2: pointer),
  forall (H: (base_addr p1) = (base_addr p2)),
  (sig_1 bool
   (fun (result: bool)  =>
    ((if result then (offset p1) > (offset p2) else (offset p1) <=
      (offset p2))))).

(*Why*) Parameter ge_pointer_ :
  forall (p1: pointer), forall (p2: pointer),
  forall (H: (base_addr p1) = (base_addr p2)),
  (sig_1 bool
   (fun (result: bool)  =>
    ((if result then (offset p1) >= (offset p2) else (offset p1) <
      (offset p2))))).

(*Why logic*) Definition acc :
  forall (A41:Set), ((memory) A41) -> pointer -> A41.
Admitted.
Implicit Arguments acc.

(*Why*) Parameter acc_ :
  forall (A5: Set), forall (p: pointer), forall (alloc: alloc_table),
  forall (m: ((memory) A5)), forall (H: (valid alloc p)),
  (sig_1 A5 (fun (result: A5)  => (result = (acc m p)))).

(*Why logic*) Definition upd :
  forall (A42:Set), ((memory) A42) -> pointer -> A42 -> ((memory) A42).
Admitted.
Implicit Arguments upd.

(*Why*) Parameter upd_ :
  forall (A11: Set), forall (p: pointer), forall (v: A11),
  forall (alloc: alloc_table), forall (m: ((memory) A11)),
  forall (H: (valid alloc p)),
  (sig_2 ((memory) A11) unit
   (fun (m0: ((memory) A11)) (result: unit)  => (m0 = (upd m p v)))).

(*Why axiom*) Lemma acc_upd :
  forall (A43:Set),
  (forall (m:((memory) A43)),
   (forall (p:pointer), (forall (a:A43), (acc (upd m p a) p) = a))).
Admitted.

(*Why axiom*) Lemma acc_upd_eq :
  forall (A44:Set),
  (forall (m:((memory) A44)),
   (forall (p1:pointer),
    (forall (p2:pointer),
     (forall (a:A44), (p1 = p2 -> (acc (upd m p1 a) p2) = a))))).
Admitted.

(*Why axiom*) Lemma acc_upd_neq :
  forall (A45:Set),
  (forall (m:((memory) A45)),
   (forall (p1:pointer),
    (forall (p2:pointer),
     (forall (a:A45), (~(p1 = p2) -> (acc (upd m p1 a) p2) = (acc m p2)))))).
Admitted.

(*Why logic*) Definition fresh : alloc_table -> pointer -> Prop.
Admitted.

(*Why axiom*) Lemma false_not_true : ~(false = true).
Admitted.

(*Why logic*) Definition nothing_loc : assign_loc.
Admitted.

(*Why logic*) Definition pointer_loc : pointer -> assign_loc.
Admitted.

(*Why logic*) Definition all_loc : pointer -> assign_loc.
Admitted.

(*Why logic*) Definition range_loc : pointer -> Z -> Z -> assign_loc.
Admitted.

(*Why logic*) Definition union_loc : assign_loc -> assign_loc -> assign_loc.
Admitted.

(*Why logic*) Definition unchanged : pointer -> assign_loc -> Prop.
Admitted.

(*Why predicate*) Definition assigns (A46:Set) (a:alloc_table)
  (m1:((memory) A46)) (m2:((memory) A46)) (l:assign_loc)
  := (forall (p:pointer),
      ((valid a p) -> ((unchanged p l) -> (acc m2 p) = (acc m1 p)))).
Implicit Arguments assigns.

(*Why axiom*) Lemma unchanged_nothing_intro :
  (forall (p:pointer), (unchanged p nothing_loc)).
Admitted.

(*Why axiom*) Lemma unchanged_pointer_intro :
  (forall (p1:pointer),
   (forall (p2:pointer), (~(p1 = p2) -> (unchanged p1 (pointer_loc p2))))).
Admitted.

(*Why axiom*) Lemma unchanged_pointer_elim :
  (forall (p1:pointer),
   (forall (p2:pointer), ((unchanged p1 (pointer_loc p2)) -> ~(p1 = p2)))).
Admitted.

(*Why axiom*) Lemma unchanged_union_intro :
  (forall (l1:assign_loc),
   (forall (l2:assign_loc),
    (forall (p:pointer),
     ((unchanged p l1) /\ (unchanged p l2) -> (unchanged p (union_loc l1 l2)))))).
Admitted.

(*Why axiom*) Lemma unchanged_union_elim1 :
  (forall (l1:assign_loc),
   (forall (l2:assign_loc),
    (forall (p:pointer),
     ((unchanged p (union_loc l1 l2)) -> (unchanged p l1))))).
Admitted.

(*Why axiom*) Lemma unchanged_union_elim2 :
  (forall (l1:assign_loc),
   (forall (l2:assign_loc),
    (forall (p:pointer),
     ((unchanged p (union_loc l1 l2)) -> (unchanged p l2))))).
Admitted.

(*Why axiom*) Lemma unchanged_range_intro :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (forall (a:Z),
     (forall (b:Z),
      ((forall (i:Z), (a <= i /\ i <= b -> ~(p1 = (shift p2 i)))) ->
       (unchanged p1 (range_loc p2 a b))))))).
Admitted.

(*Why axiom*) Lemma unchanged_range_elim :
  (forall (p1:pointer),
   (forall (p2:pointer),
    (forall (a:Z),
     (forall (b:Z),
      ((unchanged p1 (range_loc p2 a b)) ->
       (forall (i:Z), (a <= i /\ i <= b -> ~(p1 = (shift p2 i))))))))).
Admitted.



(*Why axiom*) Lemma assigns_trans :
  forall (A47:Set),
  (forall (a:alloc_table),
   (forall (l:assign_loc),
    (forall (m1:((memory) A47)),
     (forall (m2:((memory) A47)),
      (forall (m3:((memory) A47)),
       ((assigns a m1 m2 l) -> ((assigns a m2 m3 l) -> (assigns a m1 m3 l)))))))).
Proof.
unfold assigns; intuition; rewrite H0; auto.
Save.


