(floatbis
 (RND_Zero_isToZero_TCC1 0
  (RND_Zero_isToZero_TCC1-1 nil 3424513819 3424583684
   ("" (skeep) (("" (rewrite "FcanonicBounded") nil nil)) nil) proved
   ((FcanonicBounded formula-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (float type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (RND_Zero const-decl "(Fcanonic?(b))" floatbis nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" floatbis nil))
   200 90 t nil))
 (RND_Zero_isToZero 0
  (RND_Zero_isToZero-1 nil 3424514932 3424583687
   ("" (skeep)
    (("" (expand RND_Zero)
      (("" (expand ToZero?)
        (("" (rewrite RND_Min_isMin)
          (("" (rewrite RND_Max_isMax) (("" (ground) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((RND_Zero const-decl "(Fcanonic?(b))" floatbis nil)
    (RND_Min_isMin formula-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" floatbis nil)
    (RND_Max_isMax formula-decl nil float "float/")
    (ToZero? const-decl "bool" float "float/"))
   3032 90 t shostak))
 (RND_AClosest_isAFZclosest_TCC1 0
  (RND_AClosest_isAFZclosest_TCC1-1 nil 3424513819 3424583687
   ("" (skeep) (("" (rewrite "FcanonicBounded") nil nil)) nil) proved
   ((FcanonicBounded formula-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (float type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (RND_AFZClosest const-decl "(Fcanonic?(b))" floatbis nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" floatbis nil))
   48 20 t nil))
 (RND_AClosest_isAFZclosest 0
  (RND_AClosest_isAFZclosest-1 nil 3424515088 3424583732
   ("" (skeep)
    (("" (expand RND_AFZClosest)
      (("" (grind-reals)
        (("1" (expand AFZClosest?)
          (("1" (case "Closest?(b)(r, RND_Min(b)(r))")
            (("1" (split)
              (("1" (propax) nil nil)
               ("2" (skosimp*)
                (("2" (lemma "Closest_MinOrMax")
                  (("2" (expand "MinOrMax?")
                    (("2" (inst -1 b r f!1)
                      (("2" (split)
                        (("1" (lemma "isMin_Unique")
                          (("1" (expand "Unique?")
                            (("1" (inst -1 b r f!1 "RND_Min(b)(r)")
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite "RND_Min_isMin")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "Closest?" -2)
                          (("2" (inst -2 "RND_Min(b)(r)")
                            (("2" (flip-ineq -2)
                              (("2"
                                (case-replace
                                 "FtoR(f!1) = FtoR(RND_Max(b)(r))")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (lemma "isMax_Unique")
                                  (("2"
                                    (expand Unique?)
                                    (("2"
                                      (inst -1 b r f!1 "RND_Max(b)(r)")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (rewrite "RND_Max_isMax")
                                          nil
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite "FcanonicBounded")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r"))
                (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r"))
                  (("2" (expand* "isMin?" "isMax?" "Closest?")
                    (("2" (flatten)
                      (("2" (skosimp*)
                        (("2" (case "FtoR(f!1) <= r")
                          (("1" (expand abs)
                            (("1" (grind-reals) nil nil)) nil)
                           ("2" (expand abs)
                            (("2" (grind-reals) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (rewrite "FcanonicBounded") nil nil))
            nil))
          nil)
         ("2" (hide 1)
          (("2" (expand "AFZClosest?")
            (("2" (case "Closest?(b)(r, RND_Max(b)(r))")
              (("1" (split)
                (("1" (propax) nil nil)
                 ("2" (skosimp*)
                  (("2" (lemma "Closest_MinOrMax")
                    (("2" (expand "MinOrMax?")
                      (("2" (inst -1 "b" "r" "f!1")
                        (("2" (split)
                          (("1" (expand "Closest?" -2)
                            (("1" (inst -2 "RND_Max(b)(r)")
                              (("1"
                                (flip-ineq -2)
                                (("1"
                                  (case-replace
                                   "FtoR(f!1) = FtoR(RND_Min(b)(r))")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (lemma "isMin_Unique")
                                    (("2"
                                      (expand "Unique?")
                                      (("2"
                                        (inst
                                         -1
                                         b
                                         r
                                         f!1
                                         "RND_Min(b)(r)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (rewrite "RND_Min_isMin")
                                            nil
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite "FcanonicBounded")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma "isMax_Unique")
                            (("2" (expand "Unique?")
                              (("2"
                                (inst -1 b r f!1 "RND_Max(b)(r)")
                                (("2"
                                  (assert)
                                  (("2"
                                    (rewrite "RND_Max_isMax")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r"))
                  (("2"
                    (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r"))
                    (("2" (expand* "isMin?" "isMax?" "Closest?")
                      (("2" (flatten)
                        (("2" (skosimp*)
                          (("2" (case "FtoR(f!1) <= r")
                            (("1" (expand abs)
                              (("1" (grind-reals) nil nil)) nil)
                             ("2" (expand "abs")
                              (("2" (grind-reals) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (rewrite "FcanonicBounded") nil nil))
              nil))
            nil))
          nil)
         ("3" (expand AFZClosest?)
          (("3" (flip-ineq 1)
            (("3" (case "Closest?(b)(r, RND_Max(b)(r))")
              (("1" (split)
                (("1" (propax) nil nil)
                 ("2" (skosimp*)
                  (("2" (case (r <= FtoR (RND_Max (b) (r))))
                    (("1" (expand abs) (("1" (grind-reals) nil nil))
                      nil)
                     ("2" (lemma RND_Max_isMax)
                      (("2" (inst -1 b r)
                        (("2" (expand isMax?) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r"))
                  (("2"
                    (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r"))
                    (("2" (expand* "isMin?" "isMax?" "Closest?")
                      (("2" (flatten)
                        (("2" (skosimp*)
                          (("2" (case "FtoR(f!1) <= r")
                            (("1" (expand "abs")
                              (("1" (grind-reals) nil nil)) nil)
                             ("2" (expand abs)
                              (("2" (grind-reals) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (rewrite "FcanonicBounded") nil nil))
              nil))
            nil))
          nil)
         ("4" (expand "AFZClosest?")
          (("4" (case "Closest?(b)(r, RND_Min(b)(r))")
            (("1" (split)
              (("1" (propax) nil nil)
               ("2" (skosimp*)
                (("2" (lemma "Closest_MinOrMax")
                  (("2" (expand MinOrMax?)
                    (("2" (inst -1 b r f!1)
                      (("2" (split)
                        (("1" (lemma "isMin_Unique")
                          (("1" (expand "Unique?")
                            (("1" (inst -1 b r f!1 "RND_Min(b)(r)")
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite "RND_Min_isMin")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma "isMax_Unique")
                          (("2" (expand "Unique?")
                            (("2" (inst -1 b r f!1 "RND_Max(b)(r)")
                              (("1"
                                (assert)
                                (("1" (rewrite RND_Max_isMax) nil nil))
                                nil)
                               ("2"
                                (rewrite "FcanonicBounded")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r"))
                (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r"))
                  (("2" (expand* "isMin?" "isMax?" "Closest?")
                    (("2" (flatten)
                      (("2" (skosimp*)
                        (("2" (case "FtoR(f!1) <= r")
                          (("1" (expand abs)
                            (("1" (grind-reals) nil nil)) nil)
                           ("2" (expand abs)
                            (("2" (grind-reals) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (rewrite "FcanonicBounded") nil nil))
            nil))
          nil)
         ("5" (flip-ineq 2)
          (("5" (flip-ineq 2)
            (("5" (expand "AFZClosest?")
              (("5" (case "Closest?(b)(r, RND_Min(b)(r))")
                (("1" (split)
                  (("1" (propax) nil nil)
                   ("2" (case ((RND_Min (b) (r) <= r)))
                    (("1" (expand abs) (("1" (grind-reals) nil nil))
                      nil)
                     ("2" (lemma RND_Min_isMin)
                      (("2" (inst -1 b r)
                        (("2" (expand isMin?) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2"
                    (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r"))
                    (("2"
                      (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r"))
                      (("2" (expand* "isMin?" "isMax?" "Closest?")
                        (("2" (flatten)
                          (("2" (skosimp*)
                            (("2" (case "FtoR(f!1) <= r")
                              (("1"
                                (expand abs)
                                (("1" (grind-reals) nil nil))
                                nil)
                               ("2"
                                (expand abs)
                                (("2" (grind-reals) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (rewrite "FcanonicBounded") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (RND_AFZClosest const-decl "(Fcanonic?(b))" floatbis nil)
    (both_sides_minus_lt2 formula-decl nil real_props nil)
    (le_minus_le formula-decl nil real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (both_sides_minus_le1 formula-decl nil real_props nil)
    (AFZClosest? const-decl "bool" float "float/")
    (<= const-decl "bool" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (isMin? const-decl "bool" float "float/")
    (isMax? const-decl "bool" float "float/")
    (Closest_MinOrMax formula-decl nil float "float/")
    (FtoR const-decl "real" float "float/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (isMax_Unique formula-decl nil float "float/")
    (r skolem-const-decl "real" floatbis nil)
    (b skolem-const-decl "Format[radix]" floatbis nil)
    (RND_Max_isMax formula-decl nil float "float/")
    (FcanonicBounded formula-decl nil float "float/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (RND_Max const-decl "(Fcanonic?(b))" float "float/")
    (isMin_Unique formula-decl nil float "float/")
    (RND_Min_isMin formula-decl nil float "float/")
    (Unique? const-decl "bool" float "float/")
    (MinOrMax? const-decl "bool" float "float/")
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (radix formal-const-decl "above(1)" floatbis nil)
    (Format type-eq-decl nil float "float/")
    (float type-eq-decl nil float "float/")
    (Fbounded? const-decl "bool" float "float/")
    (Closest? const-decl "bool" float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (RND_Min const-decl "(Fcanonic?(b))" float "float/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   44409 12530 t shostak)))
(whyfloat
 (div_double_TCC1 0
  (div_double_TCC1-1 nil 3424583899 3424583919
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (int nonempty-type-eq-decl nil integers nil)
    (float type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (bdouble const-decl "Format" whyfloat nil)
    (double type-eq-decl nil whyfloat nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (d_to_r const-decl "real" whyfloat nil)
    (FtoR const-decl "real" float "float/")
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   527 350 nil nil))
 (div_double_TCC2 0
  (div_double_TCC2-1 nil 3424583899 3424583920
   ("" (subtype-tcc) nil nil) proved
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   408 200 nil nil))
 (div_double_TCC3 0
  (div_double_TCC3-1 nil 3424583899 3424583920
   ("" (subtype-tcc) nil nil) proved
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   348 200 nil nil))
 (sqrt_double_TCC1 0
  (sqrt_double_TCC1-1 nil 3424583899 3424583921
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (int nonempty-type-eq-decl nil integers nil)
    (float type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (bdouble const-decl "Format" whyfloat nil)
    (double type-eq-decl nil whyfloat nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (d_to_r const-decl "real" whyfloat nil)
    (FtoR const-decl "real" float "float/")
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   478 270 nil nil))
 (sqrt_double_TCC2 0
  (sqrt_double_TCC2-1 nil 3424583899 3424583921
   ("" (subtype-tcc) nil nil) proved
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   607 190 nil nil))
 (sqrt_double_TCC3 0
  (sqrt_double_TCC3-1 nil 3424583899 3424583922
   ("" (subtype-tcc) nil nil) proved
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   868 200 nil nil))
 (neg_double_TCC1 0
  (neg_double_TCC1-1 nil 3424583899 3424584091
   ("" (skeep)
    (("" (lemma FcanonicOpp)
      (("" (inst -1 bdouble "float(f1)") (("" (assert) nil nil)) nil))
      nil))
    nil)
   proved
   ((FcanonicOpp formula-decl nil float "float/")
    (double type-eq-decl nil whyfloat nil)
    (Fcanonic? const-decl "bool" float "float/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (float type-eq-decl nil float "float/")
    (int nonempty-type-eq-decl nil integers nil)
    (bdouble const-decl "Format" whyfloat nil)
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (above nonempty-type-eq-decl nil integers nil))
   135922 40 t nil))
 (abs_double_TCC1 0
  (abs_double_TCC1-1 nil 3424583899 3424584140
   ("" (skeep) (("" (rewrite FabsCanonic) nil nil)) nil) proved
   ((FabsCanonic formula-decl nil float "float/")
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (bdouble const-decl "Format" whyfloat nil)
    (int nonempty-type-eq-decl nil integers nil)
    (float type-eq-decl nil float "float/")
    (real nonempty-type-from-decl nil reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Fcanonic? const-decl "bool" float "float/")
    (double type-eq-decl nil whyfloat nil))
   32680 670 t nil)))

