
(* Built-in types: unit, bool, int, real *)
(* Built-in type constructor: 'a ref *)

(********)
(* unit *)
(********)

logic eq_unit : unit,unit -> prop
logic neq_unit : unit,unit -> prop

parameter eq_unit_ : x:unit -> y:unit -> {} bool {if result then x=y else x<>y}
parameter neq_unit_: x:unit -> y:unit -> {} bool {if result then x<>y else x=y}


(********)
(* bool *)
(********)

logic eq_bool : bool,bool -> prop
logic neq_bool : bool,bool -> prop

parameter eq_bool_ : x:bool -> y:bool -> {} bool {if result then x=y else x<>y}
parameter neq_bool_: x:bool -> y:bool -> {} bool {if result then x<>y else x=y}

logic bool_and : bool, bool -> bool
logic bool_or  : bool, bool -> bool
logic bool_xor : bool, bool -> bool
logic bool_not : bool -> bool

axiom bool_and_def: forall a,b:bool. bool_and(a,b) = true <-> a=true and b=true
axiom bool_or_def: forall a,b:bool. bool_or(a,b) = true <-> a=true or b=true
axiom bool_xor_def: forall a,b:bool. bool_xor(a,b) = true <-> a <> b
axiom bool_not_def: forall a:bool. bool_not(a) = true <-> a=false

parameter strict_bool_and_ : 
  b1:bool -> b2:bool ->  
  {} bool { if result then b1=true and b2=true 
                      else (b1=false or b1=true and b2=false) }

parameter strict_bool_or_ : 
  b1:bool -> b2:bool -> 
  {} bool { if result then b1=true or b1=false and b2=true 
                      else (b1=false and b2=false) }

parameter bool_not_ : 
  b:bool -> {} bool { if result then b=false else b=true }

(* if-then-else function symbol *)

logic ite : bool,'a,'a -> 'a

axiom ite_true : forall x, y : 'a. ite(true, x, y) = x
axiom ite_false : forall x, y : 'a. ite(false, x, y) = y


(************)
(* Integers *)
(************)

logic add_int : int,int -> int (* + *)
logic sub_int : int,int -> int (* - *)
logic mul_int : int,int -> int (* * *)
logic div_int : int,int -> int (* / in logic only *)
logic mod_int : int,int -> int (* % in logic only *)
logic neg_int : int -> int     (* prefix - *)

(* / and % in programs: *)
parameter div_int_ : x:int -> y:int -> { y<>0 } int { result = x / y }
parameter mod_int_ : x:int -> y:int -> { y<>0 } int { result = x % y }

logic lt_int : int,int -> prop  (* <  *)
logic le_int : int,int -> prop  (* <= *)
logic gt_int : int,int -> prop  (* >  *)
logic ge_int : int,int -> prop  (* >= *)
logic eq_int : int,int -> prop  (* =  *)
logic neq_int : int,int -> prop (* <> *)

(* < <= > >= = and <> in programs: *)
parameter lt_int_ : x:int -> y:int -> {} bool { if result then x<y else x>=y }
parameter le_int_ : x:int -> y:int -> {} bool { if result then x<=y else x>y }
parameter gt_int_ : x:int -> y:int -> {} bool { if result then x>y else x<=y }
parameter ge_int_ : x:int -> y:int -> {} bool { if result then x>=y else x<y }
parameter eq_int_ : x:int -> y:int -> {} bool { if result then x=y else x<>y }
parameter neq_int_ : x:int -> y:int -> {} bool { if result then x<>y else x=y }

(* boolean versions of the comparisons and the corresponding axioms *)
logic lt_int_bool : int,int -> bool
logic le_int_bool : int,int -> bool
logic gt_int_bool : int,int -> bool
logic ge_int_bool : int,int -> bool
logic eq_int_bool : int,int -> bool
logic neq_int_bool : int,int -> bool

axiom lt_int_bool_axiom : 
  forall x:int. forall y:int. lt_int_bool(x,y)=true <-> x<y
axiom le_int_bool_axiom : 
  forall x:int. forall y:int. le_int_bool(x,y)=true <-> x<=y
axiom gt_int_bool_axiom : 
  forall x:int. forall y:int. gt_int_bool(x,y)=true <-> x>y
axiom ge_int_bool_axiom : 
  forall x:int. forall y:int. ge_int_bool(x,y)=true <-> x>=y
axiom eq_int_bool_axiom : 
  forall x:int. forall y:int. eq_int_bool(x,y)=true <-> x=y
axiom neq_int_bool_axiom : 
  forall x:int. forall y:int. neq_int_bool(x,y)=true <-> x<>y

(* Reals *)

logic add_real : real,real -> real (* + *)
logic sub_real : real,real -> real (* - *)
logic mul_real : real,real -> real (* * *)
logic div_real : real,real -> real (* / *)
logic pow_real : real,real -> real 
logic neg_real : real -> real      (* prefix - *)
logic abs_real : real -> real

(* / in programs: *)
parameter div_real_ : x:real -> y:real -> { y<>0.0 } real { result = x / y }

logic sqrt_real : real -> real
parameter sqrt_real_ : x:real -> { x >= 0.0 } real { result = sqrt_real(x) }

logic real_of_int : int -> real
logic int_of_real : real -> int

(* real comparisons in logic... *)
logic lt_real : real,real -> prop
logic le_real : real,real -> prop
logic gt_real : real,real -> prop
logic ge_real : real,real -> prop
logic eq_real : real,real -> prop
logic neq_real : real,real -> prop

(* ... and in programs: *)
parameter lt_real_ : x:real -> y:real -> {} bool {if result then x<y else x>=y}
parameter le_real_ : x:real -> y:real -> {} bool {if result then x<=y else x>y}
parameter gt_real_ : x:real -> y:real -> {} bool {if result then x>y else x<=y}
parameter ge_real_ : x:real -> y:real -> {} bool {if result then x>=y else x<y}
parameter eq_real_ : x:real -> y:real -> {} bool {if result then x=y else x<>y}
parameter neq_real_: x:real -> y:real -> {} bool {if result then x<>y else x=y}

(* boolean versions of the comparisons and the corresponding axioms *)
logic lt_real_bool : real,real -> bool
logic le_real_bool : real,real -> bool
logic gt_real_bool : real,real -> bool
logic ge_real_bool : real,real -> bool
logic eq_real_bool : real,real -> bool
logic neq_real_bool : real,real -> bool

axiom lt_real_bool_axiom : 
  forall x:real. forall y:real. lt_real_bool(x,y)=true <-> x<y
axiom le_real_bool_axiom : 
  forall x:real. forall y:real. le_real_bool(x,y)=true <-> x<=y
axiom gt_real_bool_axiom : 
  forall x:real. forall y:real. gt_real_bool(x,y)=true <-> x>y
axiom ge_real_bool_axiom : 
  forall x:real. forall y:real. ge_real_bool(x,y)=true <-> x>=y
axiom eq_real_bool_axiom : 
  forall x:real. forall y:real. eq_real_bool(x,y)=true <-> x=y
axiom neq_real_bool_axiom : 
  forall x:real. forall y:real. neq_real_bool(x,y)=true <-> x<>y


(* min and max *)

logic int_max : int, int -> int
logic int_min : int, int -> int
logic real_max : real, real -> real
logic real_min : real, real -> real

(* References. := is syntactic sugar for ref_set: *)

parameter ref_set : x:'a ref -> v:'a -> {} unit writes x { x = v }

(* Non-deterministic values *)

parameter any_bool : unit -> {} bool { true }
parameter any_int : unit -> {} int { true }
parameter any_real : unit -> {} real { true }

(* Default well-founded ordering over integers *)

predicate zwf_zero(a:int, b:int) = 0 <= b and a < b
