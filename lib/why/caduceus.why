
(* default variable initialisation *)
parameter any_int: unit -> int
parameter any_pointer: unit -> pointer

(* pointer arithmetic *)
logic null : -> pointer
logic block_length: alloc,pointer -> int
logic offset: pointer -> int
logic shift: pointer,int -> pointer

parameter alloc : alloc ref

predicate valid(a:alloc, p:pointer) = 
	p <> null 
	and 0 <= offset(p)
	and offset(p) < block_length(a,p)

predicate valid_index(a:alloc, p:pointer, i:int) =
	p <> null 
	and 0 <= offset(p)+i 
	and offset(p)+i < block_length(a,p)

predicate valid_range(a:alloc, p:pointer, i:int, j:int) =
	p <> null 
	and 0 <= offset(p)+i 
	and i <= j
	and offset(p)+j < block_length(a,p)

axiom offset_shift :
  forall p:pointer. forall i:int.
  offset(shift(p,i)) = offset(p)+i

axiom block_length_shift :
  forall a:alloc. forall p:pointer. forall i:int.
  block_length(a,shift(p,i)) = block_length(a,p)

axiom shift_null :
  forall p:pointer. forall i:int.
    p=null -> shift(p,i)=null

axiom shift_not_null :
  forall p:pointer. forall i:int.
    p<>null -> shift(p,i)<>null

parameter shift_ : p:pointer -> i:int -> 
  { } pointer { result = shift(p,i) }

(* pointer access *)
logic acc: 'a memory, pointer -> 'a
parameter acc_ : m:'a memory ref -> p:pointer -> 
  { valid(alloc,p) }
  'a reads alloc,m
  { result = acc(m,p) }

(* pointer update *)
logic upd: 'a memory, pointer, 'a -> 'a memory
parameter upd_ : m:'a memory ref -> p:pointer -> v:'a -> 
  { valid(alloc,p) }
  unit reads alloc,m writes m
  { m = upd(m@,p,v) }

axiom acc_upd_eq : 
  forall m : 'a memory. forall p : pointer. forall a: 'a.
    acc(upd(m,p,a),p) = a
 
axiom acc_upd_neq : 
  forall m : 'a memory. forall p1: pointer. forall p2 : pointer. 
  forall a: 'a.
    p1 <> p2 -> acc(upd(m,p1,a),p2) = acc(m,p2)

(* memory allocation *)
logic fresh : alloc,pointer -> prop

(* exceptions *)
exception Break
exception Continue
exception Return
exception Return_int of int
exception Return_float of float
exception Return_pointer of pointer

(* for Simplify *)
axiom false_not_true : false <> true

