
(* default variable initialisation *)
parameter any_int: unit -> int
parameter any_float: unit -> float
parameter any_pointer: unit -> pointer

(* pointer arithmetic *)
parameter null : pointer
logic block_length: alloc,pointer -> int
logic base_addr: pointer -> addr
logic offset: pointer -> int
logic shift: pointer,int -> pointer
logic sub_pointer: pointer,pointer -> int

parameter eq_pointer : 
  p:pointer -> q:pointer -> {} bool { if result then p=q else p<>q }
parameter neq_pointer : 
  p:pointer -> q:pointer -> {} bool { if result then p<>q else p=q }

parameter alloc : alloc ref

predicate valid(a:alloc, p:pointer) = 
	p <> null 
	and 0 <= offset(p)
	and offset(p) < block_length(a,p)

predicate valid_index(a:alloc, p:pointer, i:int) =
	p <> null 
	and 0 <= offset(p)+i 
	and offset(p)+i < block_length(a,p)

predicate valid_range(a:alloc, p:pointer, i:int, j:int) =
	p <> null 
	and 0 <= offset(p)+i 
	and i <= j
	and offset(p)+j < block_length(a,p)

axiom offset_shift :
  forall p:pointer. forall i:int.
  offset(shift(p,i)) = offset(p)+i

axiom base_addr_shift :
  forall p:pointer. forall i:int.
  base_addr(shift(p,i)) = base_addr(p)

axiom block_length_shift :
  forall a:alloc. forall p:pointer. forall i:int.
  block_length(a,shift(p,i)) = block_length(a,p)

axiom shift_null :
  forall p:pointer. forall i:int.
    p=null -> shift(p,i)=null

axiom shift_not_null :
  forall p:pointer. forall i:int.
    p<>null -> shift(p,i)<>null

axiom base_addr_block_length :
  forall a:alloc. forall p1:pointer. forall p2:pointer.
  base_addr(p1) = base_addr(p2) -> block_length(a,p1) = block_length(a,p2)

axiom pointer_pair_1 :
  forall p1:pointer. forall p2:pointer.
  (base_addr(p1) = base_addr(p2) and offset(p1) = offset(p2)) -> p1 = p2

axiom pointer_pair_2 :
  forall p1:pointer. forall p2:pointer.
  p1 = p2 -> (base_addr(p1) = base_addr(p2) and offset(p1) = offset(p2))

(* the following properties can be proved; here to help Simplify *)
axiom neq_base_addr_neq_shift :
  forall p1:pointer. forall p2:pointer.
  forall i:int. forall j:int.
  base_addr(p1) <> base_addr(p2) -> shift(p1,i) <> shift(p2,j)

axiom neq_offset_neq_shift :
  forall p1:pointer. forall p2:pointer.
  forall i:int. forall j:int.
  offset(p1)+i <> offset(p2)+j -> shift(p1,i) <> shift(p2,j)

axiom valid_range_valid_shift :
  forall a:alloc. forall p:pointer. forall i:int. forall j:int. forall k:int.
  valid_range(a,p,i,j) -> i <= k <= j -> valid(a,shift(p,k))

axiom sub_pointer_def :
  forall p1:pointer. forall p2:pointer.
  base_addr(p1) = base_addr(p2) -> sub_pointer(p1,p2) = offset(p1)-offset(p2)

parameter shift_ : p:pointer -> i:int -> 
  { } pointer { result = shift(p,i) }

parameter sub_pointer_ : p1:pointer -> p2:pointer ->
  { base_addr(p1) = base_addr(p2) } int { result = offset(p1) - offset(p2) }

(* pointer access *)
logic acc: 'a memory, pointer -> 'a
parameter acc_ : m:'a memory ref -> p:pointer -> 
  { valid(alloc,p) }
  'a reads alloc,m
  { result = acc(m,p) }

(* pointer update *)
logic upd: 'a memory, pointer, 'a -> 'a memory
parameter upd_ : m:'a memory ref -> p:pointer -> v:'a -> 
  { valid(alloc,p) }
  unit reads alloc,m writes m
  { m = upd(m@,p,v) }

axiom acc_upd : 
  forall m : 'a memory. forall p : pointer. forall a: 'a.
    acc(upd(m,p,a),p) = a
 
axiom acc_upd_eq : 
  forall m : 'a memory. forall p1: pointer. forall p2 : pointer. 
  forall a: 'a.
    p1=p2 -> acc(upd(m,p1,a),p2) = a
 
axiom acc_upd_neq : 
  forall m : 'a memory. forall p1: pointer. forall p2 : pointer. 
  forall a: 'a.
    p1 <> p2 -> acc(upd(m,p1,a),p2) = acc(m,p2)

(* memory allocation *)
logic fresh : alloc,pointer -> prop

(* exceptions *)
exception Break
exception Continue
exception Return
exception Return_int of int
exception Return_float of float
exception Return_pointer of pointer

(* for Simplify *)
axiom false_not_true : false <> true

(* modeling assigns clauses *)

logic pointer_loc : pointer -> assign_loc
logic all_loc : pointer -> assign_loc
logic range_loc : pointer,int,int -> assign_loc
logic union_loc : assign_loc, assign_loc -> assign_loc
logic unchanged : pointer,assign_loc -> prop

predicate assigns (a:alloc,m1:'a memory,m2:'a memory,l:assign_loc) =
 forall p:pointer.
    (valid(a,p) and unchanged(p,l)) -> acc(m2,p)=acc(m1,p)


axiom unchanged_pointer_intro : 
  forall p1:pointer.forall p2:pointer.
    p1 <> p2 -> unchanged(p1,pointer_loc(p2))

axiom unchanged_pointer_elim : 
  forall p1:pointer. forall p2:pointer.
    unchanged(p1,pointer_loc(p2)) -> p1 <> p2

axiom unchanged_union_intro : 
  forall l1:assign_loc. forall l2:assign_loc. forall p:pointer.
     unchanged(p,l1) and unchanged(p,l2) -> 
     unchanged(p,union_loc(l1,l2))

axiom unchanged_union_elim1 : 
  forall l1:assign_loc. forall l2:assign_loc. forall p:pointer.
    unchanged(p,union_loc(l1,l2)) -> unchanged(p,l1) 

axiom unchanged_union_elim2 : 
  forall l1:assign_loc. forall l2:assign_loc. forall p:pointer.
    unchanged(p,union_loc(l1,l2)) -> unchanged(p,l2)

axiom unchanged_range_intro :
  forall p1:pointer.forall p2:pointer.
    forall a:int. forall b:int.
 	(forall i:int.
	    (a <= i < b) -> (p1 <> shift(p2,i))) -> 
  	       unchanged(p1,range_loc(p2,a,b))	

axiom unchanged_range_elim :
  forall p1:pointer.forall p2:pointer.
    forall a:int. forall b:int.
       unchanged(p1,range_loc(p2,a,b)) ->
 	(forall i:int. a <= i < b -> p1 <> shift(p2,i))  


(* redondant axioms *)

(* marche pas: order sup
axiom assigns_upd :
 forall a:alloc. forall m:'a memory. forall unch:assign_loc.
   forall p:pointer. forall x:'a.
    not(unch(p)) -> assigns(a,m,upd(m,p,x),unch)
*)




