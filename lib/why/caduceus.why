
(* default variable initialisation *)
parameter any_int: unit -> int
parameter any_pointer: unit -> pointer

(* pointer arithmetic *)
logic null : -> pointer
logic length: pointer -> int
logic offset: pointer -> int
logic shift: pointer,int -> pointer
logic valid : pointer, int, int -> prop

axiom offset_shift :
  forall p:pointer. forall i:int.
  offset(shift(p,i)) = offset(p)+i

axiom length_shift :
  forall p:pointer. forall i:int.
  length(shift(p,i)) = length(p)

axiom shift_null :
  forall p:pointer. forall i:int.
    p=null -> shift(p,i)=null

axiom shift_not_null :
  forall p:pointer. forall i:int.
    p<>null -> shift(p,i)<>null

axiom valid_def :
  forall p:pointer. forall i:int. forall j:int.
	(p <> null 
	and 0 <= offset(p)+i 
	and i <= j
	and offset(p)+j <= length(p))
	-> valid(p,i,j)	

axiom valid_not_null :
  forall p:pointer. forall i:int. forall j:int.
	valid(p,i,j) -> p <> null 

axiom valid1 :
  forall p:pointer. forall i:int. forall j:int.
	valid(p,i,j) -> 0 <= offset(p)+i 

axiom valid2 :
  forall p:pointer. forall i:int. forall j:int.
	valid(p,i,j) -> i <= j

axiom valid3 :
  forall p:pointer. forall i:int. forall j:int.
	valid(p,i,j) -> offset(p)+j <= length(p)

parameter shift_ : p:pointer -> i:int -> 
  { } pointer { result = shift(p,i) }

(* pointer access *)
logic acc: 'a memory, pointer -> 'a
parameter acc_ : m:'a memory ref -> p:pointer -> 
  { p <> null and 0 <= offset(p) < length(p) }
  'a reads m
  { result = acc(m,p) }

(* pointer update *)
logic upd: 'a memory, pointer, 'a -> 'a memory
parameter upd_ : m:'a memory ref -> p:pointer -> v:'a -> 
  { p <> null and 0 <= offset(p) < length(p) }
  unit reads m writes m
  { m = upd(m@,p,v) }

axiom acc_upd_eq : 
  forall m : 'a memory. forall p : pointer. forall a: 'a.
    acc(upd(m,p,a),p) = a
 
axiom acc_upd_neq : 
  forall m : 'a memory. forall p1: pointer. forall p2 : pointer. 
  forall a: 'a.
    p1 <> p2 -> acc(upd(m,p1,a),p2) = acc(m,p2)
 
(* integer pointer/arrays *)
parameter intP : int memory ref
