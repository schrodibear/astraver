
(* prelude for floating-point arithmetic *)

type mode

logic nearest_even, to_zero, up, down, nearest_away : mode

parameter rounding_mode : mode ref

(* single precision *)

type single

logic add_single : mode,single,single -> single (* + *)
logic sub_single : mode,single,single -> single (* - *)
logic mul_single : mode,single,single -> single (* * *)
logic div_single : mode,single,single -> single (* / *)
logic neg_single : mode,single -> single        (* prefix - *)
logic abs_single : mode,single -> single
logic sqrt_single : mode,single -> single

logic s_to_r, s_to_exact, s_to_model : single -> real
logic r_to_s : mode,real -> single

logic single_round_error, single_total_error : single -> real
logic single_set_model : single,real -> single

(* overflow checks *)

logic max_single : real

parameter add_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(add_single(m,x,y))) <= max_single } 
  single
  { result = add_single(m,x,y) }

parameter sub_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(sub_single(m,x,y))) <= max_single } 
  single
  { result = sub_single(m,x,y) }

parameter mul_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(mul_single(m,x,y))) <= max_single } 
  single
  { result = mul_single(m,x,y) }

parameter div_single_ : 
  m:mode -> x:single -> y:single -> 
  { s_to_r(y) <> 0.0 and abs_real(s_to_r(div_single(m,x,y))) <= max_single } 
  single
  { result = div_single(m,x,y) }

parameter sqrt_single_ :
  m:mode -> x:single -> 
  { s_to_r(x) >= 0.0 } single { result = sqrt_single(m,x) }

parameter lt_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) < s_to_r(y) else s_to_r(x) >= s_to_r(y) }
parameter le_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) <= s_to_r(y) else s_to_r(x) > s_to_r(y) }
parameter gt_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) > s_to_r(y) else s_to_r(x) <= s_to_r(y) }
parameter ge_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) >= s_to_r(y) else s_to_r(x) < s_to_r(y) }
parameter eq_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) = s_to_r(y) else s_to_r(x) <> s_to_r(y) }
parameter neq_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) <> s_to_r(y) else s_to_r(x) = s_to_r(y) }

(* double precision *)

type double

logic add_double : mode,double,double -> double (* + *)
logic sub_double : mode,double,double -> double (* - *)
logic mul_double : mode,double,double -> double (* * *)
logic div_double : mode,double,double -> double (* / *)
logic neg_double : mode,double -> double        (* prefix - *)
logic abs_double : mode,double -> double
logic sqrt_double : mode,double -> double

logic d_to_r, d_to_exact, d_to_model : double -> real
logic r_to_d : mode,real -> double

logic double_round_error, double_total_error : double -> real
logic double_set_model : double,real -> double

(* overflow checks *)

logic max_double : real

parameter add_double_ : 
  m:mode -> x:double -> y:double -> 
  { abs_real(d_to_r(add_double(m,x,y))) <= max_double } 
  double
  { result = add_double(m,x,y) }

parameter sub_double_ : 
  m:mode -> x:double -> y:double -> 
  { abs_real(d_to_r(sub_double(m,x,y))) <= max_double } 
  double
  { result = sub_double(m,x,y) }

parameter mul_double_ : 
  m:mode -> x:double -> y:double -> 
  { abs_real(d_to_r(mul_double(m,x,y))) <= max_double } 
  double
  { result = mul_double(m,x,y) }

parameter div_double_ : 
  m:mode -> x:double -> y:double -> 
  { d_to_r(y) <> 0.0 and abs_real(d_to_r(div_double(m,x,y))) <= max_double } 
  double
  { result = div_double(m,x,y) }

parameter sqrt_double_ :
  m:mode -> x:double -> 
  { d_to_r(x) >= 0.0 } double { result = sqrt_double(m,x) }

parameter lt_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) < d_to_r(y) else d_to_r(x) >= d_to_r(y) }
parameter le_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) <= d_to_r(y) else d_to_r(x) > d_to_r(y) }
parameter gt_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) > d_to_r(y) else d_to_r(x) <= d_to_r(y) }
parameter ge_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) >= d_to_r(y) else d_to_r(x) < d_to_r(y) }
parameter eq_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) = d_to_r(y) else d_to_r(x) <> d_to_r(y) }
parameter neq_double :
  x:double -> y:double -> 
  {} bool { if result then d_to_r(x) <> d_to_r(y) else d_to_r(x) = d_to_r(y) }

(* quad precision *)

type quad

logic add_quad : mode,quad,quad -> quad (* + *)
logic sub_quad : mode,quad,quad -> quad (* - *)
logic mul_quad : mode,quad,quad -> quad (* * *)
logic div_quad : mode,quad,quad -> quad (* / *)
logic neg_quad : mode,quad -> quad        (* prefix - *)
logic abs_quad : mode,quad -> quad
logic sqrt_quad : mode,quad -> quad

logic q_to_r, q_to_exact, q_to_model : quad -> real
logic r_to_q : mode,real -> quad

logic quad_round_error, quad_total_error : quad -> real
logic quad_set_model : quad,real -> quad

(* overflow checks *)

logic max_quad : real

parameter add_quad_ : 
  m:mode -> x:quad -> y:quad -> 
  { abs_real(q_to_r(add_quad(m,x,y))) <= max_quad } 
  quad
  { result = add_quad(m,x,y) }

parameter sub_quad_ : 
  m:mode -> x:quad -> y:quad -> 
  { abs_real(q_to_r(sub_quad(m,x,y))) <= max_quad } 
  quad
  { result = sub_quad(m,x,y) }

parameter mul_quad_ : 
  m:mode -> x:quad -> y:quad -> 
  { abs_real(q_to_r(mul_quad(m,x,y))) <= max_quad } 
  quad
  { result = mul_quad(m,x,y) }

parameter div_quad_ : 
  m:mode -> x:quad -> y:quad -> 
  { q_to_r(y) <> 0.0 and abs_real(q_to_r(div_quad(m,x,y))) <= max_quad } 
  quad
  { result = div_quad(m,x,y) }

parameter sqrt_quad_ :
  m:mode -> x:quad -> 
  { q_to_r(x) >= 0.0 } quad { result = sqrt_quad(m,x) }

parameter lt_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) < q_to_r(y) else q_to_r(x) >= q_to_r(y) }
parameter le_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) <= q_to_r(y) else q_to_r(x) > q_to_r(y) }
parameter gt_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) > q_to_r(y) else q_to_r(x) <= q_to_r(y) }
parameter ge_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) >= q_to_r(y) else q_to_r(x) < q_to_r(y) }
parameter eq_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) = q_to_r(y) else q_to_r(x) <> q_to_r(y) }
parameter neq_quad :
  x:quad -> y:quad -> 
  {} bool { if result then q_to_r(x) <> q_to_r(y) else q_to_r(x) = q_to_r(y) }

(* conversions *)

logic double_of_single : single -> double
logic single_of_double : mode, double -> single

logic quad_of_single : single -> quad
logic single_of_quad : mode, quad -> single

logic quad_of_double : double -> quad
logic double_of_quad : mode, quad -> double

(* Caduceus-specific *)

exception Return_single of single
exception Return_double of double
exception Return_quad of quad

parameter any_single : unit -> {} single { true }
parameter any_double : unit -> {} double { true }
parameter any_quad : unit -> {} quad { true }
