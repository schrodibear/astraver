
(* prelude for floating-point arithmetic *)

type mode

logic nearest_even, to_zero, up, down, nearest_away : mode

parameter rounding_mode : mode ref

(* single precision *)

type single

logic add_single : mode,single,single -> single (* + *)
logic sub_single : mode,single,single -> single (* - *)
logic mul_single : mode,single,single -> single (* * *)
logic div_single : mode,single,single -> single (* / *)
logic neg_single : mode,single -> single        (* prefix - *)
logic abs_single : mode,single -> single
logic sqrt_single : mode,single -> single

logic s_to_r, s_to_r1, s_to_r2 : single -> real
logic r_to_s : mode,real -> single

logic single_rnd_error, single_total_error : single -> real
logic single_set_1, single_set_2 : single,real -> single

(* overflow checks *)

logic max_single : mode -> real

parameter add_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(x) + s_to_r(y)) <= max_single(m) } 
  single
  { result = add_single(m,x,y) }

parameter sub_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(x) - s_to_r(y)) <= max_single(m) } 
  single
  { result = sub_single(m,x,y) }

parameter mul_single_ : 
  m:mode -> x:single -> y:single -> 
  { abs_real(s_to_r(x) * s_to_r(y)) <= max_single(m) } 
  single
  { result = mul_single(m,x,y) }

parameter div_single_ : 
  m:mode -> x:single -> y:single -> 
  { s_to_r(y) <> 0.0 and abs_real(s_to_r(x) / s_to_r(y)) <= max_single(m) } 
  single
  { result = div_single(m,x,y) }

parameter sqrt_single_ :
  m:mode -> x:single -> 
  { s_to_r(x) >= 0.0 } single { result = sqrt_single(m,x) }

parameter lt_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) < s_to_r(y) else s_to_r(x) >= s_to_r(y) }
parameter le_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) <= s_to_r(y) else s_to_r(x) > s_to_r(y) }
parameter gt_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) > s_to_r(y) else s_to_r(x) <= s_to_r(y) }
parameter ge_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) >= s_to_r(y) else s_to_r(x) < s_to_r(y) }
parameter eq_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) = s_to_r(y) else s_to_r(x) <> s_to_r(y) }
parameter neq_single :
  x:single -> y:single -> 
  {} bool { if result then s_to_r(x) <> s_to_r(y) else s_to_r(x) = s_to_r(y) }

(* double precision *)

type double

(* quad precision *)

type quad

(* Caduceus-specific *)

exception Return_single of single
exception Return_double of double
exception Return_quad of quad

parameter any_single : unit -> {} single { true }
parameter any_double : unit -> {} double { true }
parameter any_quad : unit -> {} quad { true }
