

(************************************************************************)
(************************************************************************)
(****** Jessie prelude for floating-point arithmetic, Strict mode *******) 

(************************************************************************)
(************************************************************************)


include "floats_common.why"



(***************************************************)
(******** axioms on gen_float_of_real_logic ********)
(***************************************************)

(* obsolete ?
axiom a1: forall f:float_format. forall m:mode. forall x:real.
          no_overflow(f,m,x) ->
          float_value(gen_float_of_real_logic(f,m,x)) = round_float(f,m,x)

axiom a2: forall f:float_format. forall m:mode. forall x:real.
          exact_value(gen_float_of_real_logic(f,m,x)) = x

axiom a3: forall f:float_format. forall m:mode. forall x:real.
          model_value(gen_float_of_real_logic(f,m,x)) = x

*)
(* FAUX
axiom a4: forall f:float_format. forall m:mode. forall x:real. 
          no_overflow(f,m,x) and (exists y:gen_float. x = float_value(y)) -> 
          float_value(gen_float_of_real_logic(f,m,x))= x
*)
 


(***************************************************)
(** specification of unary and binary operations ***)
(***************************************************)


predicate gen_float_of_real_post(f:float_format,m:mode,x:real,res:gen_float) =
    float_value(res) = round_float(f,m,x)
    and
    exact_value(res) = x
    and
    model_value(res) = x



parameter gen_float_of_real : 
  f:float_format -> m:mode -> x:real ->
  { no_overflow(f,m,x) }
  gen_float
  { gen_float_of_real_post(f,m,x,result) }



parameter gen_float_of_real_safe : 
  f:float_format -> m:mode -> x:real ->
  { }
  gen_float
  { no_overflow(f,m,x) and
    gen_float_of_real_post(f,m,x,result) }



predicate add_gen_float_post(f:float_format,m:mode,
                             x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) + float_value(y))
    and 
    exact_value(res) = exact_value(x) + exact_value(y)
    and 
    model_value(res) = model_value(x) + model_value(y)



parameter add_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x) + float_value(y)) }
  gen_float
  { add_gen_float_post(f,m,x,y,result) }



parameter add_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { no_overflow(f,m,float_value(x) + float_value(y)) and
    add_gen_float_post(f,m,x,y,result) }



predicate sub_gen_float_post(f:float_format,m:mode,
	                     x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) - float_value(y))
    and 
    exact_value(res) = exact_value(x) - exact_value(y)
    and 
    model_value(res) = model_value(x) - model_value(y)



parameter sub_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x) - float_value(y)) }
  gen_float
  { sub_gen_float_post(f,m,x,y,result) }



parameter sub_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { no_overflow(f,m,float_value(x) - float_value(y)) 
    and sub_gen_float_post(f,m,x,y,result) }



predicate neg_gen_float_post(f:float_format,m:mode,
	                     x:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,-(float_value(x)))
    and 
    exact_value(res) = -(exact_value(x))
    and 
    model_value(res) = -(model_value(x))



parameter neg_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  { no_overflow(f,m,-(float_value(x))) }
  gen_float
  { neg_gen_float_post(f,m,x,result) }



parameter neg_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> 
  { }
  gen_float
  { no_overflow(f,m,-(float_value(x))) and
    neg_gen_float_post(f,m,x,result) }



predicate mul_gen_float_post(f:float_format,m:mode,
                             x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) * float_value(y))
    and 
    exact_value(res) = exact_value(x) * exact_value(y)
    and 
    model_value(res) = model_value(x) * model_value(y)



parameter mul_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x)*float_value(y)) }
  gen_float
  { mul_gen_float_post(f,m,x,y,result) }



parameter mul_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { no_overflow(f,m,float_value(x)*float_value(y)) and
    mul_gen_float_post(f,m,x,y,result) }



predicate div_gen_float_post(f:float_format,m:mode,
                             x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x)/float_value(y))
    and 
    exact_value(res) = exact_value(x)/exact_value(y)
    and 
    model_value(res) = model_value(x)/model_value(y)



parameter div_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { float_value(y) <> 0.0 
    and 
    no_overflow(f,m,float_value(x)/float_value(y)) }
  gen_float
  { div_gen_float_post(f,m,x,y,result) }



parameter div_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { float_value(y) <> 0.0 
    and 
    no_overflow(f,m,float_value(x)/float_value(y))
    and div_gen_float_post(f,m,x,y,result) }



parameter sqrt_gen_float_requires : 
  f:float_format -> m:mode -> x:gen_float -> 
  { float_value(x) >= 0.0 
    and 
    no_overflow(f,m,sqrt_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,sqrt_real(float_value(x)))
    and 
    exact_value(result) = sqrt_real(exact_value(x))
    and 
    model_value(result) = sqrt_real(model_value(x))
  }



parameter sqrt_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  {  }
  gen_float
  { float_value(result) = round_float(f,m,sqrt_real(float_value(x)))
    and 
    exact_value(result) = sqrt_real(exact_value(x))
    and 
    model_value(result) = sqrt_real(model_value(x))
  }



parameter abs_gen_float_requires : 
  f:float_format -> m:mode -> x:gen_float -> 
  { no_overflow(f,m,abs_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,abs_real(float_value(x)))
    and 
    exact_value(result) = abs_real(exact_value(x))
    and 
    model_value(result) = abs_real(model_value(x))
  }


parameter abs_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  {  }
  gen_float
  { float_value(result) = round_float(f,m,abs_real(float_value(x)))
    and 
    exact_value(result) = abs_real(exact_value(x))
    and 
    model_value(result) = abs_real(model_value(x))
  }


(***************************************************)
(******** comparisons of floats in the code ********)
(***************************************************)

parameter lt_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) < float_value(y) 
            else float_value(x) >= float_value(y) }

parameter le_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) <= float_value(y) 
            else float_value(x) > float_value(y) }

parameter gt_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) > float_value(y) 
            else float_value(x) <= float_value(y) }

parameter ge_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) >= float_value(y) 
            else float_value(x) < float_value(y) }

parameter eq_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) = float_value(y) 
            else float_value(x) <> float_value(y) }

parameter neq_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) <> float_value(y) 
            else float_value(x) = float_value(y) }



(***************************************************)
(*********** conversions between formats ***********)
(***************************************************)

predicate cast_gen_float_post(f:float_format,m:mode,x:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x))
    and
    exact_value(res) = exact_value(x)
    and
    model_value(res) = model_value(x)

parameter cast_gen_float : f:float_format -> m:mode -> x:gen_float ->
  { no_overflow(f,m,float_value(x)) }
  gen_float
  { cast_gen_float_post(f,m,x,result) }

parameter cast_gen_float_safe : f:float_format -> m:mode -> x:gen_float ->
  { }
  gen_float
  { no_overflow(f,m,float_value(x)) and
    cast_gen_float_post(f,m,x,result) }



(***************************************************)
(***************** any function ********************) 
(***************************************************)

parameter any_gen_float : float_format -> { } gen_float { }
