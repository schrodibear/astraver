
(* Jessie prelude for floating-point arithmetic, strict mode *)

include "floats_common.why"


axiom a1: forall f:float_format. forall m:mode. forall x:real.
          no_overflow(f,m,x) ->
          float_value(gen_float_of_real_logic(f,m,x)) = round_float(f,m,x)

axiom a2: forall f:float_format. forall m:mode. forall x:real.
          exact_value(gen_float_of_real_logic(f,m,x)) = x

axiom a3: forall f:float_format. forall m:mode. forall x:real.
          model_value(gen_float_of_real_logic(f,m,x)) = x



(* a false axiom: for f=Single, m=nearest_even and x=0.1 
axiom a4: forall f:float_format. forall m:mode. forall x:real. 
          float_value(gen_float_of_real(f,m,x))=x

axiom a5: forall f:float_format. forall m:mode. forall x:real. 
          no_overflow(f,m,x) -> (exists y:gen_float. x = float_value(y)) -> 
          float_value(gen_float_of_real(f,m,x))= x

axiom a6: forall f:float_format. forall m:mode. forall x:gen_float.
          eq_gen_float(gen_float_of_real(f,m,float_value(x)),x)  
*)

 
(* binary operations *)

parameter gen_float_of_real : 
  f:float_format -> m:mode -> x:real ->
  { no_overflow(f,m,x) }
  gen_float
  { float_value(result) = round_float(f,m,x) 
    and exact_value(result) = x
    and model_value(result) = x }

parameter gen_float_of_real_safe : 
  f:float_format -> m:mode -> x:real ->
  { }
  gen_float
  { float_value(result) = round_float(f,m,x) 
    and exact_value(result) = x
    and model_value(result) = x }


predicate add_gen_float_post(f:float_format,m:mode,x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) + float_value(y))
    and 
    exact_value(res) = exact_value(x) + exact_value(y)
    and 
    model_value(res) = model_value(x) + model_value(y)

parameter add_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x) + float_value(y)) }
  gen_float
  { add_gen_float_post(f,m,x,y,result) }

parameter add_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { add_gen_float_post(f,m,x,y,result) }

predicate sub_gen_float_post(f:float_format,m:mode,x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) - float_value(y))
    and 
    exact_value(res) = exact_value(x) - exact_value(y)
    and 
    model_value(res) = model_value(x) - model_value(y)

parameter sub_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x) - float_value(y)) }
  gen_float
  { sub_gen_float_post(f,m,x,y,result) }

parameter sub_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { no_overflow(f,m,float_value(x) - float_value(y)) 
    and sub_gen_float_post(f,m,x,y,result) }

parameter neg_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  { no_overflow(f,m,neg_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,neg_real(float_value(x)))
    and 
    exact_value(result) = neg_real(exact_value(x))
    and 
    model_value(result) = neg_real(model_value(x))
  }

predicate mul_gen_float_post(f:float_format,m:mode,x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x) * float_value(y))
    and 
    exact_value(res) = exact_value(x) * exact_value(y)
    and 
    model_value(res) = model_value(x) * model_value(y)

parameter mul_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { no_overflow(f,m,float_value(x)*float_value(y)) }
  gen_float
  { no_overflow(f,m,float_value(x)*float_value(y))
    and mul_gen_float_post(f,m,x,y,result) }

parameter mul_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { mul_gen_float_post(f,m,x,y,result) }

predicate div_gen_float_post(f:float_format,m:mode,x:gen_float,y:gen_float,res:gen_float) =
    float_value(res) = round_float(f,m,float_value(x)/float_value(y))
    and 
    exact_value(res) = exact_value(x)/exact_value(y)
    and 
    model_value(res) = model_value(x)/model_value(y)

parameter div_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { float_value(y) <> 0.0 
    and 
    no_overflow(f,m,float_value(x)/float_value(y)) }
  gen_float
  { div_gen_float_post(f,m,x,y,result) }

parameter div_gen_float_safe : 
  f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
  { }
  gen_float
  { float_value(y) <> 0.0 
    and 
    no_overflow(f,m,float_value(x)/float_value(y))
    and div_gen_float_post(f,m,x,y,result) }

parameter sqrt_gen_float_requires : 
  f:float_format -> m:mode -> x:gen_float -> 
  { float_value(x) >= 0.0 
    and 
    no_overflow(f,m,sqrt_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,sqrt_real(float_value(x)))
    and 
    exact_value(result) = sqrt_real(exact_value(x))
    and 
    model_value(result) = sqrt_real(model_value(x))
  }

parameter sqrt_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  {  }
  gen_float
  { float_value(result) = round_float(f,m,sqrt_real(float_value(x)))
    and 
    exact_value(result) = sqrt_real(exact_value(x))
    and 
    model_value(result) = sqrt_real(model_value(x))
  }

(*
parameter neg_gen_float_requires : 
  f:float_format -> m:mode -> x:gen_float -> 
  {no_overflow(f,m,neg_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,neg_real(float_value(x)))
    and 
    exact_value(result) = neg_real(exact_value(x))
    and 
    model_value(result) = neg_real(model_value(x))
  }
*)

parameter abs_gen_float_requires : 
  f:float_format -> m:mode -> x:gen_float -> 
  { no_overflow(f,m,abs_real(float_value(x))) }
  gen_float
  { float_value(result) = round_float(f,m,abs_real(float_value(x)))
    and 
    exact_value(result) = abs_real(exact_value(x))
    and 
    model_value(result) = abs_real(model_value(x))
  }

parameter abs_gen_float : 
  f:float_format -> m:mode -> x:gen_float -> 
  {  }
  gen_float
  { float_value(result) = round_float(f,m,abs_real(float_value(x)))
    and 
    exact_value(result) = abs_real(exact_value(x))
    and 
    model_value(result) = abs_real(model_value(x))
  }

function gen_round_error(x:gen_float) : real = 
	 abs_real(float_value(x) - exact_value(x))

function gen_relative_error(x:gen_float) : real =
         abs_real(float_value(x) - exact_value(x))/exact_value(x)

function gen_total_error(x:gen_float) : real = 
	 abs_real(float_value(x) - model_value(x))

parameter set_model : x:gen_float ref -> y:real ->
  { } 
  unit writes x
  { float_value(x) = float_value(x@)
    and exact_value(x) = exact_value(x@)
    and model_value(x) = y }


parameter lt_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) < float_value(y) else float_value(x) >= float_value(y) }
parameter le_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) <= float_value(y) else float_value(x) > float_value(y) }
parameter gt_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) > float_value(y) else float_value(x) <= float_value(y) }
parameter ge_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) >= float_value(y) else float_value(x) < float_value(y) }
parameter eq_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) = float_value(y) else float_value(x) <> float_value(y) }
parameter neq_gen_float :
  x:gen_float -> y:gen_float -> 
  {} bool { if result then float_value(x) <> float_value(y) else float_value(x) = float_value(y) }



(* conversions *)

parameter cast_gen_float : f:float_format -> m:mode -> x:gen_float ->
   { no_overflow(f,m,float_value(x)) }
   gen_float
   { float_value(result) = round_float(f,m,float_value(x)) 
     and exact_value(result) = exact_value(x)
     and model_value(result) = model_value(x) }

(* any function *)

parameter any_gen_float : float_format -> { } gen_float { }
