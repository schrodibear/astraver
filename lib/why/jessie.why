

(****************************

 pointers, allocation, validity 

*********************************)

type alloc_table

type pointer

logic offset_max : alloc_table, pointer -> int
logic offset_min : alloc_table, pointer -> int

predicate valid (a:alloc_table, p:pointer) = 
  offset_min(a,p) <= 0 and offset_max(a,p) >= 0

parameter alloc : alloc_table ref


(**************************************

heap memories, select and store

****************************)

type 'v memory

logic select : 'v memory, pointer -> 'v 
logic store : 'v memory, pointer, 'v -> 'v memory

axiom select_store_eq:
  forall m: 'v memory. 
  forall p1: pointer. 
  forall p2: pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1=p2 -> select(store(m,p1,a),p2) = a
 
axiom select_store_neq : 
  forall m: 'v memory. 
  forall p1: pointer. 
  forall p2: pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1 <> p2 -> select(store(m,p1,a),p2) = select(m,p2)


(****************************

structure invariants

***************************)

parameter mutable : bool memory ref 

parameter unpack_ : p:pointer ->
  { select(mutable,p) = false }
  unit
  reads mutable 
  writes mutable	
  { mutable = store(mutable@,p,true) }

parameter pack_ : p:pointer ->
  { select(mutable,p) = true }
  unit
  reads mutable 
  writes mutable	
  { mutable = store(mutable@,p,false) }

(****************************

access and update side-effect functions

***************************)

parameter acc_ : m : 'v memory ref -> p:pointer ->
	{ valid(alloc,p) }
	'v 
	reads alloc,m
	{ result = select(m,p) }

parameter upd_ : m : 'v memory ref -> p:pointer -> v:'v ->
	{ valid(alloc,p)  and select(mutable,p) = true }
	unit
	reads alloc,mutable writes m
	{ m = store(m@,p,v) }

parameter safe_upd_ : m : 'v memory ref -> p:pointer -> v:'v ->
	{ select(mutable,p) = true }
	unit
	reads alloc,mutable writes m
	{ m = store(m@,p,v) }


(*************

memory locations, not_assigns predicate

***************)


type pset

logic pset_empty : pset
logic pset_singleton : pointer -> pset
logic pset_union : pset, pset -> pset


logic in_pset : pointer, pset -> prop

axiom in_pset_empty:
  forall p:pointer. not in_pset(p,pset_empty)

axiom in_pset_singleton:
  forall p:pointer. 
  forall q:pointer.
    in_pset(p,pset_singleton(q)) <-> p=q

 axiom in_pset_union:
  forall p:pointer. 
  forall s1:pset.
  forall s2:pset.
    in_pset(p,pset_union(s1,s2)) <-> in_pset(p,s1) or in_pset(p,s2)
 
predicate not_assigns 
  (a:alloc_table, m1:'v memory, m2:'v memory, l:pset) =
    forall p:pointer. 
      valid(a,p) and not in_pset(p,l) -> select(m2,p)=select(m1,p)

(*******************

  lattice of structures


**********************)


type struct_id

logic instanceof : alloc_table, pointer, struct_id -> prop

parameter instanceof_ : 
  a:alloc_table -> p:pointer -> s:struct_id ->
  { } bool 
  { if result then instanceof(a,p,s) else not instanceof(a,p,s) }

logic downcast : alloc_table, pointer, struct_id -> pointer

axiom downcast_instanceof :
  forall a:alloc_table.
  forall p:pointer.
  forall s:struct_id.
   instanceof(a,p,s) -> downcast(a,p,s)=p

parameter downcast_ : 
  a:alloc_table -> p:pointer -> s:struct_id ->
  { instanceof(a,p,s) } pointer 
  { result=p }

