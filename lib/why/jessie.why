

(****************************

 pointers, allocation, validity 

*********************************)

type 't alloc_table

type 't pointer

logic offset_max : 't alloc_table, 't pointer -> int
logic offset_min : 't alloc_table, 't pointer -> int

predicate valid (a:'t alloc_table, p:'t pointer) = 
  offset_min(a,p) <= 0 and offset_max(a,p) >= 0

logic shift : 't pointer, int -> 't pointer

axiom offset_max_shift :
 forall a:'t alloc_table.
  forall p: 't pointer. forall i:int.
	offset_max(a,shift(p,i)) = offset_max(a,p)-i

axiom offset_min_shift : 
 forall a:'t alloc_table.
  forall p: 't pointer. forall i:int.
	offset_min(a,shift(p,i)) = offset_min(a,p)-i

(* the null pointer *)

logic null : 't pointer

axiom null_not_valid: forall a:'t alloc_table. not valid(a,null)

(**************************************

heap memories, select and store

****************************)

type ('t,'v) memory

logic select : ('t,'v) memory, 't pointer -> 'v 
logic store : ('t,'v) memory, 't pointer, 'v -> ('t,'v) memory

axiom select_store_eq:
  forall m: ('t,'v) memory. 
  forall p1: 't pointer. 
  forall p2: 't pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1=p2 -> select(store(m,p1,a),p2) = a
 
axiom select_store_neq : 
  forall m: ('t,'v) memory. 
  forall p1: 't pointer. 
  forall p2: 't pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1 <> p2 -> select(store(m,p1,a),p2) = select(m,p2)


(****************************

structure invariants

***************************)

(*
parameter mutable : bool memory ref 

parameter unpack_ : p:'t pointer ->
  { select(mutable,p) = false }
  unit
  reads mutable 
  writes mutable	
  { mutable = store(mutable@,p,true) }

parameter pack_ : p:'t pointer ->
  { select(mutable,p) = true }
  unit
  reads mutable 
  writes mutable	
  { mutable = store(mutable@,p,false) }
*)

(****************************

access and update side-effect functions

***************************)

parameter acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer ->
  { valid(alloc,p) }
  'v 
  reads alloc,m
  { result = select(m,p) }

parameter upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> v:'v ->
  { valid(alloc,p) (* and select(mutable,p) = true *) }
  unit
  reads alloc,m (* ,mutable *)
  writes m
  { m = store(m@,p,v) }

parameter safe_upd_ : m : ('t,'v) memory ref -> p:'t pointer -> v:'v ->
  { (* select(mutable,p) = true *) }
  unit
  reads m (* ,mutable *) 
  writes m
  { m = store(m@,p,v) }


(*************

memory locations, not_assigns predicate

***************)


type 't pset

logic pset_empty : 't pset
logic pset_singleton : 't pointer -> 't pset
logic pset_deref : ('t,'v pointer) memory, 't pset -> 'v pset
logic pset_union : 't pset, 't pset -> 't pset
logic pset_range : 't pset, int, int -> 't pset

logic in_pset : 't pointer, 't pset -> prop

axiom in_pset_empty:
  forall p:'t pointer. not in_pset(p,pset_empty)

axiom in_pset_singleton:
  forall p:'t pointer. 
  forall q:'t pointer.
    in_pset(p,pset_singleton(q)) <-> p=q

axiom in_pset_deref:
  forall p:'v pointer. 
  forall m:('t,'v pointer) memory.
  forall q:'t pset.
    in_pset(p,pset_deref(m,q)) <-> 
	exists r:'t pointer. in_pset(r,q) and p = select(m,r)

axiom in_pset_range:
  forall p:'t pointer. 
  forall q:'t pset.
  forall a:int. forall b:int.
    in_pset(p,pset_range(q,a,b)) <-> 
	exists i:int. exists r:'t pointer.
          a <= i and i <= b and in_pset(r,q) and p=shift(r,i)

axiom in_pset_union:
  forall p:'t pointer. 
  forall s1:'t pset.
  forall s2:'t pset.
    in_pset(p,pset_union(s1,s2)) <-> in_pset(p,s1) or in_pset(p,s2)
 
predicate not_assigns 
  (a:'t alloc_table, m1:('t,'v) memory, m2:('t,'v) memory, l:'t pset) =
    forall p:'t pointer. 
      valid(a,p) and not in_pset(p,l) -> select(m2,p)=select(m1,p)

(*******************

  lattice of structures


**********************)


type 't tag_table

type 't tag_id

logic instanceof : 't tag_table, 't pointer, 't tag_id -> prop

parameter instanceof_ : 
  a:'t tag_table -> p:'t pointer -> s:'t tag_id ->
  { } 
  bool 
  { if result then instanceof(a,p,s) else not instanceof(a,p,s) }

logic downcast : 't tag_table, 't pointer, 't tag_id -> 't pointer

axiom downcast_instanceof :
  forall a:'t tag_table.
  forall p:'t pointer.
  forall s:'t tag_id.
   instanceof(a,p,s) -> downcast(a,p,s)=p

parameter downcast_ : 
  a:'t tag_table -> p:'t pointer -> s:'t tag_id ->
  { instanceof(a,p,s) } 
  't pointer 
  { result=p }


