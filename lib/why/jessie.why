
axiom div_int_euclid :
  forall i:int. forall j:int [i/j].
    i>=0 and j>0 -> (i-j+1 <= j*(i/j) and j*(i/j) <= i)


(*****************************************************************************)
(* pointers, allocation, validity                                            *)
(*****************************************************************************)

type 't alloc_table

type 't pointer

logic offset_max : 't alloc_table, 't pointer -> int
logic offset_min : 't alloc_table, 't pointer -> int

predicate valid (a:'t alloc_table, p:'t pointer) = 
  offset_min(a,p) <= 0 and offset_max(a,p) >= 0

logic shift : 't pointer, int -> 't pointer
logic sub_pointer: 't pointer, 't pointer -> int

axiom shift_zero :
  forall p: 't pointer [shift(p,0)]. shift(p,0) = p

axiom offset_max_shift :
 forall a:'t alloc_table.
  forall p: 't pointer. forall i:int.
	offset_max(a,shift(p,i)) = offset_max(a,p)-i

axiom offset_min_shift : 
 forall a:'t alloc_table.
  forall p: 't pointer. forall i:int.
	offset_min(a,shift(p,i)) = offset_min(a,p)-i

(* the null pointer *)

logic null : 't pointer

axiom null_not_valid : forall a:'t alloc_table. not valid(a,null)

(* pointer comparison *)

parameter eq_pointer : 
  p: 't pointer -> q: 't pointer -> {} bool { if result then p=q else p<>q }
parameter neq_pointer : 
  p: 't pointer -> q: 't pointer -> {} bool { if result then p<>q else p=q }


(*****************************************************************************)
(* heap memories, select and store                                           *)
(*****************************************************************************)

type ('t,'v) memory

logic select : ('t,'v) memory, 't pointer -> 'v 
logic store : ('t,'v) memory, 't pointer, 'v -> ('t,'v) memory

axiom select_store_eq:
  forall m: ('t,'v) memory. 
  forall p1: 't pointer. 
  forall p2: 't pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1=p2 -> select(store(m,p1,a),p2) = a
 
axiom select_store_neq : 
  forall m: ('t,'v) memory. 
  forall p1: 't pointer. 
  forall p2: 't pointer. 
  forall a: 'v [select(store(m,p1,a),p2)].
    p1 <> p2 -> select(store(m,p1,a),p2) = select(m,p2)


(*****************************************************************************)
(* access and update side-effect functions                                   *)
(*****************************************************************************)

(* normal access *)
parameter acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  { offset_min(alloc,p) <= 0 and 0 <= offset_max(alloc,p) }
  'v 
  reads alloc,m
  { result = select(m,p) }

(* offset access *)
parameter offset_acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> 
  p:'t pointer -> off:int ->
  { offset_min(alloc,p) <= off and off <= offset_max(alloc,p) }
  'v 
  reads alloc,m
  { result = select(m,shift(p,off)) }

(* safe access *)
parameter safe_acc_ : 
  m : ('t,'v) memory ref -> p:'t pointer ->
  { }
  'v 
  reads m
  { result = select(m,p) }

(* bounded access *)
parameter bound_acc_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> lb:int -> rb:int -> 
  { lb <= off and off <= rb }
  'v 
  reads m
  { result = select(m,shift(p,off)) }

(* bounded access with safe left bound *)
parameter lsafe_bound_acc_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> rb:int -> 
  { off <= rb }
  'v 
  reads m
  { result = select(m,shift(p,off)) }

(* bounded access with safe right bound *)
parameter rsafe_bound_acc_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> lb:int -> 
  { lb <= off }
  'v 
  reads m
  { result = select(m,shift(p,off)) }

(* left bounded access *)
parameter lbound_acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> lb:int -> 
  { lb <= off and off <= offset_max(alloc,p) }
  'v 
  reads alloc,m
  { result = select(m,shift(p,off)) }

(* left bounded access with safe left bound *)
parameter lsafe_lbound_acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> 
  { off <= offset_max(alloc,p) }
  'v 
  reads alloc,m
  { result = select(m,shift(p,off)) }

(* right bounded access *)
parameter rbound_acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> rb:int -> 
  { offset_min(alloc,p) <= off and off <= rb }
  'v 
  reads alloc,m
  { result = select(m,shift(p,off)) }

(* right bounded access with safe right bound *)
parameter rsafe_rbound_acc_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> 
  { offset_min(alloc,p) <= off }
  'v 
  reads alloc,m
  { result = select(m,shift(p,off)) }

(* normal update *)
parameter upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> v:'v ->
  { offset_min(alloc,p) <= 0 and 0 <= offset_max(alloc,p) }
  (* and select(mutable,p) = true *)
  unit
  reads alloc,m (* ,mutable *)
  writes m
  { m = store(m@,p,v) }

(* offset update *)
parameter offset_upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer ->
   off:int -> v:'v ->
  { offset_min(alloc,p) <= off and off <= offset_max(alloc,p) }
  (* and select(mutable,p) = true *)
  unit
  reads alloc,m (* ,mutable *)
  writes m
  { m = store(m@,shift(p,off),v) }

(* safe update *)
parameter safe_upd_ : m : ('t,'v) memory ref -> p:'t pointer -> v:'v ->
  { (* select(mutable,p) = true *) }
  unit
  reads m (* ,mutable *) 
  writes m
  { m = store(m@,p,v) }

(* bounded update *)
parameter bound_upd_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> lb:int -> rb:int -> 
  v:'v ->
  { lb <= off and off <= rb }
  unit
  reads m
  writes m
  { m = store(m@,shift(p,off),v) }

(* bounded update with safe left bound *)
parameter lsafe_bound_upd_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> rb:int -> v:'v ->
  { off <= rb }
  unit
  reads m
  writes m
  { m = store(m@,shift(p,off),v) }

(* bounded update with safe right bound *)
parameter rsafe_bound_upd_ : 
  m : ('t,'v) memory ref -> p:'t pointer -> off:int -> lb:int -> v:'v ->
  { lb <= off }
  unit
  reads m
  writes m
  { m = store(m@,shift(p,off),v) }

(* left bounded update *)
parameter lbound_upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> lb:int -> v:'v ->
  { lb <= off and off <= offset_max(alloc,p) }
  unit
  reads alloc,m
  writes m
  { m = store(m@,shift(p,off),v) }

(* left bounded update with safe left bound *)
parameter lsafe_lbound_upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> v:'v ->
  { off <= offset_max(alloc,p) }
  unit
  reads alloc,m
  writes m
  { m = store(m@,shift(p,off),v) }

(* right bounded update *)
parameter rbound_upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> rb:int -> v:'v ->
  { offset_min(alloc,p) <= off and off <= rb }
  unit
  reads alloc,m
  writes m
  { m = store(m@,shift(p,off),v) }

(* right bounded update with safe right bound *)
parameter rsafe_rbound_upd_ : 
  alloc:'t alloc_table ref -> m : ('t,'v) memory ref -> p:'t pointer -> 
  off:int -> v:'v ->
  { offset_min(alloc,p) <= off }
  unit
  reads alloc,m
  writes m
  { m = store(m@,shift(p,off),v) }


(*****************************************************************************)
(* memory locations, not_assigns predicate, separation                       *)
(*****************************************************************************)

type 't pset

logic pset_empty : 't pset
logic pset_singleton : 't pointer -> 't pset
logic pset_deref : ('t,'v pointer) memory, 't pset -> 'v pset
logic pset_union : 't pset, 't pset -> 't pset
logic pset_all : 'z pset -> 'z pset (* l(..) *)
logic pset_range : 't pset, int, int -> 't pset (* l(a..b) *)
logic pset_range_left : 'z pset, int -> 'z pset (* l(..b) *)
logic pset_range_right : 'z pset, int -> 'z pset (* l(a..) *)

logic in_pset : 't pointer, 't pset -> prop

axiom in_pset_empty:
  forall p:'t pointer. not in_pset(p,pset_empty)

axiom in_pset_singleton:
  forall p:'t pointer. 
  forall q:'t pointer.
    in_pset(p,pset_singleton(q)) <-> p=q

axiom in_pset_deref:
  forall p:'v pointer. 
  forall m:('t,'v pointer) memory.
  forall q:'t pset.
    in_pset(p,pset_deref(m,q)) <-> 
	exists r:'t pointer. in_pset(r,q) and p = select(m,r)

axiom in_pset_all:
  forall p:'t pointer. 
  forall q:'t pset.
    in_pset(p,pset_all(q)) <-> 
	exists i:int. exists r:'t pointer.
          in_pset(r,q) and p=shift(r,i)

axiom in_pset_range:
  forall p:'t pointer. 
  forall q:'t pset.
  forall a:int. forall b:int.
    in_pset(p,pset_range(q,a,b)) <-> 
	exists i:int. exists r:'t pointer.
          a <= i and i <= b and in_pset(r,q) and p=shift(r,i)

axiom in_pset_range_left:
  forall p:'t pointer. 
  forall q:'t pset.
  forall b:int.
    in_pset(p,pset_range_left(q,b)) <-> 
	exists i:int. exists r:'t pointer.
          i <= b and in_pset(r,q) and p=shift(r,i)

axiom in_pset_range_right:
  forall p:'t pointer. 
  forall q:'t pset.
  forall a:int.
    in_pset(p,pset_range_right(q,a)) <-> 
	exists i:int. exists r:'t pointer.
          a <= i and in_pset(r,q) and p=shift(r,i)

axiom in_pset_union:
  forall p:'t pointer. 
  forall s1:'t pset.
  forall s2:'t pset.
    in_pset(p,pset_union(s1,s2)) <-> in_pset(p,s1) or in_pset(p,s2)
 
predicate not_assigns 
  (a:'t alloc_table, m1:('t,'v) memory, m2:('t,'v) memory, l:'t pset) =
    forall p:'t pointer. 
      valid(a,p) and not in_pset(p,l) -> select(m2,p)=select(m1,p)

logic full_separated : 't pointer, 't pointer -> prop

axiom full_separated_shift1 :
  forall p: 'z pointer. forall q : 'z pointer. forall i: int.
    full_separated(p,q) -> full_separated(p,shift(q,i))

axiom full_separated_shift2 :
  forall p: 'z pointer. forall q : 'z pointer. forall i: int.
    full_separated(p,q) -> full_separated(shift(q,i),p)

axiom full_separated_shift3 :
  forall p: 'z pointer. forall q : 'z pointer. forall i: int.
    full_separated(q,p) -> full_separated(shift(q,i),p)

axiom full_separated_shift4 :
  forall p: 'z pointer. forall q : 'z pointer. forall i: int.
    full_separated(q,p) -> full_separated(p,shift(q,i))


(*****************************************************************************)
(* lattice of structures                                                     *)
(*****************************************************************************)

(*****
typeof gives the dynamic type of an object.

parenttag is defined by axioms in jc_interp, and defines the hierarchy.
  parenttag(a, t1, t2) <-> t2 is the immediate superclass of t1

subtag is axiomatized from parenttag, and is the reflexive, transitive
  closure of parenttag.

instanceof is defined from typeof and subtag.
*****)

type 't tag_table

type 't tag_id

logic typeof: 't tag_table, 't pointer -> 't tag_id

logic parenttag: 't tag_id, 't tag_id -> prop

logic subtag: 't tag_id, 't tag_id -> prop

axiom subtag_refl:
  forall t: 't tag_id.
    subtag(t, t)

axiom subtag_parent:
  forall t1: 't tag_id.
  forall t2: 't tag_id.
  forall t3: 't tag_id.
    subtag(t1, t2) -> parenttag(t2, t3) -> subtag(t1, t3)

predicate instanceof (a: 't tag_table, p: 't pointer, t: 't tag_id) =
  subtag(typeof(a, p), t)

parameter instanceof_ : 
  a:'t tag_table -> p:'t pointer -> s:'t tag_id ->
  { } 
  bool 
  { if result then instanceof(a,p,s) else not instanceof(a,p,s) }

logic downcast : 't tag_table, 't pointer, 't tag_id -> 't pointer

axiom downcast_instanceof :
  forall a:'t tag_table.
  forall p:'t pointer.
  forall s:'t tag_id.
   instanceof(a,p,s) -> downcast(a,p,s)=p

parameter downcast_ : 
  a:'t tag_table -> p:'t pointer -> s:'t tag_id ->
  { instanceof(a,p,s) } 
  't pointer 
  { result=p }

logic bottom_tag: 'a tag_id

axiom bottom_tag_axiom:
  forall t: 't tag_id.
    subtag(t, bottom_tag)


(*****************************************************************************)
(* structure invariants                                                      *)
(*****************************************************************************)

predicate fully_packed(
  tag_table: 'a tag_table,
  mutable: ('a, 'a tag_id) memory,
  this: 'a pointer) =
    select(mutable, this) = typeof(tag_table, this)


(*****************************************************************************)
(* default values                                                            *)
(*****************************************************************************)

(* already in Why
parameter any_int : unit -> {} int {}
*)

parameter any_pointer: unit -> {} 'z pointer { true }


(*****************************************************************************)
(* bitwise operations                                                        *)
(*****************************************************************************)

logic bw_compl : int -> int

logic bw_and : int,int -> int

logic bw_xor : int,int -> int

logic bw_or : int,int -> int

logic lsl : int,int -> int

logic lsr : int,int -> int

logic asr : int,int -> int


(*****************************************************************************)
(* dynamic allocation/deallocation                                           *)
(*****************************************************************************)

logic alloc_extends : 't alloc_table, 't alloc_table -> prop

axiom alloc_extends_offset_min : 
  forall a1:'t alloc_table. forall a2:'t alloc_table [alloc_extends(a1,a2)]. 
    alloc_extends(a1,a2) -> 
      forall p:'t pointer. forall a:int.
        offset_min(a1,p) <= a -> offset_min(a2,p) <= a

axiom alloc_extends_offset_max : 
  forall a1:'t alloc_table. forall a2:'t alloc_table [alloc_extends(a1,a2)]. 
    alloc_extends(a1,a2) -> 
      forall p:'t pointer. forall b:int.
        offset_max(a1,p) >= b -> offset_max(a2,p) >= b

parameter alloc_parameter_ownership : 
  a:'t alloc_table ref -> mut:('t,'t tag_id) memory ref ->
  com:('t,bool) memory ref -> at:'t tag_table ref -> s:'t tag_id -> n:int -> 
  { n > 0 }
  't pointer 
  reads mut, com
  writes a, at
  { alloc_extends(a@,a)
    and offset_min(a,result) = 0 and offset_max(a,result) = n-1 
    and instanceof(at,result,s) and select(mut,result) = bottom_tag 
    and select(com,result) = false }

parameter free_parameter_ownership : 
  a:'t alloc_table ref -> com:('t,bool) memory ref -> p:'t pointer -> 
  { offset_min(a,p) = 0 and offset_max(a,p) >= 0 
	and select(com,p) = false }
  unit
  reads com
  writes a
  { offset_max(a,p) < offset_min(a,p) }

(* With -inv-sem <> ownership *)

parameter alloc_parameter : 
  a:'t alloc_table ref -> at:'t tag_table ref -> s:'t tag_id -> n:int -> 
  { n > 0 }
  't pointer 
  writes a, at
  { alloc_extends(a@,a)
    and offset_min(a,result) = 0 and offset_max(a,result) = n-1 
    and instanceof(at,result,s) }

parameter free_parameter : 
  a:'t alloc_table ref -> p:'t pointer -> 
  { offset_min(a,p) = 0 and offset_max(a,p) >= 0 }
  unit
  writes a
  { offset_max(a,p) < offset_min(a,p) }


(*****************************************************************************)
(* exceptions for control flow handling                                      *)
(*****************************************************************************)

exception Return