
(*********************************************************************************)
(*********************************************************************************)
(* Jessie prelude for floating-point arithmetic, common to Strcit and Full mode **) 

(*********************************************************************************)
(*********************************************************************************)


include "real.why"

type mode = nearest_even | to_zero | up | down | nearest_away 

parameter current_rounding_mode : mode ref



(***************************************************)
(*********** generic precision floats **************) 
(***************************************************)

type float_format = Single | Double | Binary80 | Quad 

(* [gen_float] denotes the type of generic floats *)

type gen_float

logic round_float : float_format, mode, real -> real
logic gen_float_of_real_logic : float_format, mode, real -> gen_float

logic float_value : gen_float -> real
logic exact_value : gen_float -> real
logic model_value : gen_float -> real

function max_gen_float(f:float_format): real =
  match f with 
   | Single -> 0x1.FFFFFEp127 (* (2 - 2^-23)*2^127 *)
   | Double -> 0x1.FFFFFFFFFFFFFp1023 (* (2 - 2^-52)*2^1023 *)
   | Binary80 -> 0x1.FFFFFFFFFFFFFFFEp16383 
   | Quad -> 0x1.FFFFFFFFFFFFFFFFFFFFFFFFFFFFp16383 
  end

logic min_gen_float : float_format -> real
(*logic max_exp : float_format -> int*)

(* values of max_gen_float *)
goal max_single: max_gen_float(Single) = 0x1.FFFFFEp127
                 (* (2 - 2^-23)*2^127 *)
goal max_double: max_gen_float(Double) = 0x1.FFFFFFFFFFFFFp1023 
                 (* (2 - 2^-52)*2^1023 *)
goal max_binary80: max_gen_float(Binary80) = 0x1.FFFFFFFFFFFFFFFEp16383 


(* values of min_gen_float *)
axiom min_single : min_gen_float(Single) = 0x1p-149
axiom min_double : min_gen_float(Double) = 0x1p-1074

(* values of max_exp: the exponent of the next gen_float after max_gen_float *)
(*
axiom max_exp_single: max_exp(Single) = 128
axiom max_exp_double: max_exp(Double) = 1024 
*)


predicate no_overflow(f:float_format,m:mode,x:real) =
  abs_real(round_float(f, m, x)) <= max_gen_float(f)

function gen_round_error(x:gen_float) : real =
  abs_real(float_value(x) - exact_value(x))

function gen_relative_error(x:gen_float) : real =
  abs_real((float_value(x) - exact_value(x)) / exact_value(x))

function gen_total_error(x:gen_float) : real =
  abs_real(float_value(x) - model_value(x))

parameter set_model : x:gen_float ref -> y:real ->
	{ }
	unit writes x
	{ float_value(x) = float_value(x@)
	  and exact_value(x) = exact_value(x@)
	  and model_value(x) = y }



(*************************************************************)
(**** a few lemmas for automatic provers others than gappa ***)
(*************************************************************)
(*
axiom bounded_real_no_overflow : 
      forall f:float_format. forall m:mode. forall x:real. 
      	     abs_real(x) <= max_gen_float(f) -> no_overflow(f,m,x)

axiom round_of_zero: forall f:float_format. forall m:mode. 
      round_float(f,m,0.0) = 0.0

axiom round_greater_max: forall f:float_format. forall m:mode. forall x:real.  
      not no_overflow(f,m,x) -> abs_real(x) > max_gen_float(f)

axiom round_increasing: 
      forall f:float_format. forall m:mode. forall x:real. forall y:real.
      x <= y -> round_float(f,m,x) <= round_float(f,m,y)

(* just for m <> nearest_even *)
axiom bounded_real_overflow_pos: forall f:float_format. forall m:mode. forall x:real.
      x > max_gen_float(f) -> 
      (m = up or  m = nearest_away -> not no_overflow(f,m,x)) 
      and 
      (m = down or m = to_zero -> round_float(f,m,x) = max_gen_float(f))

(* just for m <> nearest_even *)
axiom bounded_real_overflow_neg: forall f:float_format. forall m:mode. forall x:real.
      x < - max_gen_float(f) -> 
      (m = down  or m = nearest_away -> not no_overflow(f,m,x)) 
      and 
      (m = up or m = to_zero -> round_float(f,m,x) = - max_gen_float(f))

(* and for m = nearest_even *)
axiom bounded_real_overflow_nearest_even: forall x:real.
      (abs_real(x) >= 0x2.0p128 -> not no_overflow(Single,nearest_even,x)) and
      (abs_real(x) >= 0x2.0p1024 -> not no_overflow(Double,nearest_even,x))

axiom positive_constant: forall f:float_format. forall m:mode. forall x:real.  
      min_gen_float(f) <= x <= max_gen_float(f) ->
             no_overflow(f,m,x) and round_float(f,m,x) > 0.0 

axiom negative_constant: forall f:float_format. forall m:mode. forall x:real.  
      - max_gen_float(f) <= x <= - min_gen_float(f) -> 
             no_overflow(f,m,x) and round_float(f,m,x) < 0.0

axiom round_greater_min: forall f:float_format. forall m:mode. forall x:real.
      abs_real(x) >= min_gen_float(f) -> 
                     abs_real(round_float(f,m,x)) >= min_gen_float(f)

(* just for m <> nearest_even *)
axiom round_less_min_pos: forall f:float_format. forall m:mode. forall x:real.
      0.0 < x < min_gen_float(f) ->
      (m = up or  m = nearest_away -> round_float(f,m,x) = min_gen_float(f))
      and
      (m = down or m = to_zero -> round_float(f,m,x) = 0.0)

(* just for m <> nearest_even *)
axiom round_less_min_neg: forall f:float_format. forall m:mode. forall x:real.
      - min_gen_float(f) < x < 0.0 ->
      (m = down  or m = nearest_away -> round_float(f,m,x) = - min_gen_float(f))
      and
      (m = up or m = to_zero -> round_float(f,m,x) = 0.0)

(* and for m = nearest_even *)
axiom round_less_min_nearest_even: forall x:real.
      (abs_real(x) <= 0x1p-150 -> round_float(Single,nearest_even,x) = 0.0) and
      (abs_real(x) <= 0x1p-1075 -> round_float(Double,nearest_even,x) = 0.0)




axiom round_of_max_gen: forall f:float_format. forall m:mode.
      round_float(f,m,max_gen_float(f)) = max_gen_float(f)

axiom round_of_opp_max_gen: forall f:float_format. forall m:mode.
      round_float(f,m,-max_gen_float(f)) = -max_gen_float(f)

axiom round_of_min_gen: forall f:float_format. forall m:mode.
      round_float(f,m,min_gen_float(f)) = min_gen_float(f)

axiom round_of_opp_min_gen: forall f:float_format. forall m:mode.
      round_float(f,m,-min_gen_float(f)) = -min_gen_float(f)






axiom round_down_le: forall f:float_format. forall x:real. 
      round_float(f,down,x) <= x

axiom round_down_neg: forall f:float_format. forall x:real. 
     round_float(f,down,-x) = -round_float(f,up,x)

*)
axiom round_up_ge: forall f:float_format. forall x:real. 
      round_float(f,up,x) >= x

axiom round_up_neg: forall f:float_format. forall x:real. 
     round_float(f,up,-x) = -round_float(f,down,x)

axiom round_idempotent:
      forall f:float_format. forall m1:mode. forall m2:mode. forall x:real. 
      round_float(f,m1,round_float(f,m2,x)) = round_float(f,m2,x)
