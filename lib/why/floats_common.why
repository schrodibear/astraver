
(*********************************************************************************)
(*********************************************************************************)
(* Jessie prelude for floating-point arithmetic, common to Strcit and Full mode **) 

(*********************************************************************************)
(*********************************************************************************)


include "real.why"

type mode

logic nearest_even, to_zero, up, down, nearest_away : mode

axiom no_other_mode : forall m:mode. 
      m = nearest_even or m = to_zero or m = up or m = down or m = nearest_away
axiom mode_distinct : 
      nearest_even <> to_zero and nearest_even <> up and nearest_even <> down and 
      nearest_even <> nearest_away and  to_zero <> up and to_zero <> down and 
      to_zero <> nearest_away and up <> down and up <> nearest_away and 
      down <> nearest_away

parameter current_rounding_mode : mode ref



(***************************************************)
(*********** generic precision floats **************) 
(***************************************************)

type float_format

logic Single, Double, Binary80, Quad : float_format

(* [gen_float] denotes the type of generic floats *)

type gen_float

logic round_float : float_format, mode, real -> real
logic gen_float_of_real_logic : float_format, mode, real -> gen_float

logic float_value : gen_float -> real
logic exact_value : gen_float -> real
logic model_value : gen_float -> real

logic max_gen_float : float_format -> real
logic min_gen_float : float_format -> real
(*logic max_exp : float_format -> int*)

(* values of max_gen_float *)
axiom max_single: max_gen_float(Single) = 0x1.FFFFFEp127
                 (* (2 - 2^-23)*2^127 *)
axiom max_double: max_gen_float(Double) = 0x1.FFFFFFFFFFFFFp1023 
                 (* (2 - 2^-52)*2^1023 *)
axiom max_binary80: max_gen_float(Binary80) = 0x1.FFFFFFFFFFFFFFFEp16383 

(* commented out because makes Yices fail (really ? to check)
axiom max_quad: max_gen_float(Quad) = 0x1.FFFFFFFFFFFFFFFFFFFFFFFFFFFFp16383 
                (* (2 - 2^-112)*2^16383 *)
*)


(* values of min_gen_float *)
axiom min_single : min_gen_float(Single) = 0x1p-149
axiom min_double : min_gen_float(Double) = 0x1p-1074

(* values of max_exp: the exponent of the next gen_float after max_gen_float *)
(*
axiom max_exp_single: max_exp(Single) = 128
axiom max_exp_double: max_exp(Double) = 1024 
*)


predicate no_overflow(f:float_format,m:mode,x:real) =
	abs_real(round_float(f, m, x)) <= max_gen_float(f)

function gen_round_error(x:gen_float) : real =
	abs_real(float_value(x) - exact_value(x))

function gen_relative_error(x:gen_float) : real =
	abs_real((float_value(x) - exact_value(x)) / exact_value(x))

function gen_total_error(x:gen_float) : real =
	abs_real(float_value(x) - model_value(x))

parameter set_model : x:gen_float ref -> y:real ->
	{ }
	unit writes x
	{ float_value(x) = float_value(x@)
	  and exact_value(x) = exact_value(x@)
	  and model_value(x) = y }


(*************************************************************)
(**** a few lemmas for automatic provers others than gappa ***)
(*************************************************************)


(**** useful at least for constants ****)

axiom bounded_real_no_overflow : 
      forall f:float_format. forall m:mode. forall x:real. 
      	     abs_real(x) <= max_gen_float(f) -> no_overflow(f,m,x)

(*
(* just for m <> nearest_even *)
axiom bounded_real_overflow_pos: forall f:float_format. forall m:mode. forall x:real.
      x > max_gen_float(f) -> 
      (m = up or  m = nearest_away -> not no_overflow(f,m,x)) 
      and 
      (m = down or m = to_zero -> round_float(f,m,x) = max_gen_float(f))

(* just for m <> nearest_even *)
axiom bounded_real_overflow_neg: forall f:float_format. forall m:mode. forall x:real.
      x < - max_gen_float(f) -> 
      (m = down  or m = nearest_away -> not no_overflow(f,m,x)) 
      and 
      (m = up or m = to_zero -> round_float(f,m,x) = - max_gen_float(f))

(* and for m = nearest_even *)
axiom bounded_real_overflow_nearest_even: forall x:real.
      (abs_real(x) >= 0x2.0p128 -> not no_overflow(Single,nearest_even,x)) and
      (abs_real(x) >= 0x2.0p1024 -> not no_overflow(Double,nearest_even,x))

axiom round_greater_max: forall f:float_format. forall m:mode. forall x:real.  
      not no_overflow(f,m,x) -> abs_real(x) > max_gen_float(f)

axiom positive_constant: forall f:float_format. forall m:mode. forall x:real.  
      min_gen_float(f) <= x <= max_gen_float(f) -> 
      no_overflow(f,m,x) and round_float(f,m,x) > 0.0 

axiom negative_constant: forall f:float_format. forall m:mode. forall x:real.  
       - max_gen_float(f) <= x <= - min_gen_float(f) -> 
      no_overflow(f,m,x) and round_float(f,m,x) < 0.0

axiom round_increasing: 
      forall f:float_format. forall m:mode. forall x:real. forall y:real.
      x <= y -> round_float(f,m,x) <= round_float(f,m,y)

axiom round_greater_min: forall f:float_format. forall m:mode. forall x:real.
      abs_real(x) >= min_gen_float(f) -> abs_real(round_float(f,m,x)) >= min_gen_float(f)


(* just for m <> nearest_even *)
axiom round_less_min_pos: forall f:float_format. forall m:mode. forall x:real.
      0.0 < x < min_gen_float(f) ->
      (m = up or  m = nearest_away -> round_float(f,m,x) = min_gen_float(f))
      and
      (m = down or m = to_zero -> round_float(f,m,x) = 0.0)

(* just for m <> nearest_even *)
axiom round_less_min_neg: forall f:float_format. forall m:mode. forall x:real.
      - min_gen_float(f) < x < 0.0 ->
      (m = down  or m = nearest_away -> round_float(f,m,x) = - min_gen_float(f))
      and
      (m = up or m = to_zero -> round_float(f,m,x) = 0.0)

(* and for m = nearest_even *)
axiom round_less_min_nearest_even: forall x:real.
      (abs_real(x) <= 0x2.0p-150 -> round_float(Single,nearest_even,x) = 0.0) and
      (abs_real(x) <= 0x2.0p-1075 -> round_float(Double,nearest_even,x) = 0.0)


axiom round_of_zero: forall f:float_format. forall m:mode. 
      round_float(f,m,0.0) = 0.0

(* wrong
axiom round_of_float_value:
      forall f:float_format. forall m:mode. forall x:gen_float. 
      round_float(f,m,float_value(x)) = float_value(x)
*)

(* round_float of hexadecimal constant !!
axiom round_hexa: forall f:float_format. forall m:mode. forall n:int. forall y:real.
      (* need hypotheses on n *)
      round_float(f,m,0xypn) = 0xypn

axiom round_pow_constant: 
      forall f:float_format. forall m:mode. forall x:real. forall y:real.
      round_float(f,m,pow_real(x,y)) = pow_real(x,y)

axiom round_of_max_gen: forall f:float_format. forall m:mode.
      round_float(f,m,max_gen_float(f)) = max_gen_float(f)

axiom round_of_opp_max_gen: forall f:float_format. forall m:mode.
      round_float(f,m,-max_gen_float(f)) = -max_gen_float(f)

axiom round_of_min_gen: forall f:float_format. forall m:mode.
      round_float(f,m,min_gen_float(f)) = min_gen_float(f)

axiom round_of_opp_min_gen: forall f:float_format. forall m:mode.
      round_float(f,m,-min_gen_float(f)) = -min_gen_float(f)

*)
*)

(* axioms about round_float and round modes *)
axiom round_down_le: forall f:float_format. forall x:real. 
      round_float(f,down,x) <= x


axiom round_up_ge: forall f:float_format. forall x:real. 
      round_float(f,up,x) >= x

axiom round_down_neg: forall f:float_format. forall x:real. 
     round_float(f,down,-x) = -round_float(f,up,x)

axiom round_up_neg: forall f:float_format. forall x:real. 
     round_float(f,up,-x) = -round_float(f,down,x)

axiom round_idempotent:
      forall f:float_format. forall m1:mode. forall m2:mode. forall x:real. 
      round_float(f,m1,round_float(f,m2,x)) = round_float(f,m2,x)




