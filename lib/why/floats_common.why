
(* Jessie prelude for floating-point arithmetic, common to strict and full mode *)

include "real.why"

type mode

logic nearest_even, to_zero, up, down, nearest_away : mode

axiom no_other_mode : forall m:mode. m = nearest_even or m = to_zero or m = up or m = down or m = nearest_away
axiom mode_distinct : nearest_even <> to_zero and nearest_even <> up and nearest_even <> down and 
                      nearest_even <> nearest_away and  to_zero <> up and to_zero <> down and to_zero <> nearest_away and 
                      up <> down and up <> nearest_away and down <> nearest_away
 
parameter rounding_mode : mode ref

(* generic precision floats *)

type float_format

logic Single, Double, Quad : float_format

(* [gen_float] denotes the type of generic floats *)

type gen_float

logic round_float : float_format, mode, real -> real
logic gen_float_of_real_logic : float_format, mode, real -> gen_float

logic float_value : gen_float -> real
logic exact_value : gen_float -> real
logic model_value : gen_float -> real

logic max_gen_float : float_format -> real
logic min_gen_float : float_format -> real

axiom max_single: max_gen_float(Single) = 0x1.FFFFFEp127
 (* (2 - 2^-23)*2^127 *)

axiom max_double: max_gen_float(Double) = 0x1.FFFFFFFFFFFFFp1023 
 (* (2 - 2^-52)*2^1023 *)

axiom max_quad: max_gen_float(Quad) = 0x1.FFFFFFFFFFFFFFFFFFFFFFFFFFFFp16383 
 (* (2 - 2^-112)*2^16383 *)


predicate no_overflow(f:float_format,m:mode,x:real) = 
	  abs_real(round_float(f,m,x)) <= max_gen_float(f)


(********************************************************)
(* a few lemmas for automatic provers others than gappa *)
(********************************************************)

(* useful at least for constants *)
axiom bounded_real_no_overflow : 
      forall f:float_format. forall m:mode. forall x:real. 
      	     abs_real(x) <= max_gen_float(f) -> no_overflow(f,m,x)
