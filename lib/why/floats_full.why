(***************************************************************************)
(***************************************************************************)
(*** Jessie prelude for floating-point arithmetic: Full mode ***************)
(***************************************************************************)
(***************************************************************************)

include "floats_common.why"


function min_single() : real =  0x1p-149
function min_double() : real =  0x1p-1074


(***************************************************)
(*************** additional views ******************)
(***************************************************)

type Float_class = Finite | Infinite | NaN

type sign = Negative | Positive

logic single_class : single -> Float_class
logic double_class : double -> Float_class

logic single_sign : single -> sign
logic double_sign : double -> sign


inductive same_sign_real_bool : sign, real -> prop =
 | neg_case : forall x:real. x < 0.0 -> same_sign_real_bool(Negative,x)
 | pos_case : forall x:real. x > 0.0 -> same_sign_real_bool(Positive,x)



(***************************************************)
(*********** axioms on float_sign ******************)
(***************************************************)

(* useful ???

axiom single_sign_not_pos_neg : forall x:single.
      single_sign(x) <> Positive -> single_sign(x) = Negative
axiom single_sign_not_neg_pos : forall x:single.
      single_sign(x) <> Negative -> single_sign(x) = Positive

axiom double_sign_not_pos_neg : forall x:double.
      double_sign(x) <> Positive -> double_sign(x) = Negative
axiom double_sign_not_neg_pos : forall x:double.
      double_sign(x) <> Negative -> double_sign(x) = Positive
*)

axiom same_sign_real_bool_zero1 : forall b:sign. not same_sign_real_bool(b,0.0)
axiom same_sign_real_bool_zero2 : forall x:real.
         same_sign_real_bool(Negative,x) and
         same_sign_real_bool(Positive,x) -> false
axiom same_sign_real_bool_zero3 : forall b:sign. forall x:real.
         same_sign_real_bool(b,x) -> x <> 0.0
axiom same_sign_real_bool_correct2 : forall b:sign. forall x:real.
         same_sign_real_bool(b,x) -> (x < 0.0 <-> b = Negative)
axiom same_sign_real_bool_correct3 : forall b:sign. forall x:real.
         same_sign_real_bool(b,x) -> (x > 0.0 <-> b = Positive)



(***************************************************)
(******** predicates to deal with float_sign *******)
(***************************************************)

predicate single_same_sign_real (x:single,y:real) = same_sign_real_bool(single_sign(x),y)
predicate single_same_sign(x:single,y:single)  = single_sign(x) = single_sign(y)
predicate single_diff_sign(x:single,y:single)  = single_sign(x) <> single_sign(y)

predicate single_product_sign(z:single,x:single,y:single) =
	  (single_same_sign(x,y) -> single_sign(z)= Positive) and
          (single_diff_sign(x,y) -> single_sign(z)= Negative)

predicate double_same_sign_real (x:double,y:real) = same_sign_real_bool(double_sign(x),y)
predicate double_same_sign(x:double,y:double)  = double_sign(x) = double_sign(y)
predicate double_diff_sign(x:double,y:double)  = double_sign(x) <> double_sign(y)

predicate double_product_sign(z:double,x:double,y:double) =
	  (double_same_sign(x,y) -> double_sign(z)= Positive) and
          (double_diff_sign(x,y) -> double_sign(z)= Negative)



(***************************************************)
(******* predicates to deal with float_class *******)
(***************************************************)

predicate single_same_class(x:single,y:single) = single_class(x) = single_class(y)
predicate singlediff_class(x:single,y:single) = single_class(x) <> single_class(y)
predicate double_same_class(x:double,y:double) = double_class(x) = double_class(y)
predicate doublediff_class(x:double,y:double) = double_class(x) <> double_class(y)



(***************************************************)
(******* axioms on sign of finite gen_float ********)
(***************************************************)

(* non-zero finite gen_float has the same sign as its float_value *)
axiom single_finite_sign : forall x:single.
      (single_class(x) = Finite and single_value(x) <> 0.0) ->
       single_same_sign_real(x,single_value(x))

axiom single_finite_sign_neg1: forall x:single.
      single_class(x) = Finite and single_value(x) < 0.0 ->
                                  single_sign(x) = Negative
axiom single_finite_sign_neg2: forall x:single.
      single_class(x) = Finite and single_value(x) <> 0.0
      and single_sign(x) = Negative -> single_value(x) < 0.0
axiom single_finite_sign_pos1: forall x:single.
      single_class(x) = Finite and single_value(x) > 0.0 ->
                                  single_sign(x) = Positive
axiom single_finite_sign_pos2: forall x:single.
      single_class(x) = Finite and single_value(x) <> 0.0
      and single_sign(x) = Positive -> single_value(x) > 0.0
axiom single_diff_sign_trans: forall x:single. forall y:single. forall z:single.
      single_diff_sign(x,y) and single_diff_sign(y,z) -> single_same_sign(x,z)

axiom single_same_sign_product: forall x:single. forall y:single.
      single_class(x) = Finite and single_class(y) = Finite and
      single_same_sign(x,y) -> single_value(x) * single_value(y) >= 0.0

axiom single_diff_sign_product: forall x:single. forall y:single.
      single_class(x) = Finite and single_class(y) = Finite and
      single_value(x) * single_value(y) < 0.0 -> single_diff_sign(x,y)

axiom double_finite_sign : forall x:double.
      (double_class(x) = Finite and double_value(x) <> 0.0) ->
       double_same_sign_real(x,double_value(x))

axiom double_finite_sign_neg1: forall x:double.
      double_class(x) = Finite and double_value(x) < 0.0 ->
                                  double_sign(x) = Negative
axiom double_finite_sign_neg2: forall x:double.
      double_class(x) = Finite and double_value(x) <> 0.0
      and double_sign(x) = Negative -> double_value(x) < 0.0
axiom double_finite_sign_pos1: forall x:double.
      double_class(x) = Finite and double_value(x) > 0.0 ->
                                  double_sign(x) = Positive
axiom double_finite_sign_pos2: forall x:double.
      double_class(x) = Finite and double_value(x) <> 0.0
      and double_sign(x) = Positive -> double_value(x) > 0.0
axiom double_diff_sign_trans: forall x:double. forall y:double. forall z:double.
      double_diff_sign(x,y) and double_diff_sign(y,z) -> double_same_sign(x,z)

axiom double_same_sign_product: forall x:double. forall y:double.
      double_class(x) = Finite and double_class(y) = Finite and
      double_same_sign(x,y) -> double_value(x) * double_value(y) >= 0.0

axiom double_diff_sign_product: forall x:double. forall y:double.
      double_class(x) = Finite and double_class(y) = Finite and
      double_value(x) * double_value(y) < 0.0 -> double_diff_sign(x,y)


(***************************************************)
(************** usefull predicates *****************)
(***************************************************)

predicate single_is_finite(x:single) = single_class(x) = Finite
predicate single_is_infinite(x:single) = single_class(x) = Infinite
predicate single_is_NaN(x:single) = single_class(x) = NaN
predicate single_is_not_NaN(x:single) = single_is_finite(x) or single_is_infinite(x)
predicate single_is_minus_infinity(x:single)
    = single_is_infinite(x) and single_sign(x) = Negative
predicate single_is_plus_infinity(x:single)
    = single_is_infinite(x) and single_sign(x) = Positive
predicate single_is_gen_zero(x:single)= single_is_finite(x) and single_value(x) = 0.0
predicate single_is_gen_zero_plus(x:single)
    = single_is_gen_zero(x) and single_sign(x) = Positive
predicate single_is_gen_zero_minus(x:single)
    = single_is_gen_zero(x) and single_sign(x) = Negative

predicate double_is_finite(x:double) = double_class(x) = Finite
predicate double_is_infinite(x:double) = double_class(x) = Infinite
predicate double_is_NaN(x:double) = double_class(x) = NaN
predicate double_is_not_NaN(x:double) = double_is_finite(x) or double_is_infinite(x)
predicate double_is_minus_infinity(x:double)
    = double_is_infinite(x) and double_sign(x) = Negative
predicate double_is_plus_infinity(x:double)
    = double_is_infinite(x) and double_sign(x) = Positive
predicate double_is_gen_zero(x:double)= double_is_finite(x) and double_value(x) = 0.0
predicate double_is_gen_zero_plus(x:double)
    = double_is_gen_zero(x) and double_sign(x) = Positive
predicate double_is_gen_zero_minus(x:double)
    = double_is_gen_zero(x) and double_sign(x) = Negative


(* predicate to use in case of overflow result of an operation *)
predicate single_overflow_value(m:mode,x:single) =
         (m = down -> (single_sign(x) = Negative -> single_is_infinite(x)) and
	              (single_sign(x) = Positive -> single_is_finite(x) and
                                                   single_value(x)= max_single))
          and
         (m = up -> (single_sign(x) = Negative -> single_is_finite(x) and
                                                 single_value(x)= - max_single) and
                    (single_sign(x) = Positive -> single_is_infinite(x)))
          and
         (m = to_zero -> single_is_finite(x) and
                 (single_sign(x) = Negative -> single_value(x)= - max_single) and
                 (single_sign(x) = Positive -> single_value(x)=   max_single))
          and
         (m = nearest_away or m = nearest_even -> single_is_infinite(x))

predicate double_overflow_value(m:mode,x:double) =
         (m = down -> (double_sign(x) = Negative -> double_is_infinite(x)) and
	              (double_sign(x) = Positive -> double_is_finite(x) and
                                                   double_value(x)= max_double))
          and
         (m = up -> (double_sign(x) = Negative -> double_is_finite(x) and
                                                 double_value(x)= - max_double) and
                    (double_sign(x) = Positive -> double_is_infinite(x)))
          and
         (m = to_zero -> double_is_finite(x) and
                 (double_sign(x) = Negative -> double_value(x)= - max_double) and
                 (double_sign(x) = Positive -> double_value(x)=   max_double))
          and
         (m = nearest_away or m = nearest_even -> double_is_infinite(x))


(* predicate to use in case of underflow result of an operation *)
predicate single_underflow_value(m:mode,x:single) =
          single_is_finite(x)
          and
          (single_sign(x) = Positive ->
              (m = down or m = to_zero or m = nearest_even or m = nearest_away ->
                                      single_value(x) = 0.0)
               and
              (m = up -> single_value(x) = min_single))
          and
          (single_sign(x) = Negative ->
              (m = up or m = to_zero or m = nearest_even or m = nearest_away ->
                                      single_value(x) = 0.0)
               and
               (m = down -> single_value(x) = - min_single))

predicate double_underflow_value(m:mode,x:double) =
          double_is_finite(x)
          and
          (double_sign(x) = Positive ->
              (m = down or m = to_zero or m = nearest_even or m = nearest_away ->
                                      double_value(x) = 0.0)
               and
              (m = up -> double_value(x) = min_double))
          and
          (double_sign(x) = Negative ->
              (m = up or m = to_zero or m = nearest_even or m = nearest_away ->
                                      double_value(x) = 0.0)
               and
               (m = down -> double_value(x) = - min_double))


(* predicate to get the sign of a zero result of an operation *)
predicate single_sign_zero_result(m:mode,x:single) =
           single_value(x) = 0.0 ->
          ((m = down -> single_sign(x) = Negative)
           and
           (m <> down -> single_sign(x) = Positive))

predicate double_sign_zero_result(m:mode,x:double) =
           double_value(x) = 0.0 ->
          ((m = down -> double_sign(x) = Negative)
           and
           (m <> down -> double_sign(x) = Positive))


(**** Comparisons of floats in the logic ****)
predicate le_single_full(x:single,y:single) =
          (single_is_finite(x) and single_is_finite(y)
              and single_value(x) <= single_value(y))
           or (single_is_minus_infinity(x) and single_is_not_NaN(y))
           or (single_is_not_NaN(x) and single_is_plus_infinity(y))

predicate lt_single_full(x:single,y:single) =
          (single_is_finite(x) and single_is_finite(y)
              and single_value(x) < single_value(y))
           or (single_is_minus_infinity(x) and single_is_not_NaN(y)
               and not single_is_minus_infinity(y))
           or (single_is_not_NaN(x) and not single_is_plus_infinity(x)
               and single_is_plus_infinity(y))

predicate ge_single_full(x:single,y:single) = le_single_full(y,x)

predicate gt_single_full(x:single,y:single) = lt_single_full(y,x)

predicate eq_single_full(x:single,y:single) =
          single_is_not_NaN(x) and single_is_not_NaN(y) and
          ((single_is_finite(x) and single_is_finite(y)
             and single_value(x) = single_value(y))
           or
          (single_is_infinite(x) and single_is_infinite(y)
             and single_same_sign(x,y)))

predicate ne_single_full(x:single,y:single) = not eq_single_full(x,y)


predicate le_double_full(x:double,y:double) =
          (double_is_finite(x) and double_is_finite(y)
              and double_value(x) <= double_value(y))
           or (double_is_minus_infinity(x) and double_is_not_NaN(y))
           or (double_is_not_NaN(x) and double_is_plus_infinity(y))

predicate lt_double_full(x:double,y:double) =
          (double_is_finite(x) and double_is_finite(y)
              and double_value(x) < double_value(y))
           or (double_is_minus_infinity(x) and double_is_not_NaN(y)
               and not double_is_minus_infinity(y))
           or (double_is_not_NaN(x) and not double_is_plus_infinity(x)
               and double_is_plus_infinity(y))

predicate ge_double_full(x:double,y:double) = le_double_full(y,x)

predicate gt_double_full(x:double,y:double) = lt_double_full(y,x)

predicate eq_double_full(x:double,y:double) =
          double_is_not_NaN(x) and double_is_not_NaN(y) and
          ((double_is_finite(x) and double_is_finite(y)
             and double_value(x) = double_value(y))
           or
          (double_is_infinite(x) and double_is_infinite(y)
             and double_same_sign(x,y)))

predicate ne_double_full(x:double,y:double) = not eq_double_full(x,y)


axiom le_lt_double_trans:
      forall x,y,z:double.
         le_double_full(x,y) and lt_double_full(y,z) -> lt_double_full(x,z)

axiom lt_le_double_trans:
      forall x,y,z:double.
         lt_double_full(x,y) and le_double_full(y,z) -> lt_double_full(x,z)



(***************************************************)
(******** axioms on gen_float_of_real_logic ********)
(***************************************************)

axiom round_single1 : forall m:mode. forall x:real.
           no_overflow_single(m,x) ->
           (single_is_finite(round_single_logic(m,x)) and
           single_value(round_single_logic(m,x)) = round_single(m,x))

axiom round_single2 : forall m:mode. forall x:real.
           not no_overflow_single(m,x) ->
           (single_same_sign_real(round_single_logic(m,x),x) and
            single_overflow_value(m,round_single_logic(m,x)))

axiom round_single3 : forall m:mode. forall x:real.
           single_exact(round_single_logic(m,x)) = x

axiom round_single4 : forall m:mode. forall x:real.
           single_model(round_single_logic(m,x)) = x

axiom single_of_zero : forall m:mode.
            single_is_gen_zero(round_single_logic(m,0.0))


axiom round_single_logic_le : forall m:mode. forall x:real.
      single_is_finite(round_single_logic(m,x)) ->
      abs_real(single_value(round_single_logic(m,x))) <= max_single

axiom round_single_no_overflow : forall m:mode. forall x:real.
          abs_real(x) <= max_single ->
          (single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) = round_single(m,x))

axiom single_positive_constant : forall m:mode. forall x:real.
          min_single <= x <= max_single ->
          single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) > 0.0  and
          single_sign(round_single_logic(m,x)) = Positive

axiom single_negative_constant : forall m:mode. forall x:real.
          - max_single <= x <= - min_single ->
          single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) < 0.0  and
          single_sign(round_single_logic(m,x)) = Negative


axiom round_double1 : forall m:mode. forall x:real.
           no_overflow_double(m,x) ->
           (double_is_finite(round_double_logic(m,x)) and
           double_value(round_double_logic(m,x)) = round_double(m,x))

axiom round_double2 : forall m:mode. forall x:real.
           not no_overflow_double(m,x) ->
           (double_same_sign_real(round_double_logic(m,x),x) and
            double_overflow_value(m,round_double_logic(m,x)))

axiom round_double3 : forall m:mode. forall x:real.
           double_exact(round_double_logic(m,x)) = x

axiom round_double4 : forall m:mode. forall x:real.
           double_model(round_double_logic(m,x)) = x

axiom double_of_zero : forall m:mode.
            double_is_gen_zero(round_double_logic(m,0.0))


axiom round_double_logic_le : forall m:mode. forall x:real.
      double_is_finite(round_double_logic(m,x)) ->
      abs_real(double_value(round_double_logic(m,x))) <= max_double

axiom round_double_no_overflow : forall m:mode. forall x:real.
          abs_real(x) <= max_double ->
          (double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) = round_double(m,x))

axiom double_positive_constant : forall m:mode. forall x:real.
          min_double <= x <= max_double ->
          double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) > 0.0  and
          double_sign(round_double_logic(m,x)) = Positive

axiom double_negative_constant : forall m:mode. forall x:real.
          - max_double <= x <= - min_double ->
          double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) < 0.0  and
          double_sign(round_double_logic(m,x)) = Negative



(***************************************************)
(************** axioms on gen_zero *****************)
(***************************************************)

axiom single_is_gen_zero_comp1 : forall x:single. forall y:single.
      single_is_gen_zero(x) and single_value(x) = single_value(y)
       and single_is_finite(y) ->  single_is_gen_zero(y)

axiom single_is_gen_zero_comp2 : forall x:single. forall y:single.
      single_is_finite(x) and not single_is_gen_zero(x)
       and single_value(x) = single_value(y) -> not single_is_gen_zero(y)

axiom double_is_gen_zero_comp1 : forall x:double. forall y:double.
      double_is_gen_zero(x) and double_value(x) = double_value(y)
       and double_is_finite(y) ->  double_is_gen_zero(y)

axiom double_is_gen_zero_comp2 : forall x:double. forall y:double.
      double_is_finite(x) and not double_is_gen_zero(x)
       and double_value(x) = double_value(y) -> not double_is_gen_zero(y)



(***************************************************)
(** specification of unary and binary operations ***)
(***************************************************)

(* in single *)

parameter single_of_real : m:mode -> x:real ->
{ }
single
{ (*result = single_round_logic(m,x) *)
  (no_overflow_single(m,x)
     -> (single_is_finite(result) and single_value(result) = round_single(m,x)))
  and
   (not no_overflow_single(m,x)
     -> (single_same_sign_real(result,x) and single_overflow_value(m,result)))
  and single_exact(result) = x
  and single_model(result) = x
}



parameter add_single : m:mode -> x:single -> y:single ->
{ }
single
{ (single_is_NaN(x) or single_is_NaN(y) -> single_is_NaN(result))
  and
  ((single_is_finite(x) and single_is_infinite(y))
          -> (single_is_infinite(result) and single_same_sign(result,y)))
  and
  ((single_is_infinite(x) and single_is_finite(y))
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_same_sign(x,y))
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_diff_sign(x,y))
          -> single_is_NaN(result))
  and
  ((single_is_finite(x) and single_is_finite(y)
     and no_overflow_single(m,single_value(x)+single_value(y)))
          -> (single_is_finite(result) and
 	     single_value(result) = round_single(m,single_value(x)+single_value(y)) and
             single_sign_zero_result(m,result)))
  and
  ((single_is_finite(x) and single_is_finite(y)
     and not no_overflow_single(m,single_value(x)+single_value(y)))
          -> (single_same_sign_real(result,single_value(x)+single_value(y)) and
	             single_overflow_value(m,result)))
  and
  single_exact(result) = single_exact(x) + single_exact(y) and
  single_model(result) = single_model(x) + single_model(y)
}



parameter sub_single : m:mode -> x:single -> y:single ->
{ }
single
{ ((single_is_NaN(x) or single_is_NaN(y)) -> single_is_NaN(result))
  and
  ((single_is_finite(x) and single_is_infinite(y))
          -> (single_is_infinite(result) and single_diff_sign(result,y)))
  and
  ((single_is_infinite(x) and single_is_finite(y))
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_same_sign(x,y))
          -> single_is_NaN(result))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_diff_sign(x,y))
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_finite(x) and single_is_finite(y)
     and no_overflow_single(m,single_value(x)-single_value(y)))
          -> (single_is_finite(result) and
	      single_value(result)= round_single(m,single_value(x)-single_value(y))and
	      single_sign_zero_result(m,result)))
  and
  ((single_is_finite(x) and single_is_finite(y)
     and not no_overflow_single(m,single_value(x)-single_value(y)))
          -> (single_same_sign_real(result,single_value(x)-single_value(y)) and
              single_overflow_value(m,result)))
  and
  single_exact(result) = single_exact(x) - single_exact(y) and
  single_model(result) = single_model(x) - single_model(y)
}




parameter abs_single : m:mode -> x:single ->
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and
  (single_is_infinite(x) -> single_is_infinite(result))
and
  (single_is_finite(x)  -> (single_is_finite(result) and
           single_value(result)= abs_real(single_value(x))))
and
  single_sign(result) = Positive and
  single_exact(result) = abs_real(single_exact(x)) and
  single_model(result) = abs_real(single_model(x))
}



parameter mul_single : m:mode -> x:single -> y:single ->
{ }
single
{ ((single_is_NaN(x)  or  single_is_NaN(y)) -> single_is_NaN(result))
and
  ((single_is_gen_zero(x) and single_is_infinite(y)) -> single_is_NaN(result))
and
  ((single_is_finite(x) and single_is_infinite(y) and single_value(x) <> 0.0)
     -> single_is_infinite(result))
and
  ((single_is_infinite(x) and single_is_gen_zero(y)) -> single_is_NaN(result))
and
  ((single_is_infinite(x) and single_is_finite(y) and single_value(y) <> 0.0)
     -> single_is_infinite(result))
and
  ((single_is_infinite(x) and single_is_infinite(y)) -> single_is_infinite(result))
and
  ((single_is_finite(x) and single_is_finite(y)
     and no_overflow_single(m,single_value(x)*single_value(y)))
     ->	(single_is_finite(result) and
	 single_value(result) = round_single(m,single_value(x) * single_value(y))))
and
  ((single_is_finite(x) and single_is_finite(y)
     and not no_overflow_single(m,single_value(x)*single_value(y)))
     -> (single_overflow_value(m,result)))
and
  single_product_sign(result,x,y)
and
  single_exact(result) = single_exact(x) * single_exact(y) and
  single_model(result) = single_model(x) * single_model(y)
}




parameter div_single : m:mode -> x:single -> y:single ->
{ }
single
{ ((single_is_NaN(x) or single_is_NaN(y)) -> single_is_NaN(result))
and
  ((single_is_finite(x) and single_is_infinite(y)) -> single_is_gen_zero(result))
and
  ((single_is_infinite(x) and single_is_finite(y)) -> single_is_infinite(result))
and
  ((single_is_infinite(x) and single_is_infinite(y)) -> single_is_NaN(result))
and
  ((single_is_finite(x) and single_is_finite(y) and single_value(y) <> 0.0 and
     no_overflow_single(m,single_value(x)/single_value(y)))
      -> (single_is_finite(result) and
          single_value(result)= round_single(m,single_value(x)/single_value(y))))
and
  ((single_is_finite(x) and single_is_finite(y) and single_value(y) <> 0.0 and
     not no_overflow_single(m,single_value(x)/single_value(y)))
      -> single_overflow_value(m,result))
and
  ((single_is_finite(x) and single_is_gen_zero(y) and single_value(x) <> 0.0)
      -> single_is_infinite(result))
and
  ((single_is_gen_zero(x) and single_is_gen_zero(y)) -> single_is_NaN(result))
and
  single_product_sign(result,x,y)
and
  single_exact(result) = single_exact(x)/single_exact(y) and
  single_model(result) = single_model(x)/single_model(y)
}



parameter sqrt_single :  m:mode -> x:single ->
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and
  (single_is_minus_infinity(x) -> single_is_NaN(result))
and
  (single_is_plus_infinity(x) -> single_is_infinite(result))
and
  ((single_is_finite(x) and single_value(x)< 0.0) -> single_is_NaN(result))
and
  (single_is_finite(x) and single_value(x) >= 0.0
       ->  (single_is_finite(result) and
          single_value(result)= round_single(m,sqrt_real(single_value(x)))))
and
   (* not always positive because sqrt(-0) = -0 *)
   single_same_sign(result,x)
and
   single_exact(result) = sqrt_real(single_exact(x)) and
   single_model(result) = sqrt_real(single_model(x))
}




parameter neg_single : x:single ->
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and
  (single_is_infinite(x) -> single_is_infinite(result))
and
  (single_is_finite(x)
     -> (single_is_finite(result) and
         single_value(result) = neg_real(single_value(x))))
and
  single_diff_sign(result,x)
and
  single_exact(result) = neg_real(single_exact(x)) and
  single_model(result) = neg_real(single_model(x))
}



parameter lt_single : x:single -> y:single ->
{ }
bool
{
if result then
single_is_not_NaN(x) and single_is_not_NaN(y) and
   (single_is_finite(x) and single_is_finite(y) and single_value(x) < single_value(y))
    or
   (single_is_minus_infinity(x) and single_is_plus_infinity(y))
    or
   (single_is_minus_infinity(x) and single_is_finite(y))
    or
   (single_is_finite(x) and single_is_plus_infinity(y))
else (single_is_NaN(x) or single_is_NaN(y)
    or
    (single_is_finite(x) and single_is_finite(y) and single_value(x) >= single_value(y))
    or
     single_is_plus_infinity(x)
    or
     single_is_minus_infinity(y))
}


parameter le_single : x:single -> y:single ->
{ }
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y))
        -> if result then single_sign(y) = Positive
  	    	     else single_sign(y) = Negative)
and
  ((single_is_infinite(x) and single_is_finite(y))
        -> if result then single_sign(x) = Negative
    		     else single_sign(x) = Positive)
and
  ((single_is_infinite(x) and single_is_infinite(y)) ->
                    if result then (single_sign(x)= Negative or
                                    single_sign(y)= Positive)
			      else (single_sign(x)= Positive and
                                    single_sign(y)= Negative))
and
 ((single_is_finite(x) and single_is_finite(y))
      -> if result then single_value(x) <= single_value(y)
 		   else single_value(x) > single_value(y))
}




parameter gt_single : x:single -> y:single ->
{ }
bool
{
if result then single_is_not_NaN(x) and single_is_not_NaN(y) and
   (single_is_finite(x) and single_is_finite(y) and single_value(x) > single_value(y))
    or
   (single_is_plus_infinity(x) and single_is_minus_infinity(y))
    or
   (single_is_plus_infinity(x) and single_is_finite(y))
    or
   (single_is_finite(x) and single_is_minus_infinity(y))
else (single_is_NaN(x) or single_is_NaN(y)
    or
    (single_is_finite(x) and single_is_finite(y) and single_value(x) <= single_value(y))
    or
     single_is_minus_infinity(x)
    or
     single_is_plus_infinity(y))
}



parameter ge_single : x:single -> y:single ->
{}
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y))
     -> if result then single_sign(y)= Negative
   	          else single_sign(y)= Positive)
and
  ((single_is_infinite(x) and single_is_finite(y))
     -> if result then single_sign(x)= Positive
   	       	  else single_sign(x)= Negative)
and
  ((single_is_infinite(x) and single_is_infinite(y))
     -> if result then (single_sign(x)= Positive or single_sign(y)= Negative)
                  else (single_sign(x)= Negative and single_sign(y)= Positive))
and
 ((single_is_finite(x) and single_is_finite(y))
     -> if result then single_value(x) >= single_value(y)
 		  else single_value(x) < single_value(y))
}




parameter eq_single :
x:single -> y:single ->
{ }
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y)) -> result = false)
and
  ((single_is_infinite(x) and single_is_finite(y)) -> result = false)
and
  ((single_is_infinite(x) and single_is_infinite(y))
     -> if result then single_same_sign(x,y) else single_diff_sign(x,y))
and
 ((single_is_finite(x) and single_is_finite(y))
     -> if result then single_value(x) = single_value(y)
 		  else single_value(x) <> single_value(y))
}



parameter neq_single :
x:single -> y:single ->
{ }
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = true)
and
  ((single_is_finite(x) and single_is_infinite(y)) -> result = true)
and
  ((single_is_infinite(x) and single_is_finite(y)) -> result = true)
and
  ((single_is_infinite(x) and single_is_infinite(y))
     -> if result then single_diff_sign(x,y) else single_same_sign(x,y))
and
 ((single_is_finite(x) and single_is_finite(y))
     -> if result then single_value(x) <> single_value(y)
 		  else single_value(x) = single_value(y))
}

(* in double *)

(* Parameters in double precision *)

parameter double_of_real : m:mode -> x:real ->
{ }
double
{ (*result = double_round_logic(m,x) *)
  (no_overflow_double(m,x)
     -> (double_is_finite(result) and double_value(result) = round_double(m,x)))
  and
   (not no_overflow_double(m,x)
     -> (double_same_sign_real(result,x) and double_overflow_value(m,result)))
  and double_exact(result) = x
  and double_model(result) = x
}

(*
parameter double_of_real : m:mode -> x:real ->
  { no_overflow_double(m,x) }
  double
  { double_of_real_post(m,x,result) }
parameter double_of_real_safe : m:mode -> x:real ->
  { }
  double
  { no_overflow_double(m,x) and
    double_of_real_post(m,x,result) }
*)

parameter double_of_real_exact : x:real ->
  { }
  double
  { double_is_finite(result) and
    double_value(result) = x and
    double_exact(result) = x and
    double_model(result) = x }




parameter add_double : m:mode -> x:double -> y:double ->
{ }
double
{ (double_is_NaN(x) or double_is_NaN(y) -> double_is_NaN(result))
  and
  ((double_is_finite(x) and double_is_infinite(y))
          -> (double_is_infinite(result) and double_same_sign(result,y)))
  and
  ((double_is_infinite(x) and double_is_finite(y))
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_same_sign(x,y))
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_diff_sign(x,y))
          -> double_is_NaN(result))
  and
  ((double_is_finite(x) and double_is_finite(y)
     and no_overflow_double(m,double_value(x)+double_value(y)))
          -> (double_is_finite(result) and
 	     double_value(result) = round_double(m,double_value(x)+double_value(y)) and
             double_sign_zero_result(m,result)))
  and
  ((double_is_finite(x) and double_is_finite(y)
     and not no_overflow_double(m,double_value(x)+double_value(y)))
          -> (double_same_sign_real(result,double_value(x)+double_value(y)) and
	             double_overflow_value(m,result)))
  and
  double_exact(result) = double_exact(x) + double_exact(y) and
  double_model(result) = double_model(x) + double_model(y)
}



parameter sub_double : m:mode -> x:double -> y:double ->
{ }
double
{ ((double_is_NaN(x) or double_is_NaN(y)) -> double_is_NaN(result))
  and
  ((double_is_finite(x) and double_is_infinite(y))
          -> (double_is_infinite(result) and double_diff_sign(result,y)))
  and
  ((double_is_infinite(x) and double_is_finite(y))
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_same_sign(x,y))
          -> double_is_NaN(result))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_diff_sign(x,y))
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_finite(x) and double_is_finite(y)
     and no_overflow_double(m,double_value(x)-double_value(y)))
          -> (double_is_finite(result) and
	      double_value(result)= round_double(m,double_value(x)-double_value(y))and
	      double_sign_zero_result(m,result)))
  and
  ((double_is_finite(x) and double_is_finite(y)
     and not no_overflow_double(m,double_value(x)-double_value(y)))
          -> (double_same_sign_real(result,double_value(x)-double_value(y)) and
              double_overflow_value(m,result)))
  and
  double_exact(result) = double_exact(x) - double_exact(y) and
  double_model(result) = double_model(x) - double_model(y)
}




parameter abs_double : m:mode -> x:double ->
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and
  (double_is_infinite(x) -> double_is_infinite(result))
and
  (double_is_finite(x)  -> (double_is_finite(result) and
           double_value(result)= abs_real(double_value(x))))
and
  double_sign(result) = Positive and
  double_exact(result) = abs_real(double_exact(x)) and
  double_model(result) = abs_real(double_model(x))
}



parameter mul_double : m:mode -> x:double -> y:double ->
{ }
double
{ ((double_is_NaN(x)  or  double_is_NaN(y)) -> double_is_NaN(result))
and
  ((double_is_gen_zero(x) and double_is_infinite(y)) -> double_is_NaN(result))
and
  ((double_is_finite(x) and double_is_infinite(y) and double_value(x) <> 0.0)
     -> double_is_infinite(result))
and
  ((double_is_infinite(x) and double_is_gen_zero(y)) -> double_is_NaN(result))
and
  ((double_is_infinite(x) and double_is_finite(y) and double_value(y) <> 0.0)
     -> double_is_infinite(result))
and
  ((double_is_infinite(x) and double_is_infinite(y)) -> double_is_infinite(result))
and
  ((double_is_finite(x) and double_is_finite(y)
     and no_overflow_double(m,double_value(x)*double_value(y)))
     ->	(double_is_finite(result) and
	 double_value(result) = round_double(m,double_value(x) * double_value(y))))
and
  ((double_is_finite(x) and double_is_finite(y)
     and not no_overflow_double(m,double_value(x)*double_value(y)))
     -> (double_overflow_value(m,result)))
and
  double_product_sign(result,x,y)
and
  double_exact(result) = double_exact(x) * double_exact(y) and
  double_model(result) = double_model(x) * double_model(y)
}




parameter div_double : m:mode -> x:double -> y:double ->
{ }
double
{ ((double_is_NaN(x) or double_is_NaN(y)) -> double_is_NaN(result))
and
  ((double_is_finite(x) and double_is_infinite(y)) -> double_is_gen_zero(result))
and
  ((double_is_infinite(x) and double_is_finite(y)) -> double_is_infinite(result))
and
  ((double_is_infinite(x) and double_is_infinite(y)) -> double_is_NaN(result))
and
  ((double_is_finite(x) and double_is_finite(y) and double_value(y) <> 0.0 and
     no_overflow_double(m,double_value(x)/double_value(y)))
      -> (double_is_finite(result) and
          double_value(result)= round_double(m,double_value(x)/double_value(y))))
and
  ((double_is_finite(x) and double_is_finite(y) and double_value(y) <> 0.0 and
     not no_overflow_double(m,double_value(x)/double_value(y)))
      -> double_overflow_value(m,result))
and
  ((double_is_finite(x) and double_is_gen_zero(y) and double_value(x) <> 0.0)
      -> double_is_infinite(result))
and
  ((double_is_gen_zero(x) and double_is_gen_zero(y)) -> double_is_NaN(result))
and
  double_product_sign(result,x,y)
and
  double_exact(result) = double_exact(x)/double_exact(y) and
  double_model(result) = double_model(x)/double_model(y)
}



parameter sqrt_double :  m:mode -> x:double ->
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and
  (double_is_minus_infinity(x) -> double_is_NaN(result))
and
  (double_is_plus_infinity(x) -> double_is_infinite(result))
and
  ((double_is_finite(x) and double_value(x)< 0.0) -> double_is_NaN(result))
and
  (double_is_finite(x) and double_value(x) >= 0.0
       ->  (double_is_finite(result) and
          double_value(result)= round_double(m,sqrt_real(double_value(x)))))
and
   (* not always positive because sqrt(-0) = -0 *)
   double_same_sign(result,x)
and
   double_exact(result) = sqrt_real(double_exact(x)) and
   double_model(result) = sqrt_real(double_model(x))
}




parameter neg_double : x:double ->
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and
  (double_is_infinite(x) -> double_is_infinite(result))
and
  (double_is_finite(x)
     -> (double_is_finite(result) and
         double_value(result) = neg_real(double_value(x))))
and
  double_diff_sign(result,x)
and
  double_exact(result) = neg_real(double_exact(x)) and
  double_model(result) = neg_real(double_model(x))
}



parameter lt_double_ : x:double -> y:double ->
{ }
bool
{
if result then lt_double_full(x,y) else not lt_double_full(x,y)

(*
double_is_not_NaN(x) and double_is_not_NaN(y) and
   (double_is_finite(x) and double_is_finite(y) and double_value(x) < double_value(y))
    or
   (double_is_minus_infinity(x) and double_is_plus_infinity(y))
    or
   (double_is_minus_infinity(x) and double_is_finite(y))
    or
   (double_is_finite(x) and double_is_plus_infinity(y))
else (double_is_NaN(x) or double_is_NaN(y)
    or
    (double_is_finite(x) and double_is_finite(y) and double_value(x) >= double_value(y))
    or
     double_is_plus_infinity(x)
    or
     double_is_minus_infinity(y))
*)
}



parameter le_double_ : x:double -> y:double ->
{ }
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y))
        -> if result then double_sign(y) = Positive
  	    	     else double_sign(y) = Negative)
and
  ((double_is_infinite(x) and double_is_finite(y))
        -> if result then double_sign(x) = Negative
    		     else double_sign(x) = Positive)
and
  ((double_is_infinite(x) and double_is_infinite(y)) ->
                    if result then (double_sign(x)= Negative or
                                    double_sign(y)= Positive)
			      else (double_sign(x)= Positive and
                                    double_sign(y)= Negative))
and
 ((double_is_finite(x) and double_is_finite(y))
      -> if result then double_value(x) <= double_value(y)
 		   else double_value(x) > double_value(y))
}




parameter gt_double_ : x:double -> y:double ->
{ }
bool
{
if result then gt_double_full(x,y) else not gt_double_full(x,y)

(*
double_is_not_NaN(x) and double_is_not_NaN(y) and
   (double_is_finite(x) and double_is_finite(y) and double_value(x) > double_value(y))
    or
   (double_is_plus_infinity(x) and double_is_minus_infinity(y))
    or
   (double_is_plus_infinity(x) and double_is_finite(y))
    or
   (double_is_finite(x) and double_is_minus_infinity(y))
else (double_is_NaN(x) or double_is_NaN(y)
    or
    (double_is_finite(x) and double_is_finite(y) and double_value(x) <= double_value(y))
    or
     double_is_minus_infinity(x)
    or
     double_is_plus_infinity(y))
*)
}



parameter ge_double_ : x:double -> y:double ->
{}
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y))
     -> if result then double_sign(y)= Negative
   	          else double_sign(y)= Positive)
and
  ((double_is_infinite(x) and double_is_finite(y))
     -> if result then double_sign(x)= Positive
   	       	  else double_sign(x)= Negative)
and
  ((double_is_infinite(x) and double_is_infinite(y))
     -> if result then (double_sign(x)= Positive or double_sign(y)= Negative)
                  else (double_sign(x)= Negative and double_sign(y)= Positive))
and
 ((double_is_finite(x) and double_is_finite(y))
     -> if result then double_value(x) >= double_value(y)
 		  else double_value(x) < double_value(y))
}




parameter eq_double_ :
x:double -> y:double ->
{ }
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y)) -> result = false)
and
  ((double_is_infinite(x) and double_is_finite(y)) -> result = false)
and
  ((double_is_infinite(x) and double_is_infinite(y))
     -> if result then double_same_sign(x,y) else double_diff_sign(x,y))
and
 ((double_is_finite(x) and double_is_finite(y))
     -> if result then double_value(x) = double_value(y)
 		  else double_value(x) <> double_value(y))
}



parameter neq_double_ :
x:double -> y:double ->
{ }
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = true)
and
  ((double_is_finite(x) and double_is_infinite(y)) -> result = true)
and
  ((double_is_infinite(x) and double_is_finite(y)) -> result = true)
and
  ((double_is_infinite(x) and double_is_infinite(y))
     -> if result then double_diff_sign(x,y) else double_same_sign(x,y))
and
 ((double_is_finite(x) and double_is_finite(y))
     -> if result then double_value(x) <> double_value(y)
 		  else double_value(x) = double_value(y))
}
