(***************************************************************************)
(***************************************************************************)
(*** Jessie prelude for floating-point arithmetic: Full mode ***************)
(***************************************************************************)
(***************************************************************************)

include "floats_common.why"

function min_single() : real =  0x1p-149
function min_double() : real =  0x1p-1074


(***************************************************)
(*************** additional views ******************) 
(***************************************************)

type Float_class

logic Finite : Float_class
logic Infinite : Float_class
logic NaN : Float_class

axiom no_other_class : forall f:Float_class. f = Finite or f = Infinite or f = NaN
axiom class_distinct : Finite <> Infinite and Finite <> NaN and Infinite <> NaN 
 
type sign 

logic Negative : sign     
logic Positive : sign    

axiom no_other_sign : forall s:sign. s = Negative or s = Positive
axiom sign_distinct : Negative <> Positive

logic single_class : single -> Float_class
logic double_class : double -> Float_class

logic single_sign : single -> sign
logic double_sign : double -> sign


inductive same_sign_real_bool : sign, real -> prop =
 | neg_case : forall x:real. x < 0.0 -> same_sign_real_bool(Negative,x)
 | pos_case : forall x:real. x > 0.0 -> same_sign_real_bool(Positive,x)



(***************************************************)
(*********** axioms on float_sign ******************) 
(***************************************************)

axiom single_sign_not_pos_neg : forall x:single. 
      single_sign(x) <> Positive -> single_sign(x) = Negative
axiom single_sign_not_neg_pos : forall x:single. 
      single_sign(x) <> Negative -> single_sign(x) = Positive

axiom double_sign_not_pos_neg : forall x:double. 
      double_sign(x) <> Positive -> double_sign(x) = Negative
axiom double_sign_not_neg_pos : forall x:double. 
      double_sign(x) <> Negative -> double_sign(x) = Positive

axiom same_sign_real_bool_zero1 : forall b:sign. not same_sign_real_bool(b,0.0)
axiom same_sign_real_bool_zero2 : forall x:real. 
         same_sign_real_bool(Negative,x) and 
         same_sign_real_bool(Positive,x) -> false
axiom same_sign_real_bool_zero3 : forall b:sign. forall x:real. 
         same_sign_real_bool(b,x) -> x <> 0.0
axiom same_sign_real_bool_correct2 : forall b:sign. forall x:real.
         same_sign_real_bool(b,x) -> (x < 0.0 <-> b = Negative)
axiom same_sign_real_bool_correct3 : forall b:sign. forall x:real.
         same_sign_real_bool(b,x) -> (x > 0.0 <-> b = Positive)



(***************************************************)
(******** predicates to deal with float_sign *******)
(***************************************************)

predicate single_same_sign_real (x:single,y:real) = same_sign_real_bool(single_sign(x),y)
predicate single_same_sign(x:single,y:single)  = single_sign(x) = single_sign(y)
predicate single_diff_sign(x:single,y:single)  = single_sign(x) <> single_sign(y)

predicate single_product_sign(z:single,x:single,y:single) = 
	  (single_same_sign(x,y) -> single_sign(z)= Positive) and
          (single_diff_sign(x,y) -> single_sign(z)= Negative)

predicate double_same_sign_real (x:double,y:real) = same_sign_real_bool(double_sign(x),y)
predicate double_same_sign(x:double,y:double)  = double_sign(x) = double_sign(y)
predicate double_diff_sign(x:double,y:double)  = double_sign(x) <> double_sign(y)

predicate double_product_sign(z:double,x:double,y:double) = 
	  (double_same_sign(x,y) -> double_sign(z)= Positive) and
          (double_diff_sign(x,y) -> double_sign(z)= Negative)



(***************************************************)
(******* predicates to deal with float_class *******)
(***************************************************)

predicate single_same_class(x:single,y:single) = single_class(x) = single_class(y)
predicate singlediff_class(x:single,y:single) = single_class(x) <> single_class(y)
predicate double_same_class(x:double,y:double) = double_class(x) = double_class(y)
predicate doublediff_class(x:double,y:double) = double_class(x) <> double_class(y)



(***************************************************)
(******* axioms on sign of finite gen_float ********)
(***************************************************)

(* non-zero finite gen_float has the same sign as its float_value *)
axiom single_finite_sign : forall x:single.
      (single_class(x) = Finite and single_value(x) <> 0.0) -> 
       single_same_sign_real(x,single_value(x))

axiom single_finite_sign_neg1: forall x:single. 
      single_class(x) = Finite and single_value(x) < 0.0 -> 
                                  single_sign(x) = Negative
axiom single_finite_sign_neg2: forall x:single. 
      single_class(x) = Finite and single_value(x) <> 0.0 
      and single_sign(x) = Negative -> single_value(x) < 0.0
axiom single_finite_sign_pos1: forall x:single. 
      single_class(x) = Finite and single_value(x) > 0.0 -> 
                                  single_sign(x) = Positive
axiom single_finite_sign_pos2: forall x:single. 
      single_class(x) = Finite and single_value(x) <> 0.0 
      and single_sign(x) = Positive -> single_value(x) > 0.0
axiom single_diff_sign_trans: forall x:single. forall y:single. forall z:single.
      single_diff_sign(x,y) and single_diff_sign(y,z) -> single_same_sign(x,z)

axiom single_same_sign_product: forall x:single. forall y:single.
      single_class(x) = Finite and single_class(y) = Finite and 
      single_same_sign(x,y) -> single_value(x) * single_value(y) >= 0.0

axiom single_diff_sign_product: forall x:single. forall y:single.
      single_class(x) = Finite and single_class(y) = Finite and 
      single_value(x) * single_value(y) < 0.0 -> single_diff_sign(x,y)

axiom double_finite_sign : forall x:double.
      (double_class(x) = Finite and double_value(x) <> 0.0) -> 
       double_same_sign_real(x,double_value(x))

axiom double_finite_sign_neg1: forall x:double. 
      double_class(x) = Finite and double_value(x) < 0.0 -> 
                                  double_sign(x) = Negative
axiom double_finite_sign_neg2: forall x:double. 
      double_class(x) = Finite and double_value(x) <> 0.0 
      and double_sign(x) = Negative -> double_value(x) < 0.0
axiom double_finite_sign_pos1: forall x:double. 
      double_class(x) = Finite and double_value(x) > 0.0 -> 
                                  double_sign(x) = Positive
axiom double_finite_sign_pos2: forall x:double. 
      double_class(x) = Finite and double_value(x) <> 0.0 
      and double_sign(x) = Positive -> double_value(x) > 0.0
axiom double_diff_sign_trans: forall x:double. forall y:double. forall z:double.
      double_diff_sign(x,y) and double_diff_sign(y,z) -> double_same_sign(x,z)

axiom double_same_sign_product: forall x:double. forall y:double.
      double_class(x) = Finite and double_class(y) = Finite and 
      double_same_sign(x,y) -> double_value(x) * double_value(y) >= 0.0

axiom double_diff_sign_product: forall x:double. forall y:double.
      double_class(x) = Finite and double_class(y) = Finite and 
      double_value(x) * double_value(y) < 0.0 -> double_diff_sign(x,y)


(***************************************************)
(************** usefull predicates *****************)
(***************************************************)

predicate single_is_finite(x:single) = single_class(x) = Finite
predicate single_is_infinite(x:single) = single_class(x) = Infinite
predicate single_is_NaN(x:single) = single_class(x) = NaN
predicate single_is_not_NaN(x:single) = single_is_finite(x) or single_is_infinite(x)
predicate single_is_minus_infinity(x:single) 
    = single_is_infinite(x) and single_sign(x) = Negative
predicate single_is_plus_infinity(x:single) 
    = single_is_infinite(x) and single_sign(x) = Positive
predicate single_is_gen_zero(x:single)= single_is_finite(x) and single_value(x) = 0.0
predicate single_is_gen_zero_plus(x:single) 
    = single_is_gen_zero(x) and single_sign(x) = Positive
predicate single_is_gen_zero_minus(x:single) 
    = single_is_gen_zero(x) and single_sign(x) = Negative

predicate double_is_finite(x:double) = double_class(x) = Finite
predicate double_is_infinite(x:double) = double_class(x) = Infinite
predicate double_is_NaN(x:double) = double_class(x) = NaN
predicate double_is_not_NaN(x:double) = double_is_finite(x) or double_is_infinite(x)
predicate double_is_minus_infinity(x:double) 
    = double_is_infinite(x) and double_sign(x) = Negative
predicate double_is_plus_infinity(x:double) 
    = double_is_infinite(x) and double_sign(x) = Positive
predicate double_is_gen_zero(x:double)= double_is_finite(x) and double_value(x) = 0.0
predicate double_is_gen_zero_plus(x:double) 
    = double_is_gen_zero(x) and double_sign(x) = Positive
predicate double_is_gen_zero_minus(x:double) 
    = double_is_gen_zero(x) and double_sign(x) = Negative


(* predicate to use in case of overflow result of an operation *)
predicate single_overflow_value(m:mode,x:single) = 
         (m = down -> (single_sign(x) = Negative -> single_is_infinite(x)) and
	              (single_sign(x) = Positive -> single_is_finite(x) and 
                                                   single_value(x)= max_single))  
          and
         (m = up -> (single_sign(x) = Negative -> single_is_finite(x) and 
                                                 single_value(x)= - max_single) and 
                    (single_sign(x) = Positive -> single_is_infinite(x)))  
          and 
         (m = to_zero -> single_is_finite(x) and 
                 (single_sign(x) = Negative -> single_value(x)= - max_single) and 
                 (single_sign(x) = Positive -> single_value(x)=   max_single))  
          and 
         (m = nearest_away or m = nearest_even -> single_is_infinite(x)) 

predicate double_overflow_value(m:mode,x:double) = 
         (m = down -> (double_sign(x) = Negative -> double_is_infinite(x)) and
	              (double_sign(x) = Positive -> double_is_finite(x) and 
                                                   double_value(x)= max_double))  
          and
         (m = up -> (double_sign(x) = Negative -> double_is_finite(x) and 
                                                 double_value(x)= - max_double) and 
                    (double_sign(x) = Positive -> double_is_infinite(x)))  
          and 
         (m = to_zero -> double_is_finite(x) and 
                 (double_sign(x) = Negative -> double_value(x)= - max_double) and 
                 (double_sign(x) = Positive -> double_value(x)=   max_double))  
          and 
         (m = nearest_away or m = nearest_even -> double_is_infinite(x)) 


(* predicate to use in case of underflow result of an operation *)
predicate single_underflow_value(m:mode,x:single) = 
          single_is_finite(x) 
          and
          (single_sign(x) = Positive -> 
              (m = down or m = to_zero or m = nearest_even or m = nearest_away -> 
                                      single_value(x) = 0.0) 
               and 
              (m = up -> single_value(x) = min_single))
          and 
          (single_sign(x) = Negative -> 
              (m = up or m = to_zero or m = nearest_even or m = nearest_away -> 
                                      single_value(x) = 0.0) 
               and 
               (m = down -> single_value(x) = - min_single))

predicate double_underflow_value(m:mode,x:double) = 
          double_is_finite(x) 
          and
          (double_sign(x) = Positive -> 
              (m = down or m = to_zero or m = nearest_even or m = nearest_away -> 
                                      double_value(x) = 0.0) 
               and 
              (m = up -> double_value(x) = min_double))
          and 
          (double_sign(x) = Negative -> 
              (m = up or m = to_zero or m = nearest_even or m = nearest_away -> 
                                      double_value(x) = 0.0) 
               and 
               (m = down -> double_value(x) = - min_double))


(* predicate to get the sign of a zero result of an operation *)
predicate single_sign_zero_result(m:mode,x:single) = 
           single_value(x) = 0.0 -> 
          ((m = down -> single_sign(x) = Negative) 
           and 
           (m <> down -> single_sign(x) = Positive)) 

predicate double_sign_zero_result(m:mode,x:double) = 
           double_value(x) = 0.0 -> 
          ((m = down -> double_sign(x) = Negative) 
           and 
           (m <> down -> double_sign(x) = Positive)) 


(**** Comparisons of floats in the logic ****)
predicate le_single(x:single,y:single) = 
          (single_is_finite(x) and single_is_finite(y) 
              and single_value(x) <= single_value(y))
           or (single_is_minus_infinity(x) and single_is_not_NaN(y))
           or (single_is_not_NaN(x) and single_is_plus_infinity(y))

predicate lt_single(x:single,y:single) = 
          (single_is_finite(x) and single_is_finite(y) 
              and single_value(x) < single_value(y))
           or (single_is_minus_infinity(x) and single_is_not_NaN(y) 
               and not single_is_minus_infinity(y)) 
           or (single_is_not_NaN(x) and not single_is_plus_infinity(x) 
               and single_is_plus_infinity(y))

predicate ge_single(x:single,y:single) = le_single(y,x)

predicate gt_single(x:single,y:single) = lt_single(y,x)

predicate eq_single(x:single,y:single) = 
          single_is_not_NaN(x) and single_is_not_NaN(y) and 
          ((single_is_finite(x) and single_is_finite(y) 
             and single_value(x) = single_value(y))
           or 
          (single_is_infinite(x) and single_is_infinite(y) 
             and single_same_sign(x,y)))

predicate ne_single(x:single,y:single) = not eq_single(x,y)


predicate le_double(x:double,y:double) = 
          (double_is_finite(x) and double_is_finite(y) 
              and double_value(x) <= double_value(y))
           or (double_is_minus_infinity(x) and double_is_not_NaN(y))
           or (double_is_not_NaN(x) and double_is_plus_infinity(y))

predicate lt_double(x:double,y:double) = 
          (double_is_finite(x) and double_is_finite(y) 
              and double_value(x) < double_value(y))
           or (double_is_minus_infinity(x) and double_is_not_NaN(y) 
               and not double_is_minus_infinity(y)) 
           or (double_is_not_NaN(x) and not double_is_plus_infinity(x) 
               and double_is_plus_infinity(y))

predicate ge_double(x:double,y:double) = le_double(y,x)

predicate gt_double(x:double,y:double) = lt_double(y,x)

predicate eq_double(x:double,y:double) = 
          double_is_not_NaN(x) and double_is_not_NaN(y) and 
          ((double_is_finite(x) and double_is_finite(y) 
             and double_value(x) = double_value(y))
           or 
          (double_is_infinite(x) and double_is_infinite(y) 
             and double_same_sign(x,y)))

predicate ne_double(x:double,y:double) = not eq_double(x,y)




(***************************************************)
(******** axioms on gen_float_of_real_logic ********)
(***************************************************)

axiom round_single1 : forall m:mode. forall x:real.
           no_overflow_single(m,x) -> 
           (single_is_finite(round_single_logic(m,x)) and
           single_value(round_single_logic(m,x)) = round_single(m,x))

axiom round_single2 : forall m:mode. forall x:real.
           not no_overflow_single(m,x) -> 
           (single_same_sign_real(round_single_logic(m,x),x) and 
            single_overflow_value(m,round_single_logic(m,x)))

axiom round_single3 : forall m:mode. forall x:real.
           single_exact(round_single_logic(m,x)) = x

axiom round_single4 : forall m:mode. forall x:real.
           single_model(round_single_logic(m,x)) = x

axiom single_of_zero : forall m:mode.
            single_is_gen_zero(round_single_logic(m,0.0))


axiom round_single_logic_le : forall m:mode. forall x:real.
      single_is_finite(round_single_logic(m,x)) ->
      abs_real(single_value(round_single_logic(m,x))) <= max_single

axiom round_single_no_overflow : forall m:mode. forall x:real. 
          abs_real(x) <= max_single -> 
          (single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) = round_single(m,x))

axiom single_positive_constant : forall m:mode. forall x:real.
          min_single <= x <= max_single ->
          single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) > 0.0  and
          single_sign(round_single_logic(m,x)) = Positive

axiom single_negative_constant : forall m:mode. forall x:real.
          - max_single <= x <= - min_single ->
          single_is_finite(round_single_logic(m,x)) and
          single_value(round_single_logic(m,x)) < 0.0  and
          single_sign(round_single_logic(m,x)) = Negative


axiom round_double1 : forall m:mode. forall x:real.
           no_overflow_double(m,x) -> 
           (double_is_finite(round_double_logic(m,x)) and
           double_value(round_double_logic(m,x)) = round_double(m,x))

axiom round_double2 : forall m:mode. forall x:real.
           not no_overflow_double(m,x) -> 
           (double_same_sign_real(round_double_logic(m,x),x) and 
            double_overflow_value(m,round_double_logic(m,x)))

axiom round_double3 : forall m:mode. forall x:real.
           double_exact(round_double_logic(m,x)) = x

axiom round_double4 : forall m:mode. forall x:real.
           double_model(round_double_logic(m,x)) = x

axiom double_of_zero : forall m:mode.
            double_is_gen_zero(round_double_logic(m,0.0))


axiom round_double_logic_le : forall m:mode. forall x:real.
      double_is_finite(round_double_logic(m,x)) ->
      abs_real(double_value(round_double_logic(m,x))) <= max_double

axiom round_double_no_overflow : forall m:mode. forall x:real. 
          abs_real(x) <= max_double -> 
          (double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) = round_double(m,x))

axiom double_positive_constant : forall m:mode. forall x:real.
          min_double <= x <= max_double ->
          double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) > 0.0  and
          double_sign(round_double_logic(m,x)) = Positive

axiom double_negative_constant : forall m:mode. forall x:real.
          - max_double <= x <= - min_double ->
          double_is_finite(round_double_logic(m,x)) and
          double_value(round_double_logic(m,x)) < 0.0  and
          double_sign(round_double_logic(m,x)) = Negative

 

(***************************************************)
(************** axioms on gen_zero *****************)
(***************************************************)

axiom single_is_gen_zero_comp1 : forall x:single. forall y:single.
      single_is_gen_zero(x) and single_value(x) = single_value(y) 
       and single_is_finite(y) ->  single_is_gen_zero(y)

axiom single_is_gen_zero_comp2 : forall x:single. forall y:single. 
      single_is_finite(x) and not single_is_gen_zero(x) 
       and single_value(x) = single_value(y) -> not single_is_gen_zero(y)

axiom double_is_gen_zero_comp1 : forall x:double. forall y:double.
      double_is_gen_zero(x) and double_value(x) = double_value(y) 
       and double_is_finite(y) ->  double_is_gen_zero(y)

axiom double_is_gen_zero_comp2 : forall x:double. forall y:double. 
      double_is_finite(x) and not double_is_gen_zero(x) 
       and double_value(x) = double_value(y) -> not double_is_gen_zero(y)



(***************************************************)
(** specification of unary and binary operations ***)
(***************************************************)

(* in single *)

parameter single_of_real : m:mode -> x:real ->
{ }
single
{ (*result = single_round_logic(m,x) *)
  (no_overflow_single(m,x)     
     -> (single_is_finite(result) and single_value(result) = round_single(m,x))) 
  and 
   (not no_overflow_single(m,x) 
     -> (single_same_sign_real(result,x) and single_overflow_value(m,result)))
  and single_exact(result) = x	
  and single_model(result) = x
}



parameter add_single : m:mode -> x:single -> y:single -> 
{ }
single
{ (single_is_NaN(x) or single_is_NaN(y) -> single_is_NaN(result))
  and 
  ((single_is_finite(x) and single_is_infinite(y)) 
          -> (single_is_infinite(result) and single_same_sign(result,y)))
  and                    
  ((single_is_infinite(x) and single_is_finite(y))
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_same_sign(x,y)) 
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_diff_sign(x,y)) 
          -> single_is_NaN(result))
  and 
  ((single_is_finite(x) and single_is_finite(y) 
     and no_overflow_single(m,single_value(x)+single_value(y))) 
          -> (single_is_finite(result) and
 	     single_value(result) = round_single(m,single_value(x)+single_value(y)) and 
             single_sign_zero_result(m,result)))
  and 
  ((single_is_finite(x) and single_is_finite(y) 
     and not no_overflow_single(m,single_value(x)+single_value(y))) 
          -> (single_same_sign_real(result,single_value(x)+single_value(y)) and
	             single_overflow_value(m,result)))      
  and
  single_exact(result) = single_exact(x) + single_exact(y) and 
  single_model(result) = single_model(x) + single_model(y)
}



parameter sub_single : m:mode -> x:single -> y:single -> 
{ }
single
{ ((single_is_NaN(x) or single_is_NaN(y)) -> single_is_NaN(result))
  and 
  ((single_is_finite(x) and single_is_infinite(y)) 
          -> (single_is_infinite(result) and single_diff_sign(result,y)))
  and                    
  ((single_is_infinite(x) and single_is_finite(y)) 
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_same_sign(x,y)) 
          -> single_is_NaN(result))
  and
  ((single_is_infinite(x) and single_is_infinite(y) and single_diff_sign(x,y)) 
          -> (single_is_infinite(result) and single_same_sign(result,x)))
  and 
  ((single_is_finite(x) and single_is_finite(y) 
     and no_overflow_single(m,single_value(x)-single_value(y))) 
          -> (single_is_finite(result) and
	      single_value(result)= round_single(m,single_value(x)-single_value(y))and 
	      single_sign_zero_result(m,result)))
  and 
  ((single_is_finite(x) and single_is_finite(y) 
     and not no_overflow_single(m,single_value(x)-single_value(y))) 
          -> (single_same_sign_real(result,single_value(x)-single_value(y)) and
              single_overflow_value(m,result)))      
  and
  single_exact(result) = single_exact(x) - single_exact(y) and 
  single_model(result) = single_model(x) - single_model(y)
}




parameter abs_single : m:mode -> x:single -> 
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and 
  (single_is_infinite(x) -> single_is_infinite(result))
and
  (single_is_finite(x)  -> (single_is_finite(result) and
           single_value(result)= abs_real(single_value(x))))
and
  single_sign(result) = Positive and 
  single_exact(result) = abs_real(single_exact(x)) and 
  single_model(result) = abs_real(single_model(x))
} 



parameter mul_single : m:mode -> x:single -> y:single -> 
{ }
single
{ ((single_is_NaN(x)  or  single_is_NaN(y)) -> single_is_NaN(result))
and 
  ((single_is_gen_zero(x) and single_is_infinite(y)) -> single_is_NaN(result))
and 
  ((single_is_finite(x) and single_is_infinite(y) and single_value(x) <> 0.0) 
     -> single_is_infinite(result))
and                    
  ((single_is_infinite(x) and single_is_gen_zero(y)) -> single_is_NaN(result))
and
  ((single_is_infinite(x) and single_is_finite(y) and single_value(y) <> 0.0) 
     -> single_is_infinite(result))
and
  ((single_is_infinite(x) and single_is_infinite(y)) -> single_is_infinite(result))
and 
  ((single_is_finite(x) and single_is_finite(y) 
     and no_overflow_single(m,single_value(x)*single_value(y))) 
     ->	(single_is_finite(result) and
	 single_value(result) = round_single(m,single_value(x) * single_value(y))))
and 
  ((single_is_finite(x) and single_is_finite(y) 
     and not no_overflow_single(m,single_value(x)*single_value(y))) 
     -> (single_overflow_value(m,result)))          
and
  single_product_sign(result,x,y) 
and
  single_exact(result) = single_exact(x) * single_exact(y) and 
  single_model(result) = single_model(x) * single_model(y)
}




parameter div_single : m:mode -> x:single -> y:single -> 
{ }
single
{ ((single_is_NaN(x) or single_is_NaN(y)) -> single_is_NaN(result))
and 
  ((single_is_finite(x) and single_is_infinite(y)) -> single_is_gen_zero(result))
and 
  ((single_is_infinite(x) and single_is_finite(y)) -> single_is_infinite(result))
and
  ((single_is_infinite(x) and single_is_infinite(y)) -> single_is_NaN(result))
and 
  ((single_is_finite(x) and single_is_finite(y) and single_value(y) <> 0.0 and 
     no_overflow_single(m,single_value(x)/single_value(y))) 
      -> (single_is_finite(result) and
          single_value(result)= round_single(m,single_value(x)/single_value(y))))
and 
  ((single_is_finite(x) and single_is_finite(y) and single_value(y) <> 0.0 and 
     not no_overflow_single(m,single_value(x)/single_value(y))) 
      -> single_overflow_value(m,result)) 
and 
  ((single_is_finite(x) and single_is_gen_zero(y) and single_value(x) <> 0.0) 
      -> single_is_infinite(result))
and 
  ((single_is_gen_zero(x) and single_is_gen_zero(y)) -> single_is_NaN(result))
and
  single_product_sign(result,x,y) 
and
  single_exact(result) = single_exact(x)/single_exact(y) and 
  single_model(result) = single_model(x)/single_model(y)
}



parameter sqrt_single :  m:mode -> x:single -> 
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and 
  (single_is_minus_infinity(x) -> single_is_NaN(result))
and 
  (single_is_plus_infinity(x) -> single_is_infinite(result))
and 
  ((single_is_finite(x) and single_value(x)< 0.0) -> single_is_NaN(result))
and 
  (single_is_finite(x) and single_value(x) >= 0.0 
       ->  (single_is_finite(result) and 
          single_value(result)= round_single(m,sqrt_real(single_value(x)))))
and 
   (* not always positive because sqrt(-0) = -0 *)
   single_same_sign(result,x) 
and 
   single_exact(result) = sqrt_real(single_exact(x)) and 
   single_model(result) = sqrt_real(single_model(x))
}



		    	        
parameter neg_single : m:mode -> x:single -> 
{ }
single
{ (single_is_NaN(x)  -> single_is_NaN(result))
and 
  (single_is_infinite(x) -> single_is_infinite(result))
and 
  (single_is_finite(x) 
     -> (single_is_finite(result) and 
         single_value(result) = neg_real(single_value(x))))
and
  single_diff_sign(result,x) 
and
  single_exact(result) = neg_real(single_exact(x)) and 
  single_model(result) = neg_real(single_model(x))
}



parameter lt_single : x:single -> y:single -> 
{ }
bool
{ 
if result then single_is_not_NaN(x) and single_is_not_NaN(y) and 
   (single_is_finite(x) and single_is_finite(y) and single_value(x) < single_value(y))
    or 
   (single_is_minus_infinity(x) and single_is_plus_infinity(y))
    or
   (single_is_minus_infinity(x) and single_is_finite(y))
    or 
   (single_is_finite(x) and single_is_plus_infinity(y))
else (single_is_NaN(x) or single_is_NaN(y)
    or 
    (single_is_finite(x) and single_is_finite(y) and single_value(x) >= single_value(y))
    or 
     single_is_plus_infinity(x) 
    or 
     single_is_minus_infinity(y))
}


parameter le_single : x:single -> y:single -> 
{ } 
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y)) 
        -> if result then single_sign(y) = Positive 
  	    	     else single_sign(y) = Negative)
and 
  ((single_is_infinite(x) and single_is_finite(y)) 
        -> if result then single_sign(x) = Negative
    		     else single_sign(x) = Positive)
and
  ((single_is_infinite(x) and single_is_infinite(y)) ->
                    if result then (single_sign(x)= Negative or 
                                    single_sign(y)= Positive) 
			      else (single_sign(x)= Positive and 
                                    single_sign(y)= Negative))
and
 ((single_is_finite(x) and single_is_finite(y)) 
      -> if result then single_value(x) <= single_value(y) 
 		   else single_value(x) > single_value(y))
}




parameter gt_single : x:single -> y:single -> 
{ }
bool
{ 
if result then single_is_not_NaN(x) and single_is_not_NaN(y) and 
   (single_is_finite(x) and single_is_finite(y) and single_value(x) > single_value(y))
    or 
   (single_is_plus_infinity(x) and single_is_minus_infinity(y))
    or
   (single_is_plus_infinity(x) and single_is_finite(y))
    or 
   (single_is_finite(x) and single_is_minus_infinity(y))
else (single_is_NaN(x) or single_is_NaN(y)
    or 
    (single_is_finite(x) and single_is_finite(y) and single_value(x) <= single_value(y))
    or 
     single_is_minus_infinity(x) 
    or 
     single_is_plus_infinity(y))
}



parameter ge_single : x:single -> y:single -> 
{}
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y)) 
     -> if result then single_sign(y)= Negative 
   	          else single_sign(y)= Positive)
and 
  ((single_is_infinite(x) and single_is_finite(y)) 
     -> if result then single_sign(x)= Positive
   	       	  else single_sign(x)= Negative)
and
  ((single_is_infinite(x) and single_is_infinite(y)) 
     -> if result then (single_sign(x)= Positive or single_sign(y)= Negative)
                  else (single_sign(x)= Negative and single_sign(y)= Positive))
and
 ((single_is_finite(x) and single_is_finite(y)) 
     -> if result then single_value(x) >= single_value(y) 
 		  else single_value(x) < single_value(y))
}




parameter eq_single :
x:single -> y:single -> 
{ }
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = false)
and
  ((single_is_finite(x) and single_is_infinite(y)) -> result = false)
and 
  ((single_is_infinite(x) and single_is_finite(y)) -> result = false)
and
  ((single_is_infinite(x) and single_is_infinite(y)) 
     -> if result then single_same_sign(x,y) else single_diff_sign(x,y))
and
 ((single_is_finite(x) and single_is_finite(y)) 
     -> if result then single_value(x) = single_value(y) 
 		  else single_value(x) <> single_value(y))
}



parameter neq_single :
x:single -> y:single -> 
{ }
bool
{ ((single_is_NaN(x) or single_is_NaN(y)) -> result = true)
and
  ((single_is_finite(x) and single_is_infinite(y)) -> result = true)
and 
  ((single_is_infinite(x) and single_is_finite(y)) -> result = true)
and
  ((single_is_infinite(x) and single_is_infinite(y)) 
     -> if result then single_diff_sign(x,y) else single_same_sign(x,y))
and
 ((single_is_finite(x) and single_is_finite(y)) 
     -> if result then single_value(x) <> single_value(y) 
 		  else single_value(x) = single_value(y))
}

(* in double *)

parameter double_of_real : m:mode -> x:real ->
{ }
double
{ (*result = double_round_logic(m,x) *)
  (no_overflow_double(m,x)     
     -> (double_is_finite(result) and double_value(result) = round_double(m,x))) 
  and 
   (not no_overflow_double(m,x) 
     -> (double_same_sign_real(result,x) and double_overflow_value(m,result)))
  and double_exact(result) = x	
  and double_model(result) = x
}



parameter add_double : m:mode -> x:double -> y:double -> 
{ }
double
{ (double_is_NaN(x) or double_is_NaN(y) -> double_is_NaN(result))
  and 
  ((double_is_finite(x) and double_is_infinite(y)) 
          -> (double_is_infinite(result) and double_same_sign(result,y)))
  and                    
  ((double_is_infinite(x) and double_is_finite(y))
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_same_sign(x,y)) 
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_diff_sign(x,y)) 
          -> double_is_NaN(result))
  and 
  ((double_is_finite(x) and double_is_finite(y) 
     and no_overflow_double(m,double_value(x)+double_value(y))) 
          -> (double_is_finite(result) and
 	     double_value(result) = round_double(m,double_value(x)+double_value(y)) and 
             double_sign_zero_result(m,result)))
  and 
  ((double_is_finite(x) and double_is_finite(y) 
     and not no_overflow_double(m,double_value(x)+double_value(y))) 
          -> (double_same_sign_real(result,double_value(x)+double_value(y)) and
	             double_overflow_value(m,result)))      
  and
  double_exact(result) = double_exact(x) + double_exact(y) and 
  double_model(result) = double_model(x) + double_model(y)
}



parameter sub_double : m:mode -> x:double -> y:double -> 
{ }
double
{ ((double_is_NaN(x) or double_is_NaN(y)) -> double_is_NaN(result))
  and 
  ((double_is_finite(x) and double_is_infinite(y)) 
          -> (double_is_infinite(result) and double_diff_sign(result,y)))
  and                    
  ((double_is_infinite(x) and double_is_finite(y)) 
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_same_sign(x,y)) 
          -> double_is_NaN(result))
  and
  ((double_is_infinite(x) and double_is_infinite(y) and double_diff_sign(x,y)) 
          -> (double_is_infinite(result) and double_same_sign(result,x)))
  and 
  ((double_is_finite(x) and double_is_finite(y) 
     and no_overflow_double(m,double_value(x)-double_value(y))) 
          -> (double_is_finite(result) and
	      double_value(result)= round_double(m,double_value(x)-double_value(y))and 
	      double_sign_zero_result(m,result)))
  and 
  ((double_is_finite(x) and double_is_finite(y) 
     and not no_overflow_double(m,double_value(x)-double_value(y))) 
          -> (double_same_sign_real(result,double_value(x)-double_value(y)) and
              double_overflow_value(m,result)))      
  and
  double_exact(result) = double_exact(x) - double_exact(y) and 
  double_model(result) = double_model(x) - double_model(y)
}




parameter abs_double : m:mode -> x:double -> 
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and 
  (double_is_infinite(x) -> double_is_infinite(result))
and
  (double_is_finite(x)  -> (double_is_finite(result) and
           double_value(result)= abs_real(double_value(x))))
and
  double_sign(result) = Positive and 
  double_exact(result) = abs_real(double_exact(x)) and 
  double_model(result) = abs_real(double_model(x))
} 



parameter mul_double : m:mode -> x:double -> y:double -> 
{ }
double
{ ((double_is_NaN(x)  or  double_is_NaN(y)) -> double_is_NaN(result))
and 
  ((double_is_gen_zero(x) and double_is_infinite(y)) -> double_is_NaN(result))
and 
  ((double_is_finite(x) and double_is_infinite(y) and double_value(x) <> 0.0) 
     -> double_is_infinite(result))
and                    
  ((double_is_infinite(x) and double_is_gen_zero(y)) -> double_is_NaN(result))
and
  ((double_is_infinite(x) and double_is_finite(y) and double_value(y) <> 0.0) 
     -> double_is_infinite(result))
and
  ((double_is_infinite(x) and double_is_infinite(y)) -> double_is_infinite(result))
and 
  ((double_is_finite(x) and double_is_finite(y) 
     and no_overflow_double(m,double_value(x)*double_value(y))) 
     ->	(double_is_finite(result) and
	 double_value(result) = round_double(m,double_value(x) * double_value(y))))
and 
  ((double_is_finite(x) and double_is_finite(y) 
     and not no_overflow_double(m,double_value(x)*double_value(y))) 
     -> (double_overflow_value(m,result)))          
and
  double_product_sign(result,x,y) 
and
  double_exact(result) = double_exact(x) * double_exact(y) and 
  double_model(result) = double_model(x) * double_model(y)
}




parameter div_double : m:mode -> x:double -> y:double -> 
{ }
double
{ ((double_is_NaN(x) or double_is_NaN(y)) -> double_is_NaN(result))
and 
  ((double_is_finite(x) and double_is_infinite(y)) -> double_is_gen_zero(result))
and 
  ((double_is_infinite(x) and double_is_finite(y)) -> double_is_infinite(result))
and
  ((double_is_infinite(x) and double_is_infinite(y)) -> double_is_NaN(result))
and 
  ((double_is_finite(x) and double_is_finite(y) and double_value(y) <> 0.0 and 
     no_overflow_double(m,double_value(x)/double_value(y))) 
      -> (double_is_finite(result) and
          double_value(result)= round_double(m,double_value(x)/double_value(y))))
and 
  ((double_is_finite(x) and double_is_finite(y) and double_value(y) <> 0.0 and 
     not no_overflow_double(m,double_value(x)/double_value(y))) 
      -> double_overflow_value(m,result)) 
and 
  ((double_is_finite(x) and double_is_gen_zero(y) and double_value(x) <> 0.0) 
      -> double_is_infinite(result))
and 
  ((double_is_gen_zero(x) and double_is_gen_zero(y)) -> double_is_NaN(result))
and
  double_product_sign(result,x,y) 
and
  double_exact(result) = double_exact(x)/double_exact(y) and 
  double_model(result) = double_model(x)/double_model(y)
}



parameter sqrt_double :  m:mode -> x:double -> 
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and 
  (double_is_minus_infinity(x) -> double_is_NaN(result))
and 
  (double_is_plus_infinity(x) -> double_is_infinite(result))
and 
  ((double_is_finite(x) and double_value(x)< 0.0) -> double_is_NaN(result))
and 
  (double_is_finite(x) and double_value(x) >= 0.0 
       ->  (double_is_finite(result) and 
          double_value(result)= round_double(m,sqrt_real(double_value(x)))))
and 
   (* not always positive because sqrt(-0) = -0 *)
   double_same_sign(result,x) 
and 
   double_exact(result) = sqrt_real(double_exact(x)) and 
   double_model(result) = sqrt_real(double_model(x))
}



		    	        
parameter neg_double : m:mode -> x:double -> 
{ }
double
{ (double_is_NaN(x)  -> double_is_NaN(result))
and 
  (double_is_infinite(x) -> double_is_infinite(result))
and 
  (double_is_finite(x) 
     -> (double_is_finite(result) and 
         double_value(result) = neg_real(double_value(x))))
and
  double_diff_sign(result,x) 
and
  double_exact(result) = neg_real(double_exact(x)) and 
  double_model(result) = neg_real(double_model(x))
}



parameter lt_double : x:double -> y:double -> 
{ }
bool
{ 
if result then double_is_not_NaN(x) and double_is_not_NaN(y) and 
   (double_is_finite(x) and double_is_finite(y) and double_value(x) < double_value(y))
    or 
   (double_is_minus_infinity(x) and double_is_plus_infinity(y))
    or
   (double_is_minus_infinity(x) and double_is_finite(y))
    or 
   (double_is_finite(x) and double_is_plus_infinity(y))
else (double_is_NaN(x) or double_is_NaN(y)
    or 
    (double_is_finite(x) and double_is_finite(y) and double_value(x) >= double_value(y))
    or 
     double_is_plus_infinity(x) 
    or 
     double_is_minus_infinity(y))
}


parameter le_double : x:double -> y:double -> 
{ } 
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y)) 
        -> if result then double_sign(y) = Positive 
  	    	     else double_sign(y) = Negative)
and 
  ((double_is_infinite(x) and double_is_finite(y)) 
        -> if result then double_sign(x) = Negative
    		     else double_sign(x) = Positive)
and
  ((double_is_infinite(x) and double_is_infinite(y)) ->
                    if result then (double_sign(x)= Negative or 
                                    double_sign(y)= Positive) 
			      else (double_sign(x)= Positive and 
                                    double_sign(y)= Negative))
and
 ((double_is_finite(x) and double_is_finite(y)) 
      -> if result then double_value(x) <= double_value(y) 
 		   else double_value(x) > double_value(y))
}




parameter gt_double : x:double -> y:double -> 
{ }
bool
{ 
if result then double_is_not_NaN(x) and double_is_not_NaN(y) and 
   (double_is_finite(x) and double_is_finite(y) and double_value(x) > double_value(y))
    or 
   (double_is_plus_infinity(x) and double_is_minus_infinity(y))
    or
   (double_is_plus_infinity(x) and double_is_finite(y))
    or 
   (double_is_finite(x) and double_is_minus_infinity(y))
else (double_is_NaN(x) or double_is_NaN(y)
    or 
    (double_is_finite(x) and double_is_finite(y) and double_value(x) <= double_value(y))
    or 
     double_is_minus_infinity(x) 
    or 
     double_is_plus_infinity(y))
}



parameter ge_double : x:double -> y:double -> 
{}
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y)) 
     -> if result then double_sign(y)= Negative 
   	          else double_sign(y)= Positive)
and 
  ((double_is_infinite(x) and double_is_finite(y)) 
     -> if result then double_sign(x)= Positive
   	       	  else double_sign(x)= Negative)
and
  ((double_is_infinite(x) and double_is_infinite(y)) 
     -> if result then (double_sign(x)= Positive or double_sign(y)= Negative)
                  else (double_sign(x)= Negative and double_sign(y)= Positive))
and
 ((double_is_finite(x) and double_is_finite(y)) 
     -> if result then double_value(x) >= double_value(y) 
 		  else double_value(x) < double_value(y))
}




parameter eq_double :
x:double -> y:double -> 
{ }
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = false)
and
  ((double_is_finite(x) and double_is_infinite(y)) -> result = false)
and 
  ((double_is_infinite(x) and double_is_finite(y)) -> result = false)
and
  ((double_is_infinite(x) and double_is_infinite(y)) 
     -> if result then double_same_sign(x,y) else double_diff_sign(x,y))
and
 ((double_is_finite(x) and double_is_finite(y)) 
     -> if result then double_value(x) = double_value(y) 
 		  else double_value(x) <> double_value(y))
}



parameter neq_double :
x:double -> y:double -> 
{ }
bool
{ ((double_is_NaN(x) or double_is_NaN(y)) -> result = true)
and
  ((double_is_finite(x) and double_is_infinite(y)) -> result = true)
and 
  ((double_is_infinite(x) and double_is_finite(y)) -> result = true)
and
  ((double_is_infinite(x) and double_is_infinite(y)) 
     -> if result then double_diff_sign(x,y) else double_same_sign(x,y))
and
 ((double_is_finite(x) and double_is_finite(y)) 
     -> if result then double_value(x) <> double_value(y) 
 		  else double_value(x) = double_value(y))
}
