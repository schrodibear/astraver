
(* Jessie prelude for floating-point arithmetic, full mode *)

include "floats_common.why"


(* useful ? *)
axiom min_single : min_gen_float(Single) <= 0x1p-149

axiom min_double : min_gen_float(Double) <= 0x1p-1074


(* additional views *)

type Float_class

logic Finite : Float_class
logic Infinite : Float_class
logic NaN : Float_class

axiom no_other_class : forall f:Float_class. f = Finite or f = Infinite or f = NaN
axiom class_distinct : Finite <> Infinite and Finite <> NaN and Infinite <> NaN 
 
type sign 

logic Negative : sign     
logic Positive : sign    

axiom no_other_sign : forall s:sign. s = Negative or s = Positive
axiom sign_distinct : Negative <> Positive

logic float_class : gen_float -> Float_class
logic float_sign : gen_float -> sign

(* axioms on float_sign *)
axiom sign_not_pos_neg : forall x:gen_float. float_sign(x) <> Positive -> float_sign(x) = Negative
axiom sign_not_neg_pos : forall x:gen_float. float_sign(x) <> Negative -> float_sign(x) = Positive


inductive same_sign_real_bool : sign, real -> prop =
 | neg_case : forall x:real. x < 0.0 -> same_sign_real_bool(Negative,x)
 | pos_case : forall x:real. x > 0.0 -> same_sign_real_bool(Positive,x)

(* axioms on same_sign_real_bool *)
axiom same_sign_real_bool_zero1 : forall b:sign. not same_sign_real_bool(b,0.0)
axiom same_sign_real_bool_zero2 : forall x:real. 
                                  same_sign_real_bool(Negative,x) and same_sign_real_bool(Positive,x) -> false
axiom same_sign_real_bool_zero3 : forall b:sign. forall x:real. same_sign_real_bool(b,x) -> x <> 0.0
axiom same_sign_real_bool_correct2 : forall b:sign. forall x:real.
                                     same_sign_real_bool(b,x) -> (x < 0.0 <-> b = Negative)
axiom same_sign_real_bool_correct3 : forall b:sign. forall x:real.
                                     same_sign_real_bool(b,x) -> (x > 0.0 <-> b = Positive)


predicate same_sign_real (x:gen_float,y:real) = same_sign_real_bool(float_sign(x),y)

predicate same_sign(x:gen_float,y:gen_float)  = float_sign(x) = float_sign(y)

predicate diff_sign(x:gen_float,y:gen_float)  = float_sign(x) <> float_sign(y)

predicate product_sign(z:gen_float,x:gen_float,y:gen_float) = (same_sign(x,y) -> float_sign(z)= Positive) and
          						      (diff_sign(x,y) -> float_sign(z)= Negative)

predicate same_class(x:gen_float,y:gen_float) = float_class(x) = float_class(y)
predicate diff_class(x:gen_float,y:gen_float) = float_class(x) <> float_class(y)


(* axioms on sign of finite gen_float *) 
axiom finite_sign : forall x:gen_float.
                    (float_class(x) = Finite and float_value(x) <> 0.0) -> same_sign_real(x,float_value(x))
axiom finite_sign_neg1: forall x:gen_float. float_class(x) = Finite and float_value(x) < 0.0 -> float_sign(x) = Negative
axiom finite_sign_neg2: forall x:gen_float. float_class(x) = Finite and float_value(x) <> 0.0 
                                            and float_sign(x) = Negative -> float_value(x) < 0.0
axiom finite_sign_pos1: forall x:gen_float. float_class(x) = Finite and float_value(x) > 0.0 -> float_sign(x) = Positive
axiom finite_sign_pos2: forall x:gen_float. float_class(x) = Finite and float_value(x) <> 0.0 
                                            and float_sign(x) = Positive -> float_value(x) > 0.0


(* usefull predicates *)
predicate is_finite(x:gen_float) = float_class(x) = Finite
predicate is_infinite(x:gen_float) = float_class(x) = Infinite
predicate is_NaN(x:gen_float) = float_class(x) = NaN

predicate is_not_NaN(x:gen_float) = float_class(x) = Finite or float_class(x) = Infinite

predicate is_minus_infinity(x:gen_float) = float_class(x) = Infinite and float_sign(x) = Negative
predicate is_plus_infinity(x:gen_float) = float_class(x) = Infinite and float_sign(x) = Positive

predicate is_gen_zero(x:gen_float)= float_class(x) = Finite and float_value(x) = 0.0
predicate is_gen_zero_plus(x:gen_float) = is_gen_zero(x) and float_sign(x) = Positive
predicate is_gen_zero_minus(x:gen_float) = is_gen_zero(x) and float_sign(x) = Negative

predicate overflow_value(f:float_format,m:mode,x:gen_float) = 
  (m = down -> (float_sign(x) = Negative -> is_infinite(x)) and 
               (float_sign(x) = Positive -> float_class(x)= Finite and float_value(x)= max_gen_float(f)))  
and
  (m = up -> (float_sign(x) = Negative -> is_finite(x) and float_value(x)= - max_gen_float(f)) and 
             (float_sign(x) = Positive -> is_infinite(x)))  
and 
  (m = to_zero -> is_finite(x) and 
                 (float_sign(x) = Negative -> float_value(x)= - max_gen_float(f)) and 
                 (float_sign(x) = Positive -> float_value(x)=   max_gen_float(f)))  
and 
  (m = nearest_away or m = nearest_even -> is_infinite(x)) 


predicate underflow_value(f:float_format,m:mode,x:gen_float) = 
float_class(x) = Finite 
and
(float_sign(x) = Positive -> (m = down or m = to_zero or m = nearest_even or m = nearest_away -> float_value(x) = 0.0) 
                              and 
                             (m = up -> float_value(x) = min_gen_float(f)))
and 
(float_sign(x) = Negative -> (m = up or m = to_zero or m = nearest_even or m = nearest_away -> float_value(x) = 0.0) 
                              and 
                             (m = down -> float_value(x) = - min_gen_float(f)))



predicate sign_zero_result(m:mode,x:gen_float) = 
  float_value(x) = 0.0 -> 
    (  (m = down -> float_sign(x) = Negative) 
     and 
       (m <> down -> float_sign(x) = Positive)) 

predicate float_less_than_real(x:gen_float,y:real) = (is_finite(x) and float_value(x) <= y) or is_minus_infinity(x)

predicate real_less_than_float(x:real, y:gen_float) = (is_finite(y) and x <= float_value(y)) or is_plus_infinity(y)

predicate float_less_than_float(x:gen_float,y:gen_float) = 
          (is_finite(x) and is_finite(y) and float_value(x) <= float_value(y))
           or (is_minus_infinity(x) and is_not_NaN(y))
           or (is_not_NaN(x) and is_plus_infinity(y))

predicate float_strict_less_than_float(x:gen_float,y:gen_float) = 
          (is_finite(x) and is_finite(y) and float_value(x) < float_value(y))
           or (is_minus_infinity(x) and is_not_NaN(y) and not is_minus_infinity(y)) 
           or (is_not_NaN(x) and not is_plus_infinity(x) and is_plus_infinity(y))

predicate float_greater_than_float(x:gen_float,y:gen_float) = float_strict_less_than_float(y,x)

predicate float_strict_greater_than_float(x:gen_float,y:gen_float) = float_strict_less_than_float(y,x)

predicate float_eq_float(x:gen_float,y:gen_float) = 
          is_not_NaN(x) and is_not_NaN(y) and 
          ((is_finite(x) and is_finite(y) and float_value(x) = float_value(y))
           or 
          (is_infinite(x) and is_infinite(y) and same_sign(x,y)))

predicate float_neq_float(x:gen_float,y:gen_float) =
          is_NaN(x) or is_NaN(y) 
          or (is_not_NaN(x) and is_not_NaN(y) and (diff_class(x,y)  
                                                   or 
 						  (is_infinite(x) and is_infinite(y) and diff_sign(x,y))
						   or 
						  (is_finite(x) and is_finite(y) and float_value(x) <> float_value(y))))



(* axioms on round_float *)
axiom round_of_zero: forall f:float_format. forall m:mode. round_float(f,m,0.0) = 0.0
axiom bounded_real_no_overflow : forall f:float_format. forall m:mode. forall x:real. 
                                 abs_real(x) <= max_gen_float(f) -> no_overflow(f,m,x)

axiom positive_constant : forall f:float_format. forall m:mode. forall x:real.  
                          min_gen_float(f) <= x <= max_gen_float(f) -> no_overflow(f,m,x) and round_float(f,m,x) > 0.0 

axiom negative_constant : forall f:float_format. forall m:mode. forall x:real.  
                          - max_gen_float(f) <= x <= - min_gen_float(f) -> no_overflow(f,m,x) and round_float(f,m,x) < 0.0

axiom round_not_zero: forall f:float_format. forall m:mode. forall x:real.  
                         abs_real(x) >= min_gen_float(f) -> abs_real(round_float(f,m,x)) >= min_gen_float(f)




(* axioms on gen_float_of_real_logic *)
axiom a1 : forall f:float_format. forall m:mode. forall x:real.
           no_overflow(f,m,x) -> (is_finite(gen_float_of_real_logic(f,m,x)) and 
                                  float_value(gen_float_of_real_logic(f,m,x)) = round_float(f,m,x) and 
				  sign_zero_result(m,gen_float_of_real_logic(f,m,x)))

axiom a2 : forall f:float_format. forall m:mode. forall x:real.
           not no_overflow(f,m,x) -> (same_sign_real(gen_float_of_real_logic(f,m,x),x) 
	      			      and overflow_value(f,m,gen_float_of_real_logic(f,m,x)))

axiom a3 : forall f:float_format. forall m:mode. forall x:real.
           exact_value(gen_float_of_real_logic(f,m,x)) = x

axiom a4 : forall f:float_format. forall m:mode. forall x:real.
           model_value(gen_float_of_real_logic(f,m,x)) = x

axiom gen_float_of_zero : forall f:float_format. forall m:mode.
                          is_gen_zero(gen_float_of_real_logic(f,m,0.0))

(* remplace l'axiom precedent !
axiom gen_float_of_zero1 : forall f:float_format. forall m:mode. is_gen_zero_plus(gen_float_of_real_logic(f,m,0.0))
*)


axiom finite_gen_float_of_real_logic : forall f:float_format. forall m:mode. forall x:real.
                                       is_finite(gen_float_of_real_logic(f,m,x)) ->
                                       abs_real(float_value(gen_float_of_real_logic(f,m,x))) <= max_gen_float(f)

axiom gen_bounded_real_no_overflow : forall f:float_format. forall m:mode. forall x:real. 
             abs_real(x) <= max_gen_float(f) -> 
             (is_finite(gen_float_of_real_logic(f,m,x)) and
             float_value(gen_float_of_real_logic(f,m,x)) = round_float(f,m,x))

axiom gen_positive_constant : forall f:float_format. forall m:mode. forall x:real.
                               min_gen_float(f) <= x <= max_gen_float(f) ->
                	       is_finite(gen_float_of_real_logic(f,m,x)) and
                  	       float_value(gen_float_of_real_logic(f,m,x)) > 0.0    and
                  	       float_sign(gen_float_of_real_logic(f,m,x)) = Positive

axiom gen_negative_constant :forall f:float_format. forall m:mode. forall x:real.
                               - max_gen_float(f) <= x <= - min_gen_float(f) ->
                  	       is_finite(gen_float_of_real_logic(f,m,x)) and
                  	       float_value(gen_float_of_real_logic(f,m,x)) < 0.0    and
                  	       float_sign(gen_float_of_real_logic(f,m,x)) = Negative



(* axioms on gen_zero *)
axiom is_gen_zero_correct1 : forall x:gen_float. is_gen_zero(x) -> float_value(x) =0.0

axiom is_gen_zero_correct2 : forall x:gen_float. is_finite(x) -> float_value(x) = 0.0 -> is_gen_zero(x)

axiom is_gen_zero_comp1 : forall x:gen_float. forall y:gen_float.
      is_gen_zero(x) -> float_value(x) = float_value(y) -> is_finite(y) -> is_gen_zero(y)

axiom is_gen_zero_comp2 : forall x:gen_float. forall y:gen_float. 
      is_finite(x) -> not is_gen_zero(x) -> float_value(x) = float_value(y) -> not is_gen_zero(y)







(* binary operations *)

parameter gen_float_of_real :
f:float_format -> m:mode -> x:real ->
{ }
gen_float
{ result = gen_float_of_real_logic(f,m,x) 

(*
(no_overflow(f,m,x)     -> (is_finite(result) and float_value(result) = round_float(f,m,x))) 
  and 
  (not no_overflow(f,m,x) -> (same_sign_real(result,x) and overflow_value(f,m,result)))

  and exact_value(result) = x	
  and model_value(result) = x
*)
}


          

parameter add_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
{ }
gen_float
{ (is_NaN(x) or is_NaN(y) -> is_NaN(result))
  and 
  ((is_finite(x) and is_infinite(y)) -> (is_infinite(result) and same_sign(result,y)))
  and                    
  ((is_infinite(x) and is_finite(y)) -> (is_infinite(result) and same_sign(result,x)))
  and
  ((is_infinite(x) and is_infinite(y) and same_sign(x,y)) -> (is_infinite(result) and same_sign(result,x)))
  and
  ((is_infinite(x) and is_infinite(y) and diff_sign(x,y)) -> is_NaN(result))
  and 
  ((is_finite(x) and is_finite(y) and no_overflow(f,m,float_value(x)+float_value(y))) -> 
                             (is_finite(result) and
 			     float_value(result) = round_float(f,m,float_value(x)+float_value(y)) and 
			     sign_zero_result(m,result)))
  and 
  ((is_finite(x) and is_finite(y) and not no_overflow(f,m,float_value(x)+float_value(y))) -> 
                             (same_sign_real(result,float_value(x)+float_value(y)) and
			      overflow_value(f,m,result)))      
  and
  exact_value(result) = exact_value(x) + exact_value(y) and 
  model_value(result) = model_value(x) + model_value(y)

}



parameter sub_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
{ }
gen_float
{ ((is_NaN(x) or is_NaN(y)) -> is_NaN(result))
  and 
  ((is_finite(x) and is_infinite(y)) -> (is_infinite(result) and diff_sign(result,y)))
  and                    
  ((is_infinite(x) and is_finite(y)) -> (is_infinite(result) and same_sign(result,x)))
  and
  ((is_infinite(x) and is_infinite(y) and same_sign(x,y)) -> is_NaN(result))
  and
  ((is_infinite(x) and is_infinite(y) and diff_sign(x,y)) -> (is_infinite(result) and same_sign(result,x)))
  and 
  ((is_finite(x) and is_finite(y) and no_overflow(f,m,float_value(x)-float_value(y))) ->
			     (is_finite(result) and
			      float_value(result)= round_float(f,m,float_value(x)-float_value(y))and 
			      sign_zero_result(m,result)))
  and 
  ((is_finite(x) and is_finite(y) and not no_overflow(f,m,float_value(x)-float_value(y))) -> 
                             (same_sign_real(result,float_value(x)-float_value(y)) and
 			      overflow_value(f,m,result)))      
  and
  exact_value(result) = exact_value(x) - exact_value(y) and 
  model_value(result) = model_value(x) - model_value(y)

}




parameter abs_gen_float : 
f:float_format -> m:mode -> x:gen_float -> 
{ }
gen_float
{ (is_NaN(x)  -> is_NaN(result))
and 
  (is_infinite(x) -> is_infinite(result))
and
  ((is_finite(x) and no_overflow(f,m,abs_real(float_value(x))))  -> 
                                (is_finite(result) and
			         float_value(result)= round_float(f,m,abs_real(float_value(x)))))
and
  ((is_finite(x) and not no_overflow(f,m,abs_real(float_value(x))))  -> overflow_value(f,m,result))
and
  float_sign(result) = Positive and 
  exact_value(result) = abs_real(exact_value(x)) and 
  model_value(result) = abs_real(model_value(x))

} 




(*
parameter fma_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float -> z:gen_float ->
{ }
gen_float
{ ((is_NaN(x)  or  is_NaN(y) or is_NaN(z)) -> is_NaN(result))
and 



}
*)





parameter mul_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
{ }
gen_float
{ ((is_NaN(x)  or  is_NaN(y)) -> is_NaN(result))
  and 
  ((is_gen_zero(x) and is_infinite(y)) -> is_NaN(result))
  and 
  ((is_finite(x) and is_infinite(y) and float_value(x) <> 0.0) -> is_infinite(result))
  and                    
  ((is_infinite(x) and is_gen_zero(y)) -> is_NaN(result))
  and
  ((is_infinite(x) and is_finite(y) and float_value(y) <> 0.0) -> is_infinite(result))
  and
  ((is_infinite(x) and is_infinite(y)) -> is_infinite(result))
  and 
  ((is_finite(x) and is_finite(y) and no_overflow(f,m,float_value(x)*float_value(y))) ->
			             (is_finite(result) and
			              float_value(result) = round_float(f,m,float_value(x) * float_value(y))))
  and 
  ((is_finite(x) and is_finite(y) and not no_overflow(f,m,float_value(x)*float_value(y))) -> (overflow_value(f,m,result)))          
  and
  product_sign(result,x,y) and
  exact_value(result) = exact_value(x) * exact_value(y) and 
  model_value(result) = model_value(x) * model_value(y)

}





parameter div_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float -> 
{ }
gen_float
{ ((is_NaN(x) or is_NaN(y)) -> is_NaN(result))
and 
  ((is_finite(x) and is_infinite(y)) -> is_gen_zero(result))
and 
  ((is_infinite(x) and is_finite(y)) -> is_infinite(result))
and
  ((is_infinite(x) and is_infinite(y)) -> is_NaN(result))
and 
  ((is_finite(x) and is_finite(y) and float_value(y) <> 0.0 and no_overflow(f,m,float_value(x)/float_value(y))) ->
			     (is_finite(result) and
			      float_value(result)= round_float(f,m,float_value(x)/float_value(y))))
and 
  ((is_finite(x) and is_finite(y) and float_value(y) <> 0.0 and not no_overflow(f,m,float_value(x)/float_value(y))) -> 
			      overflow_value(f,m,result)) 
and 
  ((is_finite(x) and is_gen_zero(y) and float_value(x) <> 0.0) -> is_infinite(result))
and 
  ((is_gen_zero(x) and is_gen_zero(y)) -> is_NaN(result))
and
  product_sign(result,x,y) and
  exact_value(result) = exact_value(x)/exact_value(y) and 
  model_value(result) = model_value(x)/model_value(y)

}



parameter sqrt_gen_float : 
f:float_format -> m:mode -> x:gen_float -> 
{ }
gen_float
{ (is_NaN(x)  -> is_NaN(result))
and 
  (is_minus_infinity(x) -> float_class(result)= NaN)
and 
  (is_plus_infinity(x) -> float_class(result) = Infinite)
and 
  ((is_finite(x) and float_value(x)< 0.0) -> is_NaN(result))
and 
  ((is_finite(x) and float_value(x) >= 0.0 and no_overflow(f,m,sqrt_real(float_value(x)))) -> 	
                			  (is_finite(result) and 
					   float_value(result)= round_float(f,m,sqrt_real(float_value(x)))))
and 
  ((is_finite(x) and float_value(x) >= 0.0 and not no_overflow(f,m,sqrt_real(float_value(x)))) ->
                        		           overflow_value(f,m,result))
and 
   (* not always positive because sqrt(-0) = -0 *)
   same_sign(result,x) and 
   exact_value(result) = sqrt_real(exact_value(x)) and 
   model_value(result) = sqrt_real(model_value(x))
}



(* if sqrt is defined in the logic: 

axiom fdfh : forall f:float_format. forall m:mode. forall x:gen_float.
                     is_gen_zero_minus(x) -> is_gen_zero_minus(sqrt_gen_float(f,m,x))            
axiom lmij : forall f:float_format. forall m:mode. forall x:gen_float.
                     is_gen_zero_plus(x) -> is_gen_zero_plus(sqrt_gen_float(f,m,x)) 
*)


		    	        
parameter neg_gen_float : 
f:float_format -> m:mode -> x:gen_float -> 
{ }
gen_float
{ (is_NaN(x)  -> is_NaN(result))
and 
  (is_infinite(x) -> (is_infinite(result) and diff_sign(result,x)))
and 
  ((is_finite(x) and no_overflow(f,m,neg_real(float_value(x)))) -> 
  		    (is_finite(result) and float_value(result) = round_float(f,m,neg_real(float_value(x)))))
and 
  ((is_finite(x) and not no_overflow(f,m,neg_real(float_value(x)))) -> overflow_value(f,m,result))
and
  diff_sign(result,x) and
  exact_value(result) = neg_real(exact_value(x)) and 
  model_value(result) = neg_real(model_value(x))

}



(*
parameter nextup_gen_float : 
f:float_format -> x:gen_float -> 
{ }
gen_float
{ (is_NaN(x) -> is_NaN(result))
and
  (is_minus_infinity(x) -> is_finite(result) and float_value(result) = - max_gen_float(f))
and 
  (is_plus_infinity(x) -> is_plus_infinity(result))
and 
  (is_finite(x) and float_value(x) < - max_gen_float(f) -> is_finite(result) and float_value(result) = - max_gen_float(f))
and 
  (is_finite(x) and - max_gen_float(f) <= float_value(x) < - min_gen_float(f) -> 
                      is_finite(result) and - max_gen_float(f) < float_value(result) <= - min_gen_float(f))
and 
  (is_finite(x) and float_value(x) = - min_gen_float(f) -> is_gen_zero_minus(result))
and 
  (is_gen_zero_minus(x) or is_gen_zero_plus(x) -> is_finite(result) and float_value(result) = min_gen_float(f)) 
and 
  (is_finite(x) and min_gen_float(f) <= float_value(x) < max_gen_float(f) -> 
                    is_finite(result) and  min_gen_float(f) < float_value(result) <= max_gen_float(f))
and 
  (is_finite(x) and float_value(x) >= max_gen_float(f) -> is_plus_infinity(result))
}

function nextdown_gen_float(f:float_format,x:gen_float) : gen_float = neg_gen_float(nextup_gen_float(neg_gen_float(x)))
*)


(*
parameter remainder_gen_float : 
f:float_format -> m:mode -> x:gen_float -> y:gen_float ->
{ }
gen_float
{ (is_NaN(x) or is_NaN(y) -> is_NaN(result))
and 
  (is_infinite(x) -> is_NaN(result))
and 
  (is_finite(x) and is_infinite(y) -> float_eq_float(result,x)) 
and 
  (is_gen_zero(y) -> is_NaN(result))
and 
  (is_finite(x) and is_finite(y) and float_value(y) <> 0.0 -> is_finite(result) and 
   float_value(result) = float_value(x) - float_value(y) * int_of_real(float_value(x)/float_value(y)) (*nearest_even*)
   and (float_value(result) = 0.0 -> same_sign(result,x)))
}
*)



(*
predicate is_negative_NaN(x:gen_float) = is_NaN(x) and float_sign(x) = Negative
predicate is_positive_NaN(x:gen_float) = is_NaN(x) and float_sign(x) = Positive


parameter min_gen_float : 
x:gen_float -> y:gen_float ->
{ }
gen_float
{ (is_negative_NaN(x) or is_negative_NaN(y) -> is_negative_NaN(result))
and 
  (is_positive_NaN(x) -> result = y)
and 
  (is_positive_NaN(y) -> result = x)
and 
  (is_minus_infinity(x) and not_is_NaN(y) -> is_minus_infinity(result))
and 
  (not_is_NaN(x) and is_minus_infinity(y) -> is_minus_infinity(result))

............
}
*)




function gen_round_error(x:gen_float) : real = abs_real(float_value(x) - exact_value(x))
function gen_relative_error(x:gen_float) : real = abs_real(float_value(x) - exact_value(x))/exact_value(x)
function gen_total_error(x:gen_float) : real = abs_real(float_value(x) - model_value(x))


parameter set_model : x:gen_float ref -> y:real ->
  { } 
  unit writes x
  { float_value(x) = float_value(x@)
    and exact_value(x) = exact_value(x@)
    and model_value(x) = y }


parameter lt_gen_float :
x:gen_float -> y:gen_float -> 
{ }
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = false)
and
  ((is_finite(x) and is_infinite(y)) -> if result then float_sign(y) = Positive 
  		    	                else float_sign(y)= Negative)
and 
  ((is_infinite(x) and is_finite(y)) -> if result then float_sign(x)= Negative
       		      		        else float_sign(x)= Positive)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then (float_sign(x) = Negative and float_sign(y) = Positive)
				          else (float_sign(x) = Positive or float_sign(y) = Negative)) 
and
 ((is_finite(x) and is_finite(y)) -> if result then float_value(x) < float_value(y) 
 		   	      	     else float_value(x) >= float_value(y))
}



parameter le_gen_float :
x:gen_float -> y:gen_float -> 
{ } 
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = false)
and
  ((is_finite(x) and is_infinite(y)) -> if result then float_sign(y) = Positive 
  		    	       	        else float_sign(y) = Negative)
and 
  ((is_infinite(x) and is_finite(y)) -> if result then float_sign(x) = Negative
    		      		        else float_sign(x) = Positive)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then (float_sign(x)= Negative or float_sign(y)= Positive) 
				          else (float_sign(x)= Positive and float_sign(y)= Negative))
and
 ((is_finite(x) and is_finite(y)) -> if result then float_value(x) <= float_value(y) 
 		   	             else float_value(x) > float_value(y))
}




parameter gt_gen_float :
x:gen_float -> y:gen_float -> 
{ }
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = false)
and
  ((is_finite(x) and is_infinite(y)) -> if result then float_sign(y)= Negative 
       		      		        else float_sign(y)= Positive)
and 
  ((is_infinite(x) and is_finite(y)) -> if result then float_sign(x)= Positive
  	       		      	        else float_sign(x)= Negative)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then (float_sign(x)= Positive and float_sign(y)= Negative)
				          else (float_sign(x)= Negative or float_sign(y)= Positive))
and
 ((is_finite(x) and is_finite(y)) ->  if result then float_value(x) > float_value(y) 
 		   	      	      else float_value(x) <= float_value(y))
}





parameter ge_gen_float :
x:gen_float -> y:gen_float -> 
{}
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = false)
and
  ((is_finite(x) and is_infinite(y)) -> if result then float_sign(y)= Negative 
   	       		                else float_sign(y)= Positive)
and 
  ((is_infinite(x) and is_finite(y)) -> if result then float_sign(x)= Positive
   	       		      	        else float_sign(x)= Negative)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then (float_sign(x)= Positive or float_sign(y)= Negative)
                  		          else (float_sign(x)= Negative and float_sign(y)= Positive))
and
 ((is_finite(x) and is_finite(y)) -> if result then float_value(x) >= float_value(y) 
 		   	             else float_value(x) < float_value(y))
}




parameter eq_gen_float :
x:gen_float -> y:gen_float -> 
{ }
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = false)
and
  ((is_finite(x) and is_infinite(y)) -> result = false)
and 
  ((is_infinite(x) and is_finite(y)) -> result = false)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then same_sign(x,y)
				          else diff_sign(x,y))
and
 ((is_finite(x) and is_finite(y)) -> if result then float_value(x) = float_value(y) 
 		   	      	     else float_value(x) <> float_value(y))
}



parameter neq_gen_float :
x:gen_float -> y:gen_float -> 
{ }
bool
{ ((is_NaN(x) or is_NaN(y)) -> result = true)
and
  ((is_finite(x) and is_infinite(y)) -> result = true)
and 
  ((is_infinite(x) and is_finite(y)) -> result = true)
and
  ((is_infinite(x) and is_infinite(y)) -> if result then diff_sign(x,y)
				          else same_sign(x,y))
and
 ((is_finite(x) and is_finite(y)) -> if result then float_value(x) <> float_value(y) 
 		   	             else float_value(x) = float_value(y))
}


(* conversions *)

parameter cast_gen_float : 
f:float_format -> m:mode -> x:gen_float ->
{ }
gen_float
{ (is_NaN(x) -> is_NaN(result)) 
  and
  (is_infinite(x) -> (is_infinite(result) and same_sign(result,x)))
  and 
  ((is_finite(x) and no_overflow(f,m,float_value(x))) -> (float_class(result) = Finite and
                   		                          float_value(result) = round_float(f,m,float_value(x))))
  and 
  ((is_finite(x) and not no_overflow(f,m,float_value(x))) -> same_sign(result,x) and overflow_value(f,m,result))
  and 
  exact_value(result) = exact_value(x)and 
  model_value(result) = model_value(x) 

}


(* any function *)

parameter any_gen_float : float_format -> { } gen_float { }
