theory Enum_intf
  type t

  function to_int t : int

  predicate in_bounds int

  function normalize int : int
end

theory Enum
  constant min : int
  constant max : int

  use import int.Int

  constant range : int = max - min + 1

  use int.EuclideanDivision

  function normalize (x : int) : int = min + (EuclideanDivision.mod (x - min) range)

  use import int.ComputerDivision

  predicate in_bounds (n : int) = min <= n <= max

  clone export Enum_intf with
    function normalize = normalize,
    predicate in_bounds = in_bounds

  axiom To_int:
    forall x : t. min <= to_int x <= max

  axiom To_int_in_bounds: forall n:t. in_bounds (to_int n)

  function of_int int : t

  axiom Of_int:
    forall x : int. min <= x <= max -> to_int (of_int x) = x

  function (+) (a b : t) : t = of_int (Int.(+) (to_int a) (to_int b))

  function (+%) (a b : t) : t = of_int (normalize (Int.(+) (to_int a) (to_int b)))

  function (-_) (a : t) : t = of_int (Int.(-_) (to_int a))

  function (-%_) (a : t) : t = of_int (normalize (Int.(-_) (to_int a)))

  function (-) (a b : t) : t = of_int (Int.(-) (to_int a) (to_int b))

  function (-%) (a b : t) : t = of_int (normalize (Int.(-) (to_int a) (to_int b)))

  function ( *) (a b : t) : t = of_int (Int.( *) (to_int a) (to_int b))

  function ( *%) (a b : t) : t = of_int (normalize (Int.( *) (to_int a) (to_int b)))

  predicate equal (a b : t) = to_int a = to_int b

  predicate ne (a b : t) = to_int a <> to_int b

  axiom Extensionality1: forall x y : t. to_int x = to_int y -> x = y

  axiom Extensionality2:
    forall x y : int. of_int x = of_int y ->
      min <= x <= max /\ min <= y <= max ->
        x = y

  predicate (<=) (a b : t) = Int.(<=) (to_int a) (to_int b)

  predicate (<) (a b : t) = Int.(<) (to_int a) (to_int b)

  predicate (>=) (a b : t) = Int.(>=) (to_int a) (to_int b)

  predicate (>) (a b : t) = Int.(>) (to_int a) (to_int b)

  function (/) (a b : t) : t = of_int (div (to_int a) (to_int b))

  function (/%) (a b : t) : t = of_int (normalize (div (to_int a) (to_int b)))

  function (%) (a b : t) : t = of_int (mod (to_int a) (to_int b))

  function (%%) (a b : t) : t = of_int (normalize (mod (to_int a) (to_int b)))
end

module Generic_enum
  clone export Enum_intf

  use import int.Int

  val (+%) (a b : t) : t
    ensures { to_int result = normalize (to_int a + to_int b) }

  val (-%) (a b : t) : t
    ensures { to_int result = normalize (to_int a - to_int b) }

  val ( *%) (a b : t) : t
    ensures { to_int result = normalize (to_int a * to_int b) }

  val (-%_) (a : t) : t
    ensures { to_int result = normalize (- to_int a) }

  val eq (a b : t) : bool
    ensures { result <-> to_int a = to_int b }

  val ne (a b : t) : bool
    ensures { result <-> to_int a <> to_int b }

  val (<=) (a b : t) : bool
    ensures  { result <-> to_int a <= to_int b }

  val (<) (a b : t) : bool
    ensures  { result <-> to_int a < to_int b }

  val (>=) (a b : t) : bool
    ensures  { result <-> to_int a >= to_int b }

  val (>) (a b : t) : bool
    ensures  { result <-> to_int a > to_int b }
end

module Safe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    requires { "expl:integer overflow" in_bounds n }
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a + to_int b) }
    ensures   { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a - to_int b) }
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a * to_int b) }
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    requires { "expl:integer overflow" in_bounds (- to_int a) }
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (div (to_int a) (to_int b)) }
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (mod (to_int a) (to_int b)) }
    ensures  { to_int result = mod (to_int a) (to_int b) }

end

module Safe_enum_ext
  clone export Enum_intf

  use import int.ComputerDivision

  val (/%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }

  val (%%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
end

module Unsafe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    ensures   { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    ensures  { to_int result = mod (to_int a) (to_int b) }
end

module Unsafe_enum_ext
  clone export Enum_intf

  use import int.ComputerDivision

  val (/%) (a b : t) : t
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }

  val (%%) (a b : t) : t
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
end

theory Powers_of_2
  use export int.Power

  lemma Powers_of_2:
    power 2 0 = 1 /\
    power 2 1 = 2 /\
    power 2 2 = 4 /\
    power 2 3 = 8 /\
    power 2 4 = 16 /\
    power 2 5 = 32 /\
    power 2 6 = 64 /\
    power 2 7 = 128 /\

    power 2 8 = 256 /\
    power 2 9 = 512 /\
    power 2 10 = 1024 /\
    power 2 11 = 2048 /\
    power 2 12 = 4096 /\
    power 2 13 = 8192 /\
    power 2 14 = 16384 /\
    power 2 15 = 32768 /\

    power 2 16 = 65536 /\
    power 2 17 = 131072 /\
    power 2 18 = 262144 /\
    power 2 19 = 524288 /\
    power 2 20 = 1048576 /\
    power 2 21 = 2097152 /\
    power 2 22 = 4194304 /\
    power 2 23 = 8388608 /\

    power 2 24 = 16777216 /\
    power 2 25 = 33554432 /\
    power 2 26 = 67108864 /\
    power 2 27 = 134217728 /\
    power 2 28 = 268435456 /\
    power 2 29 = 536870912 /\
    power 2 30 = 1073741824 /\
    power 2 31 = 2147483648 /\
    power 2 63 = 9223372036854775808 /\
    power 2 64 = 18446744073709551616
end

theory Bit_enum_intf
  namespace import E
    clone export Enum_intf

    constant range : int

    function of_int int : t

    predicate equal t t

    function (+%) t t : t
    function (-%) t t : t
    function (-%_) t : t
    function ( *%) t t : t
    function (/%) t t : t
    function (%%) t t : t
  end

  constant size : int

  predicate signed

  function (&) t t : t
  function (|.) t t : t
  function (~_) t : t
  function (^) t t : t
  function lsl t t : t
  function lsr t t : t
  function asr t t : t

  function add t t : t
  function sub t t : t
  function neg t : t
  function mul t t : t
  function udiv t t : t
  function urem t t : t
  function sdiv t t : t
  function srem t t : t
end

theory Bit_enum_intf2
  clone export Enum_intf

  constant range : int

  function of_int int : t

  predicate equal t t

  function (+%) t t : t
  function (-%) t t : t
  function (-%_) t : t
  function ( *%) t t : t
  function (/%) t t : t
  function (%%) t t : t

  clone export Bit_enum_intf with
    namespace E = .

  predicate eq t t
  predicate ne t t
end

theory Bit_enum
  clone export Bit_enum_intf

  use import int.Int

  constant zero : E.t = E.of_int 0

  constant ones : E.t = if signed then E.of_int (- 1) else E.of_int (E.range - 1)

  function to_uint (a : E.t) : int =
    if signed /\ E.to_int a < 0 then E.range + E.to_int a else E.to_int a

  function of_int_modulo (n : int) : E.t = E.of_int (E.normalize n)

  function lsl_int E.t int : E.t

  function lsr_int E.t int : E.t

  function asr_int E.t int : E.t

  use import Powers_of_2

  clone export bv.BitVector with
    type t = E.t,
    constant size = size,
    (*goal Size_pos,
      lemma Val_two_power_size,*)
    constant two_power_size = E.range,
    constant zero = zero,
    constant ones = ones,
    function bw_and = (&),
    function bw_or = (|.),
    function bw_xor = (^),
    function bw_not = (~_),
    function lsl = lsl_int,
    function lsr = lsr_int,
    function asr = asr_int,
    function lsl_bv = lsl,
    function lsr_bv = lsr,
    function asr_bv = asr,
    function to_uint = to_uint,
    function to_int = E.to_int,
    function of_int = of_int_modulo,
    function add = add,
    function sub = sub,
    function neg = neg,
    function mul = mul,
    function udiv = udiv,
    function urem = urem,
    function sdiv = sdiv,
    function srem = srem

  use import int.ComputerDivision

  axiom Nth:
    forall a : E.t.
      forall n : int.
        0 <= n < size ->
          nth a n <->
            E.to_int a >= 0 /\ mod (E.to_int a) (power 2 (n + 1)) >= power 2 n \/
            E.to_int a < 0 /\ mod (E.range  + E.to_int a) (power 2 (n + 1)) >= power 2 n

  axiom Eq:
    forall a b : E.t.
      E.equal a b -> eq a b

  axiom Add_eq:
    forall a b : E.t.
      E.(+%) a b = add a b

  axiom Sub_eq:
    forall a b : E.t.
      E.(-%) a b = sub a b

  axiom Neg_eq:
    forall a : E.t.
      E.(-%_) a = neg a

  axiom Mul_eq:
    forall a b : E.t.
      E.( *%) a b = mul a b
end

theory Signed_enum
  clone export Bit_enum_intf2

  axiom Div_eq:
    forall a b : t.
      a /% b = sdiv a b

  axiom Mod_eq:
    forall a b : t.
      a %% b = srem a b
end

theory Unsigned_enum
  clone export Bit_enum_intf2

  axiom Div_eq:
    forall a b : t.
      a /% b = udiv a b

  axiom Mod_eq:
    forall a b : t.
      a %% b = urem a b
end

module Generic_bit_enum
  clone export Bit_enum_intf2

  val (&) (x y : t) : t
    ensures { result = x & y }

  val (|^) (x y : t) : t
    ensures { result = x |. y }

  val (~_) (x : t) : t
    ensures { result = ~ x }

  val (^) (x y : t) : t
    ensures { result = x ^ y }

  use import int.Int

  val (+%) (a b : t) : t
    ensures { to_int result = normalize (to_int a + to_int b) }
    ensures { result = add a b }

  val (-%) (a b : t) : t
    ensures { to_int result = normalize (to_int a - to_int b) }
    ensures { result = sub a b }

  val ( *%) (a b : t) : t
    ensures { to_int result = normalize (to_int a * to_int b) }
    ensures { result = mul a b }

  val (-%_) (a : t) : t
    ensures { to_int result = normalize (- to_int a) }
    ensures { result = neg a }

  val eq (a b : t) : bool
    ensures { result <-> to_int a = to_int b }
    ensures { result <-> eq a b }

  val ne (a b : t) : bool
    ensures { result <-> to_int a <> to_int b }
    ensures { result <-> ne a b }
end

module Safe_bit_enum
  clone export Bit_enum_intf2

  use import Powers_of_2
  use import int.Int

  val lsl (x y : t) : t
    requires { "expl:<< second operand" 0 <= to_int y < size }
    requires { "expl:integer overflow" in_bounds (to_int x * (power 2 (to_int y))) }
    ensures { result = lsl x y }
    ensures { to_int result = to_int x * (power 2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    requires { "expl:<< second operand" 0 <= to_int y < size }
    ensures { result = lsl x y }
    ensures { to_int result = normalize (to_int x * (power 2 (to_int y))) }

  use import int.EuclideanDivision

  val lsr (x y : t) : t
    requires { "expl:>> second operand" 0 <= to_int y < size }
    ensures { result = lsr x y }
    ensures { to_int x >= 0 -> to_int result = div (to_int x) (power 2 (to_int y)) }

  val asr (x y : t) : t
    requires { "expl:>> second operand" 0 <= to_int y < size }
    ensures { result = asr x y }
    ensures { to_int result = div (to_int x) (power 2 (to_int y)) }

  val (/%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }
    ensures  { result = if signed then sdiv a b else udiv a b }

  val (%%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
    ensures  { result = if signed then srem a b else urem a b }
end

module Unsafe_bit_enum
  clone export Bit_enum_intf2

  use import int.Int
  use import Powers_of_2

  val lsl (x y : t) : t
    ensures { result = lsl x y }
    ensures { to_int result = to_int x * (power 2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    ensures { result = lsl x y }
    ensures { to_int result = normalize (to_int x * (power 2 (to_int y))) }

  use import int.EuclideanDivision

  val lsr (x y : t) : t
    ensures { result = lsr x y }
    ensures { to_int x >= 0 -> to_int result = div (to_int x) (power 2 (to_int y)) }

  val asr (x y : t) : t
    ensures { result = asr x y }
    ensures { to_int result = div (to_int x) (power 2 (to_int y)) }

  val (/%) (a b : t) : t
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }
    ensures  { result = if signed then sdiv a b else udiv a b }

  val (%%) (a b : t) : t
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
    ensures  { result = if signed then srem a b else urem a b }
end

theory Int8
  use import int.Int
  constant min : int = -128
  constant max : int = 127

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint8
  use import int.Int
  constant min : int = 0
  constant max : int = 255

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int16
  use import int.Int
  constant min : int = -32768
  constant max : int = 32767

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint16
  use import int.Int
  constant min : int = 0
  constant max : int = 65535

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int32
  use import int.Int
  constant min : int = -2147483648
  constant max : int = 2147483647

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint32
  use import int.Int
  constant min : int = 0
  constant max : int = 4294967295

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int64
  use import int.Int
  constant min : int = -9223372036854775808
  constant max : int = 9223372036854775807

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint64
  use import int.Int
  constant min : int = 0
  constant max : int = 18446744073709551615

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Bit_int8
  use export Int8

  constant size : int = 8
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Signed_enum with
    namespace . = .
end

theory Bit_uint8
  use export Uint8

  constant size : int = 8
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Unsigned_enum with
    namespace . = .
end

theory Bit_int16
  use export Int16

  constant size : int = 16
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Signed_enum with
    namespace . = .
end

theory Bit_uint16
  use export Uint16

  constant size : int = 16
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Unsigned_enum with
    namespace . = .
end

theory Bit_int32
  use export Int32

  constant size : int = 32
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Signed_enum with
    namespace . = .
end

theory Bit_uint32
  use export Uint32

  constant size : int = 32
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Unsigned_enum with
    namespace . = .
end

theory Bit_int64
  use export Int64

  constant size : int = 64
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Signed_enum with
    namespace . = .
end

theory Bit_uint64
  use export Uint64

  constant size : int = 64
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
  clone export Unsigned_enum with
    namespace . = .
end

(*
theory T1
  use import int.Int

  use Int32
  use Uint8
end

module Safe_int32
  use import Int32
  clone export Generic_enum with
    namespace . = .
  clone export Safe_enum with
    namespace . = .
  clone export Safe_enum_ext with
    namespace . = .
end

module Safe_bit_int32
  use import Bit_int32
  clone export Safe_enum with
    namespace . = .
  clone export Generic_bit_enum with
    namespace . = .
  clone export Safe_bit_enum with
    namespace . = .
end

module Unafe_bit_int32
  use import Bit_int32
  clone export Unsafe_enum with
    namespace . = .
  clone export Generic_bit_enum with
    namespace . = .
  clone export Unsafe_bit_enum with
    namespace . = .
end

module Unafe_bit_uint8
  use import Bit_uint8
  clone export Unsafe_enum with
    namespace . = .
  clone export Generic_bit_enum with
    namespace . = .
  clone export Unsafe_bit_enum with
    namespace . = .
end
*)
