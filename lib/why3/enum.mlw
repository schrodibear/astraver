theory Enum_intf
  type t

  function to_int t : int

  predicate in_bounds int
end

theory Enum
  constant min : int
  constant max : int

  use import int.Int

  meta "inline : no" predicate Int.(<=)
  meta "inline : no" predicate Int.(>=)

  use import int.ComputerDivision

  predicate in_bounds (n : int) = min <= n <= max

  clone export Enum_intf with
    predicate in_bounds = in_bounds

  axiom To_int_in_bounds:
    forall a : t [to_int a]. in_bounds (to_int a)

  function of_int int : t

  axiom Of_int:
    forall a : int [of_int a]. in_bounds a -> to_int (of_int a) = a

  (* The folowing functions are `degenerate' due to the typing in the input ACSL specs,
   *  for operation without `%' we always explicitly coerce to integer (`int') before performing the operation,
   *  for modulo operations we always use bitvector operations.
   *)

  (*
  function (+) (a b : t) : t = of_int (Int.(+) (to_int a) (to_int b))

  function (-_) (a : t) : t = of_int (Int.(-_) (to_int a))

  function (-) (a b : t) : t = of_int (Int.(-) (to_int a) (to_int b))

  function ( * ) (a b : t) : t = of_int (Int.( * ) (to_int a) (to_int b))

  function (/) (a b : t) : t = of_int (div (to_int a) (to_int b))

  function (%) (a b : t) : t = of_int (mod (to_int a) (to_int b))
  *)

  axiom Extensionality1: forall x y : t [to_int x, to_int y]. to_int x = to_int y -> x = y

  lemma Extensionality2:
    forall x y : int [of_int x, of_int y].
      of_int x = of_int y ->
        in_bounds x /\ in_bounds y ->
          x = y

  predicate (<=) (a b : t) = Int.(<=) (to_int a) (to_int b)

  predicate (<) (a b : t) = Int.(<) (to_int a) (to_int b)

  predicate (>=) (a b : t) = Int.(>=) (to_int a) (to_int b)

  predicate (>) (a b : t) = Int.(>) (to_int a) (to_int b)

  meta "inline : no" predicate (<=)
  meta "inline : no" predicate (<)
  meta "inline : no" predicate (>=)
  meta "inline : no" predicate (>)
end

module Generic_enum
  clone export Enum_intf

  use import int.Int

  val to_int (a : t) : int
    ensures { result = to_int a }

  val any_ unit : t

  val (<=) (a b : t) : bool
    ensures  { result = (to_int a <= to_int b) }

  val (<) (a b : t) : bool
    ensures  { result = (to_int a < to_int b) }

  val (>=) (a b : t) : bool
    ensures  { result = (to_int a >= to_int b) }

  val (>) (a b : t) : bool
    ensures  { result = (to_int a > to_int b) }
end

module Safe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    requires { "expl:integer overflow" in_bounds n }
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a + to_int b) }
    ensures   { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a - to_int b) }
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a * to_int b) }
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    requires { "expl:integer overflow" in_bounds (- to_int a) }
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (div (to_int a) (to_int b)) }
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (mod (to_int a) (to_int b)) }
    ensures  { to_int result = mod (to_int a) (to_int b) }
end

module Unsafe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    ensures  { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    ensures  { to_int result = mod (to_int a) (to_int b) }
end

theory Powers_of_2
  function power2 int : int

  axiom Powers_of_2:
    power2 0 = 1 /\
    power2 1 = 2 /\
    power2 2 = 4 /\
    power2 3 = 8 /\
    power2 4 = 16 /\
    power2 5 = 32 /\
    power2 6 = 64 /\
    power2 7 = 128 /\

    power2 8 = 256 /\
    power2 9 = 512 /\
    power2 10 = 1024 /\
    power2 11 = 2048 /\
    power2 12 = 4096 /\
    power2 13 = 8192 /\
    power2 14 = 16384 /\
    power2 15 = 32768 /\

    power2 16 = 65536 /\
    power2 17 = 131072 /\
    power2 18 = 262144 /\
    power2 19 = 524288 /\
    power2 20 = 1048576 /\
    power2 21 = 2097152 /\
    power2 22 = 4194304 /\
    power2 23 = 8388608 /\

    power2 24 = 16777216 /\
    power2 25 = 33554432 /\
    power2 26 = 67108864 /\
    power2 27 = 134217728 /\
    power2 28 = 268435456 /\
    power2 29 = 536870912 /\
    power2 30 = 1073741824 /\
    power2 31 = 2147483648 /\

    power2 32 = 4294967296 /\
    power2 33 = 8589934592 /\
    power2 34 = 17179869184 /\
    power2 35 = 34359738368 /\
    power2 36 = 68719476736 /\
    power2 37 = 137438953472 /\
    power2 38 = 274877906944 /\
    power2 39 = 549755813888 /\

    power2 40 = 1099511627776 /\
    power2 41 = 2199023255552 /\
    power2 42 = 4398046511104 /\
    power2 43 = 8796093022208 /\
    power2 44 = 17592186044416 /\
    power2 45 = 35184372088832 /\
    power2 46 = 70368744177664 /\
    power2 47 = 140737488355328 /\

    power2 48 = 281474976710656 /\
    power2 49 = 562949953421312 /\
    power2 50 = 1125899906842624 /\
    power2 51 = 2251799813685248 /\
    power2 52 = 4503599627370496 /\
    power2 53 = 9007199254740992 /\
    power2 54 = 18014398509481984 /\
    power2 55 = 36028797018963968 /\

    power2 56 = 72057594037927936 /\
    power2 57 = 144115188075855872 /\
    power2 58 = 288230376151711744 /\
    power2 59 = 576460752303423488 /\
    power2 60 = 1152921504606846976 /\
    power2 61 = 2305843009213693952 /\
    power2 62 = 4611686018427387904 /\
    power2 63 = 9223372036854775808 /\

    power2 64 = 18446744073709551616
end

theory Bit_enum_intf
  namespace import E
    clone export Enum_intf

    constant min : int
    constant max : int

    function of_int int : t

    predicate (<) t t
    predicate (<=) t t
    predicate (>) t t
    predicate (>=) t t
  end

  constant size : int

  predicate signed

  function normalize (x : int) : int

  function of_int_modulo int : t
  function of_int_const (n : int) : E.t

  function (+%) t t : t
  function (-%) t t : t
  function (-%_) t : t
  function ( *%) t t : t
  function (/%) t t : t
  function (%%) t t : t

  type tt
  function extend t : tt
  predicate is_safe tt
  function (+%~) tt tt : tt
  function (-%~) tt tt : tt
  function (-%~_) tt : tt
  function ( *%~) tt tt : tt
  function (/%~) tt tt : tt
  function (%%~) tt tt : tt

  function (&) t t : t
  function (|^) t t : t
  function (~_) t : t
  function (^) t t : t
  function lsl t t : t
  function lsl_modulo t t : t
  function lsr t t : t
  function asr t t : t

  function lsl_modulo_ tt tt : tt

  predicate lt t t
  predicate le t t
  predicate gt t t
  predicate ge t t
end

theory Bit_enum_intf2
  clone export Enum_intf

  constant min : int
  constant max : int

  function of_int int : t

  predicate (<) t t
  predicate (<=) t t
  predicate (>) t t
  predicate (>=) t t

  clone export Bit_enum_intf with
    namespace E = .
end

theory Bit_enum
  use import int.Int

  namespace E
    constant max : int
    constant min : int
  end

  constant range : int = E.max - E.min + 1

  use int.EuclideanDivision as ED

  function normalize (x : int) : int = E.min + (ED.mod (x - E.min) range)

  clone export Bit_enum_intf with
    constant E.max = E.max,
    constant E.min = E.min,
    function normalize = normalize

  axiom Of_int_modulo:
    forall n : int [of_int_modulo n].
      E.to_int (of_int_modulo n) = normalize n

  axiom Add_modulo:
    forall a, b : E.t [a +% b].
      E.to_int (a +% b) = normalize (Int.(+) (E.to_int a) (E.to_int b))

  axiom Neg_modulo:
    forall a : E.t [-% a].
      E.to_int (-% a) = normalize (Int.(-_) (E.to_int a))

  axiom Sub_modulo:
    forall a, b : E.t [a -% b].
      E.to_int (a -% b) = normalize (Int.(-) (E.to_int a) (E.to_int b))

  axiom Mult_modulo:
    forall a, b : E.t [a *% b].
      E.to_int (a *% b) = normalize (Int.( *) (E.to_int a) (E.to_int b))

  use int.ComputerDivision as CD

  axiom Div_modulo:
    forall a, b : E.t [a /% b].
      E.to_int (a /% b) = normalize (CD.div (E.to_int a) (E.to_int b))

  axiom Mod_modulo:
    forall a, b : E.t [a %% b].
      E.to_int (a %% b) = CD.mod (E.to_int a) (E.to_int b)

  use import Powers_of_2

  axiom Size_pos:
    Int.(>) size 0

  axiom Val_two_power_size:
    power2 size = range

  axiom Of_int_const:
    forall n : int [of_int_const n].
      of_int_const n = E.of_int n

  axiom Of_int_def:
    forall n : int [E.of_int n].
      E.in_bounds n -> E.of_int n = of_int_modulo n

  axiom Lt_eq:
    forall a b : E.t [E.(<) a b | lt a b].
      E.(<) a b = lt a b

  axiom Le_eq:
    forall a b : E.t [E.(<=) a b | le a b].
      E.(<=) a b = le a b

  axiom Gt_eq:
    forall a b : E.t [E.(>) a b | gt a b].
      E.(>) a b = gt a b

  axiom Ge_eq:
    forall a b : E.t [E.(>=) a b | ge a b].
      E.(>=) a b = ge a b

  (* The following axioms are to be removed by the drivers of solvers with native bitvector support *)

  (* ATTENTION! *Not* to be used in actual specs, it's going to be encoded with `(_ extract ...)' (in the driver),
     which only works for constant bit indices! *)

  predicate nth E.t int

  axiom Nth:
    forall a : E.t.
      forall n : int [nth a n].
        0 <= n < size ->
          nth a n =
            (E.to_int a >= 0 /\ CD.mod (E.to_int a) (power2 (n + 1)) >= power2 n \/
             E.to_int a < 0 /\ CD.mod (range + E.to_int a) (power2 (n + 1)) >= power2 n)

  axiom Nth_bw_and:
    forall a b : E.t [a & b].
      forall n : int [nth (a & b) n].
        0 <= n < size ->
          nth (a & b) n = (nth a n /\ nth b n)

  axiom Nth_bw_or:
    forall a b : E.t [a |^ b].
      forall n : int [nth (a |^ b) n].
        0 <= n < size ->
          nth (a |^ b) n = (nth a n \/ nth b n)

  axiom Nth_bw_xor:
    forall a b : E.t [a ^ b].
      forall n : int [nth (a ^ b) n].
        0 <= n < size ->
          nth (a ^ b) n = (nth a n <> nth b n)

  axiom Nth_bw_not:
    forall a : E.t [~ a].
      forall n : int [nth (~ a) n].
        0 <= n < size ->
          nth (~ a) n = not (nth a n)

  axiom Lsr_nth_low:
    forall b : E.t.
      forall s : E.t [lsr b s].
        forall n : int [nth (lsr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s < size ->
                nth (lsr b s) n = nth b (n + E.to_int s)

  axiom Lsr_nth_high:
    forall b : E.t.
      forall s : E.t [lsr b s].
        forall n : int [nth (lsr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s >= size ->
                not (nth (lsr b s) n)

  axiom Asr_nth_low:
    forall b : E.t.
      forall s : E.t [asr b s].
        forall n : int [nth (asr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              0 <= n + E.to_int s < size ->
                nth (asr b s) n = nth b (n + E.to_int s)

  axiom Asr_nth_high:
    forall b : E.t.
      forall s : E.t [asr b s].
        forall n : int [nth (asr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s >= size ->
                nth (asr b s) n = nth b (size - 1)

  axiom Lsl_modulo_nth_high:
    forall b : E.t.
      forall s : E.t [lsl_modulo b s].
        forall n : int [nth (lsl_modulo b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              0 <= n - E.to_int s < size ->
                nth (lsl_modulo b s) n = nth b (n - E.to_int s)

  axiom Lsl_modulo_nth_low:
    forall b : E.t.
      forall s : E.t [lsl_modulo b s].
        forall n : int [nth (lsl_modulo b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n - E.to_int s < 0 ->
                not (nth (lsl_modulo b s) n)

  (* End of dummy axioms, the following ones are really essential *)

  axiom Lsl:
    forall b : E.t.
      forall s : E.t [lsl b s].
        0 <= E.to_int s < size ->
          lsr (lsl_modulo b s) s = s ->
            lsl b s = lsl_modulo b s

  axiom Lsr_unsigned:
    not signed ->
      forall a : E.t.
        forall n : E.t [lsr a n].
          0 <= E.to_int n < size ->
            E.to_int (lsr a n) = ED.div (E.to_int a) (power2 (E.to_int n))

  (* lsr is not used for signed types in C *)

  axiom Asr_signed:
    signed ->
      forall a : E.t.
        forall n : E.t [lsr a n].
          0 <= E.to_int n < size ->
            E.to_int (asr a n) = ED.div (E.to_int a) (power2 (E.to_int n))

  axiom Lsl_modulo:
    forall a : E.t.
      forall n : E.t [lsl_modulo a n].
         0 <= E.to_int n < size ->
           E.to_int (lsl_modulo a n) = normalize (Int.( *) (E.to_int a) (power2 (E.to_int n)))
end

module Generic_bit_enum
  clone export Bit_enum_intf2

  val (&) (x y : t) : t
    ensures { result = x & y }

  val (|^) (x y : t) : t
    ensures { result = x |^ y }

  val (~_) (x : t) : t
    ensures { result = ~ x }

  val (^) (x y : t) : t
    ensures { result = x ^ y }

  use int.Int

  val of_int_modulo (n : int) : t
    ensures { result = of_int_modulo n }
    ensures { to_int result = normalize n }

  val of_int_const (n : int) : t
    ensures { result = of_int_const n }
    ensures { to_int result = n }

  val to_int (a : t) : int
    ensures { result = to_int a }

  val any_ unit : t

  val (+%) (a b : t) : t
    ensures { result = a +% b }
    ensures { to_int result = normalize (Int.(+) (to_int a) (to_int b)) }

  val (-%) (a b : t) : t
    ensures { result = a -% b }
    ensures { to_int result = normalize (Int.(-) (to_int a) (to_int b)) }

  val ( *%) (a b : t) : t
    ensures { result = a *% b }
    ensures { to_int result = normalize (Int.( *) (to_int a) (to_int b)) }

  val (-%_) (a : t) : t
    ensures { result = -% a }
    ensures { to_int result = normalize (Int.(-_) (to_int a)) }

  val (<=) (a b : t) : bool
    ensures  { result = le a b }
    ensures  { result = Int.(<=) (to_int a) (to_int b) }

  val (<) (a b : t) : bool
    ensures  { result = lt a b }
    ensures  { result = Int.(<) (to_int a) (to_int b) }

  val (>=) (a b : t) : bool
    ensures  { result = ge a b }
    ensures  { result = Int.(>=) (to_int a) (to_int b) }

  val (>) (a b : t) : bool
    ensures  { result = gt a b}
    ensures  { result = Int.(>) (to_int a) (to_int b) }
end

module Safe_bit_enum
  clone export Bit_enum_intf2

  use import Powers_of_2
  use int.Int

  val lsl (x y : t) : t
    requires { "expl:<< second operand"
               Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size \/
               le (of_int_const 0) y && lt y (of_int_const size) }
    requires { "expl:integer overflow"
               in_bounds (Int.( *) (to_int x) (power2 (to_int y))) \/
               is_safe (lsl_modulo_ (extend x) (extend y)) }
    ensures { result = lsl_modulo x y }
    ensures { to_int result = Int.( *) (to_int x) (power2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    requires { "expl:<< second operand"
               Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size \/
               le (of_int_const 0) y && lt y (of_int_const size) }
    ensures { result = lsl_modulo x y }
    ensures { to_int result = normalize (Int.( *) (to_int x) (power2 (to_int y))) }

  use int.EuclideanDivision as ED

  val lsr (x y : t) : t
    requires { "expl:>> second operand"
               Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size \/
               le (of_int_const 0) y && lt y (of_int_const size) }
    ensures { result = lsr x y }
    ensures { Int.(>=) (to_int x) 0 -> to_int result = ED.div (to_int x) (power2 (to_int y)) }

  val asr (x y : t) : t
    requires { "expl:>> second operand"
                Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size \/
                le (of_int_const 0) y && lt y (of_int_const size) }
    ensures { result = asr x y }
    ensures { to_int result = ED.div (to_int x) (power2 (to_int y)) }

  val of_int (n : int) : t
    requires { "expl:integer overflow" in_bounds n }
    ensures  { result = of_int_modulo n }
    ensures  { to_int result = n }
    ensures  { result = of_int n }

  val (+) (a b : t) : t
    requires { "expl:integer overflow"
               in_bounds (Int.(+) (to_int a) (to_int b)) \/
               is_safe (extend a +%~ extend b) }
    ensures  { to_int result = Int.(+) (to_int a) (to_int b) }
    ensures  { result = a +% b }

  val (-) (a b : t) : t
    requires { "expl:integer overflow"
               in_bounds (Int.(-) (to_int a) (to_int b)) \/
               is_safe (extend a -%~ extend b) }
    ensures  { to_int result = Int.(-) (to_int a) (to_int b) }
    ensures  { result = a -% b }

  val ( *) (a b : t) : t
    requires { "expl:integer overflow"
               in_bounds (Int.(*) (to_int a) (to_int b)) \/
               is_safe (extend a *%~ extend b) }
    ensures  { to_int result = Int.(*) (to_int a) (to_int b) }
    ensures  { result = a *% b }

  val (-_) (a : t) : t
    requires { "expl:integer overflow"
               in_bounds (Int.(-_) (to_int a)) \/
               is_safe ((-%~_) (extend a)) }
    ensures  { to_int result = Int.(-_) (to_int a) }
    ensures  { result = -% a }

  use int.ComputerDivision as CD

  val (/) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 \/ b <> of_int_const 0 }
    requires { "expl:integer overflow"
               in_bounds (CD.div (to_int a) (to_int b)) \/
               is_safe (extend a /%~ extend b) }
    ensures  { to_int result = CD.div (to_int a) (to_int b) }
    ensures  { result = a /% b }

  val (%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 \/ b <> of_int_const 0 }
    requires { "expl:integer overflow"
               in_bounds (CD.mod (to_int a) (to_int b)) \/
               is_safe (extend a %%~ extend b) }
    ensures  { to_int result = CD.mod (to_int a) (to_int b) }
    ensures  { result = a %% b }

  val (/%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 \/ b <> of_int_const 0 }
    ensures  { to_int result = normalize (CD.div (to_int a) (to_int b)) }
    ensures  { result = a /% b }

  val (%%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 \/ b <> of_int_const 0 }
    ensures  { to_int result = normalize (CD.mod (to_int a) (to_int b)) }
    ensures  { result = a %% b }
end

module Unsafe_bit_enum
  clone export Bit_enum_intf2

  use int.Int
  use import Powers_of_2

  val lsl (x y : t) : t
    ensures { result = lsl_modulo x y }
    ensures { to_int result = Int.( *) (to_int x) (power2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    ensures { result = lsl_modulo x y }
    ensures { to_int result = normalize (Int.( *) (to_int x) (power2 (to_int y))) }

  use int.EuclideanDivision as ED

  val lsr (x y : t) : t
    ensures { result = lsr x y }
    ensures { Int.(>=) (to_int x) 0 -> to_int result = ED.div (to_int x) (power2 (to_int y)) }

  val asr (x y : t) : t
    ensures { result = asr x y }
    ensures { to_int result = ED.div (to_int x) (power2 (to_int y)) }

  val of_int (n : int) : t
    ensures  { result = of_int_modulo n }
    ensures  { to_int result = n }
    ensures  { result = of_int n }

  val (+) (a b : t) : t
    ensures   { to_int result = Int.(+) (to_int a) (to_int b) }
    ensures   { result = a +% b }

  val (-) (a b : t) : t
    ensures  { to_int result = Int.(-) (to_int a) (to_int b) }
    ensures  { result = a -% b }

  val ( *) (a b : t) : t
    ensures  { to_int result = Int.( *) (to_int a) (to_int b) }
    ensures  { result = a *% b }

  val (-_) (a : t) : t
    ensures  { to_int result = Int.(-_) (to_int a) }
    ensures  { result = -% a }

  use int.ComputerDivision as CD

  val (/) (a b : t) : t
    ensures  { to_int result = CD.div (to_int a) (to_int b) }
    ensures  { result = a /% b }

  val (%) (a b : t) : t
    ensures  { to_int result = CD.mod (to_int a) (to_int b) }
    ensures  { result = a %% b }

  val (/%) (a b : t) : t
    ensures  { to_int result = normalize (CD.div (to_int a) (to_int b)) }
    ensures  { result = a /% b }

  val (%%) (a b : t) : t
    ensures  { to_int result = normalize (CD.mod (to_int a) (to_int b)) }
    ensures  { result = a %% b }
end

theory Int8
  use import int.Int
  constant min : int = -128
  constant max : int = 127

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint8
  use import int.Int
  constant min : int = 0
  constant max : int = 255

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int16
  use import int.Int
  constant min : int = -32768
  constant max : int = 32767

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint16
  use import int.Int
  constant min : int = 0
  constant max : int = 65535

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int32
  use import int.Int
  constant min : int = -2147483648
  constant max : int = 2147483647

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint32
  use import int.Int
  constant min : int = 0
  constant max : int = 4294967295

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int64
  use import int.Int
  constant min : int = -9223372036854775808
  constant max : int = 9223372036854775807

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint64
  use import int.Int
  constant min : int = 0
  constant max : int = 18446744073709551615

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Bit_int8
  use export Int8

  constant size : int = 8
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
                 (if nth a 7 then Int.(-_) 128 else 0))))))))
end

theory Bit_uint8
  use export Uint8

  constant size : int = 8
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
                 (if nth a 7 then 128 else 0))))))))
end

theory Bit_int16
  use export Int16

  constant size : int = 16
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
        (Int.(+) (if nth a 7 then 128 else 0)
        (Int.(+) (if nth a 8 then 256 else 0)
        (Int.(+) (if nth a 9 then 512 else 0)
        (Int.(+) (if nth a 10 then 1024 else 0)
        (Int.(+) (if nth a 11 then 2048 else 0)
        (Int.(+) (if nth a 12 then 4096 else 0)
        (Int.(+) (if nth a 13 then 8192 else 0)
        (Int.(+) (if nth a 14 then 16384 else 0)
                 (if nth a 15 then Int.(-_) 32768 else 0))))))))))))))))
end

theory Bit_uint16
  use export Uint16

  constant size : int = 16
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
        (Int.(+) (if nth a 7 then 128 else 0)
        (Int.(+) (if nth a 8 then 256 else 0)
        (Int.(+) (if nth a 9 then 512 else 0)
        (Int.(+) (if nth a 10 then 1024 else 0)
        (Int.(+) (if nth a 11 then 2048 else 0)
        (Int.(+) (if nth a 12 then 4096 else 0)
        (Int.(+) (if nth a 13 then 8192 else 0)
        (Int.(+) (if nth a 14 then 16384 else 0)
                 (if nth a 15 then 32768 else 0))))))))))))))))
end

theory Bit_int32
  use export Int32

  constant size : int = 32
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
        (Int.(+) (if nth a 7 then 128 else 0)
        (Int.(+) (if nth a 8 then 256 else 0)
        (Int.(+) (if nth a 9 then 512 else 0)
        (Int.(+) (if nth a 10 then 1024 else 0)
        (Int.(+) (if nth a 11 then 2048 else 0)
        (Int.(+) (if nth a 12 then 4096 else 0)
        (Int.(+) (if nth a 13 then 8192 else 0)
        (Int.(+) (if nth a 14 then 16384 else 0)
        (Int.(+) (if nth a 15 then 32768 else 0)
        (Int.(+) (if nth a 16 then 65536 else 0)
        (Int.(+) (if nth a 17 then 131072 else 0)
        (Int.(+) (if nth a 18 then 262144 else 0)
        (Int.(+) (if nth a 19 then 524288 else 0)
        (Int.(+) (if nth a 20 then 1048576 else 0)
        (Int.(+) (if nth a 21 then 2097152 else 0)
        (Int.(+) (if nth a 22 then 4194304 else 0)
        (Int.(+) (if nth a 23 then 8388608 else 0)
        (Int.(+) (if nth a 24 then 16777216 else 0)
        (Int.(+) (if nth a 25 then 33554432 else 0)
        (Int.(+) (if nth a 26 then 67108864 else 0)
        (Int.(+) (if nth a 27 then 134217728 else 0)
        (Int.(+) (if nth a 28 then 268435456 else 0)
        (Int.(+) (if nth a 29 then 536870912 else 0)
        (Int.(+) (if nth a 30 then 1073741824 else 0)
                 (if nth a 31 then Int.(-_) 2147483648 else 0))))))))))))))))))))))))))))))))
end

theory Bit_uint32
  use export Uint32

  constant size : int = 32
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size

  axiom To_int_def:
    forall a : t [to_int a].
      to_int a =
        (Int.(+) (if nth a 0 then 1 else 0)
        (Int.(+) (if nth a 1 then 2 else 0)
        (Int.(+) (if nth a 2 then 4 else 0)
        (Int.(+) (if nth a 3 then 8 else 0)
        (Int.(+) (if nth a 4 then 16 else 0)
        (Int.(+) (if nth a 5 then 32 else 0)
        (Int.(+) (if nth a 6 then 64 else 0)
        (Int.(+) (if nth a 7 then 128 else 0)
        (Int.(+) (if nth a 8 then 256 else 0)
        (Int.(+) (if nth a 9 then 512 else 0)
        (Int.(+) (if nth a 10 then 1024 else 0)
        (Int.(+) (if nth a 11 then 2048 else 0)
        (Int.(+) (if nth a 12 then 4096 else 0)
        (Int.(+) (if nth a 13 then 8192 else 0)
        (Int.(+) (if nth a 14 then 16384 else 0)
        (Int.(+) (if nth a 15 then 32768 else 0)
        (Int.(+) (if nth a 16 then 65536 else 0)
        (Int.(+) (if nth a 17 then 131072 else 0)
        (Int.(+) (if nth a 18 then 262144 else 0)
        (Int.(+) (if nth a 19 then 524288 else 0)
        (Int.(+) (if nth a 20 then 1048576 else 0)
        (Int.(+) (if nth a 21 then 2097152 else 0)
        (Int.(+) (if nth a 22 then 4194304 else 0)
        (Int.(+) (if nth a 23 then 8388608 else 0)
        (Int.(+) (if nth a 24 then 16777216 else 0)
        (Int.(+) (if nth a 25 then 33554432 else 0)
        (Int.(+) (if nth a 26 then 67108864 else 0)
        (Int.(+) (if nth a 27 then 134217728 else 0)
        (Int.(+) (if nth a 28 then 268435456 else 0)
        (Int.(+) (if nth a 29 then 536870912 else 0)
        (Int.(+) (if nth a 30 then 1073741824 else 0)
                 (if nth a 31 then 2147483648 else 0))))))))))))))))))))))))))))))))
end

theory Bit_int64
  use export Int64

  constant size : int = 64
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint64
  use export Uint64

  constant size : int = 64
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint8_of_bit_int8
  use Bit_int8
  use Bit_uint8
  function cast_modulo (a : Bit_int8.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_uint8 Bit_int8.t Bit_uint8.t
end

theory Bit_int16_of_bit_int8
  use Bit_int8
  use Bit_int16
  function cast_modulo (a : Bit_int8.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_int16 Bit_int16.t Bit_int8.t Bit_int8.t
end

theory Bit_uint16_of_bit_int8
  use Bit_int8
  use Bit_uint16
  function cast_modulo (a : Bit_int8.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_uint16 Bit_uint16.t Bit_int8.t Bit_int8.t
end

theory Bit_int32_of_bit_int8
  use Bit_int8
  use Bit_int32
  function cast_modulo (a : Bit_int8.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_int32 Bit_int32.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint32_of_bit_int8
  use Bit_int8
  use Bit_uint32
  function cast_modulo (a : Bit_int8.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_uint32 Bit_uint32.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_int64_of_bit_int8
  use Bit_int8
  use Bit_int64
  function cast_modulo (a : Bit_int8.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_int64 Bit_int64.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint64_of_bit_int8
  use Bit_int8
  use Bit_uint64
  function cast_modulo (a : Bit_int8.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_int8.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_int8.to_int a))
  predicate is_safe Bit_int8.t
  predicate bit_int8_as_bit_uint64 Bit_uint64.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_int8_of_bit_uint8
  use Bit_uint8
  use Bit_int8
  function cast_modulo (a : Bit_uint8.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_int8 Bit_int8.t Bit_uint8.t
end

theory Bit_int16_of_bit_uint8
  use Bit_uint8
  use Bit_int16
  function cast_modulo (a : Bit_uint8.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_int16 Bit_int16.t Bit_uint8.t Bit_uint8.t
end

theory Bit_uint16_of_bit_uint8
  use Bit_uint8
  use Bit_uint16
  function cast_modulo (a : Bit_uint8.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_uint16 Bit_uint16.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int32_of_bit_uint8
  use Bit_uint8
  use Bit_int32
  function cast_modulo (a : Bit_uint8.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_int32 Bit_int32.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_uint32_of_bit_uint8
  use Bit_uint8
  use Bit_uint32
  function cast_modulo (a : Bit_uint8.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_uint32 Bit_uint32.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int64_of_bit_uint8
  use Bit_uint8
  use Bit_int64
  function cast_modulo (a : Bit_uint8.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_int64 Bit_int64.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_uint64_of_bit_uint8
  use Bit_uint8
  use Bit_uint64
  function cast_modulo (a : Bit_uint8.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_uint8.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_uint8.to_int a))
  predicate is_safe Bit_uint8.t
  predicate bit_uint8_as_bit_uint64 Bit_uint64.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int8_of_bit_int16
  use Bit_int16
  use Bit_int8
  function cast_modulo (a : Bit_int16.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_int8 Bit_int16.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_int16
  use Bit_int16
  use Bit_uint8
  function cast_modulo (a : Bit_int16.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_uint8 Bit_int16.t Bit_uint8.t Bit_uint8.t
end

theory Bit_uint16_of_bit_int16
  use Bit_int16
  use Bit_uint16
  function cast_modulo (a : Bit_int16.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_uint16 Bit_int16.t Bit_uint16.t
end

theory Bit_int32_of_bit_int16
  use Bit_int16
  use Bit_int32
  function cast_modulo (a : Bit_int16.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_int32 Bit_int32.t Bit_int16.t Bit_int16.t
end

theory Bit_uint32_of_bit_int16
  use Bit_int16
  use Bit_uint32
  function cast_modulo (a : Bit_int16.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_uint32 Bit_uint32.t Bit_int16.t Bit_int16.t
end

theory Bit_int64_of_bit_int16
  use Bit_int16
  use Bit_int64
  function cast_modulo (a : Bit_int16.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_int64 Bit_int64.t Bit_int16.t Bit_int16.t Bit_int16.t Bit_int16.t
end

theory Bit_uint64_of_bit_int16
  use Bit_int16
  use Bit_uint64
  function cast_modulo (a : Bit_int16.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_int16.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_int16.to_int a))
  predicate is_safe Bit_int16.t
  predicate bit_int16_as_bit_uint64 Bit_uint64.t Bit_int16.t Bit_int16.t Bit_int16.t Bit_int16.t
end

theory Bit_int8_of_bit_uint16
  use Bit_uint16
  use Bit_int8
  function cast_modulo (a : Bit_uint16.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_int8 Bit_uint16.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_uint16
  use Bit_uint16
  use Bit_uint8
  function cast_modulo (a : Bit_uint16.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_uint8 Bit_uint16.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int16_of_bit_uint16
  use Bit_uint16
  use Bit_int16
  function cast_modulo (a : Bit_uint16.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_int16 Bit_int16.t Bit_uint16.t
end

theory Bit_int32_of_bit_uint16
  use Bit_uint16
  use Bit_int32
  function cast_modulo (a : Bit_uint16.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_int32 Bit_int32.t Bit_uint16.t Bit_uint16.t
end

theory Bit_uint32_of_bit_uint16
  use Bit_uint16
  use Bit_uint32
  function cast_modulo (a : Bit_uint16.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_uint32 Bit_uint32.t Bit_uint16.t Bit_uint16.t
end

theory Bit_int64_of_bit_uint16
  use Bit_uint16
  use Bit_int64
  function cast_modulo (a : Bit_uint16.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_int64 Bit_int64.t Bit_uint16.t Bit_uint16.t Bit_uint16.t Bit_uint16.t
end

theory Bit_uint64_of_bit_uint16
  use Bit_uint16
  use Bit_uint64
  function cast_modulo (a : Bit_uint16.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_uint16.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_uint16.to_int a))
  predicate is_safe Bit_uint16.t
  predicate bit_uint16_as_bit_uint64 Bit_uint64.t Bit_uint16.t Bit_uint16.t Bit_uint16.t Bit_uint16.t
end

theory Bit_int8_of_bit_int32
  use Bit_int32
  use Bit_int8
  function cast_modulo (a : Bit_int32.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_int8 Bit_int32.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_int32
  use Bit_int32
  use Bit_uint8
  function cast_modulo (a : Bit_int32.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_uint8 Bit_int32.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int16_of_bit_int32
  use Bit_int32
  use Bit_int16
  function cast_modulo (a : Bit_int32.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_int16 Bit_int32.t Bit_int16.t Bit_int16.t
end

theory Bit_uint16_of_bit_int32
  use Bit_int32
  use Bit_uint16
  function cast_modulo (a : Bit_int32.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_uint16 Bit_int32.t Bit_uint16.t Bit_uint16.t
end

theory Bit_uint32_of_bit_int32
  use Bit_int32
  use Bit_uint32
  function cast_modulo (a : Bit_int32.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_uint32 Bit_int32.t Bit_uint32.t
end

theory Bit_int64_of_bit_int32
  use Bit_int32
  use Bit_int64
  function cast_modulo (a : Bit_int32.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_int64 Bit_int64.t Bit_int32.t Bit_int32.t
end

theory Bit_uint64_of_bit_int32
  use Bit_int32
  use Bit_uint64
  function cast_modulo (a : Bit_int32.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_int32.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_int32.to_int a))
  predicate is_safe Bit_int32.t
  predicate bit_int32_as_bit_uint64 Bit_uint64.t Bit_int32.t Bit_int32.t
end

theory Bit_int8_of_bit_uint32
  use Bit_uint32
  use Bit_int8
  function cast_modulo (a : Bit_uint32.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_int8 Bit_uint32.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_uint32
  use Bit_uint32
  use Bit_uint8
  function cast_modulo (a : Bit_uint32.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_uint8 Bit_uint32.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int16_of_bit_uint32
  use Bit_uint32
  use Bit_int16
  function cast_modulo (a : Bit_uint32.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_int16 Bit_uint32.t Bit_int16.t Bit_int16.t
end

theory Bit_uint16_of_bit_uint32
  use Bit_uint32
  use Bit_uint16
  function cast_modulo (a : Bit_uint32.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_uint16 Bit_uint32.t Bit_uint16.t Bit_uint16.t
end

theory Bit_int32_of_bit_uint32
  use Bit_uint32
  use Bit_int32
  function cast_modulo (a : Bit_uint32.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_int32 Bit_int32.t Bit_uint32.t
end

theory Bit_int64_of_bit_uint32
  use Bit_uint32
  use Bit_int64
  function cast_modulo (a : Bit_uint32.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_int64 Bit_int64.t Bit_uint32.t Bit_uint32.t
end

theory Bit_uint64_of_bit_uint32
  use Bit_uint32
  use Bit_uint64
  function cast_modulo (a : Bit_uint32.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_uint32.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_uint32.to_int a))
  predicate is_safe Bit_uint32.t
  predicate bit_uint32_as_bit_uint64 Bit_uint64.t Bit_uint32.t Bit_uint32.t
end

theory Bit_int8_of_bit_int64
  use Bit_int64
  use Bit_int8
  function cast_modulo (a : Bit_int64.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_int8 Bit_int64.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_int64
  use Bit_int64
  use Bit_uint8
  function cast_modulo (a : Bit_int64.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_uint8 Bit_int64.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int16_of_bit_int64
  use Bit_int64
  use Bit_int16
  function cast_modulo (a : Bit_int64.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_int16 Bit_int64.t Bit_int16.t Bit_int16.t Bit_int16.t Bit_int16.t
end

theory Bit_uint16_of_bit_int64
  use Bit_int64
  use Bit_uint16
  function cast_modulo (a : Bit_int64.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_uint16 Bit_int64.t Bit_uint16.t Bit_uint16.t Bit_uint16.t Bit_uint16.t
end

theory Bit_int32_of_bit_int64
  use Bit_int64
  use Bit_int32
  function cast_modulo (a : Bit_int64.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_int32 Bit_int64.t Bit_int32.t Bit_int32.t
end

theory Bit_uint32_of_bit_int64
  use Bit_int64
  use Bit_uint32
  function cast_modulo (a : Bit_int64.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_uint32 Bit_int64.t Bit_uint32.t Bit_uint32.t
end

theory Bit_uint64_of_bit_int64
  use Bit_int64
  use Bit_uint64
  function cast_modulo (a : Bit_int64.t) : Bit_uint64.t
  axiom Cast_modulo:
    forall a : Bit_int64.t.
      cast_modulo a = Bit_uint64.of_int (Bit_uint64.normalize (Bit_int64.to_int a))
  predicate is_safe Bit_int64.t
  predicate bit_int64_as_bit_uint64 Bit_int64.t Bit_uint64.t
end

theory Bit_int8_of_bit_uint64
  use Bit_uint64
  use Bit_int8
  function cast_modulo (a : Bit_uint64.t) : Bit_int8.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_int8.of_int (Bit_int8.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_int8 Bit_uint64.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t Bit_int8.t
end

theory Bit_uint8_of_bit_uint64
  use Bit_uint64
  use Bit_uint8
  function cast_modulo (a : Bit_uint64.t) : Bit_uint8.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_uint8.of_int (Bit_uint8.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_uint8 Bit_uint64.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t Bit_uint8.t
end

theory Bit_int16_of_bit_uint64
  use Bit_uint64
  use Bit_int16
  function cast_modulo (a : Bit_uint64.t) : Bit_int16.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_int16.of_int (Bit_int16.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_int16 Bit_uint64.t Bit_int16.t Bit_int16.t Bit_int16.t Bit_int16.t
end

theory Bit_uint16_of_bit_uint64
  use Bit_uint64
  use Bit_uint16
  function cast_modulo (a : Bit_uint64.t) : Bit_uint16.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_uint16.of_int (Bit_uint16.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_uint16 Bit_uint64.t Bit_uint16.t Bit_uint16.t Bit_uint16.t Bit_uint16.t
end

theory Bit_int32_of_bit_uint64
  use Bit_uint64
  use Bit_int32
  function cast_modulo (a : Bit_uint64.t) : Bit_int32.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_int32.of_int (Bit_int32.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_int32 Bit_uint64.t Bit_int32.t Bit_int32.t
end

theory Bit_uint32_of_bit_uint64
  use Bit_uint64
  use Bit_uint32
  function cast_modulo (a : Bit_uint64.t) : Bit_uint32.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_uint32.of_int (Bit_uint32.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_uint32 Bit_uint64.t Bit_uint32.t Bit_uint32.t
end

theory Bit_int64_of_bit_uint64
  use Bit_uint64
  use Bit_int64
  function cast_modulo (a : Bit_uint64.t) : Bit_int64.t
  axiom Cast_modulo:
    forall a : Bit_uint64.t.
      cast_modulo a = Bit_int64.of_int (Bit_int64.normalize (Bit_uint64.to_int a))
  predicate is_safe Bit_uint64.t
  predicate bit_uint64_as_bit_int64 Bit_int64.t Bit_uint64.t
end