theory Enum_intf
  type t

  function to_int t : int

  predicate in_bounds int

  function normalize int : int
end

theory Enum
  constant min : int
  constant max : int

  use import int.Int

  constant range : int = max - min + 1

  use int.EuclideanDivision

  function normalize (x : int) : int = min + (EuclideanDivision.mod (x - min) range)

  use import int.ComputerDivision

  predicate in_bounds (n : int) = min <= n <= max

  clone export Enum_intf with
    function normalize = normalize,
    predicate in_bounds = in_bounds

  axiom To_int:
    forall x : t [to_int x]. min <= to_int x <= max

  axiom To_int_in_bounds: forall n : t [to_int n]. in_bounds (to_int n)

  function of_int int : t

  function of_int_modulo (n : int) : t = of_int (normalize n)

  axiom Of_int:
    forall x : int [of_int x]. min <= x <= max -> to_int (of_int x) = x

  function (+) (a b : t) : t = of_int (Int.(+) (to_int a) (to_int b))

  function (+%) (a b : t) : t = of_int (normalize (Int.(+) (to_int a) (to_int b)))

  function (-_) (a : t) : t = of_int (Int.(-_) (to_int a))

  function (-%_) (a : t) : t = of_int (normalize (Int.(-_) (to_int a)))

  function (-) (a b : t) : t = of_int (Int.(-) (to_int a) (to_int b))

  function (-%) (a b : t) : t = of_int (normalize (Int.(-) (to_int a) (to_int b)))

  function ( *) (a b : t) : t = of_int (Int.( *) (to_int a) (to_int b))

  function ( *%) (a b : t) : t = of_int (normalize (Int.( *) (to_int a) (to_int b)))

  predicate equal (a b : t) = to_int a = to_int b

  predicate nequal (a b : t) = to_int a <> to_int b

  axiom Extensionality1: forall x y : t [to_int x, to_int y]. to_int x = to_int y -> x = y

  axiom Extensionality2:
    forall x y : int [of_int x, of_int y].
      of_int x = of_int y ->
        min <= x <= max /\ min <= y <= max ->
          x = y

  predicate (<=) (a b : t) = Int.(<=) (to_int a) (to_int b)

  predicate (<) (a b : t) = Int.(<) (to_int a) (to_int b)

  predicate (>=) (a b : t) = Int.(>=) (to_int a) (to_int b)

  predicate (>) (a b : t) = Int.(>) (to_int a) (to_int b)

  function (/) (a b : t) : t = of_int (div (to_int a) (to_int b))

  function (/%) (a b : t) : t = of_int (normalize (div (to_int a) (to_int b)))

  function (%) (a b : t) : t = of_int (mod (to_int a) (to_int b))

  function (%%) (a b : t) : t = of_int (normalize (mod (to_int a) (to_int b)))
end

module Generic_enum
  clone export Enum_intf

  use import int.Int

  val to_int (a : t) : int
    ensures { result = to_int a }

  val any_ unit : t

  val (+%) (a b : t) : t
    ensures { to_int result = normalize (to_int a + to_int b) }

  val (-%) (a b : t) : t
    ensures { to_int result = normalize (to_int a - to_int b) }

  val ( *%) (a b : t) : t
    ensures { to_int result = normalize (to_int a * to_int b) }

  val (-%_) (a : t) : t
    ensures { to_int result = normalize (- to_int a) }

  val eq (a b : t) : bool
    ensures { result <-> to_int a = to_int b }
    ensures { result <-> a = b }

  val ne (a b : t) : bool
    ensures { result <-> to_int a <> to_int b }
    ensures { result <-> a <> b }

  val (<=) (a b : t) : bool
    ensures  { result <-> to_int a <= to_int b }

  val (<) (a b : t) : bool
    ensures  { result <-> to_int a < to_int b }

  val (>=) (a b : t) : bool
    ensures  { result <-> to_int a >= to_int b }

  val (>) (a b : t) : bool
    ensures  { result <-> to_int a > to_int b }
end

module Safe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    requires { "expl:integer overflow" in_bounds n }
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a + to_int b) }
    ensures   { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a - to_int b) }
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (to_int a * to_int b) }
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    requires { "expl:integer overflow" in_bounds (- to_int a) }
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (div (to_int a) (to_int b)) }
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (mod (to_int a) (to_int b)) }
    ensures  { to_int result = mod (to_int a) (to_int b) }

  val (/%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }

  val (%%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
end

module Unsafe_enum
  clone export Enum_intf

  val of_int (n : int) : t
    ensures  { to_int result = n }

  use import int.Int

  val (+) (a b : t) : t
    ensures   { to_int result = to_int a + to_int b }

  val (-) (a b : t) : t
    ensures  { to_int result = to_int a - to_int b }

  val ( *) (a b : t) : t
    ensures  { to_int result = to_int a * to_int b }

  val (-_) (a : t) : t
    ensures  { to_int result = - to_int a }

  use import int.ComputerDivision

  val (/) (a b : t) : t
    ensures  { to_int result = div (to_int a) (to_int b) }

  val (%) (a b : t) : t
    ensures  { to_int result = mod (to_int a) (to_int b) }

  val (/%) (a b : t) : t
    ensures  { to_int result = normalize (div (to_int a) (to_int b)) }

  val (%%) (a b : t) : t
    ensures  { to_int result = normalize (mod (to_int a) (to_int b)) }
end

theory Powers_of_2
  use export int.Power

  lemma Powers_of_2:
    power 2 0 = 1 /\
    power 2 1 = 2 /\
    power 2 2 = 4 /\
    power 2 3 = 8 /\
    power 2 4 = 16 /\
    power 2 5 = 32 /\
    power 2 6 = 64 /\
    power 2 7 = 128 /\

    power 2 8 = 256 /\
    power 2 9 = 512 /\
    power 2 10 = 1024 /\
    power 2 11 = 2048 /\
    power 2 12 = 4096 /\
    power 2 13 = 8192 /\
    power 2 14 = 16384 /\
    power 2 15 = 32768 /\

    power 2 16 = 65536 /\
    power 2 17 = 131072 /\
    power 2 18 = 262144 /\
    power 2 19 = 524288 /\
    power 2 20 = 1048576 /\
    power 2 21 = 2097152 /\
    power 2 22 = 4194304 /\
    power 2 23 = 8388608 /\

    power 2 24 = 16777216 /\
    power 2 25 = 33554432 /\
    power 2 26 = 67108864 /\
    power 2 27 = 134217728 /\
    power 2 28 = 268435456 /\
    power 2 29 = 536870912 /\
    power 2 30 = 1073741824 /\
    power 2 31 = 2147483648 /\

    power 2 32 = 4294967296 /\
    power 2 33 = 8589934592 /\
    power 2 34 = 17179869184 /\
    power 2 35 = 34359738368 /\
    power 2 36 = 68719476736 /\
    power 2 37 = 137438953472 /\
    power 2 38 = 274877906944 /\
    power 2 39 = 549755813888 /\

    power 2 40 = 1099511627776 /\
    power 2 41 = 2199023255552 /\
    power 2 42 = 4398046511104 /\
    power 2 43 = 8796093022208 /\
    power 2 44 = 17592186044416 /\
    power 2 45 = 35184372088832 /\
    power 2 46 = 70368744177664 /\
    power 2 47 = 140737488355328 /\

    power 2 48 = 281474976710656 /\
    power 2 49 = 562949953421312 /\
    power 2 50 = 1125899906842624 /\
    power 2 51 = 2251799813685248 /\
    power 2 52 = 4503599627370496 /\
    power 2 53 = 9007199254740992 /\
    power 2 54 = 18014398509481984 /\
    power 2 55 = 36028797018963968 /\

    power 2 56 = 72057594037927936 /\
    power 2 57 = 144115188075855872 /\
    power 2 58 = 288230376151711744 /\
    power 2 59 = 576460752303423488 /\
    power 2 60 = 1152921504606846976 /\
    power 2 61 = 2305843009213693952 /\
    power 2 62 = 4611686018427387904 /\
    power 2 63 = 9223372036854775808 /\

    power 2 64 = 18446744073709551616
end

theory Bit_enum_intf
  namespace import E
    clone export Enum_intf

    constant range : int

    function of_int int : t
    function of_int_modulo int : t

    predicate equal t t
    predicate nequal t t

    function (+%) t t : t
    function (-%) t t : t
    function (-%_) t : t
    function ( *%) t t : t
    function (/%) t t : t
    function (%%) t t : t

    predicate (<) t t
    predicate (<=) t t
    predicate (>) t t
    predicate (>=) t t
  end

  constant size : int

  predicate signed

  function (&) t t : t
  function (|.) t t : t
  function (~_) t : t
  function (^) t t : t
  function lsl t t : t
  function lsl_modulo t t : t
  function lsr t t : t
  function asr t t : t

  function add t t : t
  function sub t t : t
  function neg t : t
  function mul t t : t
  function div t t : t
  function rem t t : t

  predicate eq t t
  predicate ne t t

  predicate lt t t
  predicate le t t
  predicate gt t t
  predicate ge t t
end

theory Bit_enum_intf2
  clone export Enum_intf

  constant range : int

  function of_int int : t
  function of_int_modulo int : t

  predicate equal t t
  predicate nequal t t

  function (+%) t t : t
  function (-%) t t : t
  function (-%_) t : t
  function ( *%) t t : t
  function (/%) t t : t
  function (%%) t t : t

  predicate (<) t t
  predicate (<=) t t
  predicate (>) t t
  predicate (>=) t t

  clone export Bit_enum_intf with
    namespace E = .
end

theory Bit_enum
  clone export Bit_enum_intf

  use import int.Int

  use import Powers_of_2

  axiom Size_pos:
    Int.(>) size 0

  axiom Val_two_power_size:
    power 2 size = E.range

  function of_int_const (n : int) : E.t = E.of_int n

  function to_uint (a : E.t) : int

  axiom To_uint:
    forall a : E.t [E.to_int a].
      E.to_int a = to_uint a - if lt a (of_int_const 0) then power 2 (size - 1) else 0

  use int.ComputerDivision as CD

  predicate nth E.t int

  axiom Nth:
    forall a : E.t.
      forall n : int [nth a n].
        0 <= n < size ->
          nth a n <->
            E.to_int a >= 0 /\ CD.mod (E.to_int a) (power 2 (n + 1)) >= power 2 n \/
            E.to_int a < 0 /\ CD.mod (E.range  + E.to_int a) (power 2 (n + 1)) >= power 2 n

  axiom Eq:
    forall a b : E.t [E.equal a b | eq a b].
      E.equal a b -> eq a b

  axiom Neq:
    forall a b : E.t [E.nequal a b | ne a b].
      E.nequal a b -> ne a b

  axiom Add_eq:
    forall a b : E.t [E.(+%) a b | add a b].
      E.(+%) a b = add a b

  axiom Sub_eq:
    forall a b : E.t [E.(-%) a b | sub a b].
      E.(-%) a b = sub a b

  axiom Neg_eq:
    forall a : E.t [E.(-%_) a | neg a].
      E.(-%_) a = neg a

  axiom Mul_eq:
    forall a b : E.t [E.( *%) a b | mul a b].
      E.( *%) a b = mul a b

  axiom Div_eq:
    forall a b : E.t [E.(/%) a b | div a b].
      E.(/%) a b = div a b

  axiom Mod_eq:
    forall a b : E.t [E.(%%) a b | rem a b].
      E.(%%) a b = rem a b

  axiom Lt_eq:
    forall a b : E.t [E.(<) a b | lt a b].
      E.(<) a b <-> lt a b

  axiom Le_eq:
    forall a b : E.t [E.(<=) a b | le a b].
      E.(<=) a b <-> le a b

  axiom Gt_eq:
    forall a b : E.t [E.(>) a b | gt a b].
      E.(>) a b <-> gt a b

  axiom Ge_eq:
    forall a b : E.t [E.(>=) a b | ge a b].
      E.(>=) a b <-> ge a b

  (* The following axioms are to be removed by the drivers of solvers with native bitvector support *)

  axiom Nth_bw_and:
    forall a b : E.t [a & b].
      forall n : int [nth (a & b) n].
        0 <= n < size ->
          nth (a & b) n <-> nth a n /\ nth b n

  axiom Nth_bw_or:
    forall a b : E.t [a |. b].
      forall n : int [nth (a |. b) n].
        0 <= n < size ->
          nth (a |. b) n <-> nth a n \/ nth b n

  axiom Nth_bw_xor:
    forall a b : E.t [a ^ b].
      forall n : int [nth (a ^ b) n].
        0 <= n < size ->
          nth (a ^ b) n <-> nth a n <> nth b n

  axiom Nth_bw_not:
    forall a : E.t [~ a].
      forall n : int [nth (~ a) n].
        0 <= n < size ->
          nth (~ a) n = not (nth a n)

  axiom Lsl_def:
    forall b : E.t.
      forall s : E.t [lsl b s].
        ge (lsl_modulo b s) (of_int_const 0) ->
          lsl b s = lsl_modulo b s

  axiom Lsr_nth_low:
    forall b : E.t.
      forall s : E.t [lsr b s].
        forall n : int [nth (lsr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s < size ->
                nth (lsr b s) n = nth b (n + E.to_int s)

  axiom Lsr_nth_high:
    forall b : E.t.
      forall s : E.t [lsr b s].
        forall n : int [nth (lsr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s >= size ->
                not (nth (lsr b s) n)

  axiom Asr_nth_low:
    forall b : E.t.
      forall s : E.t [asr b s].
        forall n : int [nth (asr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              0 <= n + E.to_int s < size ->
                nth (asr b s) n = nth b (n + E.to_int s)

  axiom Asr_nth_high:
    forall b : E.t.
      forall s : E.t [asr b s].
        forall n : int [nth (asr b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n + E.to_int s >= size ->
                nth (asr b s) n = nth b (size - 1)

  axiom Lsl_modulo_nth_high:
    forall b : E.t.
      forall s : E.t [lsl_modulo b s].
        forall n : int [nth (lsl_modulo b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              0 <= n - E.to_int s < size ->
                nth (lsl_modulo b s) n = nth b (n - E.to_int s)

  axiom Lsl_modulo_nth_low:
    forall b : E.t.
      forall s : E.t [lsl_modulo b s].
        forall n : int [nth (lsl_modulo b s) n].
          0 <= E.to_int s < size ->
            0 <= n < size ->
              n - E.to_int s < 0 ->
                not (nth (lsl_modulo b s) n)

  use int.EuclideanDivision as ED

  axiom To_uint_lsr:
    not signed ->
      forall a : E.t.
        forall n : E.t [lsr a n].
          E.to_int n >= 0 ->
            E.to_int (lsr a n) = ED.div (E.to_int a) (power 2 (E.to_int n))

  axiom To_uint_lsl_modulo:
    not signed ->
      forall a : E.t.
        forall n : E.t [lsl_modulo a n].
          E.to_int n >= 0 ->
            E.to_int (lsl_modulo a n) = ED.mod (Int.( *) (E.to_int a) (power 2 (E.to_int n))) E.range
end

module Generic_bit_enum
  clone export Bit_enum_intf2

  val (&) (x y : t) : t
    ensures { result = x & y }

  val (|.) (x y : t) : t
    ensures { result = x |. y }

  val (~_) (x : t) : t
    ensures { result = ~ x }

  val (^) (x y : t) : t
    ensures { result = x ^ y }

  use int.Int

  val to_int (a : t) : int
    ensures { result = to_int a }

  val any_ unit : t

  val (+%) (a b : t) : t
    ensures { to_int result = normalize (Int.(+) (to_int a) (to_int b)) }
    ensures { result = add a b }

  val (-%) (a b : t) : t
    ensures { to_int result = normalize (Int.(-) (to_int a) (to_int b)) }
    ensures { result = sub a b }

  val ( *%) (a b : t) : t
    ensures { to_int result = normalize (Int.( *) (to_int a) (to_int b)) }
    ensures { result = mul a b }

  val (-%_) (a : t) : t
    ensures { to_int result = normalize (Int.(-_) (to_int a)) }
    ensures { result = neg a }

  val eq (a b : t) : bool
    ensures { result <-> Int.(=) (to_int a) (to_int b) }
    ensures { result <-> eq a b }
    ensures { result <-> a = b }

  val ne (a b : t) : bool
    ensures { result <-> to_int a <> to_int b }
    ensures { result <-> ne a b }
    ensures { result <-> a <> b }

  val (<=) (a b : t) : bool
    ensures  { result <-> Int.(<=) (to_int a) (to_int b) }
    ensures  { result <-> le a b }

  val (<) (a b : t) : bool
    ensures  { result <-> Int.(<) (to_int a) (to_int b) }
    ensures  { result <-> lt a b }

  val (>=) (a b : t) : bool
    ensures  { result <-> Int.(>=) (to_int a) (to_int b) }
    ensures  { result <-> ge a b }

  val (>) (a b : t) : bool
    ensures  { result <-> Int.(>) (to_int a) (to_int b) }
    ensures  { result <-> gt a b}
end

module Safe_bit_enum
  clone export Bit_enum_intf2

  use import Powers_of_2
  use int.Int

  val lsl (x y : t) : t
    requires { "expl:<< second operand" Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size }
    requires { "expl:integer overflow" in_bounds (Int.( *) (to_int x) (power 2 (to_int y))) }
    ensures { result = lsl_modulo x y }
    ensures { to_int result = Int.( *) (to_int x) (power 2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    requires { "expl:<< second operand" Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size }
    ensures { result = lsl_modulo x y }
    ensures { to_int result = normalize (Int.( *) (to_int x) (power 2 (to_int y))) }

  use int.EuclideanDivision as ED

  val lsr (x y : t) : t
    requires { "expl:>> second operand" Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size }
    ensures { result = lsr x y }
    ensures { Int.(>=) (to_int x) 0 -> to_int result = ED.div (to_int x) (power 2 (to_int y)) }

  val asr (x y : t) : t
    requires { "expl:>> second operand" Int.(<=) 0 (to_int y) && Int.(<) (to_int y) size }
    ensures { result = asr x y }
    ensures { to_int result = ED.div (to_int x) (power 2 (to_int y)) }

  val of_int (n : int) : t
    requires { "expl:integer overflow" in_bounds n }
    ensures  { to_int result = n }
    ensures  { result = of_int n }

  val (+) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (Int.(+) (to_int a) (to_int b)) }
    ensures  { to_int result = Int.(+) (to_int a) (to_int b) }
    ensures  { result = add a b }

  val (-) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (Int.(-) (to_int a) (to_int b)) }
    ensures  { to_int result = Int.(-) (to_int a) (to_int b) }
    ensures  { result = sub a b }

  val ( *) (a b : t) : t
    requires { "expl:integer overflow" in_bounds (Int.(*) (to_int a) (to_int b)) }
    ensures  { to_int result = Int.(*) (to_int a) (to_int b) }
    ensures  { result = mul a b }

  val (-_) (a : t) : t
    requires { "expl:integer overflow" in_bounds (Int.(-_) (to_int a)) }
    ensures  { to_int result = Int.(-_) (to_int a) }
    ensures  { result = neg a }

  use int.ComputerDivision as CD

  val (/) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (CD.div (to_int a) (to_int b)) }
    ensures  { to_int result = CD.div (to_int a) (to_int b) }
    ensures  { result = div a b }

  val (%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    requires { "expl:integer overflow" in_bounds (CD.mod (to_int a) (to_int b)) }
    ensures  { to_int result = CD.mod (to_int a) (to_int b) }
    ensures  { result = rem a b }

  val (/%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (CD.div (to_int a) (to_int b)) }
    ensures  { result = div a b }

  val (%%) (a b : t) : t
    requires { "expl:division by zero" to_int b <> 0 }
    ensures  { to_int result = normalize (CD.mod (to_int a) (to_int b)) }
    ensures  { result = rem a b }
end

module Unsafe_bit_enum
  clone export Bit_enum_intf2

  use int.Int
  use import Powers_of_2

  val lsl (x y : t) : t
    ensures { result = lsl_modulo x y }
    ensures { to_int result = Int.( *) (to_int x) (power 2 (to_int y)) }

  val lsl_modulo (x y : t) : t
    ensures { result = lsl_modulo x y }
    ensures { to_int result = normalize (Int.( *) (to_int x) (power 2 (to_int y))) }

  use int.EuclideanDivision as ED

  val lsr (x y : t) : t
    ensures { result = lsr x y }
    ensures { Int.(>=) (to_int x) 0 -> to_int result = ED.div (to_int x) (power 2 (to_int y)) }

  val asr (x y : t) : t
    ensures { result = asr x y }
    ensures { to_int result = ED.div (to_int x) (power 2 (to_int y)) }

  val of_int (n : int) : t
    ensures  { to_int result = n }
    ensures  { result = of_int n }

  val (+) (a b : t) : t
    ensures   { to_int result = Int.(+) (to_int a) (to_int b) }
    ensures   { result = add a b }

  val (-) (a b : t) : t
    ensures  { to_int result = Int.(-) (to_int a) (to_int b) }
    ensures  { result = sub a b }

  val ( *) (a b : t) : t
    ensures  { to_int result = Int.(*) (to_int a) (to_int b) }
    ensures  { result = mul a b }

  val (-_) (a : t) : t
    ensures  { to_int result = Int.(-_) (to_int a) }
    ensures  { result = neg a }

  use int.ComputerDivision as CD

  val (/) (a b : t) : t
    ensures  { to_int result = CD.div (to_int a) (to_int b) }
    ensures  { result = div a b }

  val (%) (a b : t) : t
    ensures  { to_int result = CD.mod (to_int a) (to_int b) }
    ensures  { result = rem a b }

  val (/%) (a b : t) : t
    ensures  { to_int result = normalize (CD.div (to_int a) (to_int b)) }
    ensures  { result = div a b }

  val (%%) (a b : t) : t
    ensures  { to_int result = normalize (CD.mod (to_int a) (to_int b)) }
    ensures  { result = rem a b }
end

theory Int8
  use import int.Int
  constant min : int = -128
  constant max : int = 127

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint8
  use import int.Int
  constant min : int = 0
  constant max : int = 255

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int16
  use import int.Int
  constant min : int = -32768
  constant max : int = 32767

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint16
  use import int.Int
  constant min : int = 0
  constant max : int = 65535

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int32
  use import int.Int
  constant min : int = -2147483648
  constant max : int = 2147483647

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint32
  use import int.Int
  constant min : int = 0
  constant max : int = 4294967295

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Int64
  use import int.Int
  constant min : int = -9223372036854775808
  constant max : int = 9223372036854775807

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Uint64
  use import int.Int
  constant min : int = 0
  constant max : int = 18446744073709551615

  clone export Enum with
    constant min = min,
    constant max = max
end

theory Bit_int8
  use export Int8

  constant size : int = 8
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint8
  use export Uint8

  constant size : int = 8
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_int16
  use export Int16

  constant size : int = 16
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint16
  use export Uint16

  constant size : int = 16
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_int32
  use export Int32

  constant size : int = 32
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint32
  use export Uint32

  constant size : int = 32
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_int64
  use export Int64

  constant size : int = 64
  predicate signed = true
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint64
  use export Uint64

  constant size : int = 64
  predicate signed = false
  clone export Bit_enum with
    namespace E = .,
    constant size = size,
    predicate signed = signed,
    goal Size_pos,
    lemma Val_two_power_size
end

theory Bit_uint8_of_bit_int8
  use Int8
  use Uint8
  function bw_cast Int8.t : Uint8.t
  function cast_modulo (n : Int8.t) : Uint8.t = Uint8.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_int8
  use Int8
  use Int16
  function bw_cast Int8.t : Int16.t
  function cast_modulo (n : Int8.t) : Int16.t = Int16.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_int8
  use Int8
  use Uint16
  function bw_cast Int8.t : Uint16.t
  function cast_modulo (n : Int8.t) : Uint16.t = Uint16.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_int8
  use Int8
  use Int32
  function bw_cast Int8.t : Int32.t
  function cast_modulo (n : Int8.t) : Int32.t = Int32.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_int8
  use Int8
  use Uint32
  function bw_cast Int8.t : Uint32.t
  function cast_modulo (n : Int8.t) : Uint32.t = Uint32.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_int8
  use Int8
  use Int64
  function bw_cast Int8.t : Int64.t
  function cast_modulo (n : Int8.t) : Int64.t = Int64.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_int8
  use Int8
  use Uint64
  function bw_cast Int8.t : Uint64.t
  function cast_modulo (n : Int8.t) : Uint64.t = Uint64.of_int_modulo (Int8.to_int n)
  axiom Bw_cast_eq:
    forall n : Int8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_uint8
  use Uint8
  use Int8
  function bw_cast Uint8.t : Int8.t
  function cast_modulo (n : Uint8.t) : Int8.t = Int8.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_uint8
  use Uint8
  use Int16
  function bw_cast Uint8.t : Int16.t
  function cast_modulo (n : Uint8.t) : Int16.t = Int16.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_uint8
  use Uint8
  use Uint16
  function bw_cast Uint8.t : Uint16.t
  function cast_modulo (n : Uint8.t) : Uint16.t = Uint16.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_uint8
  use Uint8
  use Int32
  function bw_cast Uint8.t : Int32.t
  function cast_modulo (n : Uint8.t) : Int32.t = Int32.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_uint8
  use Uint8
  use Uint32
  function bw_cast Uint8.t : Uint32.t
  function cast_modulo (n : Uint8.t) : Uint32.t = Uint32.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_uint8
  use Uint8
  use Int64
  function bw_cast Uint8.t : Int64.t
  function cast_modulo (n : Uint8.t) : Int64.t = Int64.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_uint8
  use Uint8
  use Uint64
  function bw_cast Uint8.t : Uint64.t
  function cast_modulo (n : Uint8.t) : Uint64.t = Uint64.of_int_modulo (Uint8.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint8.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_int16
  use Int16
  use Int8
  function bw_cast Int16.t : Int8.t
  function cast_modulo (n : Int16.t) : Int8.t = Int8.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_int16
  use Int16
  use Uint8
  function bw_cast Int16.t : Uint8.t
  function cast_modulo (n : Int16.t) : Uint8.t = Uint8.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_int16
  use Int16
  use Uint16
  function bw_cast Int16.t : Uint16.t
  function cast_modulo (n : Int16.t) : Uint16.t = Uint16.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_int16
  use Int16
  use Int32
  function bw_cast Int16.t : Int32.t
  function cast_modulo (n : Int16.t) : Int32.t = Int32.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_int16
  use Int16
  use Uint32
  function bw_cast Int16.t : Uint32.t
  function cast_modulo (n : Int16.t) : Uint32.t = Uint32.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_int16
  use Int16
  use Int64
  function bw_cast Int16.t : Int64.t
  function cast_modulo (n : Int16.t) : Int64.t = Int64.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_int16
  use Int16
  use Uint64
  function bw_cast Int16.t : Uint64.t
  function cast_modulo (n : Int16.t) : Uint64.t = Uint64.of_int_modulo (Int16.to_int n)
  axiom Bw_cast_eq:
    forall n : Int16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_uint16
  use Uint16
  use Int8
  function bw_cast Uint16.t : Int8.t
  function cast_modulo (n : Uint16.t) : Int8.t = Int8.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_uint16
  use Uint16
  use Uint8
  function bw_cast Uint16.t : Uint8.t
  function cast_modulo (n : Uint16.t) : Uint8.t = Uint8.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_uint16
  use Uint16
  use Int16
  function bw_cast Uint16.t : Int16.t
  function cast_modulo (n : Uint16.t) : Int16.t = Int16.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_uint16
  use Uint16
  use Int32
  function bw_cast Uint16.t : Int32.t
  function cast_modulo (n : Uint16.t) : Int32.t = Int32.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_uint16
  use Uint16
  use Uint32
  function bw_cast Uint16.t : Uint32.t
  function cast_modulo (n : Uint16.t) : Uint32.t = Uint32.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_uint16
  use Uint16
  use Int64
  function bw_cast Uint16.t : Int64.t
  function cast_modulo (n : Uint16.t) : Int64.t = Int64.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_uint16
  use Uint16
  use Uint64
  function bw_cast Uint16.t : Uint64.t
  function cast_modulo (n : Uint16.t) : Uint64.t = Uint64.of_int_modulo (Uint16.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint16.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_int32
  use Int32
  use Int8
  function bw_cast Int32.t : Int8.t
  function cast_modulo (n : Int32.t) : Int8.t = Int8.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_int32
  use Int32
  use Uint8
  function bw_cast Int32.t : Uint8.t
  function cast_modulo (n : Int32.t) : Uint8.t = Uint8.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_int32
  use Int32
  use Int16
  function bw_cast Int32.t : Int16.t
  function cast_modulo (n : Int32.t) : Int16.t = Int16.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_int32
  use Int32
  use Uint16
  function bw_cast Int32.t : Uint16.t
  function cast_modulo (n : Int32.t) : Uint16.t = Uint16.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_int32
  use Int32
  use Uint32
  function bw_cast Int32.t : Uint32.t
  function cast_modulo (n : Int32.t) : Uint32.t = Uint32.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_int32
  use Int32
  use Int64
  function bw_cast Int32.t : Int64.t
  function cast_modulo (n : Int32.t) : Int64.t = Int64.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_int32
  use Int32
  use Uint64
  function bw_cast Int32.t : Uint64.t
  function cast_modulo (n : Int32.t) : Uint64.t = Uint64.of_int_modulo (Int32.to_int n)
  axiom Bw_cast_eq:
    forall n : Int32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_uint32
  use Uint32
  use Int8
  function bw_cast Uint32.t : Int8.t
  function cast_modulo (n : Uint32.t) : Int8.t = Int8.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_uint32
  use Uint32
  use Uint8
  function bw_cast Uint32.t : Uint8.t
  function cast_modulo (n : Uint32.t) : Uint8.t = Uint8.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_uint32
  use Uint32
  use Int16
  function bw_cast Uint32.t : Int16.t
  function cast_modulo (n : Uint32.t) : Int16.t = Int16.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_uint32
  use Uint32
  use Uint16
  function bw_cast Uint32.t : Uint16.t
  function cast_modulo (n : Uint32.t) : Uint16.t = Uint16.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_uint32
  use Uint32
  use Int32
  function bw_cast Uint32.t : Int32.t
  function cast_modulo (n : Uint32.t) : Int32.t = Int32.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_uint32
  use Uint32
  use Int64
  function bw_cast Uint32.t : Int64.t
  function cast_modulo (n : Uint32.t) : Int64.t = Int64.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_uint32
  use Uint32
  use Uint64
  function bw_cast Uint32.t : Uint64.t
  function cast_modulo (n : Uint32.t) : Uint64.t = Uint64.of_int_modulo (Uint32.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint32.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_int64
  use Int64
  use Int8
  function bw_cast Int64.t : Int8.t
  function cast_modulo (n : Int64.t) : Int8.t = Int8.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_int64
  use Int64
  use Uint8
  function bw_cast Int64.t : Uint8.t
  function cast_modulo (n : Int64.t) : Uint8.t = Uint8.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_int64
  use Int64
  use Int16
  function bw_cast Int64.t : Int16.t
  function cast_modulo (n : Int64.t) : Int16.t = Int16.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_int64
  use Int64
  use Uint16
  function bw_cast Int64.t : Uint16.t
  function cast_modulo (n : Int64.t) : Uint16.t = Uint16.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_int64
  use Int64
  use Int32
  function bw_cast Int64.t : Int32.t
  function cast_modulo (n : Int64.t) : Int32.t = Int32.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_int64
  use Int64
  use Uint32
  function bw_cast Int64.t : Uint32.t
  function cast_modulo (n : Int64.t) : Uint32.t = Uint32.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint64_of_bit_int64
  use Int64
  use Uint64
  function bw_cast Int64.t : Uint64.t
  function cast_modulo (n : Int64.t) : Uint64.t = Uint64.of_int_modulo (Int64.to_int n)
  axiom Bw_cast_eq:
    forall n : Int64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int8_of_bit_uint64
  use Uint64
  use Int8
  function bw_cast Uint64.t : Int8.t
  function cast_modulo (n : Uint64.t) : Int8.t = Int8.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint8_of_bit_uint64
  use Uint64
  use Uint8
  function bw_cast Uint64.t : Uint8.t
  function cast_modulo (n : Uint64.t) : Uint8.t = Uint8.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int16_of_bit_uint64
  use Uint64
  use Int16
  function bw_cast Uint64.t : Int16.t
  function cast_modulo (n : Uint64.t) : Int16.t = Int16.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint16_of_bit_uint64
  use Uint64
  use Uint16
  function bw_cast Uint64.t : Uint16.t
  function cast_modulo (n : Uint64.t) : Uint16.t = Uint16.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int32_of_bit_uint64
  use Uint64
  use Int32
  function bw_cast Uint64.t : Int32.t
  function cast_modulo (n : Uint64.t) : Int32.t = Int32.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_uint32_of_bit_uint64
  use Uint64
  use Uint32
  function bw_cast Uint64.t : Uint32.t
  function cast_modulo (n : Uint64.t) : Uint32.t = Uint32.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end

theory Bit_int64_of_bit_uint64
  use Uint64
  use Int64
  function bw_cast Uint64.t : Int64.t
  function cast_modulo (n : Uint64.t) : Int64.t = Int64.of_int_modulo (Uint64.to_int n)
  axiom Bw_cast_eq:
    forall n : Uint64.t [cast_modulo n | bw_cast n].
      cast_modulo n = bw_cast n
end