
module JessieDivision

use import int.Int
use import int.ComputerDivision

val computer_div_ (x:int) (y:int) : int
  requires { y<>0 } ensures { result = div x y }

val computer_mod_ (x:int) (y:int) : int
  requires { y<>0 } ensures { result = mod x y }

use import real.Real

val div_real_ (x:real) (y:real) : real
  requires { y<>0.0 } ensures { result = Real.(/) x y }

end

module JessieFloats

use import real.Real
use import floating_point.Rounding
use import floating_point.Single
use import floating_point.Double

(* Specification of operations in single precision *)

predicate single_of_double_post (m:mode) (x:double) (res:single) =
  Single.value res = Single.round m (Double.value x) /\
  Single.exact res = Double.exact x /\
  Single.model res = Double.model x

val any_single (_void:unit) : single

val single_of_real (m:mode) (x:real) : single
  requires { Single.no_overflow m x }
  ensures  { Single.of_real_post m x result }

val single_of_real_safe (m:mode) (x:real) : single
  requires { true }
  ensures  { Single.of_real_post m x result }

val single_of_real_exact (x:real) : single
  requires { true }
  ensures  { Single.value result = x /\
    Single.exact result = x /\
    Single.model result = x }

val single_of_double (m:mode) (x:double) : single
  requires { Single.no_overflow m (Double.value x) }
  ensures  { single_of_double_post m x result }

val single_of_double_safe (m:mode) (x:double) : single
  requires { true }
  ensures  { single_of_double_post m x result }

val neg_single (x:single) : single
  requires { true }
  ensures  { Single.neg_post x result }

val add_single (m:mode) (x y:single) : single
  requires { Single.no_overflow m (Single.value x + Single.value y) }
  ensures  { Single.add_post m x y result }

val add_single_safe (m:mode) (x y:single) : single
  requires { true }
  ensures  { Single.add_post m x y result }

val sub_single (m:mode) (x y:single) : single
  requires { Single.no_overflow m (Single.value x - Single.value y) }
  ensures  { Single.sub_post m x y result }

val sub_single_safe (m:mode) (x y:single) : single
  requires { true }
  ensures  { Single.sub_post m x y result }

val mul_single (m:mode) (x y:single) : single
  requires { Single.no_overflow m (Single.value x * Single.value y) }
  ensures  { Single.mul_post m x y result }

val mul_single_safe (m:mode) (x y:single) : single
  requires { true }
  ensures  { Single.mul_post m x y result }

val div_single (m:mode) (x y:single) :  single
  requires { Single.value y <> 0.0 /\
             Single.no_overflow m (Single.value x / Single.value y) }
  ensures  { Single.div_post m x y result }

val div_single_safe (m:mode) (x y:single) : single
  requires { true }
  ensures  { Single.value y <> 0.0 /\
    Single.div_post m x y result }

val lt_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.lt x y else not (Single.lt x y) }

val le_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.value x <= Single.value y
            else Single.value x > Single.value y }

val gt_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.value x > Single.value y
            else Single.value x <= Single.value y }

val ge_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.value x >= Single.value y
            else Single.value x < Single.value y }

val eq_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.value x = Single.value y
            else Single.value x <> Single.value y }

val ne_single_ (x y:single) : bool
  requires { true }
  ensures  { if result = True then Single.value x <> Single.value y
            else Single.value x = Single.value y }

(* Specification of operations in double precision *)

predicate double_of_single_post (x:single) (res:double) =
  Double.value res = Single.value x /\
  Double.exact res = Single.exact x /\
  Double.model res = Single.model x

val any_double (_void:unit) : double

val double_of_real (m:mode) (x:real) : double
  requires { Double.no_overflow m x }
  ensures  { Double.of_real_post m x result }

val double_of_real_safe (m:mode) (x:real) : double
  requires { true }
  ensures  { Double.of_real_post m x result }

val double_of_real_exact (x:real) : double
  requires { true }
  ensures  { Double.value result = x /\
    Double.exact result = x /\
    Double.model result = x }

val double_of_single (x:single) : double
  requires { true }
  ensures  { double_of_single_post x result }

val neg_double (x:double) : double
  requires { true }
  ensures  { Double.neg_post x result }

val neg_double_safe (x:double) : double
  requires { true }
  ensures  { Double.neg_post x result }

val add_double (m:mode) (x y:double) : double
  requires { Double.no_overflow m (Double.value x + Double.value y) }
  ensures  { Double.add_post m x y result }

val add_double_safe (m:mode) (x y:double) : double
  requires { true }
  ensures  { Double.add_post m x y result }

val sub_double (m:mode) (x y:double) :
  double

  requires { Double.no_overflow m (Double.value x - Double.value y) }
  ensures  { Double.sub_post m x y result }

val sub_double_safe (m:mode) (x y:double) :
  double

  requires { true }
  ensures  { Double.sub_post m x y result }

val mul_double (m:mode) (x y:double) :
  double

  requires { Double.no_overflow m (Double.value x * Double.value y) }
  ensures  { Double.mul_post m x y result }

val mul_double_safe (m:mode) (x y:double) :
  double

  requires { true }
  ensures  { Double.mul_post m x y result }

val div_double (m:mode) (x y:double) : double
  requires { Double.value y <> 0.0 /\
             Double.no_overflow m (Double.value x / Double.value y) }
  ensures  { Double.div_post m x y result }

val div_double_safe (m:mode) (x y:double) :
  double

  requires { true }
  ensures  { Double.value y <> 0.0 /\ Double.div_post m x y result }

val lt_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.lt x y else not (Double.lt x y) }

val le_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.value x <= Double.value y
            else Double.value x > Double.value y }

val gt_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.value x > Double.value y
            else Double.value x <= Double.value y }

val ge_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.value x >= Double.value y
            else Double.value x < Double.value y }

val eq_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.value x = Double.value y
            else Double.value x <> Double.value y }

val ne_double_ (x y:double) : bool
  requires { true }
  ensures  { if result = True then Double.value x <> Double.value y
            else Double.value x = Double.value y }

end


module JessieFloatsFull

use import real.Real
use import floating_point.Rounding
use import floating_point.SingleFull
use import floating_point.DoubleFull as Double

val any_double (_void:unit) : double

val lt_double_ (x:double) (y:double) : bool
  requires { true }
  ensures  { if result = True then Double.lt x y else not (Double.lt x y) }

val gt_double_ (x:double) (y:double) : bool
  requires { true }
  ensures  { if result = True then Double.gt x y else not (Double.gt x y) }

(* TODO: add missing parameters *)

val add_double (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.add_post m x y result }

val sub_double (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.sub_post m x y result }

val mul_double (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.mul_post m x y result }

val div_double (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.div_post m x y result }

val neg_double (x:double) : double
  requires { true }
  ensures  { Double.neg_post x result }


val double_of_real_exact (x:real) : double
  requires { true }
  ensures  { Double.of_real_exact_post x result }

end

module JessieFloatsMultiRounding

use import real.Real
use import floating_point.Rounding
use import floating_point.DoubleMultiRounding as Double

val any_double (_void:unit) : double

val lt_double_ (x:double) (y:double) : bool
  requires { true }
  ensures  { if result = True then Double.lt x y else not Double.lt x y }

val gt_double_ (x:double) (y:double) : bool
  requires { true }
  ensures  { if result = True then Double.gt x y else not Double.gt x y }

val add_double (m:mode) (x:double) (y:double) :
  double

  requires { Double.no_overflow m (Double.value x + Double.value y) }
  ensures  { Double.add_post m x y result }

val add_double_safe (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.add_post m x y result }

val sub_double (m:mode) (x:double) (y:double) : double
  requires { Double.no_overflow m (value x - value y) }
  ensures  { Double.sub_post m x y result }

val sub_double_safe (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.sub_post m x y result }

val mul_double (m:mode) (x:double) (y:double) :
  double

  requires { Double.no_overflow m (Double.value x * Double.value y) }
  ensures  { Double.mul_post m x y result }

val mul_double_safe (m:mode) (x:double) (y:double) : double
  requires { true }
  ensures  { Double.mul_post m x y result }


val neg_double (m:mode) (x:double) : double
  requires { Double.no_overflow m (- (value x)) }
  ensures  { Double.neg_post m x result }

val neg_double_safe (m:mode) (x:double) : double
  requires { true }
  ensures  { Double.neg_post m x result }


val double_of_real (m:mode) (x:real) : double
  requires { Double.no_overflow m x }
  ensures  { Double.of_real_exact_post x result }

val double_of_real_exact (x:real) : double
  requires { true }
  ensures  { Double.of_real_exact_post x result }

val double_of_real_safe (m:mode) (x:real) : double
  requires { true }
  ensures  { Double.of_real_post m x result }

end


module Jessie_memory_model_parameters

use import int.Int
use import jessie3theories.Jessie_memory_model
use import ref.Ref

val sub_pointer_ (p : pointer 't) (q : pointer 't) : int
  requires { "expl:Pointer difference" same_block p q }
  ensures  { result = sub_pointer p q }

val safe_sub_pointer_ (p : pointer 't) (q : pointer 't) : int
  requires { true }
  ensures  { result = sub_pointer p q }

(* pointer comparison *)

val eq_pointer (a1 : alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) (q : pointer 't) : bool
  requires { "expl:Pointer equality"
               ("expl:Same block" same_block p q) \/
               ("expl:Is null" p = null \/ q = null) \/
               ("expl:Both valid" valid a1 p /\ valid a2 q) }
  ensures  { result = True <-> p = q }

val safe_eq_pointer (p : pointer 't) (q : pointer 't) : bool
  requires { true }
  ensures  { result = True <-> p = q }

val neq_pointer (a1 : alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) (q : pointer 't) : bool
  requires { "expl:Pointer inequality"
               ("expl:Same block" same_block p q) \/
               ("expl:Is not null" p = null \/ q = null) \/
               ("expl:Both valid" valid a1 p /\ valid a2 q) }
  ensures  { result = True <-> p <> q }

val safe_neq_pointer (p : pointer 't) (q : pointer 't) : bool
  requires { true }
  ensures  { result = True <-> p<>q }

(*****************************************************************************)
(* access and update side-effect functions                                   *)
(*****************************************************************************)

(* normal access *)
val acc_ (alloc : alloc_table 't) (m : memory 't 'v) (p : pointer 't) : 'v
  requires { "expl:Validity" offset_min alloc p <= 0 <= offset_max alloc p }
  ensures  { result = select m p }

(* offset access *)
val offset_acc_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : memory 't 'v)  (p : pointer 't) (s : tag_id 't) (off : int) :  'v
  requires { "expl:Dereference by offset"
               ("expl:Validity" offset_min alloc p <= off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* safe access (statically proven safe) *)
val safe_acc_requires_  (m : memory 't 'v) (p : pointer 't)  : 'v
  requires { "expl:Valid bounded access" true }
  ensures  { result = select m p }

(* safe access *)
val safe_acc_ (m : memory 't 'v) (p : pointer 't) : 'v
  requires { true }
  ensures  { result = select m p }

(* bounded access *)
val bound_acc_
    (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't) (off : int) (lb : int) (rb : int) : 'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" lb <= off <= rb) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* bounded access with safe left bound *)
val lsafe_bound_acc_
    (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't) (off : int) (rb : int) : 'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" off <= rb) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* bounded access with safe right bound *)
val rsafe_bound_acc_
    (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't) (off : int) (lb : int) : 'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" lb <= off) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* left bounded access *)
val lbound_acc_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't)
    (off : int) (lb : int) : 'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" lb <= off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* left bounded access with safe left bound *)
val lsafe_lbound_acc_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't) (off : int) : 'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* right bounded access *)
val rbound_acc_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't)
    (off : int) (rb : int) :  'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" offset_min alloc p <= off <= rb) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* right bounded access with safe right bound *)
val rsafe_rbound_acc_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : memory 't 'v) (p : pointer 't) (s : tag_id 't) (off : int) :  'v
  requires { "expl:Bounded pointer dereference"
               ("expl:Validity" offset_min alloc p <= off) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { result = select m (shift p off) }

(* normal update *)
val upd_
    (alloc : alloc_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (v : 'v) :  unit
  requires { "expl:Assignment"
               ("expl:Left valid" offset_min alloc p <= 0) /\ ("expl:Right valid" 0 <= offset_max alloc p) }
  reads { m }
  writes { m }
  ensures { !m = store (old !m) p v }

(* offset update *)
val offset_upd_
    (alloc : alloc_table 't) (tag: tag_table 't) (m: ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int)
    (v : 'v) : unit
  requires { "expl:Assignment with offset"
               ("expl:Left valid" offset_min alloc p <= off) /\ ("expl:Right valid" off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  reads    { m }
  writes   { m }
  ensures  { !m = store (old !m) (shift p off) v }

(* safe update *)
val safe_upd_ (m : ref (memory 't 'v)) (p : pointer 't) (v : 'v) : unit
  requires { true }
  reads    { m  }
  writes   { m }
  ensures  { !m = store (old !m) p v }

(* bounded update *)
val bound_upd_
    (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int) (lb : int)
    (rb : int) (v : 'v) : unit
  requires { "expl:Assignment"
               ("expl:Validity" lb <= off /\ off <= rb) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  reads { m }
  writes { m }
  ensures  { !m = store (old !m) (shift p off) v }

(* bounded update with safe right bound *)
val rsafe_bound_upd_
    (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int) (lb : int)
    (v : 'v) : unit
  requires { "expl:Assignment"
               ("expl:Validity" lb <= off) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  reads { m }
  writes { m }
  ensures  { !m = store (old !m) (shift p off) v }

(* left bounded update *)
val lbound_upd_
    (alloc : alloc_table 't) (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int)
    (lb : int) (v : 'v) : unit
  reads { m }
  writes { m }
  requires { "expl:Assignment"
               ("expl:Validity" lb <= off /\ off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { !m = store (old !m) (shift p off) v }

(* left bounded update with safe left bound *)
val lsafe_lbound_upd_ (alloc : alloc_table 't) (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int) (v : 'v) :  unit
  reads { m }
  writes { m }
  requires { "expl:Assignment"
               ("expl:Validity" off <= offset_max alloc p) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { !m = store (old !m) (shift p off) v }

(* right bounded update *)
val rbound_upd_ (alloc : alloc_table 't) (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int) (rb : int) (v : 'v) : unit
  reads { m }
  writes { m }
  requires { "expl:Assignment"
               ("expl:Validity" offset_min alloc p <= off /\ off <= rb) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { !m = store (old !m) (shift p off) v }

(* right bounded update with safe right bound *)
val rsafe_rbound_upd_ (alloc : alloc_table 't) (tag : tag_table 't) (m : ref (memory 't 'v)) (p : pointer 't) (s : tag_id 't) (off : int) (v : 'v) :  unit
  reads { m }
  writes { m }
  requires { "expl:Assignment"
               ("expl:Validity" offset_min alloc p <= off) /\
               ("expl:Correct type" (("expl:Zero offset" off = 0 /\ instanceof tag p s) \/
                                     ("expl:Non-zero offset" typeof tag p = s))) }
  ensures  { !m = store (old !m) (shift p off) v }

val instanceof_ (t : tag_table 't) (p : pointer 't) (s: tag_id 't) : bool
  requires { true }
  ensures  { result = True <-> instanceof t p s }

val downcast_ (t : tag_table 't) (p : pointer 't) (s : tag_id 't) :  pointer 't
  requires { "expl:Prefix or reinterpret"
             ("expl:Up/downcast" instanceof t p s) \/ ("expl:Reinterpret cast" cast_factor (typeof t p) s <> 0) }
  ensures  { result = downcast t p s }

val safe_downcast_ (t : tag_table 't) (p : pointer 't) (s : tag_id 't) : pointer 't
  requires { true }
  ensures  { result = downcast t p s }

val shift_ (t : tag_table 't) (p : pointer 't) (s : tag_id 't) (off : int) : pointer 't
  requires { "expl:Correct type" typeof t p = s }
  ensures { result = shift p off }

val safe_shift_ (p : pointer 't) (off : int) : pointer 't
  requires { true }
  ensures { result = shift p off }

(*****************************************************************************)
(* default values                                                            *)
(*****************************************************************************)

val any_int (_void : unit) :  int

val any_real (_void : unit) :  real

val any_bool (_void : unit) :  bool

val any_pointer (_void : unit) :  pointer 'z

val any_memory (_void : unit) :  memory 't 'v

val any_alloc_table (_void : unit) :  alloc_table 't

val any_tag_table (_void : unit) :  tag_table 't

(*****************************************************************************)
(* exceptions for control flow handling                                      *)
(*****************************************************************************)

exception Return

val safe_free_parameter (a : ref (alloc_table 't)) (p : pointer 't) : unit
  writes { a }
  ensures  { (p = null -> !a = (old !a)) /\
             (p <> null ->
              free (old !a) !a p /\
              offset_max !a p < offset_min !a p) }

let free_parameter (a : ref (alloc_table 't)) (p : pointer 't) : unit
  writes { a }
  requires { "expl:Deallocation"
               (("expl:Null" p = null) (* allowed, see man 3 free *) \/
                ("expl:Valid" offset_min !a p = 0 /\ offset_max !a p >= 0)) } =
  safe_free_parameter a p

val safe_reinterpret_parameter
      (a : ref (alloc_table 't))
      (t : tag_table 't)
      (s1 : tag_id 't)
      (s2 : tag_id 't)
      (m : ref (memory 't 'v))
      (p : pointer 't) :
      unit
  writes { a, m }
  ensures  { let pset_old = pset_all (pset_singleton p) in
             let ps = downcast t p s2 in
             let pset_new = pset_all (pset_singleton ps) in
             alloc_same_except (old !a) !a (pset_reinterpret_all t pset_old) /\
             not_assigns (old !m) !m pset_new }

use import int.ComputerDivision

let reinterpret_parameter
      (a : ref (alloc_table 't))
      (t : tag_table 't)
      (s1 : tag_id 't)
      (s2 : tag_id 't)
      (m : ref (memory 't 'v))
      (p : pointer 't) :
      unit
  writes { a, m }
  requires { "expl:Reinterpret cast"
               ("expl:Correct type" typeof t (shift p (offset_min !a p - 1)) = s1)
             /\ ("expl:Validity" (offset_min !a p <= offset_max !a p))
             /\  ("expl:Valid cast" ("expl:Split" cast_factor s1 s2 > 0) \/
                  ("expl:Join" mod (offset_max !a p - offset_min !a p + 1) (- cast_factor s1 s2) = 0))
           } =
  safe_reinterpret_parameter a t s1 s2 m p

end
