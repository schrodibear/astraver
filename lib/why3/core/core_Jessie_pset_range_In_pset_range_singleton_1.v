(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.

Axiom block : Type.
Parameter block_WhyType : WhyType block.
Existing Instance block_WhyType.

(* Why3 assumption *)
Definition pointer (t:Type) := (block* Z)%type.

Parameter null: (block* Z)%type.

(* Why3 assumption *)
Definition sub_pointer (a:(block* Z)%type) (b:(block* Z)%type): Z :=
  match a with
  | (_, a1) => match b with
      | (_, b1) => (a1 - b1)%Z
      end
  end.

(* Why3 assumption *)
Definition shift (p:(block* Z)%type) (n:Z): (block* Z)%type :=
  match p with
  | (b, o) => (b, (o + n)%Z)
  end.

(* Why3 assumption *)
Definition same_block (p1:(block* Z)%type) (p2:(block* Z)%type): Prop :=
  match p1 with
  | (b1, _) => match p2 with
      | (b2, _) => (b1 = b2)
      end
  end.

Axiom pset : forall (t:Type), Type.
Parameter pset_WhyType : forall (t:Type) {t_WT:WhyType t}, WhyType (pset t).
Existing Instance pset_WhyType.

Parameter pset_empty: forall {t:Type} {t_WT:WhyType t}, (pset t).

Parameter pset_singleton: forall {t:Type} {t_WT:WhyType t}, (block*
  Z)%type -> (pset t).

Parameter in_pset: forall {t:Type} {t_WT:WhyType t}, (block* Z)%type -> (pset
  t) -> Prop.

Axiom In_pset_empty : forall {t:Type} {t_WT:WhyType t}, forall (p:(block*
  Z)%type), ~ (in_pset p (pset_empty : (pset t))).

Axiom In_pset_singleton : forall {t:Type} {t_WT:WhyType t}, forall (p:(block*
  Z)%type), forall (q:(block* Z)%type), (in_pset p (pset_singleton q: (pset
  t))) <-> (p = q).

Parameter pset_range: forall {t:Type} {t_WT:WhyType t}, (pset t) -> Z -> Z ->
  (pset t).

Axiom In_pset_range : forall {t:Type} {t_WT:WhyType t}, forall (p:(block*
  Z)%type), forall (q:(pset t)), forall (a:Z) (b:Z), (in_pset p (pset_range q
  a b)) <-> exists i:Z, exists r:(block* Z)%type, (a <= i)%Z /\
  ((i <= b)%Z /\ ((in_pset r q) /\ (p = (shift r i)))).

(* Why3 goal *)
Theorem In_pset_range_singleton : forall {t:Type} {t_WT:WhyType t},
  forall (p:(block* Z)%type), forall (q:(block* Z)%type), forall (a:Z) (b:Z),
  (in_pset p (pset_range (pset_singleton q: (pset t)) a b)) <-> ((same_block
  p q) /\ ((a <= (sub_pointer p q))%Z /\ ((sub_pointer p q) <= b)%Z)).
(* Why3 intros t t_WT p q a b. *)
intros t t_WT p q a b.
rewrite -> In_pset_range. split.
  intros. destruct H. destruct H. rewrite In_pset_singleton in H.
    destruct H. destruct H0. destruct H1. rewrite <- H1. rewrite H2.
    split. unfold same_block. unfold shift. destruct x0. reflexivity.
    unfold sub_pointer, shift. destruct x0. omega.
  intro. exists (sub_pointer p q). exists q. split. omega. split. omega.
    rewrite In_pset_singleton. unfold sub_pointer, shift. destruct q.
    destruct p. split. reflexivity. destruct H. elim H.
    apply injective_projections. simpl. reflexivity. simpl. omega.
Qed.
