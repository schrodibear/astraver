(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require map.Map.

Axiom block : Type.
Parameter block_WhyType : WhyType block.
Existing Instance block_WhyType.

(* Why3 assumption *)
Definition pointer (t:Type) := (block* Z)%type.

Parameter null: (block* Z)%type.

(* Why3 assumption *)
Definition sub_pointer (a:(block* Z)%type) (b:(block* Z)%type): Z :=
  match a with
  | (_, a1) => match b with
      | (_, b1) => (a1 - b1)%Z
      end
  end.

(* Why3 assumption *)
Definition shift (p:(block* Z)%type) (n:Z): (block* Z)%type :=
  match p with
  | (b, o) => (b, (o + n)%Z)
  end.

(* Why3 assumption *)
Definition same_block (p1:(block* Z)%type) (p2:(block* Z)%type): Prop :=
  match p1 with
  | (b1, _) => match p2 with
      | (b2, _) => (b1 = b2)
      end
  end.

Axiom alloc_table : forall (t:Type), Type.
Parameter alloc_table_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (alloc_table t).
Existing Instance alloc_table_WhyType.

Parameter offset_min: forall {t:Type} {t_WT:WhyType t}, (alloc_table t) ->
  (block* Z)%type -> Z.

Parameter offset_max: forall {t:Type} {t_WT:WhyType t}, (alloc_table t) ->
  (block* Z)%type -> Z.

Axiom Null_pointer : forall {t:Type} {t_WT:WhyType t}, forall (a:(alloc_table
  t)), ((offset_max a null) = (-2%Z)%Z) /\ (((-2%Z)%Z < (offset_min a
  null))%Z /\ ((offset_min a null) = 0%Z)).

Axiom Offset_max_shift : forall {t:Type} {t_WT:WhyType t},
  forall (a:(alloc_table t)), forall (p:(block* Z)%type), forall (i:Z),
  ((offset_max a (shift p i)) = ((offset_max a p) - i)%Z).

Axiom Offset_min_shift : forall {t:Type} {t_WT:WhyType t},
  forall (a:(alloc_table t)), forall (p:(block* Z)%type), forall (i:Z),
  ((offset_min a (shift p i)) = ((offset_min a p) - i)%Z).

(* Why3 assumption *)
Definition valid {t:Type} {t_WT:WhyType t} (a:(alloc_table t)) (p:(block*
  Z)%type): Prop := ((offset_min a p) <= 0%Z)%Z /\ (0%Z <= (offset_max a
  p))%Z.

Axiom tag_id : forall (t:Type), Type.
Parameter tag_id_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (tag_id t).
Existing Instance tag_id_WhyType.

Parameter int_of_tag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> Z.

Parameter parenttag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> (tag_id
  t) -> Prop.

Axiom Proper_parenttag : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id
  t)), forall (t2:(tag_id t)), (parenttag t1 t2) -> ~ (t1 = t2).

Axiom Int_of_parent_tag : forall {t:Type} {t_WT:WhyType t},
  forall (t1:(tag_id t)), forall (t2:(tag_id t)), (parenttag t1 t2) ->
  ((int_of_tag t2) < (int_of_tag t1))%Z.

Parameter subtag: forall {t:Type} {t_WT:WhyType t}, (tag_id t) -> (tag_id
  t) -> Prop.

Axiom Subtag_refl : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id t)),
  (subtag t1 t1).

Axiom Subtag_parent : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id
  t)), forall (t2:(tag_id t)), forall (t3:(tag_id t)), (subtag t1 t2) ->
  ((parenttag t2 t3) -> (subtag t1 t3)).

Parameter bottom_tag: forall {a:Type} {a_WT:WhyType a}, (tag_id a).

Axiom Bottom_tag : forall {t:Type} {t_WT:WhyType t}, forall (t1:(tag_id t)),
  (subtag t1 (bottom_tag : (tag_id t))).

Axiom Root_subtag : forall {t:Type} {t_WT:WhyType t}, forall (a:(tag_id t)),
  forall (b:(tag_id t)), forall (c:(tag_id t)), (parenttag a
  (bottom_tag : (tag_id t))) -> ((parenttag b (bottom_tag : (tag_id t))) ->
  ((~ (a = b)) -> ((subtag c a) -> ~ (subtag c b)))).

(* Why3 assumption *)
Definition tag_table (t:Type) := (map.Map.map (block* Z)%type (tag_id t)).

(* Why3 assumption *)
Definition instanceof {t:Type} {t_WT:WhyType t} (t1:(map.Map.map (block*
  Z)%type (tag_id t))) (p:(block* Z)%type) (s:(tag_id t)): Prop := (subtag
  (map.Map.get t1 p) s).

Parameter downcast: forall {t:Type} {t_WT:WhyType t}, (map.Map.map (block*
  Z)%type (tag_id t)) -> (block* Z)%type -> (tag_id t) -> (block* Z)%type.

Axiom Downcast_instanceof : forall {t:Type} {t_WT:WhyType t},
  forall (t1:(map.Map.map (block* Z)%type (tag_id t))), forall (p:(block*
  Z)%type), forall (s:(tag_id t)), (instanceof t1 p s) -> ((downcast t1 p
  s) = p).

(* Why3 assumption *)
Definition allocable {t:Type} {t_WT:WhyType t} (a:(alloc_table t)) (p:(block*
  Z)%type): Prop := ((offset_max a p) = (-1%Z)%Z) /\
  (((-1%Z)%Z < (offset_min a p))%Z /\ ((offset_min a p) = 0%Z)).

(* Why3 assumption *)
Definition freeable {t:Type} {t_WT:WhyType t} (a:(alloc_table t)) (p:(block*
  Z)%type): Prop := ((offset_min a p) = 0%Z) /\ (0%Z <= (offset_max a p))%Z.

(* Why3 assumption *)
Definition allocated {t:Type} {t_WT:WhyType t} (a:(alloc_table t)) (p:(block*
  Z)%type): Prop := ((offset_min a p) <= (offset_max a p))%Z.

(* Why3 assumption *)
Definition tag_fresh {t:Type} {t_WT:WhyType t} (t1:(map.Map.map (block*
  Z)%type (tag_id t))) (p:(block* Z)%type): Prop := ((map.Map.get t1
  p) = (bottom_tag : (tag_id t))).

(* Why3 goal *)
Theorem Alloc_fresh_not_same_block : forall {t:Type} {t_WT:WhyType t},
  forall (p1:(block* Z)%type), forall (p2:(block* Z)%type),
  forall (a:(alloc_table t)), ((allocable a p1) /\ (freeable a p2)) ->
  ~ (same_block p1 p2).
intros t t_WT p1 p2 a (h1,h2).
unfold not. intros. unfold allocable in h1. unfold freeable in h2.
destruct p1. destruct p2. unfold same_block in H. destruct h1. destruct h2.
destruct H1.
  assert (Hyp := Offset_min_shift a (b0, z0) (sub_pointer (b, z) (b0, z0))).
simpl in Hyp. rewrite H2 in Hyp. rewrite <- H in Hyp.
  assert (z0 + (z - z0) = z)%Z. omega. rewrite H5 in Hyp. rewrite H4 in Hyp.
  assert (z = z0). rewrite <- H5. omega.
  rewrite H, H6 in H0.
  rewrite H0 in H3. apply H3. omega.
Qed.

