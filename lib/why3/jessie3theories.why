
theory Jessie_memory_model

use import int.Int

predicate zwf_zero (a : int) (b : int) = 0 <= a /\ a < b

(*****************************************************************************)
(* pointers, allocation, validity                                            *)
(*****************************************************************************)

type alloc_table 't
type pointer 't

(* memory model *)

function offset_max (alloc_table 't) (pointer 't) : int
function offset_min (alloc_table 't) (pointer 't) : int

(* shortcuts *)

predicate valid (a : alloc_table 't) (p : pointer 't) =
  offset_min a p <= 0 /\ offset_max a p >= 0

predicate same_block (p : pointer 't) (q : pointer 't)

(* pointer arithmetic *)

function sub_pointer (pointer 't) (pointer 't) : int
function shift (pointer 't) int : pointer 't

(* null pointer*)

function null : pointer 't

(* shift *)

axiom shift_zero:
  forall p : pointer 't [shift p 0]. shift p 0 = p

axiom shift_shift:
  forall p : pointer 't. forall i : int. forall j : int [shift (shift p i) j].
    shift (shift p i) j = shift p (i + j)

axiom offset_max_shift:
  forall a : alloc_table 't. forall p : pointer 't. forall i : int.
    offset_max a (shift p i) = offset_max a p - i

axiom offset_min_shift:
  forall a : alloc_table 't. forall p : pointer 't. forall i : int.
    offset_min a (shift p i) = offset_min a p - i

axiom neq_shift:
  forall p : pointer 't. forall i : int. forall j : int [shift p i, shift p j].
    i <> j -> shift p i <> shift p j

(* null *)

axiom null_pointer:
  forall a : alloc_table 't.
    offset_max a null < offset_min a null

use import bool.Bool

(* special functions for constructing terms where predicates are actually needed (but only terms allowed) *)

function eq_pointer_bool (p1 : pointer 't) (p2 : pointer 't) : bool = if p1 = p2 then True else False
function neq_pointer_bool (p1 : pointer 't) (p2 : pointer 't) : bool = if p1 <> p2 then True else False

axiom same_block_shift_right:
  forall p : pointer 't. forall q : pointer 't. forall i : int
  [same_block p (shift q i)].
    same_block p q -> same_block p (shift q i)

axiom same_block_shift_left:
  forall p : pointer 't. forall q : pointer 't. forall i : int
  [same_block (shift q i) p].
    same_block q p -> same_block (shift q i) p

(* sub_pointer *)

axiom sub_pointer_shift:
  forall p q : pointer 't [sub_pointer p q].
    same_block p q -> p = shift q (sub_pointer p q)

axiom sub_pointer_self:
  forall p : pointer 't [sub_pointer p p]. sub_pointer p p = 0

axiom sub_pointer_zero:
  forall p q : pointer 't [sub_pointer p q].
    same_block p q ->
      sub_pointer p q = 0 -> p = q

axiom sub_pointer_shift_left:
  forall p q : pointer 't, i : int [sub_pointer (shift p i) q].
      same_block p q -> sub_pointer (shift p i) q = sub_pointer p q + i

axiom sub_pointer_shift_right:
  forall p q : pointer 't, i : int [sub_pointer p (shift q i)].
      same_block p q -> sub_pointer p (shift q i) = sub_pointer p q - i

axiom sub_pointer_neg:
  forall p q : pointer 't. sub_pointer p q = - sub_pointer q p

(*****************************************************************************)
(* heap memories, select and store                                           *)
(*****************************************************************************)

use map.Map

type memory 't 'v = Map.map (pointer 't) 'v

function select (m : memory 't 'v) (p : pointer 't) : 'v = Map.get m p
function store (m : memory 't 'v) (p : pointer 't) (v : 'v) : memory 't 'v = Map.set m p v

(*****************************************************************************)
(* memory locations, not_assigns predicate, separation                       *)
(*****************************************************************************)

type pset 't

function pset_empty : pset 't
function pset_singleton (pointer 't) : pset 't
function pset_deref (memory 't (pointer 'v)) (pset 't) : pset 'v
function pset_union (pset 't) (pset 't) : pset 't
function pset_all (pset 'z) : pset 'z (* l(..) *)
function pset_range (pset 't) int int : pset 't (* l(a..b) *)
function pset_range_left (pset 'z) int : pset 'z (* l(..b) *)
function pset_range_right (pset 'z) int : pset 'z (* l(a..) *)

predicate in_pset (pointer 't) (pset 't)

predicate pset_disjoint (ps1 : pset 't) (ps2 : pset 't) =
  forall p : pointer 't.
    not (in_pset p ps1 /\ in_pset p ps2)

axiom in_pset_empty:
  forall p : pointer 't. not (in_pset p pset_empty)

axiom in_pset_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
    in_pset p (pset_singleton q) <-> p=q

axiom in_pset_deref:
  forall p : pointer 'v.
  forall m : memory 't (pointer 'v).
  forall q : pset 't.
    in_pset p (pset_deref m q) <->
        exists r : pointer 't. in_pset r q /\ p = select m r

axiom in_pset_deref_singleton:
  forall p : pointer 'v.
  forall m : memory 't (pointer 'v).
  forall q : pointer 't.
    in_pset p (pset_deref m (pset_singleton q)) <-> p = select m q

axiom in_pset_all:
  forall p : pointer 't.
  forall q : pset 't.
    in_pset p (pset_all q) <->
        exists i : int. exists r : pointer 't.
          in_pset r q /\ p = shift r i

axiom in_pset_all_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
    in_pset p (pset_all (pset_singleton q)) <-> same_block p q

axiom in_pset_range:
  forall p : pointer 't.
  forall q : pset 't.
  forall a : int. forall b :int.
    in_pset p (pset_range q a b) <->
      exists i : int. exists r : pointer 't.
        a <= i /\ i <= b /\ in_pset r q /\ p = shift r i

axiom in_pset_range_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
  forall a b : int.
    in_pset p (pset_range (pset_singleton q) a b) <->
      same_block p q /\ a <= sub_pointer p q <= b

axiom in_pset_range_left:
  forall p : pointer 't.
  forall q : pset 't.
  forall b : int.
    in_pset p (pset_range_left q b) <->
        exists i : int. exists r : pointer 't.
          i <= b /\ in_pset r q /\ p = shift r i

axiom in_pset_range_right:
  forall p : pointer 't.
  forall q : pset 't.
  forall a : int.
    in_pset p (pset_range_right q a) <->
        exists i : int. exists r : pointer 't.
          a <= i /\ in_pset r q /\ p = shift r i

axiom in_pset_union:
  forall p : pointer 't.
  forall s1 : pset 't.
  forall s2 : pset 't.
    in_pset p (pset_union s1 s2) <-> in_pset p s1 \/ in_pset p s2

predicate not_assigns
  (a : alloc_table 't) (m1 : memory 't 'v) (m2 : memory 't 'v ) (l : pset 't) =
    forall p:pointer 't.
      not in_pset p l -> select m2 p = select m1 p

axiom not_assigns_refl:
  forall a : alloc_table 't.
  forall m : memory 't 'v.
  forall l : pset 't.
    not_assigns a m m l

axiom not_assigns_trans:
  forall a : alloc_table 't.
  forall m1 : memory 't 'v.
  forall m2 : memory 't 'v.
  forall m3 : memory 't 'v.
  forall l : pset 't [not_assigns a m1 m2 l, not_assigns a m1 m3 l].
    not_assigns a m1 m2 l ->
    not_assigns a m2 m3 l ->
    not_assigns a m1 m3 l

(*****************************************************************************)
(* lattice of structures                                                     *)
(*****************************************************************************)

(*****
typeof gives the dynamic type of an object.

parenttag is defined by axioms in jc_interp, and defines the hierarchy.
  parenttag(t1, t2) <-> t2 is the immediate superclass of t1

subtag is axiomatized from parenttag, and is the reflexive, transitive
  closure of parenttag.

subtag_ is the same as subtag but for booleans.

instanceof is defined from typeof and subtag.

int_of_tag gives a different integer to each tags to differenciate them.
*****)

type tag_table 't (* TO BE DELETED! *)

type tag_id 't

function int_of_tag (tag_id 't) : int

function typeof (pointer 't) : tag_id 't

function cast_factor (tag_id 't) (tag_id 't) : int

predicate parenttag (tag_id 't) (tag_id 't)

predicate subtag (tag_id 't) (tag_id 't)

function subtag_bool (tag_id 't) (tag_id 't) : bool

axiom subtag_bool_def:
  forall t1: tag_id 't.
  forall t2: tag_id 't.
    subtag_bool t1 t2 = True <-> subtag t1 t2

axiom subtag_refl:
  forall t: tag_id 't.
    subtag t t

axiom subtag_parent:
  forall t1: (tag_id 't).
  forall t2: (tag_id 't).
  forall t3: (tag_id 't).
    subtag t1 t2 -> parenttag t2 t3 -> subtag t1 t3

predicate instanceof (p : pointer 't) (s : tag_id 't) =
  subtag (typeof p) s

function instanceof_bool (p : pointer 't) (s : tag_id 't) : bool =
  if instanceof p s then True else False

function downcast (pointer 't) (tag_id 't) : pointer 't

axiom downcast_reduce:
  forall p : pointer 't.
    forall s2 : tag_id 't [downcast p s2].
      forall s1 : tag_id 't [downcast (downcast p s1) s2].
        cast_factor s1 s2 <> 0 -> downcast (downcast p s1) s2 = downcast p s2

axiom downcast_instanceof:
  forall p : pointer 't.
  forall s : tag_id 't.
   instanceof p s -> downcast p s = p

axiom instanceof_downcast:
  forall p : pointer 't.
  forall s : tag_id 't.
   instanceof (downcast p s) s

function bottom_tag: tag_id 'a

axiom bottom_tag_axiom:
  forall t : tag_id 't.
    subtag t bottom_tag

predicate root_tag (t : tag_id 't) = parenttag t bottom_tag

axiom root_subtag:
  forall a: tag_id 't.
  forall b: tag_id 't.
  forall c: tag_id 't.
    root_tag(a) -> root_tag(b) -> a <> b -> subtag c a -> not (subtag c b)

use import int.ComputerDivision

predicate reinterpret_cast_merge
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't)
      (c : int) =
  let ps = downcast p s in
  (forall i : int [shift p i | shift ps (div i c)]. mod i c = 0 -> downcast (shift p i) s = shift ps (div i c)) /\
  (forall i : int [shift ps i | shift p (i * c)]. downcast (shift p (i * c)) s = shift ps i) /\
  offset_min a2 ps = div (offset_min a1 p) c /\
  offset_max a2 ps = div (offset_max a1 p + 1) c - 1

predicate reinterpret_cast_split
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't)
      (c : int) =
  let ps = downcast p s in
  (forall i : int [shift p i | shift ps (i * c)]. downcast (shift p i) s = shift ps (i * c)) /\
  (forall i : int [shift ps i | shift p (div i c)]. mod i c = 0 -> downcast (shift p (div i c)) s = shift ps i) /\
  offset_min a2 ps = c * offset_min a1 p /\
  offset_max a2 ps = c * (offset_max a1 p + 1) - 1

predicate reinterpret_cast_retain
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't) =
  let ps = downcast p s in
  (forall i : int [shift p i | shift ps i]. downcast (shift p i) s = shift ps i) /\
  offset_min a2 ps = offset_min a1 p /\
  offset_max a2 ps = offset_max a1 p

(*****************************************************************************)
(* bitwise operations                                                        *)
(*****************************************************************************)
(* TODO: use bitvector.why instead *)

function bw_compl int : int

function bw_and int int : int

(* Yannick: added for CVE-2003-0161-min-ok *)
axiom bw_and_not_null:
  forall a: int. forall b: int. bw_and a b <> 0 -> a <> 0 /\ b <> 0

function bw_xor int int : int

function bw_or int int : int

(* bitwise arithmetic -- partial axiomatization *)

function pow2 int : int

axiom pow2_definition:
  pow2 0 = 1 /\
  pow2 1 = 2 /\
  pow2 2 = 4 /\
  pow2 3 = 8 /\
  pow2 4 = 16 /\
  pow2 5 = 32 /\
  pow2 6 = 64 /\
  pow2 7 = 128 /\

  pow2 8 = 256 /\
  pow2 9 = 512 /\
  pow2 10 = 1024 /\
  pow2 11 = 2048 /\
  pow2 12 = 4096 /\
  pow2 13 = 8192 /\
  pow2 14 = 16384 /\
  pow2 15 = 32768 /\

  pow2 16 = 65536 /\
  pow2 17 = 131072 /\
  pow2 18 = 262144 /\
  pow2 19 = 524288 /\
  pow2 20 = 1048576 /\
  pow2 21 = 2097152 /\
  pow2 22 = 4194304 /\
  pow2 23 = 8388608 /\

  pow2 24 = 16777216 /\
  pow2 25 = 33554432 /\
  pow2 26 = 67108864 /\
  pow2 27 = 134217728 /\
  pow2 28 = 268435456 /\
  pow2 29 = 536870912 /\
  pow2 30 = 1073741824 /\
  pow2 31 = 2147483648

axiom bw_or_plus:
  forall a: int. forall b: int [bw_or a b, a + b].
    a >= 0 /\ b >= 0 /\ bw_and a b = 0 -> bw_or a b = a + b

predicate bw_set (pos: int) (n: int) = bw_and (pow2 pos) n <> 0

axiom pow2_bw_set:
  forall n: int. forall m: int [bw_set n (pow2 m)]. bw_set n (pow2 m) <-> n = m

axiom zero_bw_set:
  forall n: int [bw_set n 0]. not (bw_set n 0)

axiom zero_bw_set_iff1:
  forall a: int. forall n: int [bw_set n a]. a = 0 -> not (bw_set n a)

axiom zero_bw_set_iff2:
  forall a: int. forall n: int [bw_set n a]. bw_set n a -> a <> 0

axiom bw_and_self:
  forall a: int [bw_and a a].
    bw_and a a = a

axiom bw_or_self:
  forall a: int [bw_or a a].
    bw_or a a = a

axiom bw_and_definition:
  forall n: int. forall a: int. forall b: int
    [bw_and a b, bw_set n (bw_and a b), bw_set n a, bw_set n b].
      bw_set n (bw_and a b) <-> bw_set n a /\ bw_set n b

axiom bw_or_definition:
  forall n: int. forall a: int. forall b: int
    [bw_or a b, bw_set n (bw_or a b), bw_set n a, bw_set n b].
      bw_set n (bw_or a b) <-> bw_set n a \/ bw_set n b

axiom bw_xor_definition:
  forall n: int. forall a: int. forall b: int
    [bw_xor a b, bw_set n (bw_xor a b), bw_set n a, bw_set n b].
      bw_set n (bw_xor a b) <-> not (bw_set n a <-> bw_set n b)

axiom bw_compl_definition:
  forall n: int. forall a: int [bw_compl a, bw_set n (bw_compl a), bw_set n a].
     bw_set n (bw_compl a) <-> not (bw_set n a)

axiom bw_and_assoc:
  forall a: int. forall b: int. forall c: int [bw_and (bw_and a b) c, bw_and a (bw_and b c)].
    bw_and (bw_and a b) c = bw_and a (bw_and b c)

axiom bw_or_assoc:
  forall a: int. forall b: int. forall c: int [bw_or (bw_or a b) c, bw_or a (bw_or b c)].
    bw_or (bw_or a b) c = bw_or a (bw_or b c)

axiom bw_xor_assoc:
  forall a: int. forall b: int. forall c: int [bw_xor (bw_xor a b) c, bw_xor a (bw_xor b c)].
    bw_xor (bw_xor a b) c = bw_xor a (bw_xor b c)

axiom bw_and_comm:
  forall a: int. forall b:int [bw_and a b, bw_and b a].
    bw_and a b = bw_and b a

axiom bw_or_comm:
  forall a: int. forall b: int [bw_or a b, bw_or b a].
    bw_or a b = bw_or b a

axiom bw_xor_comm:
  forall a: int. forall b: int [bw_xor a b, bw_xor b a].
    bw_xor a b = bw_xor b a

axiom bw_and_or_distr:
  forall a: int. forall b: int. forall c: int [bw_and a (bw_or b c), bw_or (bw_and a b) (bw_and a c)].
    bw_and a (bw_or b c) = bw_or (bw_and a b) (bw_and a c)

axiom bw_or_and_distr:
  forall a: int. forall b: int. forall c: int [bw_or a (bw_and b c), bw_and (bw_or a b) (bw_or b c)].
    bw_or a (bw_and b c) = bw_and (bw_or a b) (bw_or a c)

axiom bw_and_mono:
  forall a: int. forall b: int [bw_and a b].
    a >= 0 /\ b >= 0 -> bw_and a b <= a /\ bw_and a b <= b

axiom bw_or_mono:
  forall a: int. forall b: int [bw_or a b].
    a >= 0 /\ b >= 0 -> bw_or a b >= a /\ bw_or a b >= b

(* axioms for arithmetic overflow in bitwise operations *)

function max_char : int = 127
function max_short: int  = 32767
function max_int : int = 2147483647
function max_long : int = 9223372036854775807

function min_char : int = -128
function min_short : int = -32768
function min_int : int = -2147483648
function min_long : int = -9223372036854775808

axiom bw_compl_nooverflow_signed:
  forall a : int [bw_compl a].
      (min_char <= a /\ a <= max_char ->
        min_char <= bw_compl a /\ bw_compl a <= max_char) /\
      (min_short <= a /\ a <= max_short ->
        min_short <= bw_compl a /\ bw_compl a <= max_short) /\
      (min_int <= a /\ a <= max_int ->
        min_int <= bw_compl a /\ bw_compl a <= max_int) /\
      (min_long <= a /\ a <= max_long ->
        min_long <= bw_compl a /\ bw_compl a <= max_long)

axiom bw_or_nooverflow_signed:
  forall a : int.
    forall b : int [bw_or a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_or a b /\ bw_or a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_or a b /\ bw_or a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_or a b /\ bw_or a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_or a b /\ bw_or a b <= max_long)

axiom bw_and_nooverflow_signed:
  forall a : int.
    forall b : int [bw_and a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_and a b /\ bw_and a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_and a b /\ bw_and a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_and a b /\ bw_and a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_and a b /\ bw_and a b <= max_long)

axiom bw_xor_nooverflow_signed:
  forall a : int.
    forall b : int [bw_xor a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_xor a b /\ bw_xor a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_xor a b /\ bw_xor a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_xor a b /\ bw_xor a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_xor a b /\ bw_xor a b <= max_long)

function max_uchar : int = 255
function max_ushort : int = 65535
function max_uint : int = 4294967295
function max_ulong : int = 18446744073709551615

axiom bw_or_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_or a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_or a b /\ bw_or a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_or a b /\ bw_or a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_or a b /\ bw_or a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_or a b /\ bw_or a b <= max_ulong)

axiom bw_and_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_and a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_and a b /\ bw_and a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_and a b /\ bw_and a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_and a b /\ bw_and a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_and a b /\ bw_and a b <= max_ulong)

axiom bw_xor_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_xor a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ulong)

(* logical left shift *)

function lsl int int : int

axiom lsl_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsl a (b)

axiom lsl_left_positive_monotone:
  forall a1:int. forall a2:int. forall b:int.
    0 <= a1 /\ a1 <= a2 /\ 0 <= b -> lsl a1 b <= lsl a2 b

(* logical right shift *)

function lsr int int : int

axiom lsr_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsr a (b)

axiom lsr_left_positive_decreases:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr a (b) <= a

(* arithmetic right shift *)

function asr int int : int

axiom asr_positive_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= asr a (b)

axiom asr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) <= a

(* combining shifts *)

axiom asr_lsr_same_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) = lsr a (b)

axiom lsl_of_lsr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsl (lsr a b) b <= a

axiom lsr_of_lsl_identity_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr (lsl a b) b = a

(* shifts bitwise definition *)

axiom lsl_definition:
  forall m: int. forall a: int [lsl a m]. forall n: int
    [bw_set n (lsl a m), bw_set (n - m) a, n < m].
      m >= 0 -> not (bw_set n (lsl a m)) <-> not (bw_set (n - m) a) \/ n < m

axiom lsr_definition:
  forall m: int. forall a: int [lsr a m]. forall n: int
    [bw_set n (lsr a m), bw_set (n + m) a].
      m >= 0 -> bw_set n (lsr a m) <-> bw_set (n + m) a

axiom lsl_induction:
  forall a: int.
  forall n: int [lsl a n].
  forall m: int [n + m].
  forall k: int [lsl a k].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      lsl a k = lsl (lsl a n) m

axiom lsr_induction:
  forall a: int.
  forall n: int [lsr a n].
  forall m: int [n + m].
  forall k: int [lsr a k].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      lsr a k = lsr (lsr a n) m

axiom lsl_assoc:
  forall n: int.
  forall m: int.
  forall a: int [lsl (lsl a m) n, lsl (lsl a n) m].
    n >= 0 /\ m >= 0 ->
      lsl (lsl a m) n = lsl (lsl a n) m

axiom lsr_assoc:
  forall n: int.
  forall m: int.
  forall a: int [lsr (lsr a m) n, lsr (lsr a n) m].
    n >= 0 /\ m >= 0 ->
      lsr (lsr a m) n = lsr (lsr a n) m

axiom lsl_init:
  forall a: int [lsl a 1 | a * 2]. a >= 0 -> lsl a 1 = a * 2

axiom lsl_multiply:
  forall a: int. forall n: int [lsl a n | a * pow2 n]. a >= 0 -> lsl a n = a * pow2 n

axiom lsr_init:
  forall a: int [lsr a 1 | div a 2]. a >= 0 -> lsr a 1 = div a 2

axiom lsr_divide:
  forall a: int. forall n: int [lsr a n | div a (pow2 n)]. a >= 0 -> lsr a n = div a (pow2 n)

(*****************************************************************************)
(* dynamic allocation/deallocation                                           *)
(*****************************************************************************)

predicate alloc_fresh (a : alloc_table 't) (p : pointer 't) =
  offset_max a p < offset_min a p /\
  forall p' : pointer 't. in_pset p' (pset_all (pset_singleton p)) -> not valid a p' (* excess condition *)

predicate alloc_same_except (a1 : alloc_table 't) (a2 : alloc_table 't) (l : pset 't) =
  forall p: pointer 't [valid a1 p | valid a2 p | in_pset p l | offset_min a1 p, offset_min a2 p | offset_max a1 p, offset_max a2 p].
    not in_pset p l -> (valid a1 p -> offset_min a1 p = offset_min a2 p /\ offset_max a1 p = offset_max a2 p) /\
                       (not valid a1 p -> not valid a2 p)

predicate alloc (a1 : alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) =
  alloc_same_except a1 a2 (pset_all (pset_singleton p))

predicate free (a1 : alloc_table 't) (a2 : alloc_table 't) ( p : pointer 't) = alloc a1 a2 p

end
