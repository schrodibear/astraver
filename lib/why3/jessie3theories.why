
theory Jessie_memory_model

use import int.Int

predicate zwf_zero (a : int) (b : int) = 0 <= a /\ a < b

(*****************************************************************************)
(* Pointers, allocation, validity                                            *)
(*****************************************************************************)

type alloc_table 't
type pointer 't

(* memory model *)

function offset_max (alloc_table 't) (pointer 't) : int
function offset_min (alloc_table 't) (pointer 't) : int

(* shortcuts *)

predicate valid (a : alloc_table 't) (p : pointer 't) =
  offset_min a p <= 0 <= offset_max a p

(* pointer arithmetic *)

predicate same_block (p : pointer 't) (q : pointer 't)
function sub_pointer (pointer 't) (pointer 't) : int
function shift (pointer 't) int : pointer 't

(* null pointer*)

function null : pointer 't

axiom null_pointer:
  forall a : alloc_table 't.
    offset_max a null = -2 < offset_min a null = 0

(* shift *)

axiom shift_zero:
  forall p : pointer 't [shift p 0]. shift p 0 = p

axiom shift_shift:
  forall p : pointer 't. forall i : int. forall j : int [shift (shift p i) j].
    shift (shift p i) j = shift p (i + j)

axiom offset_max_shift:
  forall a : alloc_table 't. forall p : pointer 't. forall i : int.
    offset_max a (shift p i) = offset_max a p - i

axiom offset_min_shift:
  forall a : alloc_table 't. forall p : pointer 't. forall i : int.
    offset_min a (shift p i) = offset_min a p - i

axiom neq_shift:
  forall p : pointer 't. forall i : int. forall j : int [shift p i, shift p j].
    i <> j -> shift p i <> shift p j

use import bool.Bool

axiom same_block_refl:
  forall p : pointer 't.
    same_block p p

axiom same_block_shift:
  forall p : pointer 't.
    forall i : int.
      same_block p (shift p i)

axiom same_block_symm:
  forall p : pointer 't.
    forall q : pointer 't.
      same_block p q <-> same_block q p

axiom same_block_trans:
  forall p : pointer 't.
    forall q : pointer 't.
      forall r : pointer 't.
        same_block p q /\ same_block q r -> same_block p r

axiom same_block_shift_right:
  forall p : pointer 't. forall q : pointer 't. forall i : int
  [same_block p (shift q i)].
    same_block p q -> same_block p (shift q i)

axiom same_block_shift_left:
  forall p : pointer 't. forall q : pointer 't. forall i : int
  [same_block (shift q i) p].
    same_block q p -> same_block (shift q i) p

(* sub_pointer *)

axiom sub_pointer_shift:
  forall p q : pointer 't [sub_pointer p q].
    same_block p q -> p = shift q (sub_pointer p q)

axiom sub_pointer_self:
  forall p : pointer 't [sub_pointer p p]. sub_pointer p p = 0

axiom sub_pointer_zero:
  forall p q : pointer 't [sub_pointer p q].
    same_block p q ->
      sub_pointer p q = 0 -> p = q

axiom sub_pointer_shift_left:
  forall p q : pointer 't, i : int [sub_pointer (shift p i) q].
      same_block p q -> sub_pointer (shift p i) q = sub_pointer p q + i

axiom sub_pointer_shift_right:
  forall p q : pointer 't, i : int [sub_pointer p (shift q i)].
      same_block p q -> sub_pointer p (shift q i) = sub_pointer p q - i

axiom sub_pointer_neg:
  forall p q : pointer 't. sub_pointer p q = - sub_pointer q p

(*****************************************************************************)
(* Heap memories, select and store                                           *)
(*****************************************************************************)

use map.Map

type memory 't 'v = Map.map (pointer 't) 'v

function select (m : memory 't 'v) (p : pointer 't) : 'v = Map.get m p
function store (m : memory 't 'v) (p : pointer 't) (v : 'v) : memory 't 'v = Map.set m p v

(*****************************************************************************)
(* Memory locations, not_assigns predicate, separation                       *)
(*****************************************************************************)

type pset 't

function pset_empty : pset 't
function pset_singleton (pointer 't) : pset 't
function pset_deref (memory 't (pointer 'v)) (pset 't) : pset 'v
function pset_union (pset 't) (pset 't) : pset 't
function pset_all (pset 'z) : pset 'z (* l(..) *)
function pset_range (pset 't) int int : pset 't (* l(a..b) *)
function pset_range_left (pset 'z) int : pset 'z (* l(..b) *)
function pset_range_right (pset 'z) int : pset 'z (* l(a..) *)

predicate in_pset (pointer 't) (pset 't)

predicate pset_disjoint (ps1 : pset 't) (ps2 : pset 't) =
  forall p : pointer 't.
    not (in_pset p ps1 /\ in_pset p ps2)

predicate pset_included (ps1 : pset 't) (ps2 : pset 't)

axiom in_pset_empty:
  forall p : pointer 't. not (in_pset p pset_empty)

axiom in_pset_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
    in_pset p (pset_singleton q) <-> p = q

axiom in_pset_deref:
  forall p : pointer 'v.
  forall m : memory 't (pointer 'v).
  forall q : pset 't.
    in_pset p (pset_deref m q) <->
        exists r : pointer 't. in_pset r q /\ p = select m r

axiom in_pset_deref_singleton:
  forall p : pointer 'v.
  forall m : memory 't (pointer 'v).
  forall q : pointer 't.
    in_pset p (pset_deref m (pset_singleton q)) <-> p = select m q

axiom in_pset_all:
  forall p : pointer 't.
  forall q : pset 't.
    in_pset p (pset_all q) <->
      exists r : pointer 't.
        in_pset r q /\ same_block p r

axiom in_pset_all_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
    in_pset p (pset_all (pset_singleton q)) <-> same_block p q

axiom in_pset_range:
  forall p : pointer 't.
  forall q : pset 't.
  forall a : int. forall b :int.
    in_pset p (pset_range q a b) <->
      exists i : int. exists r : pointer 't.
        a <= i /\ i <= b /\ in_pset r q /\ p = shift r i

axiom in_pset_range_singleton:
  forall p : pointer 't.
  forall q : pointer 't.
  forall a b : int.
    in_pset p (pset_range (pset_singleton q) a b) <->
      same_block p q /\ a <= sub_pointer p q <= b

axiom in_pset_range_left:
  forall p : pointer 't.
  forall q : pset 't.
  forall b : int.
    in_pset p (pset_range_left q b) <->
        exists i : int. exists r : pointer 't.
          i <= b /\ in_pset r q /\ p = shift r i

axiom in_pset_range_right:
  forall p : pointer 't.
  forall q : pset 't.
  forall a : int.
    in_pset p (pset_range_right q a) <->
        exists i : int. exists r : pointer 't.
          a <= i /\ in_pset r q /\ p = shift r i

axiom in_pset_union:
  forall p : pointer 't.
  forall s1 : pset 't.
  forall s2 : pset 't.
    in_pset p (pset_union s1 s2) <-> in_pset p s1 \/ in_pset p s2

axiom in_pset_union_singleton:
  forall p1 : pointer 't [pset_singleton p1].
    forall p2 : pointer 't [pset_singleton p2, pset_union (pset_singleton p1) (pset_singleton p2)].
      forall p : pointer 't [in_pset p (pset_union (pset_singleton p1) (pset_singleton p2))].
        in_pset p (pset_union (pset_singleton p1) (pset_singleton p2)) <->
          (p = p1 \/ p = p2)

axiom in_pset_union_all_singleton:
  forall p1 : pointer 't [pset_all (pset_singleton p1)].
    forall p2 : pointer 't [pset_all (pset_singleton p2), pset_union (pset_all (pset_singleton p1)) (pset_all (pset_singleton p2))].
      forall p : pointer 't [in_pset p (pset_union (pset_all (pset_singleton p1)) (pset_all (pset_singleton p2)))].
        in_pset p (pset_union (pset_all (pset_singleton p1)) (pset_all (pset_singleton p2))) <->
          same_block p p1 \/ same_block p p2

(*****************************************************************************)
(* Memory frame conditions                                                   *)
(*****************************************************************************)

predicate not_assigns (a1 : alloc_table 't) (a2 : alloc_table 't) (m1 : memory 't 'v) (m2 : memory 't 'v ) (l : pset 't) =
  forall p : pointer 't.
    valid a1 p /\ valid a2 p ->
      not in_pset p l ->
        select m2 p = select m1 p

axiom not_assigns_refl:
  forall a1 : alloc_table 't.
    forall a2 : alloc_table 't.
      forall m : memory 't 'v.
        forall l : pset 't.
          not_assigns a1 a2 m m l

axiom not_assigns_trans:
  forall a1 : alloc_table 't.
    forall a2 : alloc_table 't.
      forall m1 : memory 't 'v.
        forall m2 : memory 't 'v.
          forall m3 : memory 't 'v.
            forall l : pset 't [not_assigns a1 a2 m1 m2 l, not_assigns a1 a2 m2 m3 l | not_assigns a1 a2 m1 m3 l].
              not_assigns a1 a2 m1 m2 l ->
              not_assigns a1 a2 m2 m3 l ->
              not_assigns a1 a2 m1 m3 l

predicate not_assigns_strong (m1 : memory 't 'v) (m2 : memory 't 'v ) (l : pset 't) =
  forall p : pointer 't.
    not in_pset p l ->
      select m2 p = select m1 p

axiom not_assigns_strong:
  forall m1 : memory 't 'v.
    forall m2 : memory 't 'v.
      forall l : pset 't [not_assigns_strong m1 m2 l].
        not_assigns_strong m1 m2 l ->
          forall a1 : alloc_table 't.
            forall a2 : alloc_table 't [not_assigns a1 a2 m1 m2 l].
              not_assigns a1 a2 m1 m2 l

(*****************************************************************************)
(* Lattice of structures                                                     *)
(*****************************************************************************)

(*****************************************************************************)
(* typeof gives the dynamic type of an object.                               *)
(*                                                                           *)
(* parenttag is defined by axioms in jc_interp, and defines the hierarchy.   *)
(*   parenttag(t1, t2) <-> t2 is the immediate superclass of t1              *)
(*                                                                           *)
(* subtag is axiomatized from parenttag, and is the reflexive, transitive    *)
(*   closure of parenttag.                                                   *)
(*                                                                           *)
(*  subtag_ is the same as subtag but for booleans.                          *)
(*                                                                           *)
(*  instanceof is defined from typeof and subtag.                            *)
(*                                                                           *)
(*  int_of_tag gives a different integer to each tags to differenciate them. *)
(*****************************************************************************)

type tag_id 't

type tag_table 't = Map.map (pointer 't) (tag_id 't)

function tag (t : tag_table 't) (p : pointer 't) : tag_id 't = Map.get t p

function store_tag (t : tag_table 't) (p : pointer 't) (s : tag_id 't) : tag_table 't = Map.set t p s

function store_tags (tag_table 't) (pointer 't) (tag_id 't) : tag_table 't

function store_struct_tag (t : tag_table 't) (p : pointer 't) (s : tag_id 't) : tag_table 't = store_tags t p s

axiom store_tags:
  forall t : tag_table 't.
    forall p : pointer 't.
      forall s : tag_id 't [store_tags t p s].
        forall q : pointer 't [tag (store_tags t p s) q].
          let result = tag (store_tags t p s) q in
          (same_block p q -> result = s) /\ (not (same_block p q) -> result = tag t q)

function int_of_tag (tag_id 't) : int

function typeof (t : tag_table 't) (p : pointer 't) : tag_id 't = tag t p

predicate parenttag (tag_id 't) (tag_id 't)

axiom proper_parenttag:
  forall t1: tag_id 't.
    forall t2: tag_id 't [parenttag t1 t2].
      parenttag t1 t2 -> t1 <> t2

axiom int_of_parent_tag:
  forall t1: tag_id 't.
    forall t2: tag_id 't [parenttag t1 t2].
      parenttag t1 t2 -> int_of_tag t1 > int_of_tag t2

predicate subtag (tag_id 't) (tag_id 't)

(* The function \phi i.e. <> 0 iff reinterpretation is allowed, > 0 - split, < 0 - join *)

function cast_factor (tag_id 't) (tag_id 't) : int

function subtag_bool (tag_id 't) (tag_id 't) : bool

axiom subtag_bool_def:
  forall t1: tag_id 't.
  forall t2: tag_id 't.
    subtag_bool t1 t2 = True <-> subtag t1 t2

axiom subtag_refl:
  forall t: tag_id 't.
    subtag t t

axiom subtag_parent:
  forall t1: (tag_id 't).
  forall t2: (tag_id 't).
  forall t3: (tag_id 't).
    subtag t1 t2 -> parenttag t2 t3 -> subtag t1 t3

use import int.ComputerDivision

axiom cast_factor_trans:
  forall t1 : (tag_id 't).
    forall t2 : (tag_id 't).
      forall t3 : (tag_id 't).
        let c12 = cast_factor t1 t2 in
        let c23 = cast_factor t2 t3 in
        let c13 = cast_factor t1 t3 in
        (c12 > 0 /\ c23 > 0 -> c13 = c12 * c23) /\
        (c12 > 0 /\ c23 < 0 /\ c12 > (-c23) /\ mod c12 (- c23) = 0 -> c13 = div c12 (- c23)) /\
        (c12 > 0 /\ c23 < 0 /\ c12 < (-c23) /\ mod (- c23) c12 = 0 -> c13 = - (div (- c23) c12)) /\
        (c12 < 0 /\ c23 > 0 /\ c23 > (- c12) /\ mod c23 (- c12) = 0 -> c13 = div c23 (- c12)) /\
        (c12 < 0 /\ c23 > 0 /\ c23 < (- c12) /\ mod (- c12) c23 = 0 -> c13 = - (div (- c12) c23)) /\
        (c12 < 0 /\ c23 < 0 -> c13 = (- c12) * c23)

predicate instanceof (t : tag_table 't) (p : pointer 't) (s : tag_id 't) =
  subtag (typeof t p) s

function instanceof_bool (t : tag_table 't) (p : pointer 't) (s : tag_id 't) : bool =
  if instanceof t p s then True else False

function downcast (tag_table 't) (pointer 't) (tag_id 't) : pointer 't

axiom downcast_reduce:
  forall t : tag_table 't.
    forall p : pointer 't.
      forall s2 : tag_id 't [downcast t p s2].
        forall s1 : tag_id 't [downcast t (downcast t p s1) s2].
          cast_factor s1 s2 <> 0 -> downcast t (downcast t p s1) s2 = downcast t p s2

axiom downcast_instanceof:
  forall t : tag_table 't.
  forall p : pointer 't.
  forall s : tag_id 't [instanceof t p s | downcast t p s].
   instanceof t p s -> downcast t p s = p

axiom typeof_sidecast:
  forall t : tag_table 't.
  forall p : pointer 't.
  forall s1 : tag_id 't.
  forall s2 : tag_id 't [typeof t (downcast t p s2)].
    cast_factor s1 s2 <> 0 ->
    typeof t p = s1 ->
    typeof t (downcast t p s2) = s2

function bottom_tag: tag_id 'a

axiom bottom_tag_axiom:
  forall t : tag_id 't.
    subtag t bottom_tag

predicate root_tag (t : tag_id 't) = parenttag t bottom_tag

axiom root_subtag:
  forall a: tag_id 't.
  forall b: tag_id 't.
  forall c: tag_id 't.
    root_tag a -> root_tag b -> a <> b -> subtag c a -> not (subtag c b)

predicate reinterpret_cast_merge
      (t : tag_table 't)
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't)
      (c : int) =
  let ps = downcast t p s in
  (forall i : int [shift p i | shift ps (div i c)]. mod i c = 0 -> downcast t (shift p i) s = shift ps (div i c)) /\
  (forall i : int [shift ps i | shift p (i * c)]. downcast t (shift p (i * c)) s = shift ps i) /\
  offset_min a2 ps = div (offset_min a1 p) c /\
  offset_max a2 ps = div (offset_max a1 p + 1) c - 1

predicate reinterpret_cast_split
      (t : tag_table 't)
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't)
      (c : int) =
  let ps = downcast t p s in
  (forall i : int [shift p i | shift ps (i * c)]. downcast t (shift p i) s = shift ps (i * c)) /\
  (forall i : int [shift ps i | shift p (div i c)]. mod i c = 0 -> downcast t (shift p (div i c)) s = shift ps i) /\
  offset_min a2 ps = c * offset_min a1 p /\
  offset_max a2 ps = c * (offset_max a1 p + 1) - 1

predicate reinterpret_cast_retain
      (t : tag_table 't)
      (a1 : alloc_table 't)
      (a2 : alloc_table 't)
      (p : pointer 't)
      (s : tag_id 't) =
  let ps = downcast t p s in
  (forall i : int [shift p i | shift ps i]. downcast t (shift p i) s = shift ps i) /\
  offset_min a2 ps = offset_min a1 p /\
  offset_max a2 ps = offset_max a1 p

(*****************************************************************************)
(* bitwise operations                                                        *)
(*****************************************************************************)
(* TODO: use bitvector.why instead *)

function bw_compl int : int

function bw_and int int : int

(* Yannick: added for CVE-2003-0161-min-ok *)
axiom bw_and_not_null:
  forall a: int. forall b: int [bw_and a b].
    bw_and a b <> 0 -> a <> 0 /\ b <> 0

function bw_xor int int : int

function bw_or int int : int

(* bitwise arithmetic -- partial axiomatization *)

function pow2 int : int

axiom pow2_definition:
  pow2 0 = 1 /\
  pow2 1 = 2 /\
  pow2 2 = 4 /\
  pow2 3 = 8 /\
  pow2 4 = 16 /\
  pow2 5 = 32 /\
  pow2 6 = 64 /\
  pow2 7 = 128 /\

  pow2 8 = 256 /\
  pow2 9 = 512 /\
  pow2 10 = 1024 /\
  pow2 11 = 2048 /\
  pow2 12 = 4096 /\
  pow2 13 = 8192 /\
  pow2 14 = 16384 /\
  pow2 15 = 32768 /\

  pow2 16 = 65536 /\
  pow2 17 = 131072 /\
  pow2 18 = 262144 /\
  pow2 19 = 524288 /\
  pow2 20 = 1048576 /\
  pow2 21 = 2097152 /\
  pow2 22 = 4194304 /\
  pow2 23 = 8388608 /\

  pow2 24 = 16777216 /\
  pow2 25 = 33554432 /\
  pow2 26 = 67108864 /\
  pow2 27 = 134217728 /\
  pow2 28 = 268435456 /\
  pow2 29 = 536870912 /\
  pow2 30 = 1073741824 /\
  pow2 31 = 2147483648

axiom bw_or_plus:
  forall a: int. forall b: int [bw_or a b, bw_and a b, a + b].
    a >= 0 /\ b >= 0 /\ bw_and a b = 0 -> bw_or a b = a + b

predicate bw_set (pos: int) (n: int)

axiom bw_set:
  forall pos, n: int.
    pos >= 0 /\ n >= 0 ->
      bw_set pos n <-> bw_and (pow2 pos) n <> 0

axiom pow2_bw_set:
  forall n: int. forall m: int [bw_set n (pow2 m)].
    n >= 0 /\ m >= 0 ->
      bw_set n (pow2 m) <-> n = m

axiom zero_bw_set:
  forall n: int [bw_set n 0]. n >= 0 -> not (bw_set n 0)

axiom zero_bw_set_iff1:
  forall a: int. forall n: int [bw_set n a].
    a = 0 /\ n >= 0 ->
      not (bw_set n a)

axiom zero_bw_set_iff2:
  forall a: int. forall n: int [bw_set n a].
    a >= 0 /\ n >= 0 /\ bw_set n a ->
      a <> 0

axiom bw_and_self:
  forall a: int [bw_and a a].
    bw_and a a = a

axiom bw_or_self:
  forall a: int [bw_or a a].
    bw_or a a = a

axiom bw_and_definition:
  forall n: int. forall a: int. forall b: int
    [bw_and a b, bw_set n (bw_and a b), bw_set n a, bw_set n b].
    n >= 0 /\ a >= 0 /\ b >= 0 ->
      bw_set n (bw_and a b) <-> bw_set n a /\ bw_set n b

axiom bw_or_definition:
  forall n: int. forall a: int. forall b: int
    [bw_or a b, bw_set n (bw_or a b), bw_set n a, bw_set n b].
    n >= 0 /\ a >= 0 /\ b >= 0 ->
      bw_set n (bw_or a b) <-> bw_set n a \/ bw_set n b

axiom bw_xor_definition:
  forall n: int. forall a: int. forall b: int
    [bw_xor a b, bw_set n (bw_xor a b), bw_set n a, bw_set n b].
    n >= 0 /\ a >= 0 /\ b >= 0 ->
      bw_set n (bw_xor a b) <-> not (bw_set n a <-> bw_set n b)

axiom bw_and_assoc:
  forall a: int. forall b: int. forall c: int [bw_and (bw_and a b) c, bw_and a (bw_and b c)].
    bw_and (bw_and a b) c = bw_and a (bw_and b c)

axiom bw_or_assoc:
  forall a: int. forall b: int. forall c: int [bw_or (bw_or a b) c, bw_or a (bw_or b c)].
    bw_or (bw_or a b) c = bw_or a (bw_or b c)

axiom bw_xor_assoc:
  forall a: int. forall b: int. forall c: int [bw_xor (bw_xor a b) c, bw_xor a (bw_xor b c)].
    bw_xor (bw_xor a b) c = bw_xor a (bw_xor b c)

axiom bw_and_comm:
  forall a: int. forall b:int [bw_and a b, bw_and b a].
    bw_and a b = bw_and b a

axiom bw_or_comm:
  forall a: int. forall b: int [bw_or a b, bw_or b a].
    bw_or a b = bw_or b a

axiom bw_xor_comm:
  forall a: int. forall b: int [bw_xor a b, bw_xor b a].
    bw_xor a b = bw_xor b a

axiom bw_and_or_distr:
  forall a: int. forall b: int. forall c: int [bw_and a (bw_or b c), bw_or (bw_and a b) (bw_and a c)].
    bw_and a (bw_or b c) = bw_or (bw_and a b) (bw_and a c)

axiom bw_or_and_distr:
  forall a: int. forall b: int. forall c: int [bw_or a (bw_and b c), bw_and (bw_or a b) (bw_or b c)].
    bw_or a (bw_and b c) = bw_and (bw_or a b) (bw_or a c)

axiom bw_and_mono:
  forall a: int. forall b: int [bw_and a b].
    a >= 0 /\ b >= 0 -> bw_and a b <= a /\ bw_and a b <= b

axiom bw_or_mono:
  forall a: int. forall b: int [bw_or a b].
    a >= 0 /\ b >= 0 -> bw_or a b >= a /\ bw_or a b >= b

(* axioms for arithmetic overflow in bitwise operations *)

function max_char : int = 127
function max_short: int  = 32767
function max_int : int = 2147483647
function max_long : int = 9223372036854775807

function min_char : int = -128
function min_short : int = -32768
function min_int : int = -2147483648
function min_long : int = -9223372036854775808

axiom bw_or_nooverflow_signed:
  forall a : int.
    forall b : int [bw_or a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_or a b /\ bw_or a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_or a b /\ bw_or a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_or a b /\ bw_or a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_or a b /\ bw_or a b <= max_long)

axiom bw_and_nooverflow_signed:
  forall a : int.
    forall b : int [bw_and a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_and a b /\ bw_and a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_and a b /\ bw_and a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_and a b /\ bw_and a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_and a b /\ bw_and a b <= max_long)

axiom bw_xor_nooverflow_signed:
  forall a : int.
    forall b : int [bw_xor a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_xor a b /\ bw_xor a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_xor a b /\ bw_xor a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_xor a b /\ bw_xor a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_xor a b /\ bw_xor a b <= max_long)

function max_uchar : int = 255
function max_ushort : int = 65535
function max_uint : int = 4294967295
function max_ulong : int = 18446744073709551615

axiom bw_or_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_or a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_or a b /\ bw_or a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_or a b /\ bw_or a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_or a b /\ bw_or a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_or a b /\ bw_or a b <= max_ulong)

axiom bw_and_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_and a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_and a b /\ bw_and a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_and a b /\ bw_and a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_and a b /\ bw_and a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_and a b /\ bw_and a b <= max_ulong)

axiom bw_xor_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_xor a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ulong)

(* logical left shift *)

function lsl int int : int

axiom lsl_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsl a (b)

axiom lsl_left_positive_monotone:
  forall a1:int. forall a2:int. forall b:int.
    0 <= a1 /\ a1 <= a2 /\ 0 <= b -> lsl a1 b <= lsl a2 b

(* logical right shift *)

function lsr int int : int

axiom lsr_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsr a (b)

axiom lsr_left_positive_decreases:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr a (b) <= a

(* arithmetic right shift *)

function asr int int : int

axiom asr_positive_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= asr a (b)

axiom asr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) <= a

(* combining shifts *)

axiom asr_lsr_same_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) = lsr a (b)

axiom lsl_of_lsr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsl (lsr a b) b <= a

axiom lsr_of_lsl_identity_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr (lsl a b) b = a

(* shifts bitwise definition *)

axiom lsl_definition:
  forall m: int. forall a: int [lsl a m]. forall n: int
    [bw_set n (lsl a m), bw_set (n - m) a, n < m].
      m >= 0 /\ a >= 0 /\ n >= 0 -> not (bw_set n (lsl a m)) <-> not (bw_set (n - m) a) \/ n < m

axiom lsr_definition:
  forall m: int. forall a: int [lsr a m]. forall n: int
    [bw_set n (lsr a m), bw_set (n + m) a].
      m >= 0 /\ a >= 0 /\ n >= 0 -> bw_set n (lsr a m) <-> bw_set (n + m) a

axiom lsl_induction:
  forall a: int.
  forall n: int [lsl a n].
  forall m: int [n + m].
  forall k: int [lsl a k].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      lsl a k = lsl (lsl a n) m

axiom lsr_induction:
  forall a: int.
  forall n: int [lsr a n].
  forall m: int [n + m].
  forall k: int [lsr a k].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      lsr a k = lsr (lsr a n) m

axiom lsl_assoc:
  forall n: int.
  forall m: int.
  forall a: int [lsl (lsl a m) n, lsl (lsl a n) m].
    n >= 0 /\ m >= 0 ->
      lsl (lsl a m) n = lsl (lsl a n) m

axiom lsr_assoc:
  forall n: int.
  forall m: int.
  forall a: int [lsr (lsr a m) n, lsr (lsr a n) m].
    n >= 0 /\ m >= 0 ->
      lsr (lsr a m) n = lsr (lsr a n) m

axiom lsl_init:
  forall a: int [lsl a 1 | a * 2]. a >= 0 -> lsl a 1 = a * 2

axiom lsl_multiply:
  forall a: int. forall n: int [lsl a n | a * pow2 n]. a >= 0 /\ n >= 0 -> lsl a n = a * pow2 n

axiom lsr_init:
  forall a: int [lsr a 1 | div a 2]. a >= 0 -> lsr a 1 = div a 2

axiom lsr_divide:
  forall a: int. forall n: int [lsr a n | div a (pow2 n)]. a >= 0 /\ n >= 0 -> lsr a n = div a (pow2 n)

(*****************************************************************************)
(* dynamic allocation/deallocation                                           *)
(*****************************************************************************)

predicate allocable (a : alloc_table 't) (p : pointer 't) =
  offset_max a p = -1 < offset_min a p = 0

predicate freeable (a : alloc_table 't) (p : pointer 't) =
  offset_min a p = 0 <= offset_max a p

predicate allocated (a : alloc_table 't) (p : pointer 't) =
  offset_min a p <= offset_max a p

predicate tag_fresh (t : tag_table 't) (p : pointer 't) =
  typeof t p = bottom_tag

predicate alloc_fresh (a : alloc_table 't) (p : pointer 't) =
  allocable a p

axiom alloc_fresh_not_same_block:
  forall p1 : pointer 't.
    forall p2 : pointer 't [same_block p1 p2].
      forall a : alloc_table 't [allocable a p1, freeable a p2].
        allocable a p1 /\ freeable a p2 ->
         not same_block p1 p2

axiom tag_fresh_not_same_block:
  forall p1 : pointer 't.
    forall p2 : pointer 't [same_block p1 p2].
      forall t : tag_table 't [typeof t p1 = bottom_tag, typeof t p2 <> bottom_tag].
        typeof t p1 = bottom_tag /\ typeof t p2 <> bottom_tag ->
           not same_block p1 p2

predicate alloc_extends (a1 : alloc_table 't) (a2 : alloc_table 't) =
  forall p : pointer 't [valid a1 p | valid a2 p | offset_min a1 p, offset_min a2 p | offset_max a1 p, offset_max a2 p].
    valid a1 p -> offset_min a1 p = offset_min a2 p /\ offset_max a1 p = offset_max a2 p

predicate alloc_block (a1 : alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) (n : int) =
  forall q : pointer 't [offset_min a2 q | offset_min a1 q | offset_max a1 q | offset_max a1 q].
      (not same_block q p ->
        offset_min a2 q = offset_min a1 q /\
        offset_max a2 q = offset_max a1 q) /\
      (same_block q p ->
        offset_min a2 q = 0 - sub_pointer q p /\
        offset_max a2 q = n - 1 - sub_pointer q p)

predicate free_block (a1: alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) =
  forall q : pointer 't [offset_min a2 q | offset_min a1 q | offset_max a2 q | offset_max a1 q].
      (not same_block q p  ->
        offset_min a2 q = offset_min a1 q /\
        offset_max a2 q = offset_max a1 q) /\
      (same_block q p ->
        offset_min a2 q = 0 - sub_pointer q p /\
        offset_max a2 q = -1 - sub_pointer q p)

predicate switch_blocks (a1 : alloc_table 't) (a2 : alloc_table 't) (p : pointer 't) (q : pointer 't) (n : int) =
  forall r : pointer 't [offset_min a2 r | offset_min a1 r | offset_max a2 r | offset_max a1 r].
      (not same_block r p /\ not same_block r q ->
        offset_min a2 r = offset_min a1 r /\
        offset_max a2 r = offset_max a1 r) /\
      (same_block r p ->
        offset_min a2 r = 0 - sub_pointer r p /\
        offset_max a2 r = -1 - sub_pointer r p) /\
      (same_block r q ->
        offset_min a2 r = 0 - sub_pointer r q /\
        offset_max a2 r = n - 1 - sub_pointer r q)

function rmem (m : memory 't 'v1) : memory 't 'v2

function rfactor (m : memory 't 'v) : int

function rpointer_new (m : memory 't 'v) (p : pointer 't) : pointer 't

function pset_reinterpret (m : memory 't 'v) (l : pset 't) : pset 't

axiom pset_reinterpret_empty:
  forall m : memory 't 'v.
    pset_reinterpret m pset_empty = pset_empty

axiom pset_reinterpret_pset_range:
  forall m : memory 't 'v.
    forall p : pointer 't.
      forall a, b : int.
        (rfactor m > 0 ->
          pset_reinterpret m (pset_range (pset_singleton p) a b) =
          pset_range (pset_singleton (rpointer_new m p)) (a * rfactor m) ((b + 1) * rfactor m - 1)) /\
        (rfactor m < 0 /\ mod a (rfactor m) = 0 /\ mod (b + 1) (rfactor m) = 0 ->
          pset_reinterpret m (pset_range (pset_singleton p)a b) =
          pset_range (pset_singleton (rpointer_new m p)) (div a (rfactor m)) ((div (b + 1) (rfactor  m)) - 1)) /\
        (rfactor m = 0 ->
          pset_reinterpret m (pset_range (pset_singleton p) a b) =
          pset_range (pset_singleton (rpointer_new m p)) a b)

axiom pset_reinterpret_pset_union_distrib:
  forall m : memory 't 'v.
    forall l1, l2 : pset 't.
      pset_reinterpret m (pset_union l1 l2) = pset_union (pset_reinterpret m l1) (pset_reinterpret m l2)

axiom rmem_not_assigns:
  forall m1 : memory 't 'v1 [rmem m1 : memory 't 'v2].
    forall m3 : memory 't 'v2 [rmem m3 : memory 't 'v1].
      forall a1, a2 : alloc_table 't.
        forall l : pset 't [not_assigns a1 a2 (rmem m1) m3 l | not_assigns a1 a2 m1 (rmem m3) l].
          (not_assigns a1 a2 (rmem m1) m3 l <->
           not_assigns a1 a2 m1 (rmem m3) (pset_reinterpret m3 l)) /\
          (not_assigns a1 a2 (rmem m1) m3 (pset_reinterpret m1 l) <->
           not_assigns a1 a2 m1 (rmem m3) l)

predicate alloc_same_except (a1 : alloc_table 't) (a2 : alloc_table 't) (l : pset 't) =
  forall p: pointer 't [valid a1 p | valid a2 p | offset_min a1 p, offset_min a2 p | offset_max a1 p, offset_max a2 p].
    not in_pset p l ->
      offset_min a1 p = offset_min a2 p /\ offset_max a1 p = offset_max a2 p

axiom alloc_same_except_included:
  forall a1 : alloc_table 't.
    forall a2 : alloc_table 't.
      forall l1 : pset 't [alloc_same_except a1 a2 l1].
        forall l2 : pset 't [alloc_same_except a1 a2 l2 | pset_included l1 l2].
          pset_included l1 l2 /\
          alloc_same_except a1 a2 l1 ->
            alloc_same_except a1 a2 l2

axiom alloc_same_except_trans:
  forall l : pset 't.
    forall a1 : alloc_table 't.
      forall a2 : alloc_table 't [alloc_same_except a1 a2 l].
        forall a3 : alloc_table 't [alloc_same_except a2 a3 l].
          alloc_same_except a1 a2 l /\
          alloc_same_except a2 a3 l ->
          alloc_same_except a1 a3 l

predicate alloc_blockset (a1 : alloc_table 't) (a2 : alloc_table 't) (q : pset 't) =
  forall p : pointer 't [valid a1 p | valid a2 p | offset_min a1 p, offset_min a2 p | offset_max a1 p, offset_max a2 p].
    (forall r : pointer 't. in_pset r q -> not same_block p r) ->
      offset_min a1 p = offset_min a2 p /\ offset_max a1 p = offset_max a2 p

predicate tag_extends (t1 : tag_table 't) (t2 : tag_table 't) =
  forall p : pointer 't.
    tag t1 p <> bottom_tag -> tag t2 p = tag t1 p

predicate tag_same_except (t1 : tag_table 't) (t2 : tag_table 't) (l : pset 't) =
  forall p : pointer 't.
    tag t1 p <> bottom_tag -> tag t2 p = tag t1 p

axiom tag_same_except_refl:
  forall t : tag_table 't.
  forall l : pset 't.
    tag_same_except t t l

predicate alloc_tag_blockset (t1 : tag_table 't) (t2 : tag_table 't) (q : pset 't) =
  forall p : pointer 't [tag t1 p | tag t2 p].
    tag t1 p <> bottom_tag -> tag t2 p = tag t1 p

predicate alloc_tag_block (t1 : tag_table 't) (t2 : tag_table 't) (p : pointer 't) (n : int) = tag_extends t1 t2

predicate free_blockset (a1 : alloc_table 't) (a2 : alloc_table 't) (q : pset 't) = alloc_blockset a1 a2 q

end
