
theory Jessie_memory_model

use import int.Int

predicate zwf_zero (a:int) (b:int) = 0 <= b /\ a < b

(*****************************************************************************)
(* pointers, allocation, validity                                            *)
(*****************************************************************************)

type alloc_table 't
type pointer 't

(* memory model *)

function offset_max (alloc_table 't) (pointer 't) : int
function offset_min (alloc_table 't) (pointer 't) : int

(* shortcuts *)

predicate valid (a:alloc_table 't) (p:pointer 't) =
  offset_min a p <= 0 /\ offset_max a p >= 0

predicate same_block (p: pointer 't) (q:pointer 't)

(* pointer arithmetic *)

function sub_pointer (pointer 't) (pointer 't) : int
function shift (pointer 't) int : (pointer 't)

(* null pointer*)

function null : (pointer 't)

(* shift *)

axiom shift_zero:
  forall p:pointer 't [shift p 0]. shift p 0 = p

axiom shift_shift:
  forall p:pointer 't. forall i:int. forall j:int [shift (shift p i) j].
    shift (shift p i) j = shift p (i+j)

axiom offset_max_shift:
  forall a:alloc_table 't. forall p: pointer 't. forall i:int.
    offset_max a (shift p i) = offset_max a p - i

axiom offset_min_shift:
  forall a:alloc_table 't. forall p: pointer 't. forall i:int.
    offset_min a (shift p i) = offset_min a p - i

axiom neq_shift:
  forall p:pointer 't. forall i:int. forall j:int [shift p i,shift p j].
    i <> j -> shift p i <> shift p j

(* null *)

axiom null_not_valid:
  forall a:alloc_table 't. not (valid a null)

axiom null_pointer:
  forall a:alloc_table 't.
    offset_min a null >= 0 /\ offset_max a null <= -2

use import bool.Bool

function eq_pointer_bool (pointer 't) (pointer 't) : bool
function neq_pointer_bool (pointer 't) (pointer 't) : bool

axiom eq_pointer_bool_def:
  forall p1: pointer 't. forall p2: pointer 't.
    eq_pointer_bool p1 p2 = True <-> p1 = p2

axiom neq_pointer_bool_def:
  forall p1: pointer 't. forall p2: pointer 't.
    neq_pointer_bool p1 p2 = True <-> p1 <> p2
    
(* makes Simplify loop on bench/java/Arrays.java !!!

axiom same_block_shift:
  forall p: pointer 't. forall i: int.
    same_block p (shift p i)
*)

axiom same_block_shift_right:
  forall p: pointer 't. forall q:pointer 't. forall i:int
  [same_block p (shift q i)].
    same_block p q -> same_block p (shift q i)

axiom same_block_shift_left:
  forall p: pointer 't. forall q:pointer 't. forall i:int
  [same_block (shift q i) p].
    same_block q p -> same_block (shift q i) p


(* makes Simplify loop on Jessie test roux.c

axiom sub_pointer_same_block:
  forall p:pointer 't. forall q:pointer 't [sub_pointer p q, same_block p q].
    sub_pointer p q = 0 -> same_block p q
*)

(* sub_pointer *)

axiom sub_pointer_shift:
  forall p q:pointer 't [sub_pointer p q].
    same_block p q -> p = shift q (sub_pointer p q)

axiom sub_pointer_self:
  forall p:pointer 't [sub_pointer p p]. sub_pointer p p = 0

axiom sub_pointer_zero:
  forall p q:pointer 't [sub_pointer p q].
    same_block p q ->
      sub_pointer p q = 0 -> p = q

axiom sub_pointer_shift_left:
  forall p q:pointer 't, i:int [sub_pointer (shift p i) q].
      sub_pointer (shift p i) q = sub_pointer p q + i

axiom sub_pointer_shift_right:
  forall p q:pointer 't, i:int [sub_pointer p (shift q i)].
      sub_pointer p (shift q i) = sub_pointer p q - i

axiom sub_pointer_neg:
  forall p q:pointer 't. sub_pointer p q = - sub_pointer q p

(*****************************************************************************)
(* heap memories, select and store                                           *)
(*****************************************************************************)

type memory 't 'v

function select (memory 't 'v) (pointer 't) : 'v
function store (memory 't 'v) (pointer 't) 'v : (memory 't 'v)

axiom select_store_eq:
  forall m: (memory 't 'v).
  forall p1: pointer 't.
  forall p2: pointer 't.
  forall a: 'v [store m p1 a, p2].
    p1=p2 -> select (store m p1 a) p2 = a

axiom select_store_neq:
  forall m: (memory 't 'v).
  forall p1: pointer 't.
  forall p2: pointer 't.
  forall a: 'v [store m p1 a,p2] .
    p1 <> p2 -> select (store m p1 a) p2 = select m p2

(*****************************************************************************)
(* memory locations, not_assigns predicate, separation                       *)
(*****************************************************************************)

type pset 't

function pset_empty : (pset 't)
function pset_singleton (pointer 't) : (pset 't)
function pset_deref (memory 't (pointer 'v)) (pset 't) : pset 'v
function pset_union (pset 't) (pset 't) : (pset 't)
function pset_all (pset 'z) : (pset 'z) (* l(..) *)
function pset_range (pset 't) int int : (pset 't) (* l(a..b) *)
function pset_range_left (pset 'z) int : (pset 'z) (* l(..b) *)
function pset_range_right (pset 'z) int : (pset 'z) (* l(a..) *)

predicate in_pset (pointer 't) (pset 't) 
predicate valid_pset (alloc_table 't) (pset 't) 

predicate pset_disjoint (ps1:(pset 't)) (ps2:(pset 't)) =
  forall p:pointer 't.
    not (in_pset p ps1 /\ in_pset p ps2)

predicate pset_included (ps1:(pset 't)) (ps2:(pset 't)) =
  forall p:pointer 't.
    in_pset p ps1 -> in_pset p ps2

axiom pset_included_self:
  forall ps:(pset 't). pset_included ps ps

axiom pset_included_range:
  forall ps:(pset 't). forall a b c d : int
  [pset_included (pset_range ps a b) (pset_range ps c d)].
    c <= a /\ b <= d ->
      pset_included (pset_range ps a b) (pset_range ps c d)

axiom pset_included_range_all:
  forall ps:(pset 't), a b : int
  [pset_included (pset_range ps a b) (pset_all ps) ].
    pset_included (pset_range ps a b) (pset_all ps)

axiom in_pset_empty:
  forall p:pointer 't. not (in_pset p pset_empty)

axiom in_pset_singleton:
  forall p:pointer 't.
  forall q:pointer 't.
    in_pset p (pset_singleton q) <-> p=q

axiom in_pset_deref:
  forall p:pointer 'v.
  forall m:memory 't (pointer 'v).
  forall q:(pset 't).
    in_pset p (pset_deref m q) <->
	exists r:pointer 't. in_pset r q /\ p = select m r

axiom in_pset_all:
  forall p:pointer 't.
  forall q:(pset 't).
    in_pset p (pset_all q) <->
	exists i:int. exists r:pointer 't.
          in_pset r q /\ p = shift r i

axiom in_pset_range:
  forall p:pointer 't.
  forall q:(pset 't).
  forall a:int. forall b:int.
    in_pset p (pset_range q a b) <->
	exists i:int. exists r:pointer 't.
          a <= i /\ i <= b /\ in_pset r q /\ p=shift r i

axiom in_pset_range_left:
  forall p:pointer 't.
  forall q:(pset 't).
  forall b:int.
    in_pset p (pset_range_left q b) <->
	exists i:int. exists r:pointer 't.
          i <= b /\ in_pset r q /\ p = shift r i

axiom in_pset_range_right:
  forall p:pointer 't.
  forall q:(pset 't).
  forall a:int.
    in_pset p (pset_range_right q a) <->
	exists i:int. exists r:pointer 't.
          a <= i /\ in_pset r q /\ p = shift r i

axiom in_pset_union:
  forall p:pointer 't.
  forall s1:(pset 't).
  forall s2:(pset 't).
    in_pset p (pset_union s1 s2) <-> in_pset p s1 \/ in_pset p s2

axiom valid_pset_empty:
  forall a:alloc_table 't. valid_pset a pset_empty

axiom valid_pset_singleton:
  forall a:alloc_table 't.
  forall p:pointer 't.
    valid_pset a (pset_singleton p) <-> valid a p

axiom valid_pset_deref:
  forall a:alloc_table 'v .
  forall m:memory 't (pointer 'v).
  forall q:(pset 't).
    valid_pset a (pset_deref m q) <->
      forall r:pointer 't. forall p:pointer 'v.
        in_pset r q /\ p = select m r -> valid a p

axiom valid_pset_range:
  forall a:alloc_table 't.
  forall q:(pset 't).
  forall c:int. forall d:int.
    valid_pset a (pset_range q c d) <->
	forall i:int. forall r:pointer 't.
          in_pset r q /\ c <= i /\ i <= d -> valid a (shift r i)

axiom valid_pset_union:
  forall a:alloc_table 't.
  forall s1:(pset 't).
  forall s2:(pset 't).
    valid_pset a (pset_union s1 s2) <-> valid_pset a (s1) /\ valid_pset a (s2)

predicate not_assigns
  (a:alloc_table 't) (m1:(memory 't 'v)) (m2:(memory 't 'v)) (l:(pset 't)) =
    forall p:pointer 't.
      valid a p /\ not in_pset p l -> select m2 p = select m1 p

axiom not_assigns_refl:
  forall a: alloc_table 't.
  forall m: (memory 't 'v).
  forall l:(pset 't).
    not_assigns a m m l

axiom not_assigns_trans:
  forall a: alloc_table 't.
  forall m1: (memory 't 'v).
  forall m2: (memory 't 'v).
  forall m3: (memory 't 'v).
  forall l:(pset 't) [not_assigns a m1 m2 l, not_assigns a m1 m3 l] .
    not_assigns a m1 m2 l ->
    not_assigns a m2 m3 l ->
    not_assigns a m1 m3 l

(*****************************************************************************)
(* lattice of structures                                                     *)
(*****************************************************************************)

(*****
typeof gives the dynamic type of an object.

parenttag is defined by axioms in jc_interp, and defines the hierarchy.
  parenttag(t1, t2) <-> t2 is the immediate superclass of t1

subtag is axiomatized from parenttag, and is the reflexive, transitive
  closure of parenttag.

subtag_ is the same as subtag but for booleans.

instanceof is defined from typeof and subtag.

int_of_tag gives a different integer to each tags to differenciate them.
*****)

type tag_table 't

type tag_id 't

function int_of_tag (tag_id 't) : int

function typeof(tag_table 't) (pointer 't) : (tag_id 't)

predicate parenttag (tag_id 't)  (tag_id 't) 

predicate subtag (tag_id 't) (tag_id 't) 

function subtag_bool (tag_id 't) (tag_id 't) : bool

axiom subtag_bool_def:
  forall t1: (tag_id 't).
  forall t2: (tag_id 't).
    subtag_bool t1 t2 = True <-> subtag t1 t2

axiom subtag_refl:
  forall t: (tag_id 't).
    subtag t t

axiom subtag_parent:
  forall t1: (tag_id 't).
  forall t2: (tag_id 't).
  forall t3: (tag_id 't).
    subtag t1 t2 -> parenttag t2 t3 -> subtag t1 t3

predicate instanceof (a: (tag_table 't)) (p: pointer 't) (t: (tag_id 't)) =
  subtag (typeof a p) t

function downcast (tag_table 't) (pointer 't) (tag_id 't) : pointer 't

axiom downcast_instanceof:
  forall a:(tag_table 't).
  forall p:pointer 't.
  forall s:(tag_id 't).
   instanceof a  p (s) -> downcast a  p (s)=p

function bottom_tag: tag_id 'a

axiom bottom_tag_axiom:
  forall t: (tag_id 't).
    subtag t bottom_tag

predicate root_tag(t: (tag_id 't)) = parenttag t bottom_tag

axiom root_subtag:
  forall a: (tag_id 't).
  forall b: (tag_id 't).
  forall c: (tag_id 't).
    root_tag(a) -> root_tag(b) -> a <> b -> subtag c a -> not (subtag c b)

(*****************************************************************************)
(* structure invariants                                                      *)
(*****************************************************************************)

predicate fully_packed (tag_table: tag_table 'a)
  (_mutable: memory 'a (tag_id 'a))
  (this: pointer 'a) =
    select _mutable this = typeof tag_table this

(*****************************************************************************)
(* bitwise operations                                                        *)
(*****************************************************************************)
(* TODO: use bitvector.why instead *)

function bw_compl int : int

function bw_and int int : int

(* Yannick: added for CVE-2003-0161-min-ok *)
axiom bw_and_not_null:
  forall a: int. forall b: int. bw_and a b <> 0 -> a <> 0 /\ b <> 0

function bw_xor int int : int

function bw_or int int : int

(* bitwise arithmetic -- partial axiomatization *)

function pow2 int : int

axiom pow2_definition:
  pow2 0 = 1 /\
  pow2 1 = 2 /\
  pow2 2 = 4 /\
  pow2 3 = 8 /\
  pow2 4 = 16 /\
  pow2 5 = 32 /\
  pow2 6 = 64 /\
  pow2 7 = 128 /\
  
  pow2 8 = 256 /\
  pow2 9 = 512 /\
  pow2 10 = 1024 /\
  pow2 11 = 2048 /\
  pow2 12 = 4096 /\
  pow2 13 = 8192 /\
  pow2 14 = 16384 /\
  pow2 15 = 32768 /\
  
  pow2 16 = 65536 /\
  pow2 17 = 131072 /\
  pow2 18 = 262144 /\
  pow2 19 = 524288 /\
  pow2 20 = 1048576 /\
  pow2 21 = 2097152 /\
  pow2 22 = 4194304 /\
  pow2 23 = 8388608 /\
  
  pow2 24 = 16777216 /\
  pow2 25 = 33554432 /\
  pow2 26 = 67108864 /\
  pow2 27 = 134217728 /\
  pow2 28 = 268435456 /\
  pow2 29 = 536870912 /\
  pow2 30 = 1073741824 /\
  pow2 31 = 2147483648

axiom bw_or_plus:
  forall a: int. forall b: int [bw_or a b, a + b, a >= 0, b >= 0].
    a >= 0 /\ b >= 0 /\ bw_and a b = 0 -> bw_or a b = a + b
  
predicate bw_set (pos: int) (n: int) = bw_and (pow2 pos) n <> 0

axiom pow2_bw_set:
  forall n: int. forall m: int [bw_set n (pow2 m)]. bw_set n (pow2 m) <-> n = m

axiom zero_bw_set:
  forall n: int [bw_set n 0]. not (bw_set n 0)
  
axiom zero_bw_set_iff:
  forall a: int [a = 0]. (forall n: int [bw_set n a]. not (bw_set n a)) <-> a = 0

axiom bw_and_self:
  forall a: int [bw_and a a].
    bw_and a a = a

axiom bw_or_self:
  forall a: int [bw_or a a].
    bw_or a a = a
    
axiom bw_and_definition:
  forall n: int. forall a: int. forall b: int
    [bw_and a b, bw_set n (bw_and a b), bw_set n a, bw_set n b].
      bw_set n (bw_and a b) <-> bw_set n a /\ bw_set n b

axiom bw_or_definition:
  forall n: int. forall a: int. forall b: int
    [bw_or a b, bw_set n (bw_or a b), bw_set n a, bw_set n b].
      bw_set n (bw_or a b) <-> bw_set n a \/ bw_set n b

axiom bw_xor_definition:
  forall n: int. forall a: int. forall b: int
    [bw_xor a b, bw_set n (bw_xor a b), bw_set n a, bw_set n b].
      bw_set n (bw_xor a b) <-> not (bw_set n a <-> bw_set n b)

axiom bw_compl_definition:
  forall n: int. forall a: int [bw_compl a, bw_set n (bw_compl a), bw_set n a].
     bw_set n (bw_compl a) <-> not (bw_set n a)

axiom bw_and_assoc:
  forall a: int. forall b: int. forall c: int [bw_and (bw_and a b) c, bw_and a (bw_and b c)].
    bw_and (bw_and a b) c = bw_and a (bw_and b c)

axiom bw_or_assoc:
  forall a: int. forall b: int. forall c: int [bw_or (bw_or a b) c, bw_or a (bw_or b c)].
    bw_or (bw_or a b) c = bw_or a (bw_or b c)

axiom bw_xor_assoc:
  forall a: int. forall b: int. forall c: int [bw_xor (bw_xor a b) c, bw_xor a (bw_xor b c)].
    bw_xor (bw_xor a b) c = bw_xor a (bw_xor b c)

axiom bw_and_comm:
  forall a: int. forall b:int [bw_and a b, bw_and b a].
    bw_and a b = bw_and b a

axiom bw_or_comm:
  forall a: int. forall b: int [bw_or a b, bw_or b a].
    bw_or a b = bw_or b a

axiom bw_xor_comm:
  forall a: int. forall b: int [bw_xor a b, bw_xor b a].
    bw_xor a b = bw_xor b a

axiom bw_and_or_distr:
  forall a: int. forall b: int. forall c: int [bw_and a (bw_or b c), bw_or (bw_and a b) (bw_and a c)].
    bw_and a (bw_or b c) = bw_or (bw_and a b) (bw_and a c)

axiom bw_or_and_distr:
  forall a: int. forall b: int. forall c: int [bw_or a (bw_and b c), bw_and (bw_or a b) (bw_or b c)].
    bw_or a (bw_and b c) = bw_and (bw_or a b) (bw_or a c)

axiom bw_and_mono:
  forall a: int. forall b: int [bw_and a b, a >= 0, b >= 0].
    a >= 0 /\ b >= 0 -> bw_and a b <= a /\ bw_and a b <= b

axiom bw_or_mono:
  forall a: int. forall b: int [bw_or a b, a >= 0, b >= 0].
    a >= 0 /\ b >= 0 -> bw_or a b >= a /\ bw_or a b >= b
   
(* axioms for arithmetic overflow in bitwise operations *)

function max_char : int = 127
function max_short: int  = 32767
function max_int : int = 2147483647
function max_long : int = 9223372036854775807

function min_char : int = -128
function min_short : int = -32768
function min_int : int = -2147483648
function min_long : int = -9223372036854775808

axiom bw_compl_nooverflow_signed:
  forall a : int [bw_compl a].
      (min_char <= a /\ a <= max_char ->
        min_char <= bw_compl a /\ bw_compl a <= max_char) /\
      (min_short <= a /\ a <= max_short ->
        min_short <= bw_compl a /\ bw_compl a <= max_short) /\
      (min_int <= a /\ a <= max_int ->
        min_int <= bw_compl a /\ bw_compl a <= max_int) /\
      (min_long <= a /\ a <= max_long ->
        min_long <= bw_compl a /\ bw_compl a <= max_long)

axiom bw_or_nooverflow_signed:
  forall a : int.
    forall b : int [bw_or a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_or a b /\ bw_or a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_or a b /\ bw_or a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_or a b /\ bw_or a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_or a b /\ bw_or a b <= max_long)

axiom bw_and_nooverflow_signed:
  forall a : int.
    forall b : int [bw_and a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_and a b /\ bw_and a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_and a b /\ bw_and a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_and a b /\ bw_and a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_and a b /\ bw_and a b <= max_long)

axiom bw_xor_nooverflow_signed:
  forall a : int.
    forall b : int [bw_xor a b].
      (min_char <= a /\ a <= max_char /\ min_char <= b /\ b <= max_char ->
        min_char <= bw_xor a b /\ bw_xor a b <= max_char) /\
      (min_short <= a /\ a <= max_short /\ min_short <= b /\ b <= max_short ->
        min_short <= bw_xor a b /\ bw_xor a b <= max_short) /\
      (min_int <= a /\ a <= max_int /\ min_int <= b /\ b <= max_int ->
        min_int <= bw_xor a b /\ bw_xor a b <= max_int) /\
      (min_long <= a /\ a <= max_long /\ min_long <= b /\ b <= max_long ->
        min_long <= bw_xor a b /\ bw_xor a b <= max_long)

function max_uchar : int = 255
function max_ushort : int = 65535
function max_uint : int = 4294967295
function max_ulong : int = 18446744073709551615

axiom bw_or_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_or a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_or a b /\ bw_or a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_or a b /\ bw_or a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_or a b /\ bw_or a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_or a b /\ bw_or a b <= max_ulong)

axiom bw_and_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_and a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_and a b /\ bw_and a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_and a b /\ bw_and a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_and a b /\ bw_and a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_and a b /\ bw_and a b <= max_ulong)

axiom bw_xor_nooverflow_unsigned:
  forall a : int.
    forall b : int [bw_xor a b].
      (0 <= a /\ a <= max_uchar /\ 0 <= b /\ b <= max_uchar ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uchar) /\
      (0 <= a /\ a <= max_ushort /\ 0 <= b /\ b <= max_ushort ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ushort) /\
      (0 <= a /\ a <= max_uint /\ 0 <= b /\ b <= max_uint ->
        0 <= bw_xor a b /\ bw_xor a b <= max_uint) /\
      (0 <= a /\ a <= max_ulong /\ 0 <= b /\ b <= max_ulong ->
        0 <= bw_xor a b /\ bw_xor a b <= max_ulong)

(* logical left shift *)

function lsl int int : int

axiom lsl_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsl a (b)

axiom lsl_left_positive_monotone:
  forall a1:int. forall a2:int. forall b:int.
    0 <= a1 /\ a1 <= a2 /\ 0 <= b -> lsl a1 b <= lsl a2 b

(* logical right shift *)

function lsr int int : int

axiom lsr_left_positive_returns_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= lsr a (b)

axiom lsr_left_positive_decreases:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr a (b) <= a

(* arithmetic right shift *)

function asr int int : int

axiom asr_positive_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> 0 <= asr a (b)

axiom asr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) <= a

(* combining shifts *)

axiom asr_lsr_same_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> asr a (b) = lsr a (b)

axiom lsl_of_lsr_decreases_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsl (lsr a b) b <= a

axiom lsr_of_lsl_identity_on_positive:
  forall a:int. forall b:int. 0 <= a /\ 0 <= b -> lsr (lsl a b) b = a
  
(* shifts bitwise definition *)

axiom lsl_definition:
  forall m: int [m >= 0]. forall a: int [lsl a m]. forall n: int
    [bw_set n (lsl a m), bw_set (n - m) a, n < m].
      m >= 0 -> not (bw_set n (lsl a m)) <-> not (bw_set (n - m) a) \/ n < m

axiom lsr_definition:
  forall m: int [m >= 0]. forall a: int [lsr a m]. forall n: int
    [bw_set n (lsr a m), bw_set (n + m) a].
      m >= 0 -> bw_set n (lsr a m) <-> bw_set (n + m) a

axiom lsl_induction:
  forall n: int. forall m: int. forall k: int [n + m, k = n + m, k >= 0, n >= 0, m >= 0].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      (forall a: int. lsl a k = lsl (lsl a n) m)

axiom lsr_induction:
  forall n: int. forall m: int. forall k: int [n + m, k = n + m, k >= 0, n >= 0, m >= 0].
    k >=0 /\ n >= 0 /\ m >= 0 /\ k = n + m ->
      (forall a: int. lsr a k = lsr (lsr a n) m)

axiom lsl_assoc:
  forall n: int [n >= 0]. forall m: int [m >= 0].
    n >= 0 /\ m >= 0 ->
      (forall a: int [lsl (lsl a m) n, lsl (lsl a n) m].
        lsl (lsl a m) n = lsl (lsl a n) m)

axiom lsr_assoc:
  forall n: int [n >= 0]. forall m: int [m >= 0].
    n >= 0 /\ m >= 0 ->
      (forall a: int [lsr (lsr a m) n, lsr (lsr a n) m].
        lsr (lsr a m) n = lsr (lsr a n) m)

axiom lsl_init:
  forall a: int [lsl a 1, a >= 0]. a >= 0 -> lsl a 1 = a * 2

use import int.ComputerDivision

axiom lsr_init:
  forall a: int [lsr a 1, a >= 0]. a >= 0 -> lsr a 1 = div a 2
  
(*****************************************************************************)
(* dynamic allocation/deallocation                                           *)
(*****************************************************************************)

predicate alloc_extends (alloc_table 't) (alloc_table 't)

predicate alloc_fresh (a:alloc_table 't) (p:pointer 't) (n:int) =
  forall i:int. 0 <= i < n -> not valid a (shift p i)

axiom alloc_extends_offset_min:
  forall a1:alloc_table 't. forall a2:alloc_table 't [alloc_extends a1 a2].
    alloc_extends a1 a2 ->
      forall p:pointer 't.
        valid(a1) p -> offset_min(a1) p = offset_min(a2) p

axiom alloc_extends_offset_max:
  forall a1:alloc_table 't. forall a2:alloc_table 't [alloc_extends a1 a2].
    alloc_extends a1 a2 ->
      forall p:pointer 't.
        valid(a1) p -> offset_max(a1) p = offset_max(a2) p

axiom alloc_extends_not_assigns_empty:
  forall a1:alloc_table 't. forall a2:alloc_table 't.
  forall m1: (memory 't 'v). forall m2: (memory 't 'v).
  forall l:(pset 't). forall p:pointer 't. forall n:int
  [alloc_extends a1 a2, alloc_fresh a1 p n, not_assigns a2 m1 m2 l].
    alloc_extends a1 a2 /\ alloc_fresh a1 p n /\ not_assigns a2 m1 m2 l
    /\ pset_included l (pset_all (pset_singleton p)) ->
      not_assigns a1 m1 m2 pset_empty

predicate alloc_extends_except (alloc_table 't) (alloc_table 't) (pset 't)

axiom alloc_extends_alloc_extends_except:
  forall a1: alloc_table 't. forall a2: alloc_table 't [alloc_extends a1 a2].
    forall l: pset 't [alloc_extends_except a1 a2 l].
      alloc_extends a1 a2 -> alloc_extends_except a1 a2 l

axiom alloc_extends_except_offset_min:
 forall a1:alloc_table 't. forall a2:alloc_table 't. forall l:(pset 't)
 [alloc_extends_except a1 a2 l].
   alloc_extends_except a1 a2 l ->
     forall p:pointer 't.
       valid(a1) p /\ not in_pset p (l) -> offset_min(a1) p = offset_min(a2) p

axiom alloc_extends_except_offset_max:
 forall a1:alloc_table 't. forall a2:alloc_table 't. forall l:(pset 't)
 [alloc_extends_except a1 a2 l].
   alloc_extends_except a1 a2 l ->
     forall p:pointer 't.
       valid(a1) p /\ not in_pset p (l) -> offset_max(a1) p = offset_max(a2) p

axiom alloc_fresh_not_same_block_extends:
  forall a1:alloc_table 't. forall a2:alloc_table 't [alloc_extends a1 a2].
    alloc_extends a1 a2 ->
      forall p: pointer 't. forall n:int [alloc_fresh a1 p n].
        alloc_fresh a1 p n /\ valid(a2) p ->
          forall p_old: pointer 't [same_block p p_old].
            valid(a1) p_old -> not same_block p p_old

axiom alloc_fresh_not_same_block_extends_except:
  forall a1:alloc_table 't. forall a2:alloc_table 't. forall l:pset 't [alloc_extends_except a1 a2 l].
    alloc_extends_except a1 a2 l ->
      forall p: pointer 't. forall n:int [alloc_fresh a1 p n].
        alloc_fresh a1 p n /\ valid(a2) p ->
          forall p_old: pointer 't [same_block p p_old].
            valid(a1) p_old -> not same_block p p_old

end

